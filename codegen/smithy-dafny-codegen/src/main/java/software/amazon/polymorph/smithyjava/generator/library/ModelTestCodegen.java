// Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0

package software.amazon.polymorph.smithyjava.generator.library;

import static javax.lang.model.element.Modifier.FINAL;
import static javax.lang.model.element.Modifier.PUBLIC;
import static software.amazon.polymorph.smithyjava.generator.Generator.Constants.TESTNG_ASSERT;
import static software.amazon.polymorph.smithyjava.generator.Generator.Constants.TESTNG_TEST;

import com.squareup.javapoet.CodeBlock;
import com.squareup.javapoet.JavaFile;
import com.squareup.javapoet.MethodSpec;
import com.squareup.javapoet.TypeName;
import com.squareup.javapoet.TypeSpec;
import java.util.LinkedHashSet;
import java.util.Set;
import software.amazon.polymorph.smithyjava.generator.Generator;
import software.amazon.polymorph.smithyjava.modeled.ModeledShapeValue;
import software.amazon.polymorph.traits.LocalServiceTrait;
import software.amazon.smithy.model.node.ObjectNode;
import software.amazon.smithy.model.shapes.OperationShape;
import software.amazon.smithy.model.shapes.Shape;
import software.amazon.smithy.model.shapes.ShapeId;
import software.amazon.smithy.smoketests.traits.SmokeTestCase;
import software.amazon.smithy.smoketests.traits.SmokeTestsTrait;

/**
 * ModelTestCodegen generates tests for the content of the Subject's Model package.
 * e.g. generating JUnit tests from traits like @smithy.test#smokeTests.
 * This is distinct from the Dafny testing code
 * and the testing wrapper to support it generated by TestJavaLibrary.
 *
 * <h1>Smoke test generation</h1>
 *
 * If the {@code vendorParams} property is present,
 * the generated test constructs the client config with its values.
 *
 * <h2>Assertions</h2>
 *
 * If {@code "INVALID_CONFIG"} is present in the test case's {@code tags},
 * the generated test asserts that an exception is thrown
 * during either client config construction or client construction,
 * and the test neither constructs the operation input nor performs the operation call.
 * <p>
 * Otherwise, if the {@code expect.success} property is present,
 * the generated test asserts that no exception is thrown
 * during the operation call and all setup steps
 * (construction of client config, client, and operation input).
 * <p>
 * Otherwise, if the {@code expect.failure} property is present,
 * the generated test asserts that an exception is thrown
 * during either operation input construction or the operation call.
 */
public class ModelTestCodegen extends Generator {

  static final String INVALID_CONFIG_TAG = "INVALID_CONFIG";

  final JavaLibrary subject;

  public ModelTestCodegen(JavaLibrary subject) {
    super(subject);
    this.subject = subject;
  }

  @Override
  public Set<JavaFile> javaFiles() {
    final LinkedHashSet<JavaFile> rtn = new LinkedHashSet<>();
    subject.model
      .getOperationShapesWithTrait(SmokeTestsTrait.class)
      .stream()
      .map(this::smokeTestsClass)
      .forEachOrdered(rtn::add);
    return rtn;
  }

  private JavaFile smokeTestsClass(OperationShape shape) {
    final TypeSpec.Builder spec = TypeSpec
      .classBuilder(shape.getId().getName() + "SmokeTests")
      .addModifiers(PUBLIC, FINAL);
    final SmokeTestsTrait smokeTests = shape.expectTrait(SmokeTestsTrait.class);
    smokeTests
      .getTestCases()
      .stream()
      .map(testCase -> smokeTest(shape, testCase))
      .forEachOrdered(spec::addMethod);
    final TypeSpec classType = spec.build();
    return JavaFile.builder(subject.modelPackageName, classType).build();
  }

  private MethodSpec smokeTest(
    final OperationShape operationShape,
    SmokeTestCase testCase
  ) {
    final String methodName = testCase.getId();
    final MethodSpec.Builder method = MethodSpec
      .methodBuilder(methodName)
      .addAnnotation(TESTNG_TEST)
      .addModifiers(PUBLIC)
      .returns(TypeName.VOID);

    final TypeName clientType = subject.nativeNameResolver.typeForShape(
      subject.serviceShape.toShapeId()
    );
    final String operationName = operationShape.toShapeId().getName();
    final ShapeId configShapeId = subject.serviceShape
      .expectTrait(LocalServiceTrait.class)
      .getConfigId();
    final TypeName configType = subject.nativeNameResolver.typeForShape(
      configShapeId
    );

    // SimpleConstraintsConfig config = SimpleConstraintsConfig.builder()
    //     ...
    //     (multiple .foo(...) calls to populate builder)
    //     ...
    //     .build();
    // SimpleConstraints client = SimpleConstraints.builder()
    //     .SimpleConstraintsConfig(config)
    //     .build();
    final ObjectNode configParams = testCase
      .getVendorParams()
      .orElseGet(() -> ObjectNode.builder().build());
    final CodeBlock configValue = ModeledShapeValue.shapeValue(
      subject,
      false,
      subject.model.expectShape(configShapeId),
      configParams
    );
    final CodeBlock configAndClientConstruction = CodeBlock
      .builder()
      .addStatement("$T config = $L", configType, configValue)
      .addStatement(
        "$T client = $T.builder().$N(config).build()",
        clientType,
        clientType,
        configShapeId.getName()
      )
      .build();

    // GetConstraintsInput input = GetConstraintsInput.builder()
    //     ...
    //     (multiple .foo(...) calls to populate builder)
    //     ...
    //     .build();
    // client.GetConstraints(input);
    final Shape inputShape = subject.model.expectShape(
      operationShape.getInput().orElseThrow()
    );
    final TypeName inputType = subject.nativeNameResolver.typeForShape(
      inputShape.getId()
    );
    final CodeBlock inputValue = ModeledShapeValue.shapeValue(
      subject,
      false,
      inputShape,
      testCase.getParams().orElseThrow()
    );
    final CodeBlock inputAndClientCall = CodeBlock
      .builder()
      .addStatement("$T input = $L", inputType, inputValue)
      .addStatement("client.$L(input)", operationName)
      .build();

    if (testCase.hasTag(INVALID_CONFIG_TAG)) {
      method.addStatement(
        "$T.assertThrows(Exception.class, () -> {\n$L\n})",
        TESTNG_ASSERT,
        configAndClientConstruction.toString()
      );
    } else if (testCase.getExpectation().isSuccess()) {
      method.addCode(configAndClientConstruction);
      method.addCode(inputAndClientCall);
    } else {
      method.addCode(configAndClientConstruction);
      // We're not specific about what kind of exception for now.
      // If the smokeTests trait gets more specific we can be too.
      // The inputAndClientCall.toString() is necessary because otherwise we get nested
      // $[ ... $] statements, which JavaPoet doesn't support.
      method.addStatement(
        "$T.assertThrows(Exception.class, () -> {\n$L\n})",
        TESTNG_ASSERT,
        inputAndClientCall.toString()
      );
    }

    return method.build();
  }
}
