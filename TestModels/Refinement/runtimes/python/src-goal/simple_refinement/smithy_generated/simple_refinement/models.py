# Code generated by smithy-python-codegen DO NOT EDIT.

from typing import Any, Dict, Optional


class GetRefinementInput:
    required_string: Optional[str]
    optional_string: Optional[str]
    def __init__(
        self,
        *,
        required_string: Optional[str] = None,
        optional_string: Optional[str] = None,
    ):
        self.required_string = required_string
        self.optional_string = optional_string

    def as_dict(self) -> Dict[str, Any]:
        """Converts the GetRefinementInput to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        d: Dict[str, Any] = {}

        if self.required_string is not None:
            d["requiredString"] = self.required_string

        if self.optional_string is not None:
            d["optionalString"] = self.optional_string

        return d

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "GetRefinementInput":
        """Creates a GetRefinementInput from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {}

        if "requiredString" in d:
            kwargs["required_string"] = d["requiredString"]

        if "optionalString" in d:
            kwargs["optional_string"] = d["optionalString"]

        return GetRefinementInput(**kwargs)

    def __repr__(self) -> str:
        result = "GetRefinementInput("
        if self.required_string is not None:
            result += f"required_string={repr(self.required_string)}, "

        if self.optional_string is not None:
            result += f"optional_string={repr(self.optional_string)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, GetRefinementInput):
            return False
        attributes: list[str] = ['required_string','optional_string',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class GetRefinementOutput:
    required_string: str
    optional_string: Optional[str]
    def __init__(
        self,
        *,
        required_string: str,
        optional_string: Optional[str] = None,
    ):
        self.required_string = required_string
        self.optional_string = optional_string

    def as_dict(self) -> Dict[str, Any]:
        """Converts the GetRefinementOutput to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        d: Dict[str, Any] = {
            "requiredString": self.required_string,
        }

        if self.optional_string is not None:
            d["optionalString"] = self.optional_string

        return d

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "GetRefinementOutput":
        """Creates a GetRefinementOutput from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {
            "required_string": d["requiredString"],
        }

        if "optionalString" in d:
            kwargs["optional_string"] = d["optionalString"]

        return GetRefinementOutput(**kwargs)

    def __repr__(self) -> str:
        result = "GetRefinementOutput("
        if self.required_string is not None:
            result += f"required_string={repr(self.required_string)}, "

        if self.optional_string is not None:
            result += f"optional_string={repr(self.optional_string)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, GetRefinementOutput):
            return False
        attributes: list[str] = ['required_string','optional_string',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class OnlyInputInput:
    value: Optional[str]
    def __init__(
        self,
        *,
        value: Optional[str] = None,
    ):
        self.value = value

    def as_dict(self) -> Dict[str, Any]:
        """Converts the OnlyInputInput to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        d: Dict[str, Any] = {}

        if self.value is not None:
            d["value"] = self.value

        return d

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "OnlyInputInput":
        """Creates a OnlyInputInput from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {}

        if "value" in d:
            kwargs["value"] = d["value"]

        return OnlyInputInput(**kwargs)

    def __repr__(self) -> str:
        result = "OnlyInputInput("
        if self.value is not None:
            result += f"value={repr(self.value)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, OnlyInputInput):
            return False
        attributes: list[str] = ['value',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class OnlyOutputOutput:
    value: Optional[str]
    def __init__(
        self,
        *,
        value: Optional[str] = None,
    ):
        self.value = value

    def as_dict(self) -> Dict[str, Any]:
        """Converts the OnlyOutputOutput to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        d: Dict[str, Any] = {}

        if self.value is not None:
            d["value"] = self.value

        return d

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "OnlyOutputOutput":
        """Creates a OnlyOutputOutput from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {}

        if "value" in d:
            kwargs["value"] = d["value"]

        return OnlyOutputOutput(**kwargs)

    def __repr__(self) -> str:
        result = "OnlyOutputOutput("
        if self.value is not None:
            result += f"value={repr(self.value)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, OnlyOutputOutput):
            return False
        attributes: list[str] = ['value',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class ReadonlyOperationInput:
    required_string: str
    optional_string: Optional[str]
    def __init__(
        self,
        *,
        required_string: str,
        optional_string: Optional[str] = None,
    ):
        self.required_string = required_string
        self.optional_string = optional_string

    def as_dict(self) -> Dict[str, Any]:
        """Converts the ReadonlyOperationInput to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        d: Dict[str, Any] = {
            "requiredString": self.required_string,
        }

        if self.optional_string is not None:
            d["optionalString"] = self.optional_string

        return d

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "ReadonlyOperationInput":
        """Creates a ReadonlyOperationInput from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {
            "required_string": d["requiredString"],
        }

        if "optionalString" in d:
            kwargs["optional_string"] = d["optionalString"]

        return ReadonlyOperationInput(**kwargs)

    def __repr__(self) -> str:
        result = "ReadonlyOperationInput("
        if self.required_string is not None:
            result += f"required_string={repr(self.required_string)}, "

        if self.optional_string is not None:
            result += f"optional_string={repr(self.optional_string)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, ReadonlyOperationInput):
            return False
        attributes: list[str] = ['required_string','optional_string',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class ReadonlyOperationOutput:
    required_string: str
    optional_string: Optional[str]
    def __init__(
        self,
        *,
        required_string: str,
        optional_string: Optional[str] = None,
    ):
        self.required_string = required_string
        self.optional_string = optional_string

    def as_dict(self) -> Dict[str, Any]:
        """Converts the ReadonlyOperationOutput to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        d: Dict[str, Any] = {
            "requiredString": self.required_string,
        }

        if self.optional_string is not None:
            d["optionalString"] = self.optional_string

        return d

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "ReadonlyOperationOutput":
        """Creates a ReadonlyOperationOutput from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {
            "required_string": d["requiredString"],
        }

        if "optionalString" in d:
            kwargs["optional_string"] = d["optionalString"]

        return ReadonlyOperationOutput(**kwargs)

    def __repr__(self) -> str:
        result = "ReadonlyOperationOutput("
        if self.required_string is not None:
            result += f"required_string={repr(self.required_string)}, "

        if self.optional_string is not None:
            result += f"optional_string={repr(self.optional_string)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, ReadonlyOperationOutput):
            return False
        attributes: list[str] = ['required_string','optional_string',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )
