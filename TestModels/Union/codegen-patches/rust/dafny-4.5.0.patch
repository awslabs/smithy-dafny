diff --git b/TestModels/Union/runtimes/rust/dafny_impl/src/implementation_from_dafny.rs a/TestModels/Union/runtimes/rust/dafny_impl/src/implementation_from_dafny.rs
index 931a24b5..eeb13dc0 100644
--- b/TestModels/Union/runtimes/rust/dafny_impl/src/implementation_from_dafny.rs
+++ a/TestModels/Union/runtimes/rust/dafny_impl/src/implementation_from_dafny.rs
@@ -645,7 +645,7 @@ pub mod r#_simple_dunion_dinternaldafny_dtypes {
             message: ::dafny_runtime::Sequence<::dafny_runtime::DafnyCharUTF16>,
         },
         Opaque {
-            obj: ::dafny_runtime::Object<dyn::std::any::Any>,
+            obj: ::dafny_runtime::Object<dyn ::std::any::Any>,
         },
     }
 
@@ -666,7 +666,7 @@ pub mod r#_simple_dunion_dinternaldafny_dtypes {
                 Error::Opaque { obj } => panic!("field does not exist on this variant"),
             }
         }
-        pub fn obj(&self) -> &::dafny_runtime::Object<dyn::std::any::Any> {
+        pub fn obj(&self) -> &::dafny_runtime::Object<dyn ::std::any::Any> {
             match self {
                 Error::CollectionOfErrors { list, message } => {
                     panic!("field does not exist on this variant")
diff --git b/TestModels/Union/runtimes/rust/src/client.rs a/TestModels/Union/runtimes/rust/src/client.rs
new file mode 100644
index 00000000..058b2ed9
--- /dev/null
+++ a/TestModels/Union/runtimes/rust/src/client.rs
@@ -0,0 +1,40 @@
+// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
+
+use aws_smithy_types::error::operation::BuildError;
+
+#[derive(::std::clone::Clone, ::std::fmt::Debug)]
+pub struct Client {
+    pub(crate) dafny_client: ::dafny_runtime::Object<
+        dyn ::simple_union_dafny::r#_simple_dunion_dinternaldafny_dtypes::ISimpleUnionClient,
+    >,
+}
+
+impl Client {
+    /// Creates a new client from the service [`Config`](crate::Config).
+    #[track_caller]
+    pub fn from_conf(
+        conf: crate::types::simple_union_config::SimpleUnionConfig,
+    ) -> Result<Self, BuildError> {
+        let inner = ::simple_union_dafny::_simple_dunion_dinternaldafny::_default::SimpleUnion(
+            &crate::conversions::simple_union_config::_simple_union_config::to_dafny(conf),
+        );
+        if matches!(
+            inner.as_ref(),
+            ::simple_union_dafny::_Wrappers_Compile::Result::Failure { .. }
+        ) {
+            // TODO: convert error - the potential types are not modeled!
+            return Err(BuildError::other(
+                ::aws_smithy_types::error::metadata::ErrorMetadata::builder()
+                    .message("Invalid client config")
+                    .build(),
+            ));
+        }
+        Ok(Self {
+            dafny_client: ::dafny_runtime::UpcastTo::<dafny_runtime::Object<(dyn ::simple_union_dafny::r#_simple_dunion_dinternaldafny_dtypes::ISimpleUnionClient + 'static)>>::upcast_to(inner.Extract()),
+        })
+    }
+}
+
+mod get_union;
+
+mod get_union_known_value;
diff --git b/TestModels/Union/runtimes/rust/src/client/get_union.rs a/TestModels/Union/runtimes/rust/src/client/get_union.rs
new file mode 100644
index 00000000..7a1acd59
--- /dev/null
+++ a/TestModels/Union/runtimes/rust/src/client/get_union.rs
@@ -0,0 +1,15 @@
+// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
+impl super::Client {
+    /// Constructs a fluent builder for the [`GetUnion`](crate::operation::get_union::builders::GetUnionFluentBuilder) operation.
+    ///
+    /// - The fluent builder is configurable:
+    ///   - [`union(MyUnion)`](crate::operation::get_union::builders::GetUnionFluentBuilder::union) / [`set_union(Option<MyUnion>)`](crate::operation::get_union::builders::GetUnionFluentBuilder::set_union):<br>required: **false**<br>(undocumented)<br>
+    ///   - [`value(i32)`](crate::operation::get_union::builders::GetUnionFluentBuilder::value) / [`set_value(Option<i32>)`](crate::operation::get_union::builders::GetUnionFluentBuilder::set_value):(undocumented)<br>
+    /// - On success, responds with [`GetUnionOutput`](crate::operation::get_union::GetUnionOutput) with field(s):
+    ///   - [`union(Option<MyUnion>)`](crate::operation::get_union::GetUnionOutput::union): (undocumented)
+    ///   - [`value(Option<Union>)`](crate::operation::get_union::GetUnionOutput::value): (undocumented)
+    /// - On failure, responds with [`SdkError<GetUnionError>`](crate::operation::get_union::GetUnionError)
+    pub fn get_union(&self) -> crate::operation::get_union::builders::GetUnionFluentBuilder {
+        crate::operation::get_union::builders::GetUnionFluentBuilder::new(self.clone())
+    }
+}
diff --git b/TestModels/Union/runtimes/rust/src/client/get_union_known_value.rs a/TestModels/Union/runtimes/rust/src/client/get_union_known_value.rs
new file mode 100644
index 00000000..22e35f21
--- /dev/null
+++ a/TestModels/Union/runtimes/rust/src/client/get_union_known_value.rs
@@ -0,0 +1,17 @@
+// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
+impl super::Client {
+    /// Constructs a fluent builder for the [`GetKnownValueUnion`](crate::operation::get_known_value_union::builders::GetKnownValueUnionFluentBuilder) operation.
+    ///
+    /// - The fluent builder is configurable:
+    ///   - [`union(KnownValueUnion)`](crate::operation::get_known_value_union::builders::GetKnownValueUnionFluentBuilder::union) / [`set_union(Option<KnownValueUnion>)`](crate::operation::get_known_value_union::builders::GetKnownValueUnionFluentBuilder::set_union):<br>required: **false**<br>(undocumented)<br>
+    /// - On success, responds with [`GetKnownValueUnionOutput`](crate::operation::get_known_value_union::GetKnownValueUnionOutput) with field(s):
+    ///   - [`union(Option<KnownValueUnion>)`](crate::operation::get_known_value_union::GetKnownValueUnionOutput::union): (undocumented)
+    /// - On failure, responds with [`SdkError<GetKnownValueUnionError>`](crate::operation::get_known_value_union::GetKnownValueUnionError)
+    pub fn get_union_known_value(
+        &self,
+    ) -> crate::operation::get_known_value_union::builders::GetKnownValueUnionFluentBuilder {
+        crate::operation::get_known_value_union::builders::GetKnownValueUnionFluentBuilder::new(
+            self.clone(),
+        )
+    }
+}
diff --git b/TestModels/Union/runtimes/rust/src/conversions.rs a/TestModels/Union/runtimes/rust/src/conversions.rs
new file mode 100644
index 00000000..375f610e
--- /dev/null
+++ a/TestModels/Union/runtimes/rust/src/conversions.rs
@@ -0,0 +1,6 @@
+// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
+pub mod get_union;
+
+pub mod get_known_value_union;
+
+pub mod simple_union_config;
diff --git b/TestModels/Union/runtimes/rust/src/conversions/get_known_value_union.rs a/TestModels/Union/runtimes/rust/src/conversions/get_known_value_union.rs
new file mode 100644
index 00000000..a88ee78b
--- /dev/null
+++ a/TestModels/Union/runtimes/rust/src/conversions/get_known_value_union.rs
@@ -0,0 +1,48 @@
+// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
+
+use std::any::Any;
+
+#[allow(dead_code)]
+pub fn to_dafny_error(
+    value: crate::operation::get_known_value_union::GetKnownValueUnionError,
+) -> ::std::rc::Rc<::simple_union_dafny::r#_simple_dunion_dinternaldafny_dtypes::Error> {
+    match value {
+        crate::operation::get_known_value_union::GetKnownValueUnionError::Unhandled(unhandled) => {
+            ::std::rc::Rc::new(
+                ::simple_union_dafny::r#_simple_dunion_dinternaldafny_dtypes::Error::Opaque {
+                    obj: ::dafny_runtime::UpcastTo::<::dafny_runtime::Object<dyn Any>>::upcast_to(
+                        ::dafny_runtime::object::new(unhandled),
+                    ),
+                },
+            )
+        }
+    }
+}
+
+#[allow(dead_code)]
+pub fn from_dafny_error(
+    dafny_value: ::std::rc::Rc<::simple_union_dafny::r#_simple_dunion_dinternaldafny_dtypes::Error>,
+) -> crate::operation::get_known_value_union::GetKnownValueUnionError {
+    // TODO: Losing information here, but we have to figure out how to wrap an arbitrary Dafny value as std::error::Error
+    if matches!(
+        &dafny_value.as_ref(),
+        ::simple_union_dafny::r#_simple_dunion_dinternaldafny_dtypes::Error::CollectionOfErrors { .. }
+    ) {
+        let error_message = "TODO: can't get message yet";
+        crate::operation::get_known_value_union::GetKnownValueUnionError::generic(
+            ::aws_smithy_types::error::metadata::ErrorMetadata::builder()
+                .message(error_message)
+                .build(),
+        )
+    } else {
+        crate::operation::get_known_value_union::GetKnownValueUnionError::generic(
+            ::aws_smithy_types::error::metadata::ErrorMetadata::builder()
+                .message("Opaque error")
+                .build(),
+        )
+    }
+}
+
+pub mod _get_known_value_union_input;
+
+pub mod _get_known_value_union_output;
diff --git b/TestModels/Union/runtimes/rust/src/conversions/get_known_value_union/_get_known_value_union_input.rs a/TestModels/Union/runtimes/rust/src/conversions/get_known_value_union/_get_known_value_union_input.rs
new file mode 100644
index 00000000..3d8cc1e5
--- /dev/null
+++ a/TestModels/Union/runtimes/rust/src/conversions/get_known_value_union/_get_known_value_union_input.rs
@@ -0,0 +1,56 @@
+// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
+#[allow(dead_code)]
+pub fn to_dafny(
+    value: crate::operation::get_known_value_union::GetKnownValueUnionInput,
+) -> ::std::rc::Rc<
+    ::simple_union_dafny::r#_simple_dunion_dinternaldafny_dtypes::GetKnownValueUnionInput,
+> {
+    let dafny_value = match value.value {
+        Some(v) => ::simple_union_dafny::_Wrappers_Compile::Option::Some {
+            value: {
+                let v = match v {
+                        crate::types::_known_value_union::KnownValueUnion::Value(n) => {
+                            ::simple_union_dafny::_simple_dunion_dinternaldafny_dtypes::KnownValueUnion::Value { Value: n }
+                        }
+                        crate::types::_known_value_union::KnownValueUnion::Unknown => unreachable!()
+                    };
+
+                ::std::rc::Rc::new(v)
+            },
+        },
+        None => ::simple_union_dafny::_Wrappers_Compile::Option::None {},
+    };
+    ::std::rc::Rc::new(::simple_union_dafny::r#_simple_dunion_dinternaldafny_dtypes::GetKnownValueUnionInput::GetKnownValueUnionInput {
+    r#union: ::std::rc::Rc::new(dafny_value)
+  })
+}
+
+#[allow(dead_code)]
+pub fn from_dafny(
+    dafny_value: ::std::rc::Rc<
+        ::simple_union_dafny::r#_simple_dunion_dinternaldafny_dtypes::GetKnownValueUnionInput,
+    >,
+) -> crate::operation::get_known_value_union::GetKnownValueUnionInput {
+    let value = if matches!(
+        dafny_value.union().as_ref(),
+        ::simple_union_dafny::_Wrappers_Compile::Option::Some { .. }
+    ) {
+        let v = dafny_value.union().Extract();
+        let v = ::std::rc::Rc::try_unwrap(v).unwrap_or_else(|rc| (*rc).clone());
+        let v = match v {
+            simple_union_dafny::_simple_dunion_dinternaldafny_dtypes::KnownValueUnion::Value {
+                Value,
+            } => crate::types::_known_value_union::KnownValueUnion::Value(Value),
+        };
+        Some(v)
+    } else if matches!(
+        dafny_value.union().as_ref(),
+        ::simple_union_dafny::_Wrappers_Compile::Option::None { .. }
+    ) {
+        None
+    } else {
+        panic!("Unreachable")
+    };
+
+    crate::operation::get_known_value_union::GetKnownValueUnionInput { value }
+}
diff --git b/TestModels/Union/runtimes/rust/src/conversions/get_known_value_union/_get_known_value_union_output.rs a/TestModels/Union/runtimes/rust/src/conversions/get_known_value_union/_get_known_value_union_output.rs
new file mode 100644
index 00000000..8366c01d
--- /dev/null
+++ a/TestModels/Union/runtimes/rust/src/conversions/get_known_value_union/_get_known_value_union_output.rs
@@ -0,0 +1,54 @@
+// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
+#[allow(dead_code)]
+pub fn to_dafny(
+    value: crate::operation::get_known_value_union::GetKnownValueUnionOutput,
+) -> ::std::rc::Rc<::simple_union_dafny::r#_simple_dunion_dinternaldafny_dtypes::GetUnionOutput> {
+    let dafny_value = match value.union {
+        Some(v) => ::simple_union_dafny::_Wrappers_Compile::Option::Some {
+            value: {
+                let v = match v {
+                crate::types::_known_value_union::KnownValueUnion::Value(n) => {
+                    ::simple_union_dafny::_simple_dunion_dinternaldafny_dtypes::MyUnion::IntegerValue { IntegerValue: n }
+                }
+                crate::types::_known_value_union::KnownValueUnion::Unknown => unreachable!(),
+                };
+
+                ::std::rc::Rc::new(v)
+            },
+        },
+        None => ::simple_union_dafny::_Wrappers_Compile::Option::None {},
+    };
+    ::std::rc::Rc::new(::simple_union_dafny::r#_simple_dunion_dinternaldafny_dtypes::GetUnionOutput::GetUnionOutput {
+    r#union: ::std::rc::Rc::new(dafny_value)
+  })
+}
+
+#[allow(dead_code)]
+pub fn from_dafny(
+    dafny_value: ::std::rc::Rc<
+        ::simple_union_dafny::r#_simple_dunion_dinternaldafny_dtypes::GetKnownValueUnionOutput,
+    >,
+) -> crate::operation::get_known_value_union::GetKnownValueUnionOutput {
+    let union = if matches!(
+        dafny_value.union().as_ref(),
+        ::simple_union_dafny::_Wrappers_Compile::Option::Some { .. }
+    ) {
+        let v = dafny_value.union().Extract();
+        let v = ::std::rc::Rc::try_unwrap(v).unwrap_or_else(|rc| (*rc).clone());
+        let v = match v {
+            simple_union_dafny::_simple_dunion_dinternaldafny_dtypes::KnownValueUnion::Value {
+                Value,
+            } => crate::types::_known_value_union::KnownValueUnion::Value(Value),
+        };
+        Some(v)
+    } else if matches!(
+        dafny_value.union().as_ref(),
+        ::simple_union_dafny::_Wrappers_Compile::Option::None { .. }
+    ) {
+        None
+    } else {
+        panic!("Unreachable")
+    };
+
+    crate::operation::get_known_value_union::GetKnownValueUnionOutput { union }
+}
diff --git b/TestModels/Union/runtimes/rust/src/conversions/get_union.rs a/TestModels/Union/runtimes/rust/src/conversions/get_union.rs
new file mode 100644
index 00000000..658f0c17
--- /dev/null
+++ a/TestModels/Union/runtimes/rust/src/conversions/get_union.rs
@@ -0,0 +1,46 @@
+// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
+
+use std::any::Any;
+
+#[allow(dead_code)]
+pub fn to_dafny_error(
+    value: crate::operation::get_union::GetUnionError,
+) -> ::std::rc::Rc<::simple_union_dafny::r#_simple_dunion_dinternaldafny_dtypes::Error> {
+    match value {
+        crate::operation::get_union::GetUnionError::Unhandled(unhandled) => ::std::rc::Rc::new(
+            ::simple_union_dafny::r#_simple_dunion_dinternaldafny_dtypes::Error::Opaque {
+                obj: ::dafny_runtime::UpcastTo::<::dafny_runtime::Object<dyn Any>>::upcast_to(
+                    ::dafny_runtime::object::new(unhandled),
+                ),
+            },
+        ),
+    }
+}
+
+#[allow(dead_code)]
+pub fn from_dafny_error(
+    dafny_value: ::std::rc::Rc<::simple_union_dafny::r#_simple_dunion_dinternaldafny_dtypes::Error>,
+) -> crate::operation::get_union::GetUnionError {
+    // TODO: Losing information here, but we have to figure out how to wrap an arbitrary Dafny value as std::error::Error
+    if matches!(
+        &dafny_value.as_ref(),
+        ::simple_union_dafny::r#_simple_dunion_dinternaldafny_dtypes::Error::CollectionOfErrors { .. }
+    ) {
+        let error_message = "TODO: can't get message yet";
+        crate::operation::get_union::GetUnionError::generic(
+            ::aws_smithy_types::error::metadata::ErrorMetadata::builder()
+                .message(error_message)
+                .build(),
+        )
+    } else {
+        crate::operation::get_union::GetUnionError::generic(
+            ::aws_smithy_types::error::metadata::ErrorMetadata::builder()
+                .message("Opaque error")
+                .build(),
+        )
+    }
+}
+
+pub mod _get_union_input;
+
+pub mod _get_union_output;
diff --git b/TestModels/Union/runtimes/rust/src/conversions/get_union/_get_union_input.rs a/TestModels/Union/runtimes/rust/src/conversions/get_union/_get_union_input.rs
new file mode 100644
index 00000000..2ba16c99
--- /dev/null
+++ a/TestModels/Union/runtimes/rust/src/conversions/get_union/_get_union_input.rs
@@ -0,0 +1,60 @@
+// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
+#[allow(dead_code)]
+pub fn to_dafny(
+    value: crate::operation::get_union::GetUnionInput,
+) -> ::std::rc::Rc<::simple_union_dafny::r#_simple_dunion_dinternaldafny_dtypes::GetUnionInput> {
+    let dafny_value = match value.union {
+        Some(v) => ::simple_union_dafny::_Wrappers_Compile::Option::Some {
+            value: {
+                let v = match v {
+                crate::types::_my_union::MyUnion::IntegerValue(n) => {
+                    ::simple_union_dafny::_simple_dunion_dinternaldafny_dtypes::MyUnion::IntegerValue { IntegerValue: n }
+                }
+                crate::types::_my_union::MyUnion::StringValue(s) => simple_union_dafny::_simple_dunion_dinternaldafny_dtypes::MyUnion::StringValue { StringValue: dafny_runtime::dafny_runtime_conversions::unicode_chars_false::string_to_dafny_string(&s) },
+                crate::types::_my_union::MyUnion::Unknown => unreachable!(),
+                };
+
+                ::std::rc::Rc::new(v)
+            },
+        },
+        None => ::simple_union_dafny::_Wrappers_Compile::Option::None {},
+    };
+    ::std::rc::Rc::new(::simple_union_dafny::r#_simple_dunion_dinternaldafny_dtypes::GetUnionInput::GetUnionInput {
+    r#union: ::std::rc::Rc::new(dafny_value)
+  })
+}
+
+#[allow(dead_code)]
+pub fn from_dafny(
+    dafny_value: ::std::rc::Rc<
+        ::simple_union_dafny::r#_simple_dunion_dinternaldafny_dtypes::GetUnionInput,
+    >,
+) -> crate::operation::get_union::GetUnionInput {
+    let value = if matches!(
+        dafny_value.union().as_ref(),
+        ::simple_union_dafny::_Wrappers_Compile::Option::Some { .. }
+    ) {
+        let v = dafny_value.union().Extract();
+        let v = ::std::rc::Rc::try_unwrap(v).unwrap_or_else(|rc| (*rc).clone());
+        let v = match v {
+            simple_union_dafny::_simple_dunion_dinternaldafny_dtypes::MyUnion::IntegerValue {
+                IntegerValue,
+            } => crate::types::_my_union::MyUnion::IntegerValue(IntegerValue),
+            simple_union_dafny::_simple_dunion_dinternaldafny_dtypes::MyUnion::StringValue {
+                StringValue,
+            } => crate::types::_my_union::MyUnion::StringValue(dafny_runtime::dafny_runtime_conversions::unicode_chars_false::dafny_string_to_string(
+                &StringValue,
+            )),
+        };
+        Some(v)
+    } else if matches!(
+        dafny_value.union().as_ref(),
+        ::simple_union_dafny::_Wrappers_Compile::Option::None { .. }
+    ) {
+        None
+    } else {
+        panic!("Unreachable")
+    };
+
+    crate::operation::get_union::GetUnionInput { union: value }
+}
diff --git b/TestModels/Union/runtimes/rust/src/conversions/get_union/_get_union_output.rs a/TestModels/Union/runtimes/rust/src/conversions/get_union/_get_union_output.rs
new file mode 100644
index 00000000..95829bf2
--- /dev/null
+++ a/TestModels/Union/runtimes/rust/src/conversions/get_union/_get_union_output.rs
@@ -0,0 +1,60 @@
+// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
+#[allow(dead_code)]
+pub fn to_dafny(
+    value: crate::operation::get_union::GetUnionOutput,
+) -> ::std::rc::Rc<::simple_union_dafny::r#_simple_dunion_dinternaldafny_dtypes::GetUnionOutput> {
+    let dafny_value = match value.union {
+        Some(v) => ::simple_union_dafny::_Wrappers_Compile::Option::Some {
+            value: {
+                let v = match v {
+                crate::types::_my_union::MyUnion::IntegerValue(n) => {
+                    ::simple_union_dafny::_simple_dunion_dinternaldafny_dtypes::MyUnion::IntegerValue { IntegerValue: n }
+                }
+                crate::types::_my_union::MyUnion::StringValue(s) => simple_union_dafny::_simple_dunion_dinternaldafny_dtypes::MyUnion::StringValue { StringValue: dafny_runtime::dafny_runtime_conversions::unicode_chars_false::string_to_dafny_string(&s) },
+                crate::types::_my_union::MyUnion::Unknown => unreachable!(),
+                };
+
+                ::std::rc::Rc::new(v)
+            },
+        },
+        None => ::simple_union_dafny::_Wrappers_Compile::Option::None {},
+    };
+    ::std::rc::Rc::new(::simple_union_dafny::r#_simple_dunion_dinternaldafny_dtypes::GetUnionOutput::GetUnionOutput {
+    r#union: ::std::rc::Rc::new(dafny_value)
+  })
+}
+
+#[allow(dead_code)]
+pub fn from_dafny(
+    dafny_value: ::std::rc::Rc<
+        ::simple_union_dafny::r#_simple_dunion_dinternaldafny_dtypes::GetUnionOutput,
+    >,
+) -> crate::operation::get_union::GetUnionOutput {
+    let union = if matches!(
+        dafny_value.union().as_ref(),
+        ::simple_union_dafny::_Wrappers_Compile::Option::Some { .. }
+    ) {
+        let v = dafny_value.union().Extract();
+        let v = ::std::rc::Rc::try_unwrap(v).unwrap_or_else(|rc| (*rc).clone());
+        let v = match v {
+            simple_union_dafny::_simple_dunion_dinternaldafny_dtypes::MyUnion::IntegerValue {
+                IntegerValue,
+            } => crate::types::_my_union::MyUnion::IntegerValue(IntegerValue),
+            simple_union_dafny::_simple_dunion_dinternaldafny_dtypes::MyUnion::StringValue {
+                StringValue,
+            } => crate::types::_my_union::MyUnion::StringValue(dafny_runtime::dafny_runtime_conversions::unicode_chars_false::dafny_string_to_string(
+                &StringValue,
+            )),
+        };
+        Some(v)
+    } else if matches!(
+        dafny_value.union().as_ref(),
+        ::simple_union_dafny::_Wrappers_Compile::Option::None { .. }
+    ) {
+        None
+    } else {
+        panic!("Unreachable")
+    };
+
+    crate::operation::get_union::GetUnionOutput { union }
+}
diff --git b/TestModels/Union/runtimes/rust/src/conversions/simple_union_config.rs a/TestModels/Union/runtimes/rust/src/conversions/simple_union_config.rs
new file mode 100644
index 00000000..f47a69b4
--- /dev/null
+++ a/TestModels/Union/runtimes/rust/src/conversions/simple_union_config.rs
@@ -0,0 +1,3 @@
+// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
+
+pub mod _simple_union_config;
diff --git b/TestModels/Union/runtimes/rust/src/conversions/simple_union_config/_simple_union_config.rs a/TestModels/Union/runtimes/rust/src/conversions/simple_union_config/_simple_union_config.rs
new file mode 100644
index 00000000..702d25f2
--- /dev/null
+++ a/TestModels/Union/runtimes/rust/src/conversions/simple_union_config/_simple_union_config.rs
@@ -0,0 +1,17 @@
+// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
+#[allow(dead_code)]
+
+pub fn to_dafny(
+    value: crate::types::simple_union_config::SimpleUnionConfig,
+) -> ::std::rc::Rc<::simple_union_dafny::_simple_dunion_dinternaldafny_dtypes::SimpleUnionConfig> {
+    ::std::rc::Rc::new(::simple_union_dafny::r#_simple_dunion_dinternaldafny_dtypes::SimpleUnionConfig::SimpleUnionConfig {})
+}
+
+#[allow(dead_code)]
+pub fn from_dafny(
+    dafny_value: ::std::rc::Rc<
+        ::simple_union_dafny::r#_simple_dunion_dinternaldafny_dtypes::SimpleUnionConfig,
+    >,
+) -> crate::types::simple_union_config::SimpleUnionConfig {
+    crate::types::simple_union_config::SimpleUnionConfig {}
+}
diff --git b/TestModels/Union/runtimes/rust/src/error.rs a/TestModels/Union/runtimes/rust/src/error.rs
new file mode 100644
index 00000000..ec89cbec
--- /dev/null
+++ a/TestModels/Union/runtimes/rust/src/error.rs
@@ -0,0 +1,14 @@
+// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
+pub use ::aws_smithy_runtime_api::box_error::BoxError;
+
+/// Error type returned by the client.
+pub type SdkError<E, R = ::aws_smithy_runtime_api::client::orchestrator::HttpResponse> =
+    ::aws_smithy_runtime_api::client::result::SdkError<E, R>;
+pub use ::aws_smithy_runtime_api::client::result::ConnectorError;
+pub use ::aws_smithy_types::error::operation::BuildError;
+
+pub use ::aws_smithy_types::error::display::DisplayErrorContext;
+pub use ::aws_smithy_types::error::metadata::ErrorMetadata;
+pub use ::aws_smithy_types::error::metadata::ProvideErrorMetadata;
+
+pub(crate) mod sealed_unhandled;
diff --git b/TestModels/Union/runtimes/rust/src/error/sealed_unhandled.rs a/TestModels/Union/runtimes/rust/src/error/sealed_unhandled.rs
new file mode 100644
index 00000000..9d21fbd6
--- /dev/null
+++ a/TestModels/Union/runtimes/rust/src/error/sealed_unhandled.rs
@@ -0,0 +1,22 @@
+// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
+/// This struct is not intended to be used.
+///
+/// This struct holds information about an unhandled error,
+/// but that information should be obtained by using the
+/// [`ProvideErrorMetadata`](::aws_smithy_types::error::metadata::ProvideErrorMetadata) trait
+/// on the error type.
+///
+/// This struct intentionally doesn't yield any useful information itself.
+#[deprecated(
+    note = "Matching `Unhandled` directly is not forwards compatible. Instead, match using a \
+variable wildcard pattern and check `.code()`:
+ \
+&nbsp;&nbsp;&nbsp;`err if err.code() == Some(\"SpecificExceptionCode\") => { /* handle the error */ }`
+ \
+See [`ProvideErrorMetadata`](::aws_smithy_types::error::metadata::ProvideErrorMetadata) for what information is available for the error."
+)]
+#[derive(Debug)]
+pub struct Unhandled {
+    pub(crate) source: ::aws_smithy_runtime_api::box_error::BoxError,
+    pub(crate) meta: ::aws_smithy_types::error::metadata::ErrorMetadata,
+}
diff --git b/TestModels/Union/runtimes/rust/src/lib.rs a/TestModels/Union/runtimes/rust/src/lib.rs
new file mode 100644
index 00000000..e98c995a
--- /dev/null
+++ a/TestModels/Union/runtimes/rust/src/lib.rs
@@ -0,0 +1,17 @@
+#![allow(deprecated)]
+
+// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
+
+pub mod client;
+pub mod types;
+
+/// Common errors and error handling utilities.
+pub mod error;
+
+/// All operations that this crate can perform.
+pub mod operation;
+
+mod conversions;
+
+pub use client::Client;
+pub use types::simple_union_config::SimpleUnionConfig;
diff --git b/TestModels/Union/runtimes/rust/src/operation.rs a/TestModels/Union/runtimes/rust/src/operation.rs
new file mode 100644
index 00000000..91564304
--- /dev/null
+++ a/TestModels/Union/runtimes/rust/src/operation.rs
@@ -0,0 +1,7 @@
+// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
+
+/// Types for the `GetUnion` operation.
+pub mod get_union;
+
+/// Types for the `GetKnownValueUnion` operation.
+pub mod get_known_value_union;
diff --git b/TestModels/Union/runtimes/rust/src/operation/get_known_value_union.rs a/TestModels/Union/runtimes/rust/src/operation/get_known_value_union.rs
new file mode 100644
index 00000000..6deba10b
--- /dev/null
+++ a/TestModels/Union/runtimes/rust/src/operation/get_known_value_union.rs
@@ -0,0 +1,148 @@
+// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
+/// Orchestration and serialization glue logic for `GetKnownValueUnion`.
+#[derive(::std::clone::Clone, ::std::default::Default, ::std::fmt::Debug)]
+#[non_exhaustive]
+pub struct GetKnownValueUnion;
+impl GetKnownValueUnion {
+    /// Creates a new `GetKnownValueUnion`
+    pub fn new() -> Self {
+        Self
+    }
+    pub(crate) async fn send(
+        client: &crate::client::Client,
+        input: crate::operation::get_known_value_union::GetKnownValueUnionInput,
+    ) -> ::std::result::Result<
+        crate::operation::get_known_value_union::GetKnownValueUnionOutput,
+        crate::operation::get_known_value_union::GetKnownValueUnionError,
+    > {
+        let inner_input =
+            crate::conversions::get_known_value_union::_get_known_value_union_input::to_dafny(
+                input,
+            );
+        let inner_result =
+            ::dafny_runtime::md!(client.dafny_client.clone()).GetKnownValueUnion(&inner_input);
+        if matches!(
+            inner_result.as_ref(),
+            ::simple_union_dafny::r#_Wrappers_Compile::Result::Success { .. }
+        ) {
+            Ok(
+                crate::conversions::get_known_value_union::_get_known_value_union_output::from_dafny(
+                    inner_result.value().clone(),
+                ),
+            )
+        } else {
+            Err(crate::conversions::get_known_value_union::from_dafny_error(
+                inner_result.error().clone(),
+            ))
+        }
+    }
+}
+
+/// Error type for the `GetKnownValueUnion` operation.
+#[non_exhaustive]
+#[derive(::std::fmt::Debug)]
+pub enum GetKnownValueUnionError {
+    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
+    #[deprecated(
+        note = "Matching `Unhandled` directly is not forwards compatible. Instead, match using a \
+    variable wildcard pattern and check `.code()`:
+     \
+    &nbsp;&nbsp;&nbsp;`err if err.code() == Some(\"SpecificExceptionCode\") => { /* handle the error */ }`
+     \
+    See [`ProvideErrorMetadata`](#impl-ProvideErrorMetadata-for-GetKnownValueUnionError) for what information is available for the error."
+    )]
+    Unhandled(crate::error::sealed_unhandled::Unhandled),
+}
+impl GetKnownValueUnionError {
+    /// Creates the `GetKnownValueUnionError::Unhandled` variant from any error type.
+    pub fn unhandled(
+        err: impl ::std::convert::Into<
+            ::std::boxed::Box<
+                dyn ::std::error::Error + ::std::marker::Send + ::std::marker::Sync + 'static,
+            >,
+        >,
+    ) -> Self {
+        Self::Unhandled(crate::error::sealed_unhandled::Unhandled {
+            source: err.into(),
+            meta: ::std::default::Default::default(),
+        })
+    }
+
+    /// Creates the `GetKnownValueUnionError::Unhandled` variant from an [`ErrorMetadata`](::aws_smithy_types::error::ErrorMetadata).
+    pub fn generic(err: ::aws_smithy_types::error::ErrorMetadata) -> Self {
+        Self::Unhandled(crate::error::sealed_unhandled::Unhandled {
+            source: err.clone().into(),
+            meta: err,
+        })
+    }
+    ///
+    /// Returns error metadata, which includes the error code, message,
+    /// request ID, and potentially additional information.
+    ///
+    pub fn meta(&self) -> &::aws_smithy_types::error::ErrorMetadata {
+        match self {
+            Self::Unhandled(e) => &e.meta,
+        }
+    }
+}
+impl ::std::error::Error for GetKnownValueUnionError {
+    fn source(&self) -> ::std::option::Option<&(dyn ::std::error::Error + 'static)> {
+        match self {
+            Self::Unhandled(_inner) => ::std::option::Option::Some(&*_inner.source),
+        }
+    }
+}
+impl ::std::fmt::Display for GetKnownValueUnionError {
+    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
+        match self {
+            Self::Unhandled(_inner) => {
+                if let ::std::option::Option::Some(code) =
+                    ::aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
+                {
+                    write!(f, "unhandled error ({code})")
+                } else {
+                    f.write_str("unhandled error")
+                }
+            }
+        }
+    }
+}
+impl ::aws_smithy_types::retry::ProvideErrorKind for GetKnownValueUnionError {
+    fn code(&self) -> ::std::option::Option<&str> {
+        ::aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
+    }
+    fn retryable_error_kind(&self) -> ::std::option::Option<::aws_smithy_types::retry::ErrorKind> {
+        ::std::option::Option::None
+    }
+}
+impl ::aws_smithy_types::error::metadata::ProvideErrorMetadata for GetKnownValueUnionError {
+    fn meta(&self) -> &::aws_smithy_types::error::ErrorMetadata {
+        match self {
+            Self::Unhandled(_inner) => &_inner.meta,
+        }
+    }
+}
+impl ::aws_smithy_runtime_api::client::result::CreateUnhandledError for GetKnownValueUnionError {
+    fn create_unhandled_error(
+        source: ::std::boxed::Box<
+            dyn ::std::error::Error + ::std::marker::Send + ::std::marker::Sync + 'static,
+        >,
+        meta: ::std::option::Option<::aws_smithy_types::error::ErrorMetadata>,
+    ) -> Self {
+        Self::Unhandled(crate::error::sealed_unhandled::Unhandled {
+            source,
+            meta: meta.unwrap_or_default(),
+        })
+    }
+}
+
+pub use crate::operation::get_known_value_union::_get_known_value_union_output::GetKnownValueUnionOutput;
+
+pub use crate::operation::get_known_value_union::_get_known_value_union_input::GetKnownValueUnionInput;
+
+mod _get_known_value_union_input;
+
+mod _get_known_value_union_output;
+
+/// Builders
+pub mod builders;
diff --git b/TestModels/Union/runtimes/rust/src/operation/get_known_value_union/_get_known_value_union_input.rs a/TestModels/Union/runtimes/rust/src/operation/get_known_value_union/_get_known_value_union_input.rs
new file mode 100644
index 00000000..bfe340c3
--- /dev/null
+++ a/TestModels/Union/runtimes/rust/src/operation/get_known_value_union/_get_known_value_union_input.rs
@@ -0,0 +1,64 @@
+// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
+#[allow(missing_docs)] // documentation missing in model
+#[non_exhaustive]
+#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
+pub struct GetKnownValueUnionInput {
+    #[allow(missing_docs)] // documentation missing in model
+    pub value: ::std::option::Option<crate::types::_known_value_union::KnownValueUnion>,
+}
+impl GetKnownValueUnionInput {
+    #[allow(missing_docs)] // documentation missing in model
+    pub fn value(
+        &self,
+    ) -> &::std::option::Option<crate::types::_known_value_union::KnownValueUnion> {
+        &self.value
+    }
+}
+impl GetKnownValueUnionInput {
+    /// Creates a new builder-style object to manufacture [`GetKnownValueUnionInput`](crate::operation::get_known_value_union::GetKnownValueUnionInput).
+    pub fn builder(
+    ) -> crate::operation::get_known_value_union::builders::GetKnownValueUnionInputBuilder {
+        crate::operation::get_known_value_union::builders::GetKnownValueUnionInputBuilder::default()
+    }
+}
+
+/// A builder for [`GetKnownValueUnionInput`](crate::operation::get_known_value_union::GetKnownValueUnionInput).
+#[non_exhaustive]
+#[derive(
+    ::std::clone::Clone, ::std::cmp::PartialEq, ::std::default::Default, ::std::fmt::Debug,
+)]
+pub struct GetKnownValueUnionInputBuilder {
+    pub(crate) value: ::std::option::Option<crate::types::_known_value_union::KnownValueUnion>,
+}
+impl GetKnownValueUnionInputBuilder {
+    #[allow(missing_docs)] // documentation missing in model
+    pub fn value(mut self, input: crate::types::_known_value_union::KnownValueUnion) -> Self {
+        self.value = ::std::option::Option::Some(input);
+        self
+    }
+    #[allow(missing_docs)] // documentation missing in model
+    pub fn set_value(
+        mut self,
+        input: ::std::option::Option<crate::types::_known_value_union::KnownValueUnion>,
+    ) -> Self {
+        self.value = input;
+        self
+    }
+    #[allow(missing_docs)] // documentation missing in model
+    pub fn get_value(
+        &self,
+    ) -> &::std::option::Option<crate::types::_known_value_union::KnownValueUnion> {
+        &self.value
+    }
+    /// Consumes the builder and constructs a [`GetKnownValueUnionInput`](crate::operation::get_known_value_union::GetKnownValueUnionInput).
+    pub fn build(
+        self,
+    ) -> ::std::result::Result<
+        crate::operation::get_known_value_union::GetKnownValueUnionInput,
+        ::aws_smithy_types::error::operation::BuildError,
+    > {
+        ::std::result::Result::Ok(
+            crate::operation::get_known_value_union::GetKnownValueUnionInput { value: self.value },
+        )
+    }
+}
diff --git b/TestModels/Union/runtimes/rust/src/operation/get_known_value_union/_get_known_value_union_output.rs a/TestModels/Union/runtimes/rust/src/operation/get_known_value_union/_get_known_value_union_output.rs
new file mode 100644
index 00000000..1d9fcfa9
--- /dev/null
+++ a/TestModels/Union/runtimes/rust/src/operation/get_known_value_union/_get_known_value_union_output.rs
@@ -0,0 +1,68 @@
+// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
+#[allow(missing_docs)] // documentation missing in model
+#[non_exhaustive]
+#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
+pub struct GetKnownValueUnionOutput {
+    #[allow(missing_docs)] // documentation missing in model
+    pub union: ::std::option::Option<crate::types::_known_value_union::KnownValueUnion>,
+}
+impl GetKnownValueUnionOutput {
+    #[allow(missing_docs)] // documentation missing in model
+    pub fn value(
+        &self,
+    ) -> ::std::option::Option<&crate::types::_known_value_union::KnownValueUnion> {
+        self.union.as_ref()
+    }
+}
+impl GetKnownValueUnionOutput {
+    /// Creates a new builder-style object to manufacture [`GetKnownValueUnionOutput`](crate::operation::get_union_known_value::GetKnownValueUnionOutput).
+    pub fn builder(
+    ) -> crate::operation::get_known_value_union::builders::GetKnownValueUnionOutputBuilder {
+        crate::operation::get_known_value_union::builders::GetKnownValueUnionOutputBuilder::default(
+        )
+    }
+}
+
+/// A builder for [`GetKnownValueUnionOutput`](crate::operation::get_union_known_value::GetKnownValueUnionOutput).
+#[non_exhaustive]
+#[derive(
+    ::std::clone::Clone, ::std::cmp::PartialEq, ::std::default::Default, ::std::fmt::Debug,
+)]
+pub struct GetKnownValueUnionOutputBuilder {
+    pub(crate) value: ::std::option::Option<crate::types::_known_value_union::KnownValueUnion>,
+}
+impl GetKnownValueUnionOutputBuilder {
+    #[allow(missing_docs)] // documentation missing in model
+    pub fn value(
+        mut self,
+        input: impl ::std::convert::Into<crate::types::_known_value_union::KnownValueUnion>,
+    ) -> Self {
+        self.value = ::std::option::Option::Some(input.into());
+        self
+    }
+    #[allow(missing_docs)] // documentation missing in model
+    pub fn set_value(
+        mut self,
+        input: ::std::option::Option<crate::types::_known_value_union::KnownValueUnion>,
+    ) -> Self {
+        self.value = input;
+        self
+    }
+    #[allow(missing_docs)] // documentation missing in model
+    pub fn get_value(
+        &self,
+    ) -> &::std::option::Option<crate::types::_known_value_union::KnownValueUnion> {
+        &self.value
+    }
+    /// Consumes the builder and constructs a [`GetKnownValueUnionOutput`](crate::operation::get_union_known_value::GetKnownValueUnionOutput).
+    pub fn build(
+        self,
+    ) -> ::std::result::Result<
+        crate::operation::get_known_value_union::GetKnownValueUnionOutput,
+        ::aws_smithy_types::error::operation::BuildError,
+    > {
+        ::std::result::Result::Ok(
+            crate::operation::get_known_value_union::GetKnownValueUnionOutput { union: self.value },
+        )
+    }
+}
diff --git b/TestModels/Union/runtimes/rust/src/operation/get_known_value_union/builders.rs a/TestModels/Union/runtimes/rust/src/operation/get_known_value_union/builders.rs
new file mode 100644
index 00000000..bff69f92
--- /dev/null
+++ a/TestModels/Union/runtimes/rust/src/operation/get_known_value_union/builders.rs
@@ -0,0 +1,79 @@
+// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
+pub use crate::operation::get_known_value_union::_get_known_value_union_output::GetKnownValueUnionOutputBuilder;
+
+pub use crate::operation::get_known_value_union::_get_known_value_union_input::GetKnownValueUnionInputBuilder;
+
+impl GetKnownValueUnionInputBuilder {
+    /// Sends a request with this input using the given client.
+    pub async fn send_with(
+        self,
+        client: &crate::Client,
+    ) -> ::std::result::Result<
+        crate::operation::get_known_value_union::GetKnownValueUnionOutput,
+        crate::operation::get_known_value_union::GetKnownValueUnionError,
+    > {
+        let mut fluent_builder = client.get_union_known_value();
+        fluent_builder.inner = self;
+        fluent_builder.send().await
+    }
+}
+/// Fluent builder constructing a request to `GetKnownValueUnion`.
+///
+#[derive(::std::clone::Clone, ::std::fmt::Debug)]
+pub struct GetKnownValueUnionFluentBuilder {
+    client: crate::client::Client,
+    inner: crate::operation::get_known_value_union::builders::GetKnownValueUnionInputBuilder,
+}
+impl GetKnownValueUnionFluentBuilder {
+    /// Creates a new `GetKnownValueUnionFluentBuilder`.
+    pub(crate) fn new(client: crate::client::Client) -> Self {
+        Self {
+            client,
+            inner: ::std::default::Default::default(),
+        }
+    }
+    /// Access the GetKnownValueUnion as a reference.
+    pub fn as_input(
+        &self,
+    ) -> &crate::operation::get_known_value_union::builders::GetKnownValueUnionInputBuilder {
+        &self.inner
+    }
+    /// Sends the request and returns the response.
+    pub async fn send(
+        self,
+    ) -> ::std::result::Result<
+        crate::operation::get_known_value_union::GetKnownValueUnionOutput,
+        crate::operation::get_known_value_union::GetKnownValueUnionError,
+    > {
+        let input = self
+            .inner
+            .build()
+            // Using unhandled since GetUnion doesn't declare any validation,
+            // and smithy-rs seems to not generate a ValidationError case unless there is
+            // (but isn't that a backwards compatibility problem for output structures?)
+            // Vanilla smithy-rs uses SdkError::construction_failure,
+            // but we aren't using SdkError.
+            .map_err(crate::operation::get_known_value_union::GetKnownValueUnionError::unhandled)?;
+        crate::operation::get_known_value_union::GetKnownValueUnion::send(&self.client, input).await
+    }
+
+    #[allow(missing_docs)] // documentation missing in model
+    pub fn value(mut self, input: crate::types::_known_value_union::KnownValueUnion) -> Self {
+        self.inner = self.inner.value(input);
+        self
+    }
+    #[allow(missing_docs)] // documentation missing in model
+    pub fn set_value(
+        mut self,
+        input: ::std::option::Option<crate::types::_known_value_union::KnownValueUnion>,
+    ) -> Self {
+        self.inner = self.inner.set_value(input);
+        self
+    }
+    #[allow(missing_docs)] // documentation missing in model
+    pub fn get_value(
+        &self,
+    ) -> &::std::option::Option<crate::types::_known_value_union::KnownValueUnion> {
+        self.inner.get_value()
+    }
+}
diff --git b/TestModels/Union/runtimes/rust/src/operation/get_union.rs a/TestModels/Union/runtimes/rust/src/operation/get_union.rs
new file mode 100644
index 00000000..08f0de25
--- /dev/null
+++ a/TestModels/Union/runtimes/rust/src/operation/get_union.rs
@@ -0,0 +1,145 @@
+// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
+/// Orchestration and serialization glue logic for `GetUnion`.
+#[derive(::std::clone::Clone, ::std::default::Default, ::std::fmt::Debug)]
+#[non_exhaustive]
+pub struct GetUnion;
+impl GetUnion {
+    /// Creates a new `GetUnion`
+    pub fn new() -> Self {
+        Self
+    }
+    pub(crate) async fn send(
+        client: &crate::client::Client,
+        input: crate::operation::get_union::GetUnionInput,
+    ) -> ::std::result::Result<
+        crate::operation::get_union::GetUnionOutput,
+        crate::operation::get_union::GetUnionError,
+    > {
+        let inner_input = crate::conversions::get_union::_get_union_input::to_dafny(input);
+        let inner_result =
+            ::dafny_runtime::md!(client.dafny_client.clone()).GetUnion(&inner_input);
+        if matches!(
+            inner_result.as_ref(),
+            ::simple_union_dafny::r#_Wrappers_Compile::Result::Success { .. }
+        ) {
+            Ok(
+                crate::conversions::get_union::_get_union_output::from_dafny(
+                    inner_result.value().clone(),
+                ),
+            )
+        } else {
+            Err(crate::conversions::get_union::from_dafny_error(
+                inner_result.error().clone(),
+            ))
+        }
+    }
+}
+
+/// Error type for the `GetUnion` operation.
+#[non_exhaustive]
+#[derive(::std::fmt::Debug)]
+pub enum GetUnionError {
+    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
+    #[deprecated(
+        note = "Matching `Unhandled` directly is not forwards compatible. Instead, match using a \
+    variable wildcard pattern and check `.code()`:
+     \
+    &nbsp;&nbsp;&nbsp;`err if err.code() == Some(\"SpecificExceptionCode\") => { /* handle the error */ }`
+     \
+    See [`ProvideErrorMetadata`](#impl-ProvideErrorMetadata-for-GetUnionError) for what information is available for the error."
+    )]
+    Unhandled(crate::error::sealed_unhandled::Unhandled),
+}
+impl GetUnionError {
+    /// Creates the `GetUnionError::Unhandled` variant from any error type.
+    pub fn unhandled(
+        err: impl ::std::convert::Into<
+            ::std::boxed::Box<
+                dyn ::std::error::Error + ::std::marker::Send + ::std::marker::Sync + 'static,
+            >,
+        >,
+    ) -> Self {
+        Self::Unhandled(crate::error::sealed_unhandled::Unhandled {
+            source: err.into(),
+            meta: ::std::default::Default::default(),
+        })
+    }
+
+    /// Creates the `GetUnionError::Unhandled` variant from an [`ErrorMetadata`](::aws_smithy_types::error::ErrorMetadata).
+    pub fn generic(err: ::aws_smithy_types::error::ErrorMetadata) -> Self {
+        Self::Unhandled(crate::error::sealed_unhandled::Unhandled {
+            source: err.clone().into(),
+            meta: err,
+        })
+    }
+    ///
+    /// Returns error metadata, which includes the error code, message,
+    /// request ID, and potentially additional information.
+    ///
+    pub fn meta(&self) -> &::aws_smithy_types::error::ErrorMetadata {
+        match self {
+            Self::Unhandled(e) => &e.meta,
+        }
+    }
+}
+impl ::std::error::Error for GetUnionError {
+    fn source(&self) -> ::std::option::Option<&(dyn ::std::error::Error + 'static)> {
+        match self {
+            Self::Unhandled(_inner) => ::std::option::Option::Some(&*_inner.source),
+        }
+    }
+}
+impl ::std::fmt::Display for GetUnionError {
+    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
+        match self {
+            Self::Unhandled(_inner) => {
+                if let ::std::option::Option::Some(code) =
+                    ::aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
+                {
+                    write!(f, "unhandled error ({code})")
+                } else {
+                    f.write_str("unhandled error")
+                }
+            }
+        }
+    }
+}
+impl ::aws_smithy_types::retry::ProvideErrorKind for GetUnionError {
+    fn code(&self) -> ::std::option::Option<&str> {
+        ::aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
+    }
+    fn retryable_error_kind(&self) -> ::std::option::Option<::aws_smithy_types::retry::ErrorKind> {
+        ::std::option::Option::None
+    }
+}
+impl ::aws_smithy_types::error::metadata::ProvideErrorMetadata for GetUnionError {
+    fn meta(&self) -> &::aws_smithy_types::error::ErrorMetadata {
+        match self {
+            Self::Unhandled(_inner) => &_inner.meta,
+        }
+    }
+}
+impl ::aws_smithy_runtime_api::client::result::CreateUnhandledError for GetUnionError {
+    fn create_unhandled_error(
+        source: ::std::boxed::Box<
+            dyn ::std::error::Error + ::std::marker::Send + ::std::marker::Sync + 'static,
+        >,
+        meta: ::std::option::Option<::aws_smithy_types::error::ErrorMetadata>,
+    ) -> Self {
+        Self::Unhandled(crate::error::sealed_unhandled::Unhandled {
+            source,
+            meta: meta.unwrap_or_default(),
+        })
+    }
+}
+
+pub use crate::operation::get_union::_get_union_output::GetUnionOutput;
+
+pub use crate::operation::get_union::_get_union_input::GetUnionInput;
+
+mod _get_union_input;
+
+mod _get_union_output;
+
+/// Builders
+pub mod builders;
diff --git b/TestModels/Union/runtimes/rust/src/operation/get_union/_get_union_input.rs a/TestModels/Union/runtimes/rust/src/operation/get_union/_get_union_input.rs
new file mode 100644
index 00000000..cb4bef47
--- /dev/null
+++ a/TestModels/Union/runtimes/rust/src/operation/get_union/_get_union_input.rs
@@ -0,0 +1,57 @@
+// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
+#[allow(missing_docs)] // documentation missing in model
+#[non_exhaustive]
+#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
+pub struct GetUnionInput {
+    #[allow(missing_docs)] // documentation missing in model
+    pub union: ::std::option::Option<crate::types::_my_union::MyUnion>,
+}
+impl GetUnionInput {
+    #[allow(missing_docs)] // documentation missing in model
+    pub fn value(&self) -> ::std::option::Option<&crate::types::_my_union::MyUnion> {
+        self.union.as_ref()
+    }
+}
+impl GetUnionInput {
+    /// Creates a new builder-style object to manufacture [`GetUnionInput`](crate::operation::get_union::GetUnionInput).
+    pub fn builder() -> crate::operation::get_union::builders::GetUnionInputBuilder {
+        crate::operation::get_union::builders::GetUnionInputBuilder::default()
+    }
+}
+
+/// A builder for [`GetUnionInput`](crate::operation::get_union::GetUnionInput).
+#[non_exhaustive]
+#[derive(
+    ::std::clone::Clone, ::std::cmp::PartialEq, ::std::default::Default, ::std::fmt::Debug,
+)]
+pub struct GetUnionInputBuilder {
+    pub(crate) value: ::std::option::Option<crate::types::_my_union::MyUnion>,
+}
+impl GetUnionInputBuilder {
+    #[allow(missing_docs)] // documentation missing in model
+    pub fn value(mut self, input: crate::types::_my_union::MyUnion) -> Self {
+        self.value = ::std::option::Option::Some(input);
+        self
+    }
+    #[allow(missing_docs)] // documentation missing in model
+    pub fn set_value(
+        mut self,
+        input: ::std::option::Option<crate::types::_my_union::MyUnion>,
+    ) -> Self {
+        self.value = input;
+        self
+    }
+    #[allow(missing_docs)] // documentation missing in model
+    pub fn get_value(&self) -> &::std::option::Option<crate::types::_my_union::MyUnion> {
+        &self.value
+    }
+    /// Consumes the builder and constructs a [`GetUnionInput`](crate::operation::get_union::GetUnionInput).
+    pub fn build(
+        self,
+    ) -> ::std::result::Result<
+        crate::operation::get_union::GetUnionInput,
+        ::aws_smithy_types::error::operation::BuildError,
+    > {
+        ::std::result::Result::Ok(crate::operation::get_union::GetUnionInput { union: self.value })
+    }
+}
diff --git b/TestModels/Union/runtimes/rust/src/operation/get_union/_get_union_output.rs a/TestModels/Union/runtimes/rust/src/operation/get_union/_get_union_output.rs
new file mode 100644
index 00000000..f8992384
--- /dev/null
+++ a/TestModels/Union/runtimes/rust/src/operation/get_union/_get_union_output.rs
@@ -0,0 +1,66 @@
+// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
+#[allow(missing_docs)] // documentation missing in model
+#[non_exhaustive]
+#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
+pub struct GetUnionOutput {
+    #[allow(missing_docs)] // documentation missing in model
+    pub union: ::std::option::Option<crate::types::_my_union::MyUnion>,
+}
+
+impl GetUnionOutput {
+    #[allow(missing_docs)] // documentation missing in model
+    pub fn value(&self) -> ::std::option::Option<&crate::types::_my_union::MyUnion> {
+        self.union.as_ref()
+    }
+}
+
+impl GetUnionOutput {
+    /// Creates a new builder-style object to manufacture [`GetUnionOutput`](crate::operation::get_union::GetUnionOutput).
+    pub fn builder() -> crate::operation::get_union::builders::GetUnionOutputBuilder {
+        crate::operation::get_union::builders::GetUnionOutputBuilder::default()
+    }
+}
+
+/// A builder for [`GetUnionOutput`](crate::operation::get_union::GetUnionOutput).
+#[non_exhaustive]
+#[derive(
+    ::std::clone::Clone, ::std::cmp::PartialEq, ::std::default::Default, ::std::fmt::Debug,
+)]
+pub struct GetUnionOutputBuilder {
+    pub(crate) value: ::std::option::Option<crate::types::_my_union::MyUnion>,
+}
+
+impl GetUnionOutputBuilder {
+    #[allow(missing_docs)] // documentation missing in model
+    pub fn value(
+        mut self,
+        input: impl ::std::convert::Into<crate::types::_my_union::MyUnion>,
+    ) -> Self {
+        self.value = ::std::option::Option::Some(input.into());
+        self
+    }
+
+    #[allow(missing_docs)] // documentation missing in model
+    pub fn set_value(
+        mut self,
+        input: ::std::option::Option<crate::types::_my_union::MyUnion>,
+    ) -> Self {
+        self.value = input;
+        self
+    }
+
+    #[allow(missing_docs)] // documentation missing in model
+    pub fn get_value(&self) -> &::std::option::Option<crate::types::_my_union::MyUnion> {
+        &self.value
+    }
+
+    /// Consumes the builder and constructs a [`GetUnionOutput`](crate::operation::get_union::GetUnionOutput).
+    pub fn build(
+        self,
+    ) -> ::std::result::Result<
+        crate::operation::get_union::GetUnionOutput,
+        ::aws_smithy_types::error::operation::BuildError,
+    > {
+        ::std::result::Result::Ok(crate::operation::get_union::GetUnionOutput { union: self.value })
+    }
+}
diff --git b/TestModels/Union/runtimes/rust/src/operation/get_union/builders.rs a/TestModels/Union/runtimes/rust/src/operation/get_union/builders.rs
new file mode 100644
index 00000000..2409bdcf
--- /dev/null
+++ a/TestModels/Union/runtimes/rust/src/operation/get_union/builders.rs
@@ -0,0 +1,75 @@
+// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
+pub use crate::operation::get_union::_get_union_output::GetUnionOutputBuilder;
+
+pub use crate::operation::get_union::_get_union_input::GetUnionInputBuilder;
+
+impl GetUnionInputBuilder {
+    /// Sends a request with this input using the given client.
+    pub async fn send_with(
+        self,
+        client: &crate::Client,
+    ) -> ::std::result::Result<
+        crate::operation::get_union::GetUnionOutput,
+        crate::operation::get_union::GetUnionError,
+    > {
+        let mut fluent_builder = client.get_union();
+        fluent_builder.inner = self;
+        fluent_builder.send().await
+    }
+}
+/// Fluent builder constructing a request to `GetUnion`.
+///
+#[derive(::std::clone::Clone, ::std::fmt::Debug)]
+pub struct GetUnionFluentBuilder {
+    client: crate::Client,
+    inner: crate::operation::get_union::builders::GetUnionInputBuilder,
+}
+impl GetUnionFluentBuilder {
+    /// Creates a new `GetUnionFluentBuilder`.
+    pub(crate) fn new(client: crate::client::Client) -> Self {
+        Self {
+            client,
+            inner: ::std::default::Default::default(),
+        }
+    }
+    /// Access the GetUnion as a reference.
+    pub fn as_input(&self) -> &crate::operation::get_union::builders::GetUnionInputBuilder {
+        &self.inner
+    }
+    /// Sends the request and returns the response.
+    pub async fn send(
+        self,
+    ) -> ::std::result::Result<
+        crate::operation::get_union::GetUnionOutput,
+        crate::operation::get_union::GetUnionError,
+    > {
+        let input = self
+            .inner
+            .build()
+            // Using unhandled since GetUnion doesn't declare any validation,
+            // and smithy-rs seems to not generate a ValidationError case unless there is
+            // (but isn't that a backwards compatibility problem for output structures?)
+            // Vanilla smithy-rs uses SdkError::construction_failure,
+            // but we aren't using SdkError.
+            .map_err(crate::operation::get_union::GetUnionError::unhandled)?;
+        crate::operation::get_union::GetUnion::send(&self.client, input).await
+    }
+
+    #[allow(missing_docs)] // documentation missing in model
+    pub fn value(mut self, input: crate::types::_my_union::MyUnion) -> Self {
+        self.inner = self.inner.value(input);
+        self
+    }
+    #[allow(missing_docs)] // documentation missing in model
+    pub fn set_value(
+        mut self,
+        input: ::std::option::Option<crate::types::_my_union::MyUnion>,
+    ) -> Self {
+        self.inner = self.inner.set_value(input);
+        self
+    }
+    #[allow(missing_docs)] // documentation missing in model
+    pub fn get_value(&self) -> &::std::option::Option<crate::types::_my_union::MyUnion> {
+        self.inner.get_value()
+    }
+}
diff --git b/TestModels/Union/runtimes/rust/src/types.rs a/TestModels/Union/runtimes/rust/src/types.rs
new file mode 100644
index 00000000..d03e8b5a
--- /dev/null
+++ a/TestModels/Union/runtimes/rust/src/types.rs
@@ -0,0 +1,6 @@
+// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
+
+pub mod _known_value_union;
+pub mod _my_union;
+/// Types for the `SimpleUnionConfig`
+pub mod simple_union_config;
diff --git b/TestModels/Union/runtimes/rust/src/types/_known_value_union.rs a/TestModels/Union/runtimes/rust/src/types/_known_value_union.rs
new file mode 100644
index 00000000..a778d4b4
--- /dev/null
+++ a/TestModels/Union/runtimes/rust/src/types/_known_value_union.rs
@@ -0,0 +1,37 @@
+// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
+#[allow(missing_docs)] // documentation missing in model
+#[non_exhaustive]
+#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
+pub enum KnownValueUnion {
+    #[allow(missing_docs)] // documentation missing in model
+    Value(i32),
+    /// The `Unknown` variant represents cases where new union variant was received. Consider upgrading the SDK to the latest available version.
+    /// An unknown enum variant
+    ///
+    /// _Note: If you encounter this error, consider upgrading your SDK to the latest version._
+    /// The `Unknown` variant represents cases where the server sent a value that wasn't recognized
+    /// by the client. This can happen when the server adds new functionality, but the client has not been updated.
+    /// To investigate this, consider turning on debug logging to print the raw HTTP response.
+    #[non_exhaustive]
+    Unknown,
+}
+impl KnownValueUnion {
+    #[allow(irrefutable_let_patterns)]
+    /// Tries to convert the enum instance into [`Value`](crate::types::KnownValueUnion::Value), extracting the inner [`i32`](i32).
+    /// Returns `Err(&Self)` if it can't be converted.
+    pub fn as_value(&self) -> ::std::result::Result<&i32, &Self> {
+        if let KnownValueUnion::Value(val) = &self {
+            ::std::result::Result::Ok(val)
+        } else {
+            ::std::result::Result::Err(self)
+        }
+    }
+    /// Returns true if this is a [`Value`](crate::types::KnownValueUnion::Value).
+    pub fn is_value(&self) -> bool {
+        self.as_value().is_ok()
+    }
+    /// Returns true if the enum instance is the `Unknown` variant.
+    pub fn is_unknown(&self) -> bool {
+        matches!(self, Self::Unknown)
+    }
+}
diff --git b/TestModels/Union/runtimes/rust/src/types/_my_union.rs a/TestModels/Union/runtimes/rust/src/types/_my_union.rs
new file mode 100644
index 00000000..1f461092
--- /dev/null
+++ a/TestModels/Union/runtimes/rust/src/types/_my_union.rs
@@ -0,0 +1,51 @@
+// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
+#[allow(missing_docs)] // documentation missing in model
+#[non_exhaustive]
+#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
+pub enum MyUnion {
+    #[allow(missing_docs)] // documentation missing in model
+    IntegerValue(i32),
+    #[allow(missing_docs)] // documentation missing in model
+    StringValue(::std::string::String),
+    /// The `Unknown` variant represents cases where new union variant was received. Consider upgrading the SDK to the latest available version.
+    /// An unknown enum variant
+    ///
+    /// _Note: If you encounter this error, consider upgrading your SDK to the latest version._
+    /// The `Unknown` variant represents cases where the server sent a value that wasn't recognized
+    /// by the client. This can happen when the server adds new functionality, but the client has not been updated.
+    /// To investigate this, consider turning on debug logging to print the raw HTTP response.
+    #[non_exhaustive]
+    Unknown,
+}
+impl MyUnion {
+    /// Tries to convert the enum instance into [`IntegerValue`](crate::types::MyUnion::IntegerValue), extracting the inner [`i32`](i32).
+    /// Returns `Err(&Self)` if it can't be converted.
+    pub fn as_integer_value(&self) -> ::std::result::Result<&i32, &Self> {
+        if let MyUnion::IntegerValue(val) = &self {
+            ::std::result::Result::Ok(val)
+        } else {
+            ::std::result::Result::Err(self)
+        }
+    }
+    /// Returns true if this is a [`IntegerValue`](crate::types::MyUnion::IntegerValue).
+    pub fn is_integer_value(&self) -> bool {
+        self.as_integer_value().is_ok()
+    }
+    /// Tries to convert the enum instance into [`StringValue`](crate::types::MyUnion::StringValue), extracting the inner [`String`](::std::string::String).
+    /// Returns `Err(&Self)` if it can't be converted.
+    pub fn as_string_value(&self) -> ::std::result::Result<&::std::string::String, &Self> {
+        if let MyUnion::StringValue(val) = &self {
+            ::std::result::Result::Ok(val)
+        } else {
+            ::std::result::Result::Err(self)
+        }
+    }
+    /// Returns true if this is a [`StringValue`](crate::types::MyUnion::StringValue).
+    pub fn is_string_value(&self) -> bool {
+        self.as_string_value().is_ok()
+    }
+    /// Returns true if the enum instance is the `Unknown` variant.
+    pub fn is_unknown(&self) -> bool {
+        matches!(self, Self::Unknown)
+    }
+}
diff --git b/TestModels/Union/runtimes/rust/src/types/simple_union_config.rs a/TestModels/Union/runtimes/rust/src/types/simple_union_config.rs
new file mode 100644
index 00000000..5aeb72ca
--- /dev/null
+++ a/TestModels/Union/runtimes/rust/src/types/simple_union_config.rs
@@ -0,0 +1,48 @@
+// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
+
+#[derive(::std::clone::Clone, ::std::fmt::Debug)]
+pub struct SimpleUnionConfig {
+    // XXX : ::std::option::Option<XXXtype>
+}
+
+impl SimpleUnionConfig {
+    pub fn builder() -> SimpleUnionConfigBuilder {
+        SimpleUnionConfigBuilder::new()
+    }
+}
+
+#[derive(::std::clone::Clone, ::std::fmt::Debug)]
+pub struct SimpleUnionConfigBuilder {
+    // XXX : ::std::option::Option<XXXtype>
+}
+
+impl SimpleUnionConfigBuilder {
+    /// Creates a new `SimpleUnionConfigBuilder`.
+    pub(crate) fn new() -> Self {
+        Self {
+	    // XXX = ::std::option::Option::None
+	    // somewhere get default values for things?
+        }
+    }
+    pub fn build(
+        self,
+    ) -> ::std::result::Result<SimpleUnionConfig, ::aws_smithy_types::error::operation::BuildError>
+    {
+        ::std::result::Result::Ok(SimpleUnionConfig {})
+    }
+    /*
+        pub fn XXX(mut self, input: impl ::std::convert::Into<XXXtype>) -> Self {
+            self.XXX = ::std::option::Option::Some(input.into());
+            self
+        }
+        #[allow(missing_docs)] // documentation missing in model
+        pub fn set_XXX(mut self, input: ::std::option::Option<XXXtype>) -> Self {
+            self.XXX = input;
+            self
+        }
+        #[allow(missing_docs)] // documentation missing in model
+        pub fn get_XXX(&self) -> &::std::option::Option<XXXtype> {
+            &self.XXX
+        }
+    */
+}
