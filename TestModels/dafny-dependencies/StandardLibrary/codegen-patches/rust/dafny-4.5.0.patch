diff --git b/TestModels/dafny-dependencies/StandardLibrary/runtimes/rust/src/UTF8.rs a/TestModels/dafny-dependencies/StandardLibrary/runtimes/rust/src/UTF8.rs
new file mode 100644
index 00000000..fb5e7bf9
--- /dev/null
+++ a/TestModels/dafny-dependencies/StandardLibrary/runtimes/rust/src/UTF8.rs
@@ -0,0 +1,67 @@
+
+// Annotation to ignore the case of this module
+#[allow(non_snake_case)]
+pub mod UTF8 {
+  use crate::implementation_from_dafny::r#_Wrappers_Compile;
+  use crate::implementation_from_dafny::UTF8;
+
+  
+  impl crate::implementation_from_dafny::UTF8::_default {
+    pub fn Encode(s: &::dafny_runtime::Sequence<::dafny_runtime::DafnyCharUTF16>) -> ::std::rc::Rc<r#_Wrappers_Compile::Result<UTF8::ValidUTF8Bytes, ::dafny_runtime::Sequence<::dafny_runtime::DafnyCharUTF16>>> {
+      let v = s.to_array();
+      let mut _accumulator: Vec<u8> = vec![];
+      // Use of .encode_utf8 method.
+      let mut surrogate: Option<u16> = None;
+      for c in v.iter() {
+        let s = 
+          if let Some(s) = surrogate {
+            String::from_utf16(&[s, c.0])
+          } else {
+            String::from_utf16(&[c.0])
+          };
+        surrogate = None;
+        match s {
+          Ok(value) => {
+            _accumulator.extend(value.as_bytes());
+            continue;
+          },
+          Err(e) => {
+            if 0xD800 <= c.0 && c.0 <= 0xDFFF {
+              surrogate = Some(c.0);
+              continue;
+            } 
+            return ::std::rc::Rc::new(r#_Wrappers_Compile::Result::<UTF8::ValidUTF8Bytes, ::dafny_runtime::Sequence<::dafny_runtime::DafnyCharUTF16>>::Failure {
+              error: ::dafny_runtime::dafny_runtime_conversions::unicode_chars_false::string_to_dafny_string(
+                &e.to_string())
+            });
+          }
+        }
+      }
+      if let Some(s) = surrogate {
+        return ::std::rc::Rc::new(r#_Wrappers_Compile::Result::<UTF8::ValidUTF8Bytes, ::dafny_runtime::Sequence<::dafny_runtime::DafnyCharUTF16>>::Failure {
+          error: ::dafny_runtime::dafny_runtime_conversions::unicode_chars_false::string_to_dafny_string(
+            &format!("Surrogate pair missing: 0x{:04x}", s))
+        });
+      }
+      ::std::rc::Rc::new(r#_Wrappers_Compile::Result::<UTF8::ValidUTF8Bytes, ::dafny_runtime::Sequence<::dafny_runtime::DafnyCharUTF16>>::Success { value: ::dafny_runtime::Sequence::from_array_owned(_accumulator) })
+    }
+    pub fn Decode(b: &::dafny_runtime::Sequence<u8>) -> ::std::rc::Rc<r#_Wrappers_Compile::Result<::dafny_runtime::Sequence<::dafny_runtime::DafnyCharUTF16>, ::dafny_runtime::Sequence<::dafny_runtime::DafnyCharUTF16>>> {
+      let b = String::from_utf8(b.to_array().as_ref().clone());
+      match b {
+        Ok(s) => {
+          ::std::rc::Rc::new(r#_Wrappers_Compile::Result::<::dafny_runtime::Sequence<::dafny_runtime::DafnyCharUTF16>,
+            ::dafny_runtime::Sequence<::dafny_runtime::DafnyCharUTF16>>::Success {
+              value: ::dafny_runtime::dafny_runtime_conversions::unicode_chars_false::string_to_dafny_string(&s)
+          })
+        },
+        Err(e) => {
+          return ::std::rc::Rc::new(r#_Wrappers_Compile::Result::<::dafny_runtime::Sequence<::dafny_runtime::DafnyCharUTF16>,
+            ::dafny_runtime::Sequence<::dafny_runtime::DafnyCharUTF16>>::Failure {
+              error: ::dafny_runtime::dafny_runtime_conversions::unicode_chars_false::string_to_dafny_string(
+                &e.to_string())
+            })
+        }
+      }
+    }
+  }
+}
\ No newline at end of file
diff --git b/TestModels/dafny-dependencies/StandardLibrary/runtimes/rust/src/conversion.rs a/TestModels/dafny-dependencies/StandardLibrary/runtimes/rust/src/conversion.rs
new file mode 100644
index 00000000..3b7c2e76
--- /dev/null
+++ a/TestModels/dafny-dependencies/StandardLibrary/runtimes/rust/src/conversion.rs
@@ -0,0 +1,104 @@
+use crate::implementation_from_dafny::*;
+
+pub fn ostring_to_dafny(
+    input: &Option<String>,
+) -> ::std::rc::Rc<
+    _Wrappers_Compile::Option<::dafny_runtime::Sequence<::dafny_runtime::DafnyCharUTF16>>,
+> {
+    let dafny_value = match input {
+    Some(b) => _Wrappers_Compile::Option::Some { value:
+        dafny_runtime::dafny_runtime_conversions::unicode_chars_false::string_to_dafny_string(&b)
+        },
+    None => _Wrappers_Compile::Option::None {},
+};
+    ::std::rc::Rc::new(dafny_value)
+}
+
+pub fn ostring_from_dafny(
+    input: ::std::rc::Rc<
+        _Wrappers_Compile::Option<::dafny_runtime::Sequence<::dafny_runtime::DafnyCharUTF16>>,
+    >,
+) -> Option<String> {
+    if matches!(input.as_ref(), _Wrappers_Compile::Option::Some { .. }) {
+        Some(
+            dafny_runtime::dafny_runtime_conversions::unicode_chars_false::dafny_string_to_string(
+                &input.Extract(),
+            ),
+        )
+    } else {
+        None
+    }
+}
+
+pub fn obool_to_dafny(input: Option<bool>) -> ::std::rc::Rc<_Wrappers_Compile::Option<bool>> {
+    let dafny_value = match input {
+        Some(b) => _Wrappers_Compile::Option::Some { value: b },
+        None => _Wrappers_Compile::Option::None {},
+    };
+    ::std::rc::Rc::new(dafny_value)
+}
+
+pub fn obool_from_dafny(input: ::std::rc::Rc<_Wrappers_Compile::Option<bool>>) -> Option<bool> {
+    if matches!(input.as_ref(), _Wrappers_Compile::Option::Some { .. }) {
+        Some(input.Extract())
+    } else {
+        None
+    }
+}
+
+pub fn oint_to_dafny(input: Option<i32>) -> ::std::rc::Rc<_Wrappers_Compile::Option<i32>> {
+    let dafny_value = match input {
+        Some(b) => _Wrappers_Compile::Option::Some { value: b },
+        None => _Wrappers_Compile::Option::None {},
+    };
+    ::std::rc::Rc::new(dafny_value)
+}
+
+pub fn oint_from_dafny(input: ::std::rc::Rc<_Wrappers_Compile::Option<i32>>) -> Option<i32> {
+    if matches!(input.as_ref(), _Wrappers_Compile::Option::Some { .. }) {
+        Some(input.Extract())
+    } else {
+        None
+    }
+}
+
+pub fn olong_to_dafny(input: Option<i64>) -> ::std::rc::Rc<_Wrappers_Compile::Option<i64>> {
+    let dafny_value = match input {
+        Some(b) => _Wrappers_Compile::Option::Some { value: b },
+        None => _Wrappers_Compile::Option::None {},
+    };
+    ::std::rc::Rc::new(dafny_value)
+}
+
+pub fn olong_from_dafny(input: ::std::rc::Rc<_Wrappers_Compile::Option<i64>>) -> Option<i64> {
+    if matches!(input.as_ref(), _Wrappers_Compile::Option::Some { .. }) {
+        Some(input.Extract())
+    } else {
+        None
+    }
+}
+
+pub fn oblob_to_dafny(
+    input: &Option<Vec<u8>>,
+) -> ::std::rc::Rc<_Wrappers_Compile::Option<::dafny_runtime::Sequence<u8>>> {
+    let dafny_value = match input {
+        Some(b) => _Wrappers_Compile::Option::Some {
+            value: ::dafny_runtime::Sequence::from_array(&b),
+        },
+        None => _Wrappers_Compile::Option::None {},
+    };
+    ::std::rc::Rc::new(dafny_value)
+}
+
+pub fn oblob_from_dafny(
+    input: ::std::rc::Rc<_Wrappers_Compile::Option<::dafny_runtime::Sequence<u8>>>,
+) -> Option<Vec<u8>> {
+    if matches!(input.as_ref(), _Wrappers_Compile::Option::Some { .. }) {
+        Some(
+            ::std::rc::Rc::try_unwrap(input.Extract().to_array())
+                .unwrap_or_else(|rc| (*rc).clone()),
+        )
+    } else {
+        None
+    }
+}
diff --git b/TestModels/dafny-dependencies/StandardLibrary/runtimes/rust/src/implementation_from_dafny.rs a/TestModels/dafny-dependencies/StandardLibrary/runtimes/rust/src/implementation_from_dafny.rs
index ecfecc03..20cb9f07 100644
--- b/TestModels/dafny-dependencies/StandardLibrary/runtimes/rust/src/implementation_from_dafny.rs
+++ a/TestModels/dafny-dependencies/StandardLibrary/runtimes/rust/src/implementation_from_dafny.rs
@@ -515,12 +515,6 @@ pub mod r#_StandardLibrary_Compile_dUInt_Compile {
     #[repr(transparent)]
     pub struct uint8(pub u8);
 
-    impl uint8 {
-        pub fn is(_source: u8) -> bool {
-            return true;
-        }
-    }
-
     impl ::std::default::Default for uint8 {
         fn default() -> Self {
             uint8(::std::default::Default::default())
@@ -548,12 +542,6 @@ pub mod r#_StandardLibrary_Compile_dUInt_Compile {
     #[repr(transparent)]
     pub struct uint16(pub u16);
 
-    impl uint16 {
-        pub fn is(_source: u16) -> bool {
-            return true;
-        }
-    }
-
     impl ::std::default::Default for uint16 {
         fn default() -> Self {
             uint16(::std::default::Default::default())
@@ -581,12 +569,6 @@ pub mod r#_StandardLibrary_Compile_dUInt_Compile {
     #[repr(transparent)]
     pub struct uint32(pub u32);
 
-    impl uint32 {
-        pub fn is(_source: u32) -> bool {
-            return true;
-        }
-    }
-
     impl ::std::default::Default for uint32 {
         fn default() -> Self {
             uint32(::std::default::Default::default())
@@ -614,12 +596,6 @@ pub mod r#_StandardLibrary_Compile_dUInt_Compile {
     #[repr(transparent)]
     pub struct uint64(pub u64);
 
-    impl uint64 {
-        pub fn is(_source: u64) -> bool {
-            return true;
-        }
-    }
-
     impl ::std::default::Default for uint64 {
         fn default() -> Self {
             uint64(::std::default::Default::default())
@@ -647,12 +623,6 @@ pub mod r#_StandardLibrary_Compile_dUInt_Compile {
     #[repr(transparent)]
     pub struct int32(pub i32);
 
-    impl int32 {
-        pub fn is(_source: i32) -> bool {
-            return true;
-        }
-    }
-
     impl ::std::default::Default for int32 {
         fn default() -> Self {
             int32(::std::default::Default::default())
@@ -680,12 +650,6 @@ pub mod r#_StandardLibrary_Compile_dUInt_Compile {
     #[repr(transparent)]
     pub struct int64(pub i64);
 
-    impl int64 {
-        pub fn is(_source: i64) -> bool {
-            return true;
-        }
-    }
-
     impl ::std::default::Default for int64 {
         fn default() -> Self {
             int64(::std::default::Default::default())
@@ -713,15 +677,6 @@ pub mod r#_StandardLibrary_Compile_dUInt_Compile {
     #[repr(transparent)]
     pub struct posInt64(pub u64);
 
-    impl posInt64 {
-        pub fn is(_source: u64) -> bool {
-            let mut x: ::dafny_runtime::DafnyInt =
-                Into::<::dafny_runtime::DafnyInt>::into(_source.clone());
-            return ::dafny_runtime::int!(0) < x.clone()
-                && x.clone() < ::dafny_runtime::int!(b"9223372036854775808");
-        }
-    }
-
     impl ::std::default::Default for posInt64 {
         fn default() -> Self {
             posInt64(1)
@@ -1013,7 +968,7 @@ pub mod r#_StandardLibrary_Compile {
           let mut a = a.clone();
           let mut b = b.clone();
           let mut less = less.clone();
-          ::std::rc::Rc::new(move |r#__exists_var_0: &::dafny_runtime::DafnyInt| -> bool {
+          ::std::rc::Rc::new(move |r#__exists_var_0: ::dafny_runtime::DafnyInt| -> bool {
               let mut k: ::dafny_runtime::DafnyInt = r#__exists_var_0.clone();
               ::dafny_runtime::int!(0) <= k.clone() && k.clone() <= a.cardinality() && super::r#_StandardLibrary_Compile::_default::LexicographicLessOrEqualAux::<_T>(&a, &b, &less, &k)
             })
@@ -1036,7 +991,7 @@ pub mod r#_StandardLibrary_Compile {
                         let mut a = a.clone();
                         let mut b = b.clone();
                         ::std::rc::Rc::new(
-                            move |r#__forall_var_0: &::dafny_runtime::DafnyInt| -> bool {
+                            move |r#__forall_var_0: ::dafny_runtime::DafnyInt| -> bool {
                                 let mut i: ::dafny_runtime::DafnyInt = r#__forall_var_0.clone();
                                 !(::dafny_runtime::int!(0) <= i.clone()
                                     && i.clone() < lengthOfCommonPrefix.clone())
@@ -1092,11 +1047,11 @@ pub mod r#_StandardLibrary_Compile {
             s: &::dafny_runtime::Set<::dafny_runtime::Sequence<_T>>,
             less: &::std::rc::Rc<dyn::std::ops::Fn(&_T, &_T) -> bool>,
         ) -> bool {
-            s.contains(a) && s.iter().all(({
+            s.contains(a) && s.iter().cloned().all(({
           let mut a = a.clone();
           let mut s = s.clone();
           let mut less = less.clone();
-          ::std::rc::Rc::new(move |r#__forall_var_1: &::dafny_runtime::Sequence<_T>| -> bool {
+          ::std::rc::Rc::new(move |r#__forall_var_1: ::dafny_runtime::Sequence<_T>| -> bool {
               let mut z: ::dafny_runtime::Sequence<_T> = r#__forall_var_1.clone();
               !s.contains(&z) || super::r#_StandardLibrary_Compile::_default::LexicographicLessOrEqual::<_T>(&a, &z, &less)
             })
diff --git b/TestModels/dafny-dependencies/StandardLibrary/runtimes/rust/src/lib.rs a/TestModels/dafny-dependencies/StandardLibrary/runtimes/rust/src/lib.rs
new file mode 100644
index 00000000..4b9fb6f8
--- /dev/null
+++ a/TestModels/dafny-dependencies/StandardLibrary/runtimes/rust/src/lib.rs
@@ -0,0 +1,298 @@
+#[allow(non_snake_case)]
+pub mod UTF8;
+pub mod conversion;
+pub mod implementation_from_dafny;
+
+#[cfg(test)]
+#[allow(non_snake_case)]
+mod TestUTF8 {
+    use super::*;
+    #[test]
+    fn TestEncodeHappyCase() {
+        let unicodeString = ::dafny_runtime::string_utf16_of("abc\u{0306}\u{01FD}\u{03B2}");
+        let expectedBytes =
+            dafny_runtime::seq![0x61, 0x62, 0x63, 0xCC, 0x86, 0xC7, 0xBD, 0xCE, 0xB2];
+        let _r = implementation_from_dafny::UTF8::_default::Encode(&unicodeString);
+        if _r.IsFailure() {
+            panic!("Encode failed");
+        }
+        let encoded = _r.Extract();
+        assert_eq!(expectedBytes, encoded);
+    }
+
+    #[test]
+    fn TestEncodeInvalidUnicode() {
+        let invalidUnicode = ::dafny_runtime::seq![
+            ::dafny_runtime::DafnyCharUTF16('a' as u16),
+            ::dafny_runtime::DafnyCharUTF16('b' as u16),
+            ::dafny_runtime::DafnyCharUTF16('c' as u16),
+            ::dafny_runtime::DafnyCharUTF16(0xD800)
+        ];
+        let encoded = implementation_from_dafny::UTF8::_default::Encode(&invalidUnicode);
+        assert!(encoded.IsFailure());
+    }
+
+    #[test]
+    fn TestDecodeHappyCase() {
+        let unicodeBytes =
+            ::dafny_runtime::seq![0x61, 0x62, 0x63, 0xCC, 0x86, 0xC7, 0xBD, 0xCE, 0xB2];
+        assert!(
+            implementation_from_dafny::UTF8::_default::Uses2Bytes(
+                &::dafny_runtime::seq![0xC7 as u8, 0xBD as u8, 0xCE as u8, 0xB2 as u8]
+            )
+        );
+        assert_eq!(
+            ::dafny_runtime::seq![0xC7 as u8, 0xBD as u8, 0xCE as u8, 0xB2 as u8],
+            unicodeBytes.slice(&::dafny_runtime::int!(5), &::dafny_runtime::int!(9))
+        );
+        assert!(
+            implementation_from_dafny::UTF8::_default::ValidUTF8Range(
+                &unicodeBytes,
+                &::dafny_runtime::int!(7),
+                &::dafny_runtime::int!(9)
+            )
+        );
+        assert!(
+            implementation_from_dafny::UTF8::_default::ValidUTF8Range(
+                &unicodeBytes,
+                &::dafny_runtime::int!(0),
+                &::dafny_runtime::int!(9)
+            )
+        );
+        let expectedString = ::dafny_runtime::string_utf16_of("abc\u{0306}\u{01FD}\u{03B2}");
+        let _r = implementation_from_dafny::UTF8::_default::Decode(&unicodeBytes);
+        if _r.IsFailure() {
+            panic!("Decode failed");
+        }
+        let decoded = _r.Extract();
+        assert_eq!(expectedString, decoded);
+    }
+
+    #[test]
+    fn TestDecodeInvalidUnicode() {
+        let invalidUnicode = ::dafny_runtime::seq![
+            0x61 as u8, 0x62 as u8, 0x63 as u8, 0xED as u8, 0xA0 as u8, 0x80 as u8
+        ];
+        let _r = implementation_from_dafny::UTF8::_default::Decode(&invalidUnicode);
+        assert!(_r.IsFailure());
+    }
+
+    #[test]
+    fn Test1Byte() {
+        // Null
+        let mut decoded = ::dafny_runtime::string_utf16_of("\u{0000}");
+        let mut _r = implementation_from_dafny::UTF8::_default::Encode(&decoded);
+        assert!(!_r.IsFailure());
+        let mut encoded = _r.Extract();
+        assert_eq!(::dafny_runtime::seq![0x00 as u8], encoded);
+        assert!(implementation_from_dafny::UTF8::_default::Uses1Byte(&encoded));
+        let mut _r2 = implementation_from_dafny::UTF8::_default::Decode(&encoded);
+        assert!(!_r2.IsFailure());
+        let mut redecoded = _r2.Extract();
+        assert_eq!(decoded, redecoded);
+
+        // Space
+        decoded = ::dafny_runtime::string_utf16_of(" ");
+        _r = implementation_from_dafny::UTF8::_default::Encode(&decoded);
+        assert!(!_r.IsFailure());
+        encoded = _r.Extract();
+        assert_eq!(::dafny_runtime::seq![0x20 as u8], encoded);
+        assert!(implementation_from_dafny::UTF8::_default::Uses1Byte(&encoded));
+        _r2 = implementation_from_dafny::UTF8::_default::Decode(&encoded);
+        assert!(!_r2.IsFailure());
+        redecoded = _r2.Extract();
+        assert_eq!(decoded, redecoded);
+
+        decoded = ::dafny_runtime::string_utf16_of("$");
+        _r = implementation_from_dafny::UTF8::_default::Encode(&decoded);
+        assert!(!_r.IsFailure());
+        encoded = _r.Extract();
+        assert_eq!(::dafny_runtime::seq![0x24 as u8], encoded);
+        assert!(implementation_from_dafny::UTF8::_default::Uses1Byte(&encoded));
+        _r2 = implementation_from_dafny::UTF8::_default::Decode(&encoded);
+        assert!(!_r2.IsFailure());
+        redecoded = _r2.Extract();
+        assert_eq!(decoded, redecoded);
+
+        decoded = ::dafny_runtime::string_utf16_of("0");
+        _r = implementation_from_dafny::UTF8::_default::Encode(&decoded);
+        assert!(!_r.IsFailure());
+        encoded = _r.Extract();
+        assert_eq!(::dafny_runtime::seq![0x30 as u8], encoded);
+        assert!(implementation_from_dafny::UTF8::_default::Uses1Byte(&encoded));
+        _r2 = implementation_from_dafny::UTF8::_default::Decode(&encoded);
+        assert!(!_r2.IsFailure());
+        redecoded = _r2.Extract();
+        assert_eq!(decoded, redecoded);
+        decoded = ::dafny_runtime::string_utf16_of("A");
+        _r = implementation_from_dafny::UTF8::_default::Encode(&decoded);
+        assert!(!_r.IsFailure());
+        encoded = _r.Extract();
+        assert_eq!(::dafny_runtime::seq![0x41 as u8], encoded);
+        assert!(implementation_from_dafny::UTF8::_default::Uses1Byte(&encoded));
+        _r2 = implementation_from_dafny::UTF8::_default::Decode(&encoded);
+        assert!(!_r2.IsFailure());
+        redecoded = _r2.Extract();
+        assert_eq!(decoded, redecoded);
+        decoded = ::dafny_runtime::string_utf16_of("a");
+        _r = implementation_from_dafny::UTF8::_default::Encode(&decoded);
+        assert!(!_r.IsFailure());
+        encoded = _r.Extract();
+        assert_eq!(::dafny_runtime::seq![0x61 as u8], encoded);
+        assert!(implementation_from_dafny::UTF8::_default::Uses1Byte(&encoded));
+        _r2 = implementation_from_dafny::UTF8::_default::Decode(&encoded);
+        assert!(!_r2.IsFailure());
+        redecoded = _r2.Extract();
+        assert_eq!(decoded, redecoded);
+    }
+
+    #[test]
+    fn Test2Bytes() {
+        let mut decoded = ::dafny_runtime::string_utf16_of("\u{00A3}");
+        let mut _r = implementation_from_dafny::UTF8::_default::Encode(&decoded);
+        assert!(!_r.IsFailure());
+        let mut encoded = _r.Extract();
+        assert_eq!(::dafny_runtime::seq![0xC2 as u8, 0xA3 as u8], encoded);
+        assert!(implementation_from_dafny::UTF8::_default::Uses2Bytes(&encoded));
+        let mut _r2 = implementation_from_dafny::UTF8::_default::Decode(&encoded);
+        assert!(!_r2.IsFailure());
+        let mut redecoded = _r2.Extract();
+        assert_eq!(decoded, redecoded);
+        decoded = ::dafny_runtime::string_utf16_of("\u{00A9}");
+        _r = implementation_from_dafny::UTF8::_default::Encode(&decoded);
+        assert!(!_r.IsFailure());
+        encoded = _r.Extract();
+        assert_eq!(::dafny_runtime::seq![0xC2 as u8, 0xA9 as u8], encoded);
+        assert!(implementation_from_dafny::UTF8::_default::Uses2Bytes(&encoded));
+        _r2 = implementation_from_dafny::UTF8::_default::Decode(&encoded);
+        assert!(!_r2.IsFailure());
+        redecoded = _r2.Extract();
+        assert_eq!(decoded, redecoded);
+        decoded = ::dafny_runtime::string_utf16_of("\u{00AE}");
+        _r = implementation_from_dafny::UTF8::_default::Encode(&decoded);
+        assert!(!_r.IsFailure());
+        encoded = _r.Extract();
+        assert_eq!(::dafny_runtime::seq![0xC2 as u8, 0xAE as u8], encoded);
+        assert!(implementation_from_dafny::UTF8::_default::Uses2Bytes(&encoded));
+        _r2 = implementation_from_dafny::UTF8::_default::Decode(&encoded);
+        assert!(!_r2.IsFailure());
+        redecoded = _r2.Extract();
+        assert_eq!(decoded, redecoded);
+        decoded = ::dafny_runtime::string_utf16_of("\u{03C0}");
+        _r = implementation_from_dafny::UTF8::_default::Encode(&decoded);
+        assert!(!_r.IsFailure());
+        encoded = _r.Extract();
+        assert_eq!(::dafny_runtime::seq![0xCF as u8, 0x80 as u8], encoded);
+        assert!(implementation_from_dafny::UTF8::_default::Uses2Bytes(&encoded));
+        _r2 = implementation_from_dafny::UTF8::_default::Decode(&encoded);
+        assert!(!_r2.IsFailure());
+        redecoded = _r2.Extract();
+        assert_eq!(decoded, redecoded);
+    }
+
+    #[test]
+    fn Test3Bytes() {
+        let mut decoded = ::dafny_runtime::string_utf16_of("\u{2386}");
+        let mut _r = implementation_from_dafny::UTF8::_default::Encode(&decoded);
+        assert!(!_r.IsFailure());
+        let mut encoded = _r.Extract();
+        assert_eq!(
+            ::dafny_runtime::seq![0xE2 as u8, 0x8E as u8, 0x86 as u8],
+            encoded
+        );
+        assert!(implementation_from_dafny::UTF8::_default::Uses3Bytes(&encoded));
+        let mut _r2 = implementation_from_dafny::UTF8::_default::Decode(&encoded);
+        assert!(!_r2.IsFailure());
+        let mut redecoded = _r2.Extract();
+        assert_eq!(decoded, redecoded);
+        decoded = ::dafny_runtime::string_utf16_of("\u{2387}");
+        _r = implementation_from_dafny::UTF8::_default::Encode(&decoded);
+        assert!(!_r.IsFailure());
+        encoded = _r.Extract();
+        assert_eq!(
+            ::dafny_runtime::seq![0xE2 as u8, 0x8E as u8, 0x87 as u8],
+            encoded
+        );
+        assert!(implementation_from_dafny::UTF8::_default::Uses3Bytes(&encoded));
+        _r2 = implementation_from_dafny::UTF8::_default::Decode(&encoded);
+        assert!(!_r2.IsFailure());
+        redecoded = _r2.Extract();
+        assert_eq!(decoded, redecoded);
+        decoded = ::dafny_runtime::string_utf16_of("\u{231B}");
+        _r = implementation_from_dafny::UTF8::_default::Encode(&decoded);
+        assert!(!_r.IsFailure());
+        encoded = _r.Extract();
+        assert_eq!(
+            ::dafny_runtime::seq![0xE2 as u8, 0x8C as u8, 0x9B as u8],
+            encoded
+        );
+        assert!(implementation_from_dafny::UTF8::_default::Uses3Bytes(&encoded));
+        _r2 = implementation_from_dafny::UTF8::_default::Decode(&encoded);
+        assert!(!_r2.IsFailure());
+        redecoded = _r2.Extract();
+        assert_eq!(decoded, redecoded);
+        decoded = ::dafny_runtime::string_utf16_of("\u{1D78}");
+        _r = implementation_from_dafny::UTF8::_default::Encode(&decoded);
+        assert!(!_r.IsFailure());
+        encoded = _r.Extract();
+        assert_eq!(
+            ::dafny_runtime::seq![0xE1 as u8, 0xB5 as u8, 0xB8 as u8],
+            encoded
+        );
+        assert!(implementation_from_dafny::UTF8::_default::Uses3Bytes(&encoded));
+        _r2 = implementation_from_dafny::UTF8::_default::Decode(&encoded);
+        assert!(!_r2.IsFailure());
+        redecoded = _r2.Extract();
+        assert_eq!(decoded, redecoded);
+        decoded = ::dafny_runtime::string_utf16_of("\u{732B}");
+        _r = implementation_from_dafny::UTF8::_default::Encode(&decoded);
+        assert!(!_r.IsFailure());
+        encoded = _r.Extract();
+        assert_eq!(
+            ::dafny_runtime::seq![0xE7 as u8, 0x8C as u8, 0xAB as u8],
+            encoded
+        );
+        assert!(implementation_from_dafny::UTF8::_default::Uses3Bytes(&encoded));
+        _r2 = implementation_from_dafny::UTF8::_default::Decode(&encoded);
+        assert!(!_r2.IsFailure());
+        redecoded = _r2.Extract();
+        assert_eq!(decoded, redecoded);
+    }
+
+    #[test]
+    fn Test4Bytes() {
+        let mut decoded = ::dafny_runtime::seq![
+            ::dafny_runtime::DafnyCharUTF16(0xD808),
+            ::dafny_runtime::DafnyCharUTF16(0xDC00)
+        ];
+        let mut _r = implementation_from_dafny::UTF8::_default::Encode(&decoded);
+        println!(
+            "{}",
+            ::dafny_runtime::DafnyPrintWrapper(&_r.as_ref().clone())
+        );
+        assert!(!_r.IsFailure());
+        let mut encoded = _r.Extract();
+        assert_eq!(
+            ::dafny_runtime::seq![0xF0 as u8, 0x92 as u8, 0x80 as u8, 0x80 as u8],
+            encoded
+        );
+        assert!(implementation_from_dafny::UTF8::_default::Uses4Bytes(&encoded));
+        let mut _r2 = implementation_from_dafny::UTF8::_default::Decode(&encoded);
+        assert!(!_r2.IsFailure());
+        let mut redecoded = _r2.Extract();
+        assert_eq!(decoded, redecoded);
+        decoded = ::dafny_runtime::string_utf16_of("\u{1D7C1}");
+        _r = implementation_from_dafny::UTF8::_default::Encode(&decoded);
+        assert!(!_r.IsFailure());
+        encoded = _r.Extract();
+        assert_eq!(
+            ::dafny_runtime::seq![0xF0 as u8, 0x9D as u8, 0x9F as u8, 0x81 as u8],
+            encoded
+        );
+        assert!(implementation_from_dafny::UTF8::_default::Uses4Bytes(&encoded));
+        _r2 = implementation_from_dafny::UTF8::_default::Decode(&encoded);
+        assert!(!_r2.IsFailure());
+        redecoded = _r2.Extract();
+        assert_eq!(decoded, redecoded);
+    }
+}
