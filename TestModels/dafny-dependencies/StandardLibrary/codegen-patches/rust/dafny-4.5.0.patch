diff --git b/TestModels/dafny-dependencies/StandardLibrary/runtimes/rust/src/UTF8.rs a/TestModels/dafny-dependencies/StandardLibrary/runtimes/rust/src/UTF8.rs
new file mode 100644
index 00000000..fb5e7bf9
--- /dev/null
+++ a/TestModels/dafny-dependencies/StandardLibrary/runtimes/rust/src/UTF8.rs
@@ -0,0 +1,67 @@
+
+// Annotation to ignore the case of this module
+#[allow(non_snake_case)]
+pub mod UTF8 {
+  use crate::implementation_from_dafny::r#_Wrappers_Compile;
+  use crate::implementation_from_dafny::UTF8;
+
+  
+  impl crate::implementation_from_dafny::UTF8::_default {
+    pub fn Encode(s: &::dafny_runtime::Sequence<::dafny_runtime::DafnyCharUTF16>) -> ::std::rc::Rc<r#_Wrappers_Compile::Result<UTF8::ValidUTF8Bytes, ::dafny_runtime::Sequence<::dafny_runtime::DafnyCharUTF16>>> {
+      let v = s.to_array();
+      let mut _accumulator: Vec<u8> = vec![];
+      // Use of .encode_utf8 method.
+      let mut surrogate: Option<u16> = None;
+      for c in v.iter() {
+        let s = 
+          if let Some(s) = surrogate {
+            String::from_utf16(&[s, c.0])
+          } else {
+            String::from_utf16(&[c.0])
+          };
+        surrogate = None;
+        match s {
+          Ok(value) => {
+            _accumulator.extend(value.as_bytes());
+            continue;
+          },
+          Err(e) => {
+            if 0xD800 <= c.0 && c.0 <= 0xDFFF {
+              surrogate = Some(c.0);
+              continue;
+            } 
+            return ::std::rc::Rc::new(r#_Wrappers_Compile::Result::<UTF8::ValidUTF8Bytes, ::dafny_runtime::Sequence<::dafny_runtime::DafnyCharUTF16>>::Failure {
+              error: ::dafny_runtime::dafny_runtime_conversions::unicode_chars_false::string_to_dafny_string(
+                &e.to_string())
+            });
+          }
+        }
+      }
+      if let Some(s) = surrogate {
+        return ::std::rc::Rc::new(r#_Wrappers_Compile::Result::<UTF8::ValidUTF8Bytes, ::dafny_runtime::Sequence<::dafny_runtime::DafnyCharUTF16>>::Failure {
+          error: ::dafny_runtime::dafny_runtime_conversions::unicode_chars_false::string_to_dafny_string(
+            &format!("Surrogate pair missing: 0x{:04x}", s))
+        });
+      }
+      ::std::rc::Rc::new(r#_Wrappers_Compile::Result::<UTF8::ValidUTF8Bytes, ::dafny_runtime::Sequence<::dafny_runtime::DafnyCharUTF16>>::Success { value: ::dafny_runtime::Sequence::from_array_owned(_accumulator) })
+    }
+    pub fn Decode(b: &::dafny_runtime::Sequence<u8>) -> ::std::rc::Rc<r#_Wrappers_Compile::Result<::dafny_runtime::Sequence<::dafny_runtime::DafnyCharUTF16>, ::dafny_runtime::Sequence<::dafny_runtime::DafnyCharUTF16>>> {
+      let b = String::from_utf8(b.to_array().as_ref().clone());
+      match b {
+        Ok(s) => {
+          ::std::rc::Rc::new(r#_Wrappers_Compile::Result::<::dafny_runtime::Sequence<::dafny_runtime::DafnyCharUTF16>,
+            ::dafny_runtime::Sequence<::dafny_runtime::DafnyCharUTF16>>::Success {
+              value: ::dafny_runtime::dafny_runtime_conversions::unicode_chars_false::string_to_dafny_string(&s)
+          })
+        },
+        Err(e) => {
+          return ::std::rc::Rc::new(r#_Wrappers_Compile::Result::<::dafny_runtime::Sequence<::dafny_runtime::DafnyCharUTF16>,
+            ::dafny_runtime::Sequence<::dafny_runtime::DafnyCharUTF16>>::Failure {
+              error: ::dafny_runtime::dafny_runtime_conversions::unicode_chars_false::string_to_dafny_string(
+                &e.to_string())
+            })
+        }
+      }
+    }
+  }
+}
\ No newline at end of file
diff --git b/TestModels/dafny-dependencies/StandardLibrary/runtimes/rust/src/conversion.rs a/TestModels/dafny-dependencies/StandardLibrary/runtimes/rust/src/conversion.rs
new file mode 100644
index 00000000..3b7c2e76
--- /dev/null
+++ a/TestModels/dafny-dependencies/StandardLibrary/runtimes/rust/src/conversion.rs
@@ -0,0 +1,104 @@
+use crate::implementation_from_dafny::*;
+
+pub fn ostring_to_dafny(
+    input: &Option<String>,
+) -> ::std::rc::Rc<
+    _Wrappers_Compile::Option<::dafny_runtime::Sequence<::dafny_runtime::DafnyCharUTF16>>,
+> {
+    let dafny_value = match input {
+    Some(b) => _Wrappers_Compile::Option::Some { value:
+        dafny_runtime::dafny_runtime_conversions::unicode_chars_false::string_to_dafny_string(&b)
+        },
+    None => _Wrappers_Compile::Option::None {},
+};
+    ::std::rc::Rc::new(dafny_value)
+}
+
+pub fn ostring_from_dafny(
+    input: ::std::rc::Rc<
+        _Wrappers_Compile::Option<::dafny_runtime::Sequence<::dafny_runtime::DafnyCharUTF16>>,
+    >,
+) -> Option<String> {
+    if matches!(input.as_ref(), _Wrappers_Compile::Option::Some { .. }) {
+        Some(
+            dafny_runtime::dafny_runtime_conversions::unicode_chars_false::dafny_string_to_string(
+                &input.Extract(),
+            ),
+        )
+    } else {
+        None
+    }
+}
+
+pub fn obool_to_dafny(input: Option<bool>) -> ::std::rc::Rc<_Wrappers_Compile::Option<bool>> {
+    let dafny_value = match input {
+        Some(b) => _Wrappers_Compile::Option::Some { value: b },
+        None => _Wrappers_Compile::Option::None {},
+    };
+    ::std::rc::Rc::new(dafny_value)
+}
+
+pub fn obool_from_dafny(input: ::std::rc::Rc<_Wrappers_Compile::Option<bool>>) -> Option<bool> {
+    if matches!(input.as_ref(), _Wrappers_Compile::Option::Some { .. }) {
+        Some(input.Extract())
+    } else {
+        None
+    }
+}
+
+pub fn oint_to_dafny(input: Option<i32>) -> ::std::rc::Rc<_Wrappers_Compile::Option<i32>> {
+    let dafny_value = match input {
+        Some(b) => _Wrappers_Compile::Option::Some { value: b },
+        None => _Wrappers_Compile::Option::None {},
+    };
+    ::std::rc::Rc::new(dafny_value)
+}
+
+pub fn oint_from_dafny(input: ::std::rc::Rc<_Wrappers_Compile::Option<i32>>) -> Option<i32> {
+    if matches!(input.as_ref(), _Wrappers_Compile::Option::Some { .. }) {
+        Some(input.Extract())
+    } else {
+        None
+    }
+}
+
+pub fn olong_to_dafny(input: Option<i64>) -> ::std::rc::Rc<_Wrappers_Compile::Option<i64>> {
+    let dafny_value = match input {
+        Some(b) => _Wrappers_Compile::Option::Some { value: b },
+        None => _Wrappers_Compile::Option::None {},
+    };
+    ::std::rc::Rc::new(dafny_value)
+}
+
+pub fn olong_from_dafny(input: ::std::rc::Rc<_Wrappers_Compile::Option<i64>>) -> Option<i64> {
+    if matches!(input.as_ref(), _Wrappers_Compile::Option::Some { .. }) {
+        Some(input.Extract())
+    } else {
+        None
+    }
+}
+
+pub fn oblob_to_dafny(
+    input: &Option<Vec<u8>>,
+) -> ::std::rc::Rc<_Wrappers_Compile::Option<::dafny_runtime::Sequence<u8>>> {
+    let dafny_value = match input {
+        Some(b) => _Wrappers_Compile::Option::Some {
+            value: ::dafny_runtime::Sequence::from_array(&b),
+        },
+        None => _Wrappers_Compile::Option::None {},
+    };
+    ::std::rc::Rc::new(dafny_value)
+}
+
+pub fn oblob_from_dafny(
+    input: ::std::rc::Rc<_Wrappers_Compile::Option<::dafny_runtime::Sequence<u8>>>,
+) -> Option<Vec<u8>> {
+    if matches!(input.as_ref(), _Wrappers_Compile::Option::Some { .. }) {
+        Some(
+            ::std::rc::Rc::try_unwrap(input.Extract().to_array())
+                .unwrap_or_else(|rc| (*rc).clone()),
+        )
+    } else {
+        None
+    }
+}
diff --git b/TestModels/dafny-dependencies/StandardLibrary/runtimes/rust/src/lib.rs a/TestModels/dafny-dependencies/StandardLibrary/runtimes/rust/src/lib.rs
new file mode 100644
index 00000000..4b9fb6f8
--- /dev/null
+++ a/TestModels/dafny-dependencies/StandardLibrary/runtimes/rust/src/lib.rs
@@ -0,0 +1,298 @@
+#[allow(non_snake_case)]
+pub mod UTF8;
+pub mod conversion;
+pub mod implementation_from_dafny;
+
+#[cfg(test)]
+#[allow(non_snake_case)]
+mod TestUTF8 {
+    use super::*;
+    #[test]
+    fn TestEncodeHappyCase() {
+        let unicodeString = ::dafny_runtime::string_utf16_of("abc\u{0306}\u{01FD}\u{03B2}");
+        let expectedBytes =
+            dafny_runtime::seq![0x61, 0x62, 0x63, 0xCC, 0x86, 0xC7, 0xBD, 0xCE, 0xB2];
+        let _r = implementation_from_dafny::UTF8::_default::Encode(&unicodeString);
+        if _r.IsFailure() {
+            panic!("Encode failed");
+        }
+        let encoded = _r.Extract();
+        assert_eq!(expectedBytes, encoded);
+    }
+
+    #[test]
+    fn TestEncodeInvalidUnicode() {
+        let invalidUnicode = ::dafny_runtime::seq![
+            ::dafny_runtime::DafnyCharUTF16('a' as u16),
+            ::dafny_runtime::DafnyCharUTF16('b' as u16),
+            ::dafny_runtime::DafnyCharUTF16('c' as u16),
+            ::dafny_runtime::DafnyCharUTF16(0xD800)
+        ];
+        let encoded = implementation_from_dafny::UTF8::_default::Encode(&invalidUnicode);
+        assert!(encoded.IsFailure());
+    }
+
+    #[test]
+    fn TestDecodeHappyCase() {
+        let unicodeBytes =
+            ::dafny_runtime::seq![0x61, 0x62, 0x63, 0xCC, 0x86, 0xC7, 0xBD, 0xCE, 0xB2];
+        assert!(
+            implementation_from_dafny::UTF8::_default::Uses2Bytes(
+                &::dafny_runtime::seq![0xC7 as u8, 0xBD as u8, 0xCE as u8, 0xB2 as u8]
+            )
+        );
+        assert_eq!(
+            ::dafny_runtime::seq![0xC7 as u8, 0xBD as u8, 0xCE as u8, 0xB2 as u8],
+            unicodeBytes.slice(&::dafny_runtime::int!(5), &::dafny_runtime::int!(9))
+        );
+        assert!(
+            implementation_from_dafny::UTF8::_default::ValidUTF8Range(
+                &unicodeBytes,
+                &::dafny_runtime::int!(7),
+                &::dafny_runtime::int!(9)
+            )
+        );
+        assert!(
+            implementation_from_dafny::UTF8::_default::ValidUTF8Range(
+                &unicodeBytes,
+                &::dafny_runtime::int!(0),
+                &::dafny_runtime::int!(9)
+            )
+        );
+        let expectedString = ::dafny_runtime::string_utf16_of("abc\u{0306}\u{01FD}\u{03B2}");
+        let _r = implementation_from_dafny::UTF8::_default::Decode(&unicodeBytes);
+        if _r.IsFailure() {
+            panic!("Decode failed");
+        }
+        let decoded = _r.Extract();
+        assert_eq!(expectedString, decoded);
+    }
+
+    #[test]
+    fn TestDecodeInvalidUnicode() {
+        let invalidUnicode = ::dafny_runtime::seq![
+            0x61 as u8, 0x62 as u8, 0x63 as u8, 0xED as u8, 0xA0 as u8, 0x80 as u8
+        ];
+        let _r = implementation_from_dafny::UTF8::_default::Decode(&invalidUnicode);
+        assert!(_r.IsFailure());
+    }
+
+    #[test]
+    fn Test1Byte() {
+        // Null
+        let mut decoded = ::dafny_runtime::string_utf16_of("\u{0000}");
+        let mut _r = implementation_from_dafny::UTF8::_default::Encode(&decoded);
+        assert!(!_r.IsFailure());
+        let mut encoded = _r.Extract();
+        assert_eq!(::dafny_runtime::seq![0x00 as u8], encoded);
+        assert!(implementation_from_dafny::UTF8::_default::Uses1Byte(&encoded));
+        let mut _r2 = implementation_from_dafny::UTF8::_default::Decode(&encoded);
+        assert!(!_r2.IsFailure());
+        let mut redecoded = _r2.Extract();
+        assert_eq!(decoded, redecoded);
+
+        // Space
+        decoded = ::dafny_runtime::string_utf16_of(" ");
+        _r = implementation_from_dafny::UTF8::_default::Encode(&decoded);
+        assert!(!_r.IsFailure());
+        encoded = _r.Extract();
+        assert_eq!(::dafny_runtime::seq![0x20 as u8], encoded);
+        assert!(implementation_from_dafny::UTF8::_default::Uses1Byte(&encoded));
+        _r2 = implementation_from_dafny::UTF8::_default::Decode(&encoded);
+        assert!(!_r2.IsFailure());
+        redecoded = _r2.Extract();
+        assert_eq!(decoded, redecoded);
+
+        decoded = ::dafny_runtime::string_utf16_of("$");
+        _r = implementation_from_dafny::UTF8::_default::Encode(&decoded);
+        assert!(!_r.IsFailure());
+        encoded = _r.Extract();
+        assert_eq!(::dafny_runtime::seq![0x24 as u8], encoded);
+        assert!(implementation_from_dafny::UTF8::_default::Uses1Byte(&encoded));
+        _r2 = implementation_from_dafny::UTF8::_default::Decode(&encoded);
+        assert!(!_r2.IsFailure());
+        redecoded = _r2.Extract();
+        assert_eq!(decoded, redecoded);
+
+        decoded = ::dafny_runtime::string_utf16_of("0");
+        _r = implementation_from_dafny::UTF8::_default::Encode(&decoded);
+        assert!(!_r.IsFailure());
+        encoded = _r.Extract();
+        assert_eq!(::dafny_runtime::seq![0x30 as u8], encoded);
+        assert!(implementation_from_dafny::UTF8::_default::Uses1Byte(&encoded));
+        _r2 = implementation_from_dafny::UTF8::_default::Decode(&encoded);
+        assert!(!_r2.IsFailure());
+        redecoded = _r2.Extract();
+        assert_eq!(decoded, redecoded);
+        decoded = ::dafny_runtime::string_utf16_of("A");
+        _r = implementation_from_dafny::UTF8::_default::Encode(&decoded);
+        assert!(!_r.IsFailure());
+        encoded = _r.Extract();
+        assert_eq!(::dafny_runtime::seq![0x41 as u8], encoded);
+        assert!(implementation_from_dafny::UTF8::_default::Uses1Byte(&encoded));
+        _r2 = implementation_from_dafny::UTF8::_default::Decode(&encoded);
+        assert!(!_r2.IsFailure());
+        redecoded = _r2.Extract();
+        assert_eq!(decoded, redecoded);
+        decoded = ::dafny_runtime::string_utf16_of("a");
+        _r = implementation_from_dafny::UTF8::_default::Encode(&decoded);
+        assert!(!_r.IsFailure());
+        encoded = _r.Extract();
+        assert_eq!(::dafny_runtime::seq![0x61 as u8], encoded);
+        assert!(implementation_from_dafny::UTF8::_default::Uses1Byte(&encoded));
+        _r2 = implementation_from_dafny::UTF8::_default::Decode(&encoded);
+        assert!(!_r2.IsFailure());
+        redecoded = _r2.Extract();
+        assert_eq!(decoded, redecoded);
+    }
+
+    #[test]
+    fn Test2Bytes() {
+        let mut decoded = ::dafny_runtime::string_utf16_of("\u{00A3}");
+        let mut _r = implementation_from_dafny::UTF8::_default::Encode(&decoded);
+        assert!(!_r.IsFailure());
+        let mut encoded = _r.Extract();
+        assert_eq!(::dafny_runtime::seq![0xC2 as u8, 0xA3 as u8], encoded);
+        assert!(implementation_from_dafny::UTF8::_default::Uses2Bytes(&encoded));
+        let mut _r2 = implementation_from_dafny::UTF8::_default::Decode(&encoded);
+        assert!(!_r2.IsFailure());
+        let mut redecoded = _r2.Extract();
+        assert_eq!(decoded, redecoded);
+        decoded = ::dafny_runtime::string_utf16_of("\u{00A9}");
+        _r = implementation_from_dafny::UTF8::_default::Encode(&decoded);
+        assert!(!_r.IsFailure());
+        encoded = _r.Extract();
+        assert_eq!(::dafny_runtime::seq![0xC2 as u8, 0xA9 as u8], encoded);
+        assert!(implementation_from_dafny::UTF8::_default::Uses2Bytes(&encoded));
+        _r2 = implementation_from_dafny::UTF8::_default::Decode(&encoded);
+        assert!(!_r2.IsFailure());
+        redecoded = _r2.Extract();
+        assert_eq!(decoded, redecoded);
+        decoded = ::dafny_runtime::string_utf16_of("\u{00AE}");
+        _r = implementation_from_dafny::UTF8::_default::Encode(&decoded);
+        assert!(!_r.IsFailure());
+        encoded = _r.Extract();
+        assert_eq!(::dafny_runtime::seq![0xC2 as u8, 0xAE as u8], encoded);
+        assert!(implementation_from_dafny::UTF8::_default::Uses2Bytes(&encoded));
+        _r2 = implementation_from_dafny::UTF8::_default::Decode(&encoded);
+        assert!(!_r2.IsFailure());
+        redecoded = _r2.Extract();
+        assert_eq!(decoded, redecoded);
+        decoded = ::dafny_runtime::string_utf16_of("\u{03C0}");
+        _r = implementation_from_dafny::UTF8::_default::Encode(&decoded);
+        assert!(!_r.IsFailure());
+        encoded = _r.Extract();
+        assert_eq!(::dafny_runtime::seq![0xCF as u8, 0x80 as u8], encoded);
+        assert!(implementation_from_dafny::UTF8::_default::Uses2Bytes(&encoded));
+        _r2 = implementation_from_dafny::UTF8::_default::Decode(&encoded);
+        assert!(!_r2.IsFailure());
+        redecoded = _r2.Extract();
+        assert_eq!(decoded, redecoded);
+    }
+
+    #[test]
+    fn Test3Bytes() {
+        let mut decoded = ::dafny_runtime::string_utf16_of("\u{2386}");
+        let mut _r = implementation_from_dafny::UTF8::_default::Encode(&decoded);
+        assert!(!_r.IsFailure());
+        let mut encoded = _r.Extract();
+        assert_eq!(
+            ::dafny_runtime::seq![0xE2 as u8, 0x8E as u8, 0x86 as u8],
+            encoded
+        );
+        assert!(implementation_from_dafny::UTF8::_default::Uses3Bytes(&encoded));
+        let mut _r2 = implementation_from_dafny::UTF8::_default::Decode(&encoded);
+        assert!(!_r2.IsFailure());
+        let mut redecoded = _r2.Extract();
+        assert_eq!(decoded, redecoded);
+        decoded = ::dafny_runtime::string_utf16_of("\u{2387}");
+        _r = implementation_from_dafny::UTF8::_default::Encode(&decoded);
+        assert!(!_r.IsFailure());
+        encoded = _r.Extract();
+        assert_eq!(
+            ::dafny_runtime::seq![0xE2 as u8, 0x8E as u8, 0x87 as u8],
+            encoded
+        );
+        assert!(implementation_from_dafny::UTF8::_default::Uses3Bytes(&encoded));
+        _r2 = implementation_from_dafny::UTF8::_default::Decode(&encoded);
+        assert!(!_r2.IsFailure());
+        redecoded = _r2.Extract();
+        assert_eq!(decoded, redecoded);
+        decoded = ::dafny_runtime::string_utf16_of("\u{231B}");
+        _r = implementation_from_dafny::UTF8::_default::Encode(&decoded);
+        assert!(!_r.IsFailure());
+        encoded = _r.Extract();
+        assert_eq!(
+            ::dafny_runtime::seq![0xE2 as u8, 0x8C as u8, 0x9B as u8],
+            encoded
+        );
+        assert!(implementation_from_dafny::UTF8::_default::Uses3Bytes(&encoded));
+        _r2 = implementation_from_dafny::UTF8::_default::Decode(&encoded);
+        assert!(!_r2.IsFailure());
+        redecoded = _r2.Extract();
+        assert_eq!(decoded, redecoded);
+        decoded = ::dafny_runtime::string_utf16_of("\u{1D78}");
+        _r = implementation_from_dafny::UTF8::_default::Encode(&decoded);
+        assert!(!_r.IsFailure());
+        encoded = _r.Extract();
+        assert_eq!(
+            ::dafny_runtime::seq![0xE1 as u8, 0xB5 as u8, 0xB8 as u8],
+            encoded
+        );
+        assert!(implementation_from_dafny::UTF8::_default::Uses3Bytes(&encoded));
+        _r2 = implementation_from_dafny::UTF8::_default::Decode(&encoded);
+        assert!(!_r2.IsFailure());
+        redecoded = _r2.Extract();
+        assert_eq!(decoded, redecoded);
+        decoded = ::dafny_runtime::string_utf16_of("\u{732B}");
+        _r = implementation_from_dafny::UTF8::_default::Encode(&decoded);
+        assert!(!_r.IsFailure());
+        encoded = _r.Extract();
+        assert_eq!(
+            ::dafny_runtime::seq![0xE7 as u8, 0x8C as u8, 0xAB as u8],
+            encoded
+        );
+        assert!(implementation_from_dafny::UTF8::_default::Uses3Bytes(&encoded));
+        _r2 = implementation_from_dafny::UTF8::_default::Decode(&encoded);
+        assert!(!_r2.IsFailure());
+        redecoded = _r2.Extract();
+        assert_eq!(decoded, redecoded);
+    }
+
+    #[test]
+    fn Test4Bytes() {
+        let mut decoded = ::dafny_runtime::seq![
+            ::dafny_runtime::DafnyCharUTF16(0xD808),
+            ::dafny_runtime::DafnyCharUTF16(0xDC00)
+        ];
+        let mut _r = implementation_from_dafny::UTF8::_default::Encode(&decoded);
+        println!(
+            "{}",
+            ::dafny_runtime::DafnyPrintWrapper(&_r.as_ref().clone())
+        );
+        assert!(!_r.IsFailure());
+        let mut encoded = _r.Extract();
+        assert_eq!(
+            ::dafny_runtime::seq![0xF0 as u8, 0x92 as u8, 0x80 as u8, 0x80 as u8],
+            encoded
+        );
+        assert!(implementation_from_dafny::UTF8::_default::Uses4Bytes(&encoded));
+        let mut _r2 = implementation_from_dafny::UTF8::_default::Decode(&encoded);
+        assert!(!_r2.IsFailure());
+        let mut redecoded = _r2.Extract();
+        assert_eq!(decoded, redecoded);
+        decoded = ::dafny_runtime::string_utf16_of("\u{1D7C1}");
+        _r = implementation_from_dafny::UTF8::_default::Encode(&decoded);
+        assert!(!_r.IsFailure());
+        encoded = _r.Extract();
+        assert_eq!(
+            ::dafny_runtime::seq![0xF0 as u8, 0x9D as u8, 0x9F as u8, 0x81 as u8],
+            encoded
+        );
+        assert!(implementation_from_dafny::UTF8::_default::Uses4Bytes(&encoded));
+        _r2 = implementation_from_dafny::UTF8::_default::Decode(&encoded);
+        assert!(!_r2.IsFailure());
+        redecoded = _r2.Extract();
+        assert_eq!(decoded, redecoded);
+    }
+}
