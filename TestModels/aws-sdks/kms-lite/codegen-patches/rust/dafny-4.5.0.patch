diff --git b/TestModels/aws-sdks/kms-lite/runtimes/rust/src/client.rs a/TestModels/aws-sdks/kms-lite/runtimes/rust/src/client.rs
new file mode 100644
index 00000000..762b58c7
--- /dev/null
+++ a/TestModels/aws-sdks/kms-lite/runtimes/rust/src/client.rs
@@ -0,0 +1,88 @@
+use crate::conversions;
+
+struct Client {
+    inner: aws_sdk_kms::Client,
+
+    rt: tokio::runtime::Runtime,
+}
+
+impl dafny_runtime::UpcastObject<dyn std::any::Any> for Client {
+    ::dafny_runtime::UpcastObjectFn!(dyn::std::any::Any);
+}
+
+impl dafny_runtime::UpcastObject<dyn crate::r#software::amazon::cryptography::services::kms::internaldafny::types::IKMSClient> for Client {
+  ::dafny_runtime::UpcastObjectFn!(dyn crate::r#software::amazon::cryptography::services::kms::internaldafny::types::IKMSClient);
+}
+
+impl crate::r#software::amazon::cryptography::services::kms::internaldafny::types::IKMSClient
+  for Client {
+    fn Decrypt(&mut self, input: &std::rc::Rc<crate::r#software::amazon::cryptography::services::kms::internaldafny::types::DecryptRequest>) -> std::rc::Rc<crate::r#_Wrappers_Compile::Result<std::rc::Rc<crate::r#software::amazon::cryptography::services::kms::internaldafny::types::DecryptResponse>, std::rc::Rc<crate::r#software::amazon::cryptography::services::kms::internaldafny::types::Error>>> {
+      let native_result = 
+        self.rt.block_on(conversions::decrypt::_decrypt_request::from_dafny(input.clone(), self.inner.clone()).send());
+      crate::standard_library_conversions::result_to_dafny(&native_result,
+        conversions::decrypt::_decrypt_response::to_dafny,
+        conversions::decrypt::to_dafny_error)
+    }
+  
+    fn Encrypt(&mut self, input: &std::rc::Rc<crate::r#software::amazon::cryptography::services::kms::internaldafny::types::EncryptRequest>) -> std::rc::Rc<crate::r#_Wrappers_Compile::Result<std::rc::Rc<crate::r#software::amazon::cryptography::services::kms::internaldafny::types::EncryptResponse>, std::rc::Rc<crate::r#software::amazon::cryptography::services::kms::internaldafny::types::Error>>> {
+      let native_result = 
+        self.rt.block_on(conversions::encrypt::_encrypt_request::from_dafny(input.clone(), self.inner.clone()).send());
+      crate::standard_library_conversions::result_to_dafny(&native_result,
+        conversions::encrypt::_encrypt_response::to_dafny,
+        conversions::encrypt::to_dafny_error)
+    }
+  
+    fn GenerateDataKey(&mut self, input: &std::rc::Rc<crate::r#software::amazon::cryptography::services::kms::internaldafny::types::GenerateDataKeyRequest>) -> std::rc::Rc<crate::r#_Wrappers_Compile::Result<std::rc::Rc<crate::r#software::amazon::cryptography::services::kms::internaldafny::types::GenerateDataKeyResponse>, std::rc::Rc<crate::r#software::amazon::cryptography::services::kms::internaldafny::types::Error>>> {
+      let native_result = 
+        self.rt.block_on(conversions::generate_data_key::_generate_data_key_request::from_dafny(input.clone(), self.inner.clone()).send());
+      crate::standard_library_conversions::result_to_dafny(&native_result, 
+        conversions::generate_data_key::_generate_data_key_response::to_dafny,
+        conversions::generate_data_key::to_dafny_error)
+    }
+  
+    fn GenerateDataKeyWithoutPlaintext(&mut self, input: &std::rc::Rc<crate::r#software::amazon::cryptography::services::kms::internaldafny::types::GenerateDataKeyWithoutPlaintextRequest>) -> std::rc::Rc<crate::r#_Wrappers_Compile::Result<std::rc::Rc<crate::r#software::amazon::cryptography::services::kms::internaldafny::types::GenerateDataKeyWithoutPlaintextResponse>, std::rc::Rc<crate::r#software::amazon::cryptography::services::kms::internaldafny::types::Error>>> {
+      let native_result = 
+        self.rt.block_on(conversions::generate_data_key_without_plaintext::_generate_data_key_without_plaintext_request::from_dafny(input.clone(), self.inner.clone()).send());
+      crate::standard_library_conversions::result_to_dafny(&native_result, 
+        conversions::generate_data_key_without_plaintext::_generate_data_key_without_plaintext_response::to_dafny,
+        conversions::generate_data_key_without_plaintext::to_dafny_error)
+    }
+
+    // Leaving untested operations out for now
+  
+    fn DeriveSharedSecret(&mut self, input: &std::rc::Rc<crate::r#software::amazon::cryptography::services::kms::internaldafny::types::DeriveSharedSecretRequest>) -> std::rc::Rc<crate::r#_Wrappers_Compile::Result<std::rc::Rc<crate::r#software::amazon::cryptography::services::kms::internaldafny::types::DeriveSharedSecretResponse>, std::rc::Rc<crate::r#software::amazon::cryptography::services::kms::internaldafny::types::Error>>> {
+      todo!()
+    }
+
+    fn GetPublicKey(&mut self, input: &std::rc::Rc<crate::r#software::amazon::cryptography::services::kms::internaldafny::types::GetPublicKeyRequest>) -> std::rc::Rc<crate::r#_Wrappers_Compile::Result<std::rc::Rc<crate::r#software::amazon::cryptography::services::kms::internaldafny::types::GetPublicKeyResponse>, std::rc::Rc<crate::r#software::amazon::cryptography::services::kms::internaldafny::types::Error>>> {
+      todo!()
+    }
+  
+    fn ReEncrypt(&mut self, input: &std::rc::Rc<crate::r#software::amazon::cryptography::services::kms::internaldafny::types::ReEncryptRequest>) -> std::rc::Rc<crate::r#_Wrappers_Compile::Result<std::rc::Rc<crate::r#software::amazon::cryptography::services::kms::internaldafny::types::ReEncryptResponse>, std::rc::Rc<crate::r#software::amazon::cryptography::services::kms::internaldafny::types::Error>>> {
+      todo!()
+    }
+  }
+
+#[allow(non_snake_case)]
+impl crate::r#software::amazon::cryptography::services::kms::internaldafny::_default {
+  pub fn KMSClient() -> ::std::rc::Rc<
+    crate::r#_Wrappers_Compile::Result<
+      ::dafny_runtime::Object<dyn crate::r#software::amazon::cryptography::services::kms::internaldafny::types::IKMSClient>,
+      ::std::rc::Rc<crate::r#software::amazon::cryptography::services::kms::internaldafny::types::Error>
+      >
+    > {
+    let rt_result = tokio::runtime::Builder::new_current_thread()
+      .enable_all()
+      .build();
+    if rt_result.is_err() {
+      return conversions::error::to_opaque_error_result(rt_result.err());
+    }
+    let rt = rt_result.unwrap();
+
+    let shared_config = rt.block_on(aws_config::load_defaults(aws_config::BehaviorVersion::v2024_03_28()));
+    let inner = aws_sdk_kms::Client::new(&shared_config);
+    let client = Client { inner, rt };
+    let dafny_client = ::dafny_runtime::upcast_object()(::dafny_runtime::object::new(client));
+    std::rc::Rc::new(crate::r#_Wrappers_Compile::Result::Success { value: dafny_client })
+  }
+}
diff --git b/TestModels/aws-sdks/kms-lite/runtimes/rust/src/conversions.rs a/TestModels/aws-sdks/kms-lite/runtimes/rust/src/conversions.rs
new file mode 100644
index 00000000..8f8fb189
--- /dev/null
+++ a/TestModels/aws-sdks/kms-lite/runtimes/rust/src/conversions.rs
@@ -0,0 +1,19 @@
+// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
+
+pub mod generate_data_key;
+
+pub mod generate_data_key_without_plaintext;
+
+pub mod encrypt;
+
+pub mod decrypt;
+
+pub mod data_key_spec;
+
+pub mod recipient_info;
+
+pub mod key_encryption_mechanism;
+
+pub mod encryption_algorithm_spec;
+
+pub mod error;
diff --git b/TestModels/aws-sdks/kms-lite/runtimes/rust/src/conversions/data_key_spec.rs a/TestModels/aws-sdks/kms-lite/runtimes/rust/src/conversions/data_key_spec.rs
new file mode 100644
index 00000000..deadcdda
--- /dev/null
+++ a/TestModels/aws-sdks/kms-lite/runtimes/rust/src/conversions/data_key_spec.rs
@@ -0,0 +1,22 @@
+// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
+#[allow(dead_code)]
+
+pub fn to_dafny(
+    value: aws_sdk_kms::types::DataKeySpec,
+) -> ::std::rc::Rc<crate::software::amazon::cryptography::services::kms::internaldafny::types::DataKeySpec>{
+    ::std::rc::Rc::new(match value {
+      aws_sdk_kms::types::DataKeySpec::Aes128 => crate::r#software::amazon::cryptography::services::kms::internaldafny::types::DataKeySpec::AES_128 {},
+      aws_sdk_kms::types::DataKeySpec::Aes256 => crate::r#software::amazon::cryptography::services::kms::internaldafny::types::DataKeySpec::AES_256 {},
+      _ => panic!()
+    })
+}
+
+#[allow(dead_code)]
+pub fn from_dafny(
+    dafny_value: &crate::r#software::amazon::cryptography::services::kms::internaldafny::types::DataKeySpec,
+) -> aws_sdk_kms::types::DataKeySpec {
+    match dafny_value {
+      crate::r#software::amazon::cryptography::services::kms::internaldafny::types::DataKeySpec::AES_128 {} => aws_sdk_kms::types::DataKeySpec::Aes128,
+      crate::r#software::amazon::cryptography::services::kms::internaldafny::types::DataKeySpec::AES_256 {} => aws_sdk_kms::types::DataKeySpec::Aes256,
+    }
+}
diff --git b/TestModels/aws-sdks/kms-lite/runtimes/rust/src/conversions/decrypt.rs a/TestModels/aws-sdks/kms-lite/runtimes/rust/src/conversions/decrypt.rs
new file mode 100644
index 00000000..fe0708d2
--- /dev/null
+++ a/TestModels/aws-sdks/kms-lite/runtimes/rust/src/conversions/decrypt.rs
@@ -0,0 +1,45 @@
+pub mod _decrypt_request;
+
+pub mod _decrypt_response;
+
+use aws_sdk_kms::error::SdkError;
+use crate::r#software::amazon::cryptography::services::kms::internaldafny::types::*;
+
+#[allow(dead_code)]
+pub fn to_dafny_error(
+    value: &::aws_smithy_runtime_api::client::result::SdkError<
+        aws_sdk_kms::operation::decrypt::DecryptError,
+        ::aws_smithy_runtime_api::client::orchestrator::HttpResponse,
+    >,
+) -> ::std::rc::Rc<Error> {
+    match value {
+        SdkError::ServiceError(service_error) => match service_error.err() {
+            aws_sdk_kms::operation::decrypt::DecryptError::DependencyTimeoutException(e) =>
+                crate::conversions::error::dependency_timeout_exception::to_dafny(e.clone()),
+            aws_sdk_kms::operation::decrypt::DecryptError::DisabledException(e) =>
+                crate::conversions::error::disabled_exception::to_dafny(e.clone()),
+            aws_sdk_kms::operation::decrypt::DecryptError::DryRunOperationException(e) =>
+                crate::conversions::error::dry_run_operation_exception::to_dafny(e.clone()),
+            aws_sdk_kms::operation::decrypt::DecryptError::IncorrectKeyException(e) =>
+                crate::conversions::error::incorrect_key_exception::to_dafny(e.clone()),
+            aws_sdk_kms::operation::decrypt::DecryptError::InvalidCiphertextException(e) =>
+                crate::conversions::error::invalid_ciphertext_exception::to_dafny(e.clone()),
+            aws_sdk_kms::operation::decrypt::DecryptError::InvalidGrantTokenException(e) =>
+                crate::conversions::error::invalid_grant_token_exception::to_dafny(e.clone()),
+            aws_sdk_kms::operation::decrypt::DecryptError::InvalidKeyUsageException(e) =>
+                crate::conversions::error::invalid_key_usage_exception::to_dafny(e.clone()),
+            aws_sdk_kms::operation::decrypt::DecryptError::KeyUnavailableException(e) =>
+                crate::conversions::error::key_unavailable_exception::to_dafny(e.clone()),
+            aws_sdk_kms::operation::decrypt::DecryptError::KmsInternalException(e) =>
+                crate::conversions::error::kms_internal_exception::to_dafny(e.clone()),
+            aws_sdk_kms::operation::decrypt::DecryptError::KmsInvalidStateException(e) =>
+                crate::conversions::error::kms_invalid_state_exception::to_dafny(e.clone()),
+            aws_sdk_kms::operation::decrypt::DecryptError::NotFoundException(e) =>
+                crate::conversions::error::not_found_exception::to_dafny(e.clone()),
+            e => crate::conversions::error::to_opaque_error(e.to_string()),
+        },
+        _ => {
+            crate::conversions::error::to_opaque_error(value.to_string())
+        }
+    }
+}
diff --git b/TestModels/aws-sdks/kms-lite/runtimes/rust/src/conversions/decrypt/_decrypt_request.rs a/TestModels/aws-sdks/kms-lite/runtimes/rust/src/conversions/decrypt/_decrypt_request.rs
new file mode 100644
index 00000000..0fbf835c
--- /dev/null
+++ a/TestModels/aws-sdks/kms-lite/runtimes/rust/src/conversions/decrypt/_decrypt_request.rs
@@ -0,0 +1,88 @@
+// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
+#[allow(dead_code)]
+pub fn to_dafny(
+    value: aws_sdk_kms::operation::decrypt::DecryptInput
+) -> ::std::rc::Rc<
+    crate::r#software::amazon::cryptography::services::kms::internaldafny::types::DecryptRequest,
+>{
+    ::std::rc::Rc::new(crate::r#software::amazon::cryptography::services::kms::internaldafny::types::DecryptRequest::DecryptRequest  {
+        CiphertextBlob: crate::standard_library_conversions::oblob_to_dafny(&value.ciphertext_blob).Extract(), 
+        KeyId: crate::standard_library_conversions::ostring_to_dafny(&value.key_id),
+        EncryptionContext: 
+        ::std::rc::Rc::new(match value.encryption_context() {
+            Some(x) => crate::r#_Wrappers_Compile::Option::Some { value :
+                ::dafny_runtime::dafny_runtime_conversions::hashmap_to_dafny_map(x,
+                    |k| dafny_runtime::dafny_runtime_conversions::unicode_chars_false::string_to_dafny_string(k),
+                    |v| dafny_runtime::dafny_runtime_conversions::unicode_chars_false::string_to_dafny_string(v),
+                )
+            },
+            None => crate::r#_Wrappers_Compile::Option::None {}
+        }),
+        GrantTokens:
+        ::std::rc::Rc::new(
+            // Have to clone or else this becomes a borrow that can interfere with other branches
+            match value.grant_tokens.clone() {
+                Some(val) =>
+                crate::r#_Wrappers_Compile::Option::Some {
+                        value : ::dafny_runtime::Sequence::from_array(
+                            &val.iter().map(|x|
+                                dafny_runtime::dafny_runtime_conversions::unicode_chars_false::string_to_dafny_string(x))
+                                .collect()
+                        )
+                    },
+                None => crate::r#_Wrappers_Compile::Option::None{}
+            }
+        ),
+        Recipient: crate::conversions::recipient_info::option_to_dafny(value.recipient()),
+        DryRun: crate::standard_library_conversions::obool_to_dafny(value.dry_run),
+        EncryptionAlgorithm: ::std::rc::Rc::new(match value.encryption_algorithm {
+            Some(x) => crate::_Wrappers_Compile::Option::Some { value: crate::conversions::encryption_algorithm_spec::to_dafny(x) },
+            None => crate::_Wrappers_Compile::Option::None { }
+        })
+    })
+}
+
+#[allow(dead_code)]
+pub fn from_dafny(
+    dafny_value: ::std::rc::Rc<
+    crate::r#software::amazon::cryptography::services::kms::internaldafny::types::DecryptRequest,
+    >,
+    client: aws_sdk_kms::Client,
+) -> aws_sdk_kms::operation::decrypt::builders::DecryptFluentBuilder {
+    client.decrypt()
+        .set_ciphertext_blob(Some(
+            crate::standard_library_conversions::blob_from_dafny(dafny_value.CiphertextBlob().clone())))
+        .set_key_id(
+            crate::standard_library_conversions::ostring_from_dafny(dafny_value.KeyId().clone()),
+        )
+        .set_encryption_context( match (*dafny_value.EncryptionContext()).as_ref() {
+            crate::r#_Wrappers_Compile::Option::Some { value } =>
+                Some(
+                    ::dafny_runtime::dafny_runtime_conversions::dafny_map_to_hashmap(value,
+                        dafny_runtime::dafny_runtime_conversions::unicode_chars_false::dafny_string_to_string,
+                        dafny_runtime::dafny_runtime_conversions::unicode_chars_false::dafny_string_to_string,
+                    )
+                ),
+            _ => None
+        })
+        .set_grant_tokens(match  &**dafny_value.GrantTokens() {
+            crate::r#_Wrappers_Compile::Option::Some { value } =>
+                Some(
+                    ::dafny_runtime::dafny_runtime_conversions::dafny_sequence_to_vec(value, 
+                        dafny_runtime::dafny_runtime_conversions::unicode_chars_false::dafny_string_to_string)
+                ),
+            _ => None
+        })
+        .set_recipient(match  &**dafny_value.Recipient() {
+            crate::r#_Wrappers_Compile::Option::Some { value } =>
+                Some(
+                    crate::conversions::recipient_info::from_dafny(value.clone())
+                ),
+            _ => None
+        })
+        .set_dry_run(crate::standard_library_conversions::obool_from_dafny(dafny_value.DryRun().clone()))
+        .set_encryption_algorithm(
+            crate::standard_library_conversions::option_from_dafny(
+                dafny_value.EncryptionAlgorithm().clone(), 
+                |x| crate::conversions::encryption_algorithm_spec::from_dafny(x)))
+}
diff --git b/TestModels/aws-sdks/kms-lite/runtimes/rust/src/conversions/decrypt/_decrypt_response.rs a/TestModels/aws-sdks/kms-lite/runtimes/rust/src/conversions/decrypt/_decrypt_response.rs
new file mode 100644
index 00000000..b185a590
--- /dev/null
+++ a/TestModels/aws-sdks/kms-lite/runtimes/rust/src/conversions/decrypt/_decrypt_response.rs
@@ -0,0 +1,17 @@
+// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
+#[allow(dead_code)]
+pub fn to_dafny(
+    value: &aws_sdk_kms::operation::decrypt::DecryptOutput
+) -> ::std::rc::Rc<
+    crate::r#software::amazon::cryptography::services::kms::internaldafny::types::DecryptResponse,
+> {
+    ::std::rc::Rc::new(crate::r#software::amazon::cryptography::services::kms::internaldafny::types::DecryptResponse::DecryptResponse { 
+      Plaintext: crate::standard_library_conversions::oblob_to_dafny(&value.plaintext),
+      KeyId: crate::standard_library_conversions::ostring_to_dafny(&value.key_id),
+      CiphertextForRecipient: crate::standard_library_conversions::oblob_to_dafny(&value.ciphertext_for_recipient),
+      EncryptionAlgorithm: crate::standard_library_conversions::option_to_dafny(&value.encryption_algorithm,
+        |x| crate::conversions::encryption_algorithm_spec::to_dafny(x.clone())),
+    })
+}
+
+// from_dafny ommitted to save time until we get to actual code generation
diff --git b/TestModels/aws-sdks/kms-lite/runtimes/rust/src/conversions/encrypt.rs a/TestModels/aws-sdks/kms-lite/runtimes/rust/src/conversions/encrypt.rs
new file mode 100644
index 00000000..1dffbe0b
--- /dev/null
+++ a/TestModels/aws-sdks/kms-lite/runtimes/rust/src/conversions/encrypt.rs
@@ -0,0 +1,41 @@
+pub mod _encrypt_request;
+
+pub mod _encrypt_response;
+
+use aws_sdk_kms::error::SdkError;
+use crate::r#software::amazon::cryptography::services::kms::internaldafny::types::*;
+
+#[allow(dead_code)]
+pub fn to_dafny_error(
+    value: &::aws_smithy_runtime_api::client::result::SdkError<
+        aws_sdk_kms::operation::encrypt::EncryptError,
+        ::aws_smithy_runtime_api::client::orchestrator::HttpResponse,
+    >,
+) -> ::std::rc::Rc<Error> {
+  match value {
+    SdkError::ServiceError(service_error) => match service_error.err() {
+        aws_sdk_kms::operation::encrypt::EncryptError::DependencyTimeoutException(e) =>
+            crate::conversions::error::dependency_timeout_exception::to_dafny(e.clone()),
+        aws_sdk_kms::operation::encrypt::EncryptError::DisabledException(e) =>
+            crate::conversions::error::disabled_exception::to_dafny(e.clone()),
+        aws_sdk_kms::operation::encrypt::EncryptError::DryRunOperationException(e) =>
+            crate::conversions::error::dry_run_operation_exception::to_dafny(e.clone()),
+        aws_sdk_kms::operation::encrypt::EncryptError::InvalidGrantTokenException(e) =>
+            crate::conversions::error::invalid_grant_token_exception::to_dafny(e.clone()),
+        aws_sdk_kms::operation::encrypt::EncryptError::InvalidKeyUsageException(e) =>
+            crate::conversions::error::invalid_key_usage_exception::to_dafny(e.clone()),
+        aws_sdk_kms::operation::encrypt::EncryptError::KeyUnavailableException(e) =>
+            crate::conversions::error::key_unavailable_exception::to_dafny(e.clone()),
+        aws_sdk_kms::operation::encrypt::EncryptError::KmsInternalException(e) =>
+            crate::conversions::error::kms_internal_exception::to_dafny(e.clone()),
+        aws_sdk_kms::operation::encrypt::EncryptError::KmsInvalidStateException(e) =>
+            crate::conversions::error::kms_invalid_state_exception::to_dafny(e.clone()),
+        aws_sdk_kms::operation::encrypt::EncryptError::NotFoundException(e) =>
+            crate::conversions::error::not_found_exception::to_dafny(e.clone()),
+        e => crate::conversions::error::to_opaque_error(e.to_string()),
+    },
+    _ => {
+        crate::conversions::error::to_opaque_error(value.to_string())
+    }
+  }
+}
diff --git b/TestModels/aws-sdks/kms-lite/runtimes/rust/src/conversions/encrypt/_encrypt_request.rs a/TestModels/aws-sdks/kms-lite/runtimes/rust/src/conversions/encrypt/_encrypt_request.rs
new file mode 100644
index 00000000..42cdae13
--- /dev/null
+++ a/TestModels/aws-sdks/kms-lite/runtimes/rust/src/conversions/encrypt/_encrypt_request.rs
@@ -0,0 +1,79 @@
+// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.EncryptInput
+#[allow(dead_code)]
+pub fn to_dafny(
+    value: aws_sdk_kms::operation::encrypt::EncryptInput
+) -> ::std::rc::Rc<
+    crate::r#software::amazon::cryptography::services::kms::internaldafny::types::EncryptRequest,
+>{
+    ::std::rc::Rc::new(crate::r#software::amazon::cryptography::services::kms::internaldafny::types::EncryptRequest::EncryptRequest  {
+        Plaintext: crate::standard_library_conversions::oblob_to_dafny(&value.plaintext).Extract(),
+        KeyId: crate::standard_library_conversions::ostring_to_dafny(&value.key_id).Extract(),
+        EncryptionContext: 
+        ::std::rc::Rc::new(match value.encryption_context() {
+            Some(x) => crate::r#_Wrappers_Compile::Option::Some { value :
+                ::dafny_runtime::dafny_runtime_conversions::hashmap_to_dafny_map(x,
+                    |k| dafny_runtime::dafny_runtime_conversions::unicode_chars_false::string_to_dafny_string(k),
+                    |v| dafny_runtime::dafny_runtime_conversions::unicode_chars_false::string_to_dafny_string(v),
+                )
+            },
+            None => crate::r#_Wrappers_Compile::Option::None {}
+        }),
+        GrantTokens:
+        ::std::rc::Rc::new(
+            // Have to clone or else this becomes a borrow that can interfere with other branches
+            match value.grant_tokens.clone() {
+                Some(val) =>
+                crate::r#_Wrappers_Compile::Option::Some {
+                        value : ::dafny_runtime::Sequence::from_array(
+                            &val.iter().map(|x|
+                                dafny_runtime::dafny_runtime_conversions::unicode_chars_false::string_to_dafny_string(x))
+                                .collect()
+                        )
+                    },
+                None => crate::r#_Wrappers_Compile::Option::None{}
+            }
+        ),
+        DryRun: crate::standard_library_conversions::obool_to_dafny(value.dry_run),
+        EncryptionAlgorithm: ::std::rc::Rc::new(match value.encryption_algorithm {
+            Some(x) => crate::_Wrappers_Compile::Option::Some { value: crate::conversions::encryption_algorithm_spec::to_dafny(x) },
+            None => crate::_Wrappers_Compile::Option::None { }
+        })
+    })
+}
+
+#[allow(dead_code)]
+pub fn from_dafny(
+    dafny_value: ::std::rc::Rc<
+    crate::r#software::amazon::cryptography::services::kms::internaldafny::types::EncryptRequest,
+    >,
+    client: aws_sdk_kms::Client,
+) -> aws_sdk_kms::operation::encrypt::builders::EncryptFluentBuilder {
+    client.encrypt()
+        .set_plaintext(Some(crate::standard_library_conversions::blob_from_dafny(dafny_value.Plaintext().clone())))
+        .set_key_id(Some(
+            dafny_runtime::dafny_runtime_conversions::unicode_chars_false::dafny_string_to_string(dafny_value.KeyId())),
+        )
+        .set_encryption_context( match (*dafny_value.EncryptionContext()).as_ref() {
+            crate::r#_Wrappers_Compile::Option::Some { value } =>
+                Some(
+                    ::dafny_runtime::dafny_runtime_conversions::dafny_map_to_hashmap(value,
+                        dafny_runtime::dafny_runtime_conversions::unicode_chars_false::dafny_string_to_string,
+                        dafny_runtime::dafny_runtime_conversions::unicode_chars_false::dafny_string_to_string,
+                    )
+                ),
+            _ => None
+        })
+        .set_grant_tokens(match  &**dafny_value.GrantTokens() {
+            crate::r#_Wrappers_Compile::Option::Some { value } =>
+                Some(
+                    ::dafny_runtime::dafny_runtime_conversions::dafny_sequence_to_vec(value, 
+                        dafny_runtime::dafny_runtime_conversions::unicode_chars_false::dafny_string_to_string)
+                ),
+            _ => None
+        })
+        .set_dry_run(crate::standard_library_conversions::obool_from_dafny(dafny_value.DryRun().clone()))
+        .set_encryption_algorithm(
+            crate::standard_library_conversions::option_from_dafny(
+                dafny_value.EncryptionAlgorithm().clone(), 
+                |x| crate::conversions::encryption_algorithm_spec::from_dafny(x)))
+}
diff --git b/TestModels/aws-sdks/kms-lite/runtimes/rust/src/conversions/encrypt/_encrypt_response.rs a/TestModels/aws-sdks/kms-lite/runtimes/rust/src/conversions/encrypt/_encrypt_response.rs
new file mode 100644
index 00000000..b8e0f586
--- /dev/null
+++ a/TestModels/aws-sdks/kms-lite/runtimes/rust/src/conversions/encrypt/_encrypt_response.rs
@@ -0,0 +1,16 @@
+// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
+#[allow(dead_code)]
+pub fn to_dafny(
+    value: &aws_sdk_kms::operation::encrypt::EncryptOutput
+) -> ::std::rc::Rc<
+    crate::r#software::amazon::cryptography::services::kms::internaldafny::types::EncryptResponse,
+>{
+    ::std::rc::Rc::new(crate::r#software::amazon::cryptography::services::kms::internaldafny::types::EncryptResponse::EncryptResponse { 
+      CiphertextBlob: crate::standard_library_conversions::oblob_to_dafny(&value.ciphertext_blob),
+      KeyId: crate::standard_library_conversions::ostring_to_dafny(&value.key_id),
+      EncryptionAlgorithm: crate::standard_library_conversions::option_to_dafny(&value.encryption_algorithm,
+        |x| crate::conversions::encryption_algorithm_spec::to_dafny(x.clone())),
+    })
+}
+
+// from_dafny ommitted to save time until we get to actual code generation
diff --git b/TestModels/aws-sdks/kms-lite/runtimes/rust/src/conversions/encryption_algorithm_spec.rs a/TestModels/aws-sdks/kms-lite/runtimes/rust/src/conversions/encryption_algorithm_spec.rs
new file mode 100644
index 00000000..0328c46b
--- /dev/null
+++ a/TestModels/aws-sdks/kms-lite/runtimes/rust/src/conversions/encryption_algorithm_spec.rs
@@ -0,0 +1,32 @@
+// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
+#[allow(dead_code)]
+
+pub fn to_dafny(
+    value: aws_sdk_kms::types::EncryptionAlgorithmSpec,
+) -> ::std::rc::Rc<crate::software::amazon::cryptography::services::kms::internaldafny::types::EncryptionAlgorithmSpec>{
+    ::std::rc::Rc::new(match value {
+        aws_sdk_kms::types::EncryptionAlgorithmSpec::RsaesOaepSha1 => 
+          crate::software::amazon::cryptography::services::kms::internaldafny::types::EncryptionAlgorithmSpec::RSAES_OAEP_SHA_1 {  },
+        aws_sdk_kms::types::EncryptionAlgorithmSpec::RsaesOaepSha256 => 
+          crate::software::amazon::cryptography::services::kms::internaldafny::types::EncryptionAlgorithmSpec::RSAES_OAEP_SHA_256 {  },
+        aws_sdk_kms::types::EncryptionAlgorithmSpec::SymmetricDefault => 
+          crate::software::amazon::cryptography::services::kms::internaldafny::types::EncryptionAlgorithmSpec::SYMMETRIC_DEFAULT {  },
+        // TODO: This should not be a panic, but the Dafny image of the enum shape doesn't have an Unknown variant of any kind,
+        // so there's no way to succeed.
+        // See https://github.com/smithy-lang/smithy-dafny/issues/476.
+        // This could be handled more cleanly if conversion functions returned Results,
+        // but that would be a large and disruptie change to the overall code flow.
+        _ => panic!("Unknown enum variant: {}", value),
+    })
+}
+
+#[allow(dead_code)]
+pub fn from_dafny(
+    dafny_value: &crate::r#software::amazon::cryptography::services::kms::internaldafny::types::EncryptionAlgorithmSpec,
+) -> aws_sdk_kms::types::EncryptionAlgorithmSpec {
+    match dafny_value {
+        crate::software::amazon::cryptography::services::kms::internaldafny::types::EncryptionAlgorithmSpec::SYMMETRIC_DEFAULT {  } => aws_sdk_kms::types::EncryptionAlgorithmSpec::SymmetricDefault,
+        crate::software::amazon::cryptography::services::kms::internaldafny::types::EncryptionAlgorithmSpec::RSAES_OAEP_SHA_1 {  } => aws_sdk_kms::types::EncryptionAlgorithmSpec::RsaesOaepSha1,
+        crate::software::amazon::cryptography::services::kms::internaldafny::types::EncryptionAlgorithmSpec::RSAES_OAEP_SHA_256 {  } => aws_sdk_kms::types::EncryptionAlgorithmSpec::RsaesOaepSha256,
+    }
+}
diff --git b/TestModels/aws-sdks/kms-lite/runtimes/rust/src/conversions/error.rs a/TestModels/aws-sdks/kms-lite/runtimes/rust/src/conversions/error.rs
new file mode 100644
index 00000000..d59e6fed
--- /dev/null
+++ a/TestModels/aws-sdks/kms-lite/runtimes/rust/src/conversions/error.rs
@@ -0,0 +1,51 @@
+pub mod dependency_timeout_exception;
+
+pub mod disabled_exception;
+
+pub mod dry_run_operation_exception;
+
+pub mod incorrect_key_exception;
+
+pub mod invalid_ciphertext_exception;
+
+pub mod invalid_grant_token_exception;
+
+pub mod invalid_key_usage_exception;
+
+pub mod key_unavailable_exception;
+
+pub mod kms_internal_exception;
+
+pub mod kms_invalid_state_exception;
+
+pub mod not_found_exception;
+
+/// Wraps up an arbitrary Rust Error value as a Dafny Error
+pub fn to_opaque_error<E: 'static>(value: E) ->
+  ::std::rc::Rc<crate::r#software::amazon::cryptography::services::kms::internaldafny::types::Error>
+{
+    let error_obj: ::dafny_runtime::Object<dyn::std::any::Any> = ::dafny_runtime::Object(Some(
+        ::std::rc::Rc::new(::std::cell::UnsafeCell::new(value)),
+    ));
+    ::std::rc::Rc::new(
+    crate::r#software::amazon::cryptography::services::kms::internaldafny::types::Error::Opaque {
+        obj: error_obj,
+    },
+  )
+}
+
+/// Wraps up an arbitrary Rust Error value as a Dafny Result<T, Error>.Failure
+pub fn to_opaque_error_result<T: dafny_runtime::DafnyType, E: 'static>(value: E) ->
+  ::std::rc::Rc<
+    crate::_Wrappers_Compile::Result<
+      T,
+      ::std::rc::Rc<crate::r#software::amazon::cryptography::services::kms::internaldafny::types::Error>
+    >
+  >
+{
+    ::std::rc::Rc::new(
+        crate::_Wrappers_Compile::Result::Failure {
+            error: to_opaque_error(value),
+        },
+    )
+}
diff --git b/TestModels/aws-sdks/kms-lite/runtimes/rust/src/conversions/error/dependency_timeout_exception.rs a/TestModels/aws-sdks/kms-lite/runtimes/rust/src/conversions/error/dependency_timeout_exception.rs
new file mode 100644
index 00000000..4576a6d6
--- /dev/null
+++ a/TestModels/aws-sdks/kms-lite/runtimes/rust/src/conversions/error/dependency_timeout_exception.rs
@@ -0,0 +1,12 @@
+// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
+
+#[allow(dead_code)]
+pub fn to_dafny(
+    value: aws_sdk_kms::types::error::DependencyTimeoutException,
+) -> ::std::rc::Rc<crate::r#software::amazon::cryptography::services::kms::internaldafny::types::Error>{
+  ::std::rc::Rc::new(
+    crate::r#software::amazon::cryptography::services::kms::internaldafny::types::Error::DependencyTimeoutException {
+      message: crate::standard_library_conversions::ostring_to_dafny(&value.message)
+    }
+  )
+}
diff --git b/TestModels/aws-sdks/kms-lite/runtimes/rust/src/conversions/error/disabled_exception.rs a/TestModels/aws-sdks/kms-lite/runtimes/rust/src/conversions/error/disabled_exception.rs
new file mode 100644
index 00000000..9cfcd3a7
--- /dev/null
+++ a/TestModels/aws-sdks/kms-lite/runtimes/rust/src/conversions/error/disabled_exception.rs
@@ -0,0 +1,12 @@
+// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
+
+#[allow(dead_code)]
+pub fn to_dafny(
+    value: aws_sdk_kms::types::error::DisabledException,
+) -> ::std::rc::Rc<crate::r#software::amazon::cryptography::services::kms::internaldafny::types::Error>{
+  ::std::rc::Rc::new(
+    crate::r#software::amazon::cryptography::services::kms::internaldafny::types::Error::DisabledException {
+      message: crate::standard_library_conversions::ostring_to_dafny(&value.message)
+    }
+  )
+}
diff --git b/TestModels/aws-sdks/kms-lite/runtimes/rust/src/conversions/error/dry_run_operation_exception.rs a/TestModels/aws-sdks/kms-lite/runtimes/rust/src/conversions/error/dry_run_operation_exception.rs
new file mode 100644
index 00000000..487cb145
--- /dev/null
+++ a/TestModels/aws-sdks/kms-lite/runtimes/rust/src/conversions/error/dry_run_operation_exception.rs
@@ -0,0 +1,12 @@
+// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
+
+#[allow(dead_code)]
+pub fn to_dafny(
+    value: aws_sdk_kms::types::error::DryRunOperationException,
+) -> ::std::rc::Rc<crate::r#software::amazon::cryptography::services::kms::internaldafny::types::Error>{
+  ::std::rc::Rc::new(
+    crate::r#software::amazon::cryptography::services::kms::internaldafny::types::Error::DryRunOperationException {
+      message: crate::standard_library_conversions::ostring_to_dafny(&value.message)
+    }
+  )
+}
diff --git b/TestModels/aws-sdks/kms-lite/runtimes/rust/src/conversions/error/incorrect_key_exception.rs a/TestModels/aws-sdks/kms-lite/runtimes/rust/src/conversions/error/incorrect_key_exception.rs
new file mode 100644
index 00000000..6a2c6c50
--- /dev/null
+++ a/TestModels/aws-sdks/kms-lite/runtimes/rust/src/conversions/error/incorrect_key_exception.rs
@@ -0,0 +1,12 @@
+// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
+
+#[allow(dead_code)]
+pub fn to_dafny(
+    value: aws_sdk_kms::types::error::IncorrectKeyException,
+) -> ::std::rc::Rc<crate::r#software::amazon::cryptography::services::kms::internaldafny::types::Error>{
+  ::std::rc::Rc::new(
+    crate::r#software::amazon::cryptography::services::kms::internaldafny::types::Error::IncorrectKeyException {
+      message: crate::standard_library_conversions::ostring_to_dafny(&value.message)
+    }
+  )
+}
diff --git b/TestModels/aws-sdks/kms-lite/runtimes/rust/src/conversions/error/invalid_ciphertext_exception.rs a/TestModels/aws-sdks/kms-lite/runtimes/rust/src/conversions/error/invalid_ciphertext_exception.rs
new file mode 100644
index 00000000..8de0704e
--- /dev/null
+++ a/TestModels/aws-sdks/kms-lite/runtimes/rust/src/conversions/error/invalid_ciphertext_exception.rs
@@ -0,0 +1,12 @@
+// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
+
+#[allow(dead_code)]
+pub fn to_dafny(
+    value: aws_sdk_kms::types::error::InvalidCiphertextException,
+) -> ::std::rc::Rc<crate::r#software::amazon::cryptography::services::kms::internaldafny::types::Error>{
+  ::std::rc::Rc::new(
+    crate::r#software::amazon::cryptography::services::kms::internaldafny::types::Error::InvalidCiphertextException {
+      message: crate::standard_library_conversions::ostring_to_dafny(&value.message)
+    }
+  )
+}
diff --git b/TestModels/aws-sdks/kms-lite/runtimes/rust/src/conversions/error/invalid_grant_token_exception.rs a/TestModels/aws-sdks/kms-lite/runtimes/rust/src/conversions/error/invalid_grant_token_exception.rs
new file mode 100644
index 00000000..2e406152
--- /dev/null
+++ a/TestModels/aws-sdks/kms-lite/runtimes/rust/src/conversions/error/invalid_grant_token_exception.rs
@@ -0,0 +1,12 @@
+// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
+
+#[allow(dead_code)]
+pub fn to_dafny(
+    value: aws_sdk_kms::types::error::InvalidGrantTokenException,
+) -> ::std::rc::Rc<crate::r#software::amazon::cryptography::services::kms::internaldafny::types::Error>{
+  ::std::rc::Rc::new(
+    crate::r#software::amazon::cryptography::services::kms::internaldafny::types::Error::InvalidGrantTokenException {
+      message: crate::standard_library_conversions::ostring_to_dafny(&value.message)
+    }
+  )
+}
diff --git b/TestModels/aws-sdks/kms-lite/runtimes/rust/src/conversions/error/invalid_key_usage_exception.rs a/TestModels/aws-sdks/kms-lite/runtimes/rust/src/conversions/error/invalid_key_usage_exception.rs
new file mode 100644
index 00000000..36bc1292
--- /dev/null
+++ a/TestModels/aws-sdks/kms-lite/runtimes/rust/src/conversions/error/invalid_key_usage_exception.rs
@@ -0,0 +1,12 @@
+// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
+
+#[allow(dead_code)]
+pub fn to_dafny(
+    value: aws_sdk_kms::types::error::InvalidKeyUsageException,
+) -> ::std::rc::Rc<crate::r#software::amazon::cryptography::services::kms::internaldafny::types::Error>{
+  ::std::rc::Rc::new(
+    crate::r#software::amazon::cryptography::services::kms::internaldafny::types::Error::InvalidKeyUsageException {
+      message: crate::standard_library_conversions::ostring_to_dafny(&value.message)
+    }
+  )
+}
diff --git b/TestModels/aws-sdks/kms-lite/runtimes/rust/src/conversions/error/key_unavailable_exception.rs a/TestModels/aws-sdks/kms-lite/runtimes/rust/src/conversions/error/key_unavailable_exception.rs
new file mode 100644
index 00000000..20466e96
--- /dev/null
+++ a/TestModels/aws-sdks/kms-lite/runtimes/rust/src/conversions/error/key_unavailable_exception.rs
@@ -0,0 +1,12 @@
+// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
+
+#[allow(dead_code)]
+pub fn to_dafny(
+    value: aws_sdk_kms::types::error::KeyUnavailableException,
+) -> ::std::rc::Rc<crate::r#software::amazon::cryptography::services::kms::internaldafny::types::Error>{
+  ::std::rc::Rc::new(
+    crate::r#software::amazon::cryptography::services::kms::internaldafny::types::Error::KeyUnavailableException {
+      message: crate::standard_library_conversions::ostring_to_dafny(&value.message)
+    }
+  )
+}
diff --git b/TestModels/aws-sdks/kms-lite/runtimes/rust/src/conversions/error/kms_internal_exception.rs a/TestModels/aws-sdks/kms-lite/runtimes/rust/src/conversions/error/kms_internal_exception.rs
new file mode 100644
index 00000000..1a239549
--- /dev/null
+++ a/TestModels/aws-sdks/kms-lite/runtimes/rust/src/conversions/error/kms_internal_exception.rs
@@ -0,0 +1,12 @@
+// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
+
+#[allow(dead_code)]
+pub fn to_dafny(
+    value: aws_sdk_kms::types::error::KmsInternalException,
+) -> ::std::rc::Rc<crate::r#software::amazon::cryptography::services::kms::internaldafny::types::Error>{
+  ::std::rc::Rc::new(
+    crate::r#software::amazon::cryptography::services::kms::internaldafny::types::Error::KMSInternalException {
+      message: crate::standard_library_conversions::ostring_to_dafny(&value.message)
+    }
+  )
+}
diff --git b/TestModels/aws-sdks/kms-lite/runtimes/rust/src/conversions/error/kms_invalid_state_exception.rs a/TestModels/aws-sdks/kms-lite/runtimes/rust/src/conversions/error/kms_invalid_state_exception.rs
new file mode 100644
index 00000000..ec20b94f
--- /dev/null
+++ a/TestModels/aws-sdks/kms-lite/runtimes/rust/src/conversions/error/kms_invalid_state_exception.rs
@@ -0,0 +1,12 @@
+// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
+
+#[allow(dead_code)]
+pub fn to_dafny(
+    value: aws_sdk_kms::types::error::KmsInvalidStateException,
+) -> ::std::rc::Rc<crate::r#software::amazon::cryptography::services::kms::internaldafny::types::Error>{
+  ::std::rc::Rc::new(
+    crate::r#software::amazon::cryptography::services::kms::internaldafny::types::Error::KMSInvalidStateException {
+      message: crate::standard_library_conversions::ostring_to_dafny(&value.message)
+    }
+  )
+}
diff --git b/TestModels/aws-sdks/kms-lite/runtimes/rust/src/conversions/error/not_found_exception.rs a/TestModels/aws-sdks/kms-lite/runtimes/rust/src/conversions/error/not_found_exception.rs
new file mode 100644
index 00000000..e847930e
--- /dev/null
+++ a/TestModels/aws-sdks/kms-lite/runtimes/rust/src/conversions/error/not_found_exception.rs
@@ -0,0 +1,12 @@
+// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
+
+#[allow(dead_code)]
+pub fn to_dafny(
+    value: aws_sdk_kms::types::error::NotFoundException,
+) -> ::std::rc::Rc<crate::r#software::amazon::cryptography::services::kms::internaldafny::types::Error>{
+  ::std::rc::Rc::new(
+    crate::r#software::amazon::cryptography::services::kms::internaldafny::types::Error::NotFoundException {
+      message: crate::standard_library_conversions::ostring_to_dafny(&value.message)
+    }
+  )
+}
diff --git b/TestModels/aws-sdks/kms-lite/runtimes/rust/src/conversions/generate_data_key.rs a/TestModels/aws-sdks/kms-lite/runtimes/rust/src/conversions/generate_data_key.rs
new file mode 100644
index 00000000..061c384a
--- /dev/null
+++ a/TestModels/aws-sdks/kms-lite/runtimes/rust/src/conversions/generate_data_key.rs
@@ -0,0 +1,41 @@
+pub mod _generate_data_key_request;
+
+pub mod _generate_data_key_response;
+
+use aws_sdk_kms::error::SdkError;
+use crate::r#software::amazon::cryptography::services::kms::internaldafny::types::*;
+
+#[allow(dead_code)]
+pub fn to_dafny_error(
+    value: &::aws_smithy_runtime_api::client::result::SdkError<
+        aws_sdk_kms::operation::generate_data_key::GenerateDataKeyError,
+        ::aws_smithy_runtime_api::client::orchestrator::HttpResponse,
+    >,
+) -> ::std::rc::Rc<Error> {
+  match value {
+    SdkError::ServiceError(service_error) => match service_error.err() {
+        aws_sdk_kms::operation::generate_data_key::GenerateDataKeyError::DependencyTimeoutException(e) =>
+            crate::conversions::error::dependency_timeout_exception::to_dafny(e.clone()),
+        aws_sdk_kms::operation::generate_data_key::GenerateDataKeyError::DisabledException(e) =>
+            crate::conversions::error::disabled_exception::to_dafny(e.clone()),
+        aws_sdk_kms::operation::generate_data_key::GenerateDataKeyError::DryRunOperationException(e) =>
+            crate::conversions::error::dry_run_operation_exception::to_dafny(e.clone()),
+        aws_sdk_kms::operation::generate_data_key::GenerateDataKeyError::InvalidGrantTokenException(e) =>
+            crate::conversions::error::invalid_grant_token_exception::to_dafny(e.clone()),
+        aws_sdk_kms::operation::generate_data_key::GenerateDataKeyError::InvalidKeyUsageException(e) =>
+            crate::conversions::error::invalid_key_usage_exception::to_dafny(e.clone()),
+        aws_sdk_kms::operation::generate_data_key::GenerateDataKeyError::KeyUnavailableException(e) =>
+            crate::conversions::error::key_unavailable_exception::to_dafny(e.clone()),
+        aws_sdk_kms::operation::generate_data_key::GenerateDataKeyError::KmsInternalException(e) =>
+            crate::conversions::error::kms_internal_exception::to_dafny(e.clone()),
+        aws_sdk_kms::operation::generate_data_key::GenerateDataKeyError::KmsInvalidStateException(e) =>
+            crate::conversions::error::kms_invalid_state_exception::to_dafny(e.clone()),
+        aws_sdk_kms::operation::generate_data_key::GenerateDataKeyError::NotFoundException(e) =>
+            crate::conversions::error::not_found_exception::to_dafny(e.clone()),
+        e => crate::conversions::error::to_opaque_error(e.to_string()),
+    },
+    _ => {
+        crate::conversions::error::to_opaque_error(value.to_string())
+    }
+  }
+}
diff --git b/TestModels/aws-sdks/kms-lite/runtimes/rust/src/conversions/generate_data_key/_generate_data_key_request.rs a/TestModels/aws-sdks/kms-lite/runtimes/rust/src/conversions/generate_data_key/_generate_data_key_request.rs
new file mode 100644
index 00000000..6a7ffe06
--- /dev/null
+++ a/TestModels/aws-sdks/kms-lite/runtimes/rust/src/conversions/generate_data_key/_generate_data_key_request.rs
@@ -0,0 +1,95 @@
+// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
+#[allow(dead_code)]
+pub fn to_dafny(
+    value: aws_sdk_kms::operation::generate_data_key::GenerateDataKeyInput
+) -> ::std::rc::Rc<
+    crate::r#software::amazon::cryptography::services::kms::internaldafny::types::GenerateDataKeyRequest,
+>{
+    ::std::rc::Rc::new(crate::r#software::amazon::cryptography::services::kms::internaldafny::types::GenerateDataKeyRequest::GenerateDataKeyRequest  {
+        KeyId: crate::standard_library_conversions::ostring_to_dafny(&value.key_id).Extract(),
+        EncryptionContext: 
+        ::std::rc::Rc::new(match value.encryption_context() {
+            Some(x) => crate::r#_Wrappers_Compile::Option::Some { value :
+                ::dafny_runtime::dafny_runtime_conversions::hashmap_to_dafny_map(x,
+                    |k| dafny_runtime::dafny_runtime_conversions::unicode_chars_false::string_to_dafny_string(k),
+                    |v| dafny_runtime::dafny_runtime_conversions::unicode_chars_false::string_to_dafny_string(v),
+                )
+            },
+            None => crate::r#_Wrappers_Compile::Option::None {}
+        }),
+        NumberOfBytes: crate::standard_library_conversions::oint_to_dafny(value.number_of_bytes),
+        KeySpec: 
+        ::std::rc::Rc::new(match value.key_spec() {
+            Some(x) => crate::r#_Wrappers_Compile::Option::Some { 
+                value: crate::conversions::data_key_spec::to_dafny(x.clone())
+            },
+            _ => crate::r#_Wrappers_Compile::Option::None {}
+        }),
+        GrantTokens:
+        ::std::rc::Rc::new(
+            // Have to clone or else this becomes a borrow that can interfere with other branches
+            match value.grant_tokens.clone() {
+                Some(val) =>
+                crate::r#_Wrappers_Compile::Option::Some {
+                        value : ::dafny_runtime::Sequence::from_array(
+                            &val.iter().map(|x|
+                                dafny_runtime::dafny_runtime_conversions::unicode_chars_false::string_to_dafny_string(x))
+                                .collect()
+                        )
+                    },
+                None => crate::r#_Wrappers_Compile::Option::None{}
+            }
+        ),
+        Recipient: crate::conversions::recipient_info::option_to_dafny(value.recipient()),
+        DryRun: crate::standard_library_conversions::obool_to_dafny(value.dry_run),
+    })
+}
+
+#[allow(dead_code)]
+pub fn from_dafny(
+    dafny_value: ::std::rc::Rc<
+        crate::r#software::amazon::cryptography::services::kms::internaldafny::types::GenerateDataKeyRequest,
+    >,
+    client: aws_sdk_kms::Client,
+) -> aws_sdk_kms::operation::generate_data_key::builders::GenerateDataKeyFluentBuilder {
+    client.generate_data_key()
+        .set_key_id(Some(
+            dafny_runtime::dafny_runtime_conversions::unicode_chars_false::dafny_string_to_string(
+                dafny_value.KeyId(),
+            ),
+        ))
+        .set_encryption_context( match (*dafny_value.EncryptionContext()).as_ref() {
+            crate::r#_Wrappers_Compile::Option::Some { value } =>
+                Some(
+                    ::dafny_runtime::dafny_runtime_conversions::dafny_map_to_hashmap(value,
+                        dafny_runtime::dafny_runtime_conversions::unicode_chars_false::dafny_string_to_string,
+                        dafny_runtime::dafny_runtime_conversions::unicode_chars_false::dafny_string_to_string,
+                    )
+                ),
+            _ => None
+        })
+        .set_number_of_bytes(crate::standard_library_conversions::oint_from_dafny(dafny_value.NumberOfBytes().clone()))
+        .set_key_spec(match  &**dafny_value.KeySpec() {
+            crate::r#_Wrappers_Compile::Option::Some { value } =>
+                Some(
+                    crate::conversions::data_key_spec::from_dafny(value)
+                ),
+            _ => None
+        })
+        .set_grant_tokens(match  &**dafny_value.GrantTokens() {
+            crate::r#_Wrappers_Compile::Option::Some { value } =>
+                Some(
+                    ::dafny_runtime::dafny_runtime_conversions::dafny_sequence_to_vec(value, 
+                        dafny_runtime::dafny_runtime_conversions::unicode_chars_false::dafny_string_to_string)
+                ),
+            _ => None
+        })
+        .set_recipient(match  &**dafny_value.Recipient() {
+            crate::r#_Wrappers_Compile::Option::Some { value } =>
+                Some(
+                    crate::conversions::recipient_info::from_dafny(value.clone())
+                ),
+            _ => None
+        })
+        .set_dry_run(crate::standard_library_conversions::obool_from_dafny(dafny_value.DryRun().clone()))
+}
diff --git b/TestModels/aws-sdks/kms-lite/runtimes/rust/src/conversions/generate_data_key/_generate_data_key_response.rs a/TestModels/aws-sdks/kms-lite/runtimes/rust/src/conversions/generate_data_key/_generate_data_key_response.rs
new file mode 100644
index 00000000..474f6be2
--- /dev/null
+++ a/TestModels/aws-sdks/kms-lite/runtimes/rust/src/conversions/generate_data_key/_generate_data_key_response.rs
@@ -0,0 +1,16 @@
+// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
+#[allow(dead_code)]
+pub fn to_dafny(
+    value: &aws_sdk_kms::operation::generate_data_key::GenerateDataKeyOutput
+) -> ::std::rc::Rc<
+    crate::r#software::amazon::cryptography::services::kms::internaldafny::types::GenerateDataKeyResponse,
+>{
+    ::std::rc::Rc::new(crate::r#software::amazon::cryptography::services::kms::internaldafny::types::GenerateDataKeyResponse::GenerateDataKeyResponse { 
+      CiphertextBlob: crate::standard_library_conversions::oblob_to_dafny(&value.ciphertext_blob), 
+      Plaintext: crate::standard_library_conversions::oblob_to_dafny(&value.plaintext),
+      KeyId: crate::standard_library_conversions::ostring_to_dafny(&value.key_id),
+      CiphertextForRecipient: crate::standard_library_conversions::oblob_to_dafny(&value.ciphertext_for_recipient),
+    })
+}
+
+// from_dafny ommitted to save time until we get to actual code generation
\ No newline at end of file
diff --git b/TestModels/aws-sdks/kms-lite/runtimes/rust/src/conversions/generate_data_key_without_plaintext.rs a/TestModels/aws-sdks/kms-lite/runtimes/rust/src/conversions/generate_data_key_without_plaintext.rs
new file mode 100644
index 00000000..7a940fd8
--- /dev/null
+++ a/TestModels/aws-sdks/kms-lite/runtimes/rust/src/conversions/generate_data_key_without_plaintext.rs
@@ -0,0 +1,41 @@
+pub mod _generate_data_key_without_plaintext_request;
+
+pub mod _generate_data_key_without_plaintext_response;
+
+use aws_sdk_kms::error::SdkError;
+use crate::r#software::amazon::cryptography::services::kms::internaldafny::types::*;
+
+#[allow(dead_code)]
+pub fn to_dafny_error(
+    value: &::aws_smithy_runtime_api::client::result::SdkError<
+      aws_sdk_kms::operation::generate_data_key_without_plaintext::GenerateDataKeyWithoutPlaintextError,
+      ::aws_smithy_runtime_api::client::orchestrator::HttpResponse,
+  >,
+) -> ::std::rc::Rc<Error> {
+  match value {
+    SdkError::ServiceError(service_error) => match service_error.err() {
+        aws_sdk_kms::operation::generate_data_key_without_plaintext::GenerateDataKeyWithoutPlaintextError::DependencyTimeoutException(e) =>
+            crate::conversions::error::dependency_timeout_exception::to_dafny(e.clone()),
+        aws_sdk_kms::operation::generate_data_key_without_plaintext::GenerateDataKeyWithoutPlaintextError::DisabledException(e) =>
+            crate::conversions::error::disabled_exception::to_dafny(e.clone()),
+        aws_sdk_kms::operation::generate_data_key_without_plaintext::GenerateDataKeyWithoutPlaintextError::DryRunOperationException(e) =>
+            crate::conversions::error::dry_run_operation_exception::to_dafny(e.clone()),
+        aws_sdk_kms::operation::generate_data_key_without_plaintext::GenerateDataKeyWithoutPlaintextError::InvalidGrantTokenException(e) =>
+            crate::conversions::error::invalid_grant_token_exception::to_dafny(e.clone()),
+        aws_sdk_kms::operation::generate_data_key_without_plaintext::GenerateDataKeyWithoutPlaintextError::InvalidKeyUsageException(e) =>
+            crate::conversions::error::invalid_key_usage_exception::to_dafny(e.clone()),
+        aws_sdk_kms::operation::generate_data_key_without_plaintext::GenerateDataKeyWithoutPlaintextError::KeyUnavailableException(e) =>
+            crate::conversions::error::key_unavailable_exception::to_dafny(e.clone()),
+        aws_sdk_kms::operation::generate_data_key_without_plaintext::GenerateDataKeyWithoutPlaintextError::KmsInternalException(e) =>
+            crate::conversions::error::kms_internal_exception::to_dafny(e.clone()),
+        aws_sdk_kms::operation::generate_data_key_without_plaintext::GenerateDataKeyWithoutPlaintextError::KmsInvalidStateException(e) =>
+            crate::conversions::error::kms_invalid_state_exception::to_dafny(e.clone()),
+        aws_sdk_kms::operation::generate_data_key_without_plaintext::GenerateDataKeyWithoutPlaintextError::NotFoundException(e) =>
+            crate::conversions::error::not_found_exception::to_dafny(e.clone()),
+        e => crate::conversions::error::to_opaque_error(e.to_string()),
+    },
+    _ => {
+        crate::conversions::error::to_opaque_error(value.to_string())
+    }
+  }
+}
diff --git b/TestModels/aws-sdks/kms-lite/runtimes/rust/src/conversions/generate_data_key_without_plaintext/_generate_data_key_without_plaintext_request.rs a/TestModels/aws-sdks/kms-lite/runtimes/rust/src/conversions/generate_data_key_without_plaintext/_generate_data_key_without_plaintext_request.rs
new file mode 100644
index 00000000..4e400f6f
--- /dev/null
+++ a/TestModels/aws-sdks/kms-lite/runtimes/rust/src/conversions/generate_data_key_without_plaintext/_generate_data_key_without_plaintext_request.rs
@@ -0,0 +1,87 @@
+// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
+#[allow(dead_code)]
+pub fn to_dafny(
+    value: aws_sdk_kms::operation::generate_data_key_without_plaintext::GenerateDataKeyWithoutPlaintextInput
+) -> ::std::rc::Rc<
+    crate::r#software::amazon::cryptography::services::kms::internaldafny::types::GenerateDataKeyWithoutPlaintextRequest,
+>{
+    ::std::rc::Rc::new(crate::r#software::amazon::cryptography::services::kms::internaldafny::types::GenerateDataKeyWithoutPlaintextRequest::GenerateDataKeyWithoutPlaintextRequest  {
+        KeyId: crate::standard_library_conversions::ostring_to_dafny(&value.key_id).Extract(),
+        EncryptionContext: 
+        ::std::rc::Rc::new(match value.encryption_context() {
+            Some(x) => crate::r#_Wrappers_Compile::Option::Some { value :
+                ::dafny_runtime::dafny_runtime_conversions::hashmap_to_dafny_map(x,
+                    |k| dafny_runtime::dafny_runtime_conversions::unicode_chars_false::string_to_dafny_string(k),
+                    |v| dafny_runtime::dafny_runtime_conversions::unicode_chars_false::string_to_dafny_string(v),
+                )
+            },
+            None => crate::r#_Wrappers_Compile::Option::None {}
+        }),
+        NumberOfBytes: crate::standard_library_conversions::oint_to_dafny(value.number_of_bytes),
+        KeySpec: 
+        ::std::rc::Rc::new(match value.key_spec() {
+            Some(x) => crate::r#_Wrappers_Compile::Option::Some { 
+                value: crate::conversions::data_key_spec::to_dafny(x.clone())
+            },
+            _ => crate::r#_Wrappers_Compile::Option::None {}
+        }),
+        GrantTokens:
+        ::std::rc::Rc::new(
+            // Have to clone or else this becomes a borrow that can interfere with other branches
+            match value.grant_tokens.clone() {
+                Some(val) =>
+                crate::r#_Wrappers_Compile::Option::Some {
+                        value : ::dafny_runtime::Sequence::from_array(
+                            &val.iter().map(|x|
+                                dafny_runtime::dafny_runtime_conversions::unicode_chars_false::string_to_dafny_string(x))
+                                .collect()
+                        )
+                    },
+                None => crate::r#_Wrappers_Compile::Option::None{}
+            }
+        ),
+        DryRun: crate::standard_library_conversions::obool_to_dafny(value.dry_run),
+    })
+}
+
+#[allow(dead_code)]
+pub fn from_dafny(
+    dafny_value: ::std::rc::Rc<
+        crate::r#software::amazon::cryptography::services::kms::internaldafny::types::GenerateDataKeyWithoutPlaintextRequest,
+    >,
+    client: aws_sdk_kms::Client
+) -> aws_sdk_kms::operation::generate_data_key_without_plaintext::builders::GenerateDataKeyWithoutPlaintextFluentBuilder{
+    client.generate_data_key_without_plaintext()
+        .set_key_id(Some(
+            dafny_runtime::dafny_runtime_conversions::unicode_chars_false::dafny_string_to_string(
+                dafny_value.KeyId(),
+            ),
+        ))
+        .set_encryption_context( match (*dafny_value.EncryptionContext()).as_ref() {
+            crate::r#_Wrappers_Compile::Option::Some { value } =>
+                Some(
+                    ::dafny_runtime::dafny_runtime_conversions::dafny_map_to_hashmap(value,
+                        dafny_runtime::dafny_runtime_conversions::unicode_chars_false::dafny_string_to_string,
+                        dafny_runtime::dafny_runtime_conversions::unicode_chars_false::dafny_string_to_string,
+                    )
+                ),
+            _ => None
+        })
+        .set_number_of_bytes(crate::standard_library_conversions::oint_from_dafny(dafny_value.NumberOfBytes().clone()))
+        .set_key_spec(match  &**dafny_value.KeySpec() {
+            crate::r#_Wrappers_Compile::Option::Some { value } =>
+                Some(
+                    crate::conversions::data_key_spec::from_dafny(value)
+                ),
+            _ => None
+        })
+        .set_grant_tokens(match  &**dafny_value.GrantTokens() {
+            crate::r#_Wrappers_Compile::Option::Some { value } =>
+                Some(
+                    ::dafny_runtime::dafny_runtime_conversions::dafny_sequence_to_vec(value, 
+                        dafny_runtime::dafny_runtime_conversions::unicode_chars_false::dafny_string_to_string)
+                ),
+            _ => None
+        })
+        .set_dry_run(crate::standard_library_conversions::obool_from_dafny(dafny_value.DryRun().clone()))
+}
diff --git b/TestModels/aws-sdks/kms-lite/runtimes/rust/src/conversions/generate_data_key_without_plaintext/_generate_data_key_without_plaintext_response.rs a/TestModels/aws-sdks/kms-lite/runtimes/rust/src/conversions/generate_data_key_without_plaintext/_generate_data_key_without_plaintext_response.rs
new file mode 100644
index 00000000..6073f99a
--- /dev/null
+++ a/TestModels/aws-sdks/kms-lite/runtimes/rust/src/conversions/generate_data_key_without_plaintext/_generate_data_key_without_plaintext_response.rs
@@ -0,0 +1,14 @@
+// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
+#[allow(dead_code)]
+pub fn to_dafny(
+    value: &aws_sdk_kms::operation::generate_data_key_without_plaintext::GenerateDataKeyWithoutPlaintextOutput
+) -> ::std::rc::Rc<
+    crate::r#software::amazon::cryptography::services::kms::internaldafny::types::GenerateDataKeyWithoutPlaintextResponse,
+>{
+    ::std::rc::Rc::new(crate::r#software::amazon::cryptography::services::kms::internaldafny::types::GenerateDataKeyWithoutPlaintextResponse::GenerateDataKeyWithoutPlaintextResponse { 
+      CiphertextBlob: crate::standard_library_conversions::oblob_to_dafny(&value.ciphertext_blob), 
+      KeyId: crate::standard_library_conversions::ostring_to_dafny(&value.key_id),
+    })
+}
+
+// from_dafny ommitted to save time until we get to actual code generation
diff --git b/TestModels/aws-sdks/kms-lite/runtimes/rust/src/conversions/key_encryption_mechanism.rs a/TestModels/aws-sdks/kms-lite/runtimes/rust/src/conversions/key_encryption_mechanism.rs
new file mode 100644
index 00000000..9191dc4c
--- /dev/null
+++ a/TestModels/aws-sdks/kms-lite/runtimes/rust/src/conversions/key_encryption_mechanism.rs
@@ -0,0 +1,25 @@
+// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
+#[allow(dead_code)]
+
+pub fn to_dafny(
+    value: aws_sdk_kms::types::KeyEncryptionMechanism,
+) -> ::std::rc::Rc<crate::software::amazon::cryptography::services::kms::internaldafny::types::KeyEncryptionMechanism>{
+    match value {
+        aws_sdk_kms::types::KeyEncryptionMechanism::RsaesOaepSha256 => ::std::rc::Rc::new(crate::r#software::amazon::cryptography::services::kms::internaldafny::types::KeyEncryptionMechanism::RSAES_OAEP_SHA_256 {}),
+        // TODO: This should not be a panic, but the Dafny image of the enum shape doesn't have an Unknown variant of any kind,
+        // so there's no way to succeed.
+        // See https://github.com/smithy-lang/smithy-dafny/issues/476.
+        // This could be handled more cleanly if conversion functions returned Results,
+        // but that would be a large and disruptie change to the overall code flow.
+        _ => panic!("Unknown enum variant: {}", value),
+    }
+}
+
+#[allow(dead_code)]
+pub fn from_dafny(
+    dafny_value: &crate::r#software::amazon::cryptography::services::kms::internaldafny::types::KeyEncryptionMechanism,
+) -> aws_sdk_kms::types::KeyEncryptionMechanism {
+    match dafny_value {
+        crate::r#software::amazon::cryptography::services::kms::internaldafny::types::KeyEncryptionMechanism::RSAES_OAEP_SHA_256 {} => aws_sdk_kms::types::KeyEncryptionMechanism::RsaesOaepSha256,
+    }
+}
diff --git b/TestModels/aws-sdks/kms-lite/runtimes/rust/src/conversions/recipient_info.rs a/TestModels/aws-sdks/kms-lite/runtimes/rust/src/conversions/recipient_info.rs
new file mode 100644
index 00000000..45c18a6d
--- /dev/null
+++ a/TestModels/aws-sdks/kms-lite/runtimes/rust/src/conversions/recipient_info.rs
@@ -0,0 +1,89 @@
+use aws_sdk_kms::types::KeyEncryptionMechanism;
+
+// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
+#[allow(dead_code)]
+pub fn to_dafny(
+    value: aws_sdk_kms::types::RecipientInfo,
+) -> ::std::rc::Rc<
+    crate::r#software::amazon::cryptography::services::kms::internaldafny::types::RecipientInfo,
+>{
+    ::std::rc::Rc::new(to_dafny_plain(&value))
+}
+
+pub fn to_dafny_plain(
+    value: &aws_sdk_kms::types::RecipientInfo,
+) -> crate::r#software::amazon::cryptography::services::kms::internaldafny::types::RecipientInfo {
+    crate::r#software::amazon::cryptography::services::kms::internaldafny::types::RecipientInfo::RecipientInfo {
+        AttestationDocument: crate::standard_library_conversions::oblob_to_dafny(&value.attestation_document),
+        KeyEncryptionAlgorithm: crate::standard_library_conversions::option_to_dafny(&value.key_encryption_algorithm, 
+            |x| crate::conversions::key_encryption_mechanism::to_dafny(x.clone()))
+    }
+}
+
+pub fn option_to_dafny(
+    value: Option<&aws_sdk_kms::types::RecipientInfo>,
+) -> ::std::rc::Rc<
+    crate::_Wrappers_Compile::Option<
+        ::std::rc::Rc<
+            crate::r#software::amazon::cryptography::services::kms::internaldafny::types::RecipientInfo,
+        >,
+    >,
+>{
+    let inner = match value {
+        None => crate::_Wrappers_Compile::Option::None {},
+        Some(x) => crate::_Wrappers_Compile::Option::Some {
+            value: ::std::rc::Rc::new(to_dafny_plain(x)),
+        },
+    };
+    ::std::rc::Rc::new(inner)
+}
+
+#[allow(dead_code)]
+pub fn from_dafny(
+    dafny_value: ::std::rc::Rc<
+        crate::r#software::amazon::cryptography::services::kms::internaldafny::types::RecipientInfo,
+    >,
+) -> aws_sdk_kms::types::RecipientInfo {
+    aws_sdk_kms::types::RecipientInfo::builder()
+        .set_attestation_document(crate::standard_library_conversions::oblob_from_dafny(
+            dafny_value.AttestationDocument().clone(),
+        ))
+        .set_key_encryption_algorithm(match &**dafny_value.KeyEncryptionAlgorithm() {
+            crate::r#_Wrappers_Compile::Option::Some { value } => Some(
+                crate::conversions::key_encryption_mechanism::from_dafny(value),
+            ),
+            _ => None,
+        })
+        .build()
+}
+
+#[allow(dead_code)]
+pub fn plain_from_dafny(
+    dafny_value: &crate::r#software::amazon::cryptography::services::kms::internaldafny::types::RecipientInfo,
+) -> aws_sdk_kms::types::RecipientInfo {
+    aws_sdk_kms::types::RecipientInfo::builder()
+        .set_attestation_document(crate::standard_library_conversions::oblob_from_dafny(
+            dafny_value.AttestationDocument().clone(),
+        ))
+        .set_key_encryption_algorithm(match &**dafny_value.KeyEncryptionAlgorithm() {
+            crate::r#_Wrappers_Compile::Option::Some { value } => Some(
+                crate::conversions::key_encryption_mechanism::from_dafny(value),
+            ),
+            _ => None,
+        })
+        .build()
+}
+
+#[allow(dead_code)]
+pub fn option_from_dafny(
+    dafny_value: ::std::rc::Rc<crate::_Wrappers_Compile::Option<::std::rc::Rc<
+        crate::r#software::amazon::cryptography::services::kms::internaldafny::types::RecipientInfo,
+    >>>,
+) -> Option<aws_sdk_kms::types::RecipientInfo> {
+    match &*dafny_value {
+        crate::_Wrappers_Compile::Option::Some { value } => {
+            Some(plain_from_dafny(value))
+        }
+        _ => None,
+    }
+}
diff --git b/TestModels/aws-sdks/kms-lite/runtimes/rust/src/implementation_from_dafny.rs a/TestModels/aws-sdks/kms-lite/runtimes/rust/src/implementation_from_dafny.rs
index affa2a86..41f6c6fe 100644
--- b/TestModels/aws-sdks/kms-lite/runtimes/rust/src/implementation_from_dafny.rs
+++ a/TestModels/aws-sdks/kms-lite/runtimes/rust/src/implementation_from_dafny.rs
@@ -1,6 +1,10 @@
 #![allow(warnings, unconditional_panic)]
 #![allow(nonstandard_style)]
 
+mod client;
+mod conversions;
+mod standard_library_conversions;
+
 pub mod r#_Wrappers_Compile {
     pub use dafny_runtime::DafnyPrint;
     pub use std::cmp::Eq;
diff --git b/TestModels/aws-sdks/kms-lite/runtimes/rust/src/lib.rs a/TestModels/aws-sdks/kms-lite/runtimes/rust/src/lib.rs
new file mode 100644
index 00000000..3c941cd5
--- /dev/null
+++ a/TestModels/aws-sdks/kms-lite/runtimes/rust/src/lib.rs
@@ -0,0 +1,4 @@
+mod client;
+mod conversions;
+mod standard_library_conversions;
+pub mod implementation_from_dafny;
diff --git b/TestModels/aws-sdks/kms-lite/runtimes/rust/src/standard_library_conversions.rs a/TestModels/aws-sdks/kms-lite/runtimes/rust/src/standard_library_conversions.rs
new file mode 100644
index 00000000..2fec0ffb
--- /dev/null
+++ a/TestModels/aws-sdks/kms-lite/runtimes/rust/src/standard_library_conversions.rs
@@ -0,0 +1,246 @@
+pub fn ostring_to_dafny(
+  input: &Option<String>,
+) -> ::std::rc::Rc<
+  crate::_Wrappers_Compile::Option<::dafny_runtime::Sequence<::dafny_runtime::DafnyCharUTF16>>,
+> {
+  let dafny_value = match input {
+  Some(b) => crate::_Wrappers_Compile::Option::Some { value:
+      dafny_runtime::dafny_runtime_conversions::unicode_chars_false::string_to_dafny_string(&b)
+      },
+  None => crate::_Wrappers_Compile::Option::None {},
+};
+  ::std::rc::Rc::new(dafny_value)
+}
+
+pub fn ostring_from_dafny(
+  input: ::std::rc::Rc<
+      crate::_Wrappers_Compile::Option<::dafny_runtime::Sequence<::dafny_runtime::DafnyCharUTF16>>,
+  >,
+) -> Option<String> {
+  if matches!(input.as_ref(), crate::_Wrappers_Compile::Option::Some { .. }) {
+      Some(
+          dafny_runtime::dafny_runtime_conversions::unicode_chars_false::dafny_string_to_string(
+              &input.Extract(),
+          ),
+      )
+  } else {
+      None
+  }
+}
+
+pub fn obool_to_dafny(input: Option<bool>) -> ::std::rc::Rc<crate::_Wrappers_Compile::Option<bool>> {
+  let dafny_value = match input {
+      Some(b) => crate::_Wrappers_Compile::Option::Some { value: b },
+      None => crate::_Wrappers_Compile::Option::None {},
+  };
+  ::std::rc::Rc::new(dafny_value)
+}
+
+pub fn obool_from_dafny(input: ::std::rc::Rc<crate::_Wrappers_Compile::Option<bool>>) -> Option<bool> {
+  if matches!(input.as_ref(), crate::_Wrappers_Compile::Option::Some { .. }) {
+      Some(input.Extract())
+  } else {
+      None
+  }
+}
+
+pub fn oint_to_dafny(input: Option<i32>) -> ::std::rc::Rc<crate::_Wrappers_Compile::Option<i32>> {
+  let dafny_value = match input {
+      Some(b) => crate::_Wrappers_Compile::Option::Some { value: b },
+      None => crate::_Wrappers_Compile::Option::None {},
+  };
+  ::std::rc::Rc::new(dafny_value)
+}
+
+pub fn oint_from_dafny(input: ::std::rc::Rc<crate::_Wrappers_Compile::Option<i32>>) -> Option<i32> {
+  if matches!(input.as_ref(), crate::_Wrappers_Compile::Option::Some { .. }) {
+      Some(input.Extract())
+  } else {
+      None
+  }
+}
+
+pub fn olong_to_dafny(input: Option<i64>) -> ::std::rc::Rc<crate::_Wrappers_Compile::Option<i64>> {
+  let dafny_value = match input {
+      Some(b) => crate::_Wrappers_Compile::Option::Some { value: b },
+      None => crate::_Wrappers_Compile::Option::None {},
+  };
+  ::std::rc::Rc::new(dafny_value)
+}
+
+pub fn olong_from_dafny(input: ::std::rc::Rc<crate::_Wrappers_Compile::Option<i64>>) -> Option<i64> {
+  if matches!(input.as_ref(), crate::_Wrappers_Compile::Option::Some { .. }) {
+      Some(input.Extract())
+  } else {
+      None
+  }
+}
+
+pub fn blob_to_dafny(
+  input: &::aws_smithy_types::Blob,
+) -> ::dafny_runtime::Sequence<u8> {
+  ::dafny_runtime::Sequence::from_array(&input.clone().into_inner())
+}
+
+pub fn oblob_to_dafny(
+  input: &Option<::aws_smithy_types::Blob>,
+) -> ::std::rc::Rc<crate::_Wrappers_Compile::Option<::dafny_runtime::Sequence<u8>>> {
+  let dafny_value = match input {
+      Some(b) => crate::_Wrappers_Compile::Option::Some {
+          value: blob_to_dafny(&b),
+      },
+      None => crate::_Wrappers_Compile::Option::None {},
+  };
+  ::std::rc::Rc::new(dafny_value)
+}
+
+pub fn blob_from_dafny(
+  input: ::dafny_runtime::Sequence<u8>,
+) -> ::aws_smithy_types::Blob {
+
+  ::aws_smithy_types::Blob::new(
+      ::std::rc::Rc::try_unwrap(input.to_array())
+          .unwrap_or_else(|rc| (*rc).clone()),
+  )
+}
+
+pub fn oblob_from_dafny(
+  input: ::std::rc::Rc<crate::_Wrappers_Compile::Option<::dafny_runtime::Sequence<u8>>>,
+) -> Option<::aws_smithy_types::Blob> {
+  if matches!(input.as_ref(), crate::_Wrappers_Compile::Option::Some { .. }) {
+      Some(blob_from_dafny(input.Extract()))
+  } else {
+      None
+  }
+}
+
+pub fn double_to_dafny(
+  input: f64,
+) -> ::dafny_runtime::Sequence<u8> {
+  ::dafny_runtime::dafny_runtime_conversions::vec_to_dafny_sequence(
+      &f64::to_be_bytes(input).to_vec(),
+      |x| *x)
+}
+
+pub fn odouble_to_dafny(
+  input: &Option<f64>,
+) -> ::std::rc::Rc<crate::_Wrappers_Compile::Option<::dafny_runtime::Sequence<u8>>> {
+  let dafny_value = match input {
+      Some(f) => crate::_Wrappers_Compile::Option::Some {
+          value: double_to_dafny(*f),
+      },
+      None => crate::_Wrappers_Compile::Option::None {},
+  };
+  ::std::rc::Rc::new(dafny_value)
+}
+
+pub fn double_from_dafny(
+  input: &::dafny_runtime::Sequence<u8>,
+) -> f64 {
+  let v = ::dafny_runtime::dafny_runtime_conversions::dafny_sequence_to_vec(input, |x| *x);
+  f64::from_be_bytes(v.try_into().expect("Error converting Sequence to f64"))
+}
+
+pub fn odouble_from_dafny(
+  input: ::std::rc::Rc<crate::_Wrappers_Compile::Option<::dafny_runtime::Sequence<u8>>>,
+) -> Option<f64> {
+  if matches!(input.as_ref(), crate::_Wrappers_Compile::Option::Some { .. }) {
+      Some(double_from_dafny(&input.Extract()))
+  } else {
+      None
+  }
+}
+
+pub fn timestamp_to_dafny(
+  input: ::aws_smithy_types::DateTime,
+) -> ::dafny_runtime::Sequence<::dafny_runtime::DafnyCharUTF16> {
+  ::dafny_runtime::dafny_runtime_conversions::unicode_chars_false::string_to_dafny_string(&input.to_string())
+}
+
+pub fn otimestamp_to_dafny(
+  input: &Option<::aws_smithy_types::DateTime>,
+) -> ::std::rc::Rc<crate::_Wrappers_Compile::Option<::dafny_runtime::Sequence<::dafny_runtime::DafnyCharUTF16>>> {
+  let dafny_value = match input {
+      Some(f) => crate::_Wrappers_Compile::Option::Some {
+          value: timestamp_to_dafny(*f),
+      },
+      None => crate::_Wrappers_Compile::Option::None {},
+  };
+  ::std::rc::Rc::new(dafny_value)
+}
+
+pub fn timestamp_from_dafny(
+  input: ::dafny_runtime::Sequence<::dafny_runtime::DafnyCharUTF16>,
+) -> ::aws_smithy_types::DateTime {
+  let s = dafny_runtime::dafny_runtime_conversions::unicode_chars_false::dafny_string_to_string(&input);
+  ::aws_smithy_types::DateTime::from_str(
+      &s,
+      aws_smithy_types::date_time::Format::DateTime,
+  ).unwrap()
+}
+
+pub fn otimestamp_from_dafny(
+  input: ::std::rc::Rc<crate::_Wrappers_Compile::Option<::dafny_runtime::Sequence<::dafny_runtime::DafnyCharUTF16>>>,
+) -> Option<::aws_smithy_types::DateTime> {
+  if matches!(input.as_ref(), crate::_Wrappers_Compile::Option::Some { .. }) {
+      Some(timestamp_from_dafny(input.Extract()))
+  } else {
+      None
+  }
+}
+
+pub fn option_from_dafny<T: ::dafny_runtime::DafnyType, TR>(
+  input: ::std::rc::Rc<crate::_Wrappers_Compile::Option<T>>,
+  converter: fn(&T) -> TR,
+) -> Option<TR> {
+  match &*input {
+      crate::_Wrappers_Compile::Option::Some { value } => Some(converter(value)),
+      crate::_Wrappers_Compile::Option::None { } => None,
+  }
+}
+
+pub fn option_to_dafny<T: ::dafny_runtime::DafnyType, TR>(
+  input: &Option<TR>,
+  converter: fn(&TR) -> T,
+) -> ::std::rc::Rc<crate::_Wrappers_Compile::Option<T>> {
+  match input {
+      Some(value) => ::std::rc::Rc::new(
+          crate::_Wrappers_Compile::Option::Some {
+              value: converter(&value)
+          }
+      ),
+      None => ::std::rc::Rc::new(
+          crate::_Wrappers_Compile::Option::None {}
+      ),
+  }
+}
+
+pub fn result_from_dafny<T: ::dafny_runtime::DafnyType, TR, E: ::dafny_runtime::DafnyType, ER>(
+  input: ::std::rc::Rc<crate::_Wrappers_Compile::Result<T, E>>,
+  converter_t: fn(&T) -> TR,
+  converter_e: fn(&E) -> ER,
+) -> Result<TR, ER> {
+  match &*input {
+      crate::_Wrappers_Compile::Result::Success { value } => Ok(converter_t(value)),
+      crate::_Wrappers_Compile::Result::Failure { error } => Err(converter_e(error)),
+  }
+}
+
+pub fn result_to_dafny<T: ::dafny_runtime::DafnyType, TR, E: ::dafny_runtime::DafnyType, ER>(
+  input: &Result<TR, ER>,
+  converter_t: fn(&TR) -> T,
+  converter_e: fn(&ER) -> E,
+) -> ::std::rc::Rc<crate::_Wrappers_Compile::Result<T, E>> {
+  match input {
+      Ok(value) => ::std::rc::Rc::new(
+          crate::_Wrappers_Compile::Result::Success {
+              value: converter_t(&value)
+          }
+      ),
+      Err(error) => ::std::rc::Rc::new(
+          crate::_Wrappers_Compile::Result::Failure {
+              error: converter_e(&error)
+          }
+      ),
+  }
+}
\ No newline at end of file
