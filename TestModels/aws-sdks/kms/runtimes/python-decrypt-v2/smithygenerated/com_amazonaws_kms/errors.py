# Code generated by smithy-python-codegen DO NOT EDIT.

from typing import Any, Dict, Generic, Literal, TypeVar


class ServiceError(Exception):
    """Base error for all errors in the service.
    """
    pass

T = TypeVar('T')
class ApiError(ServiceError, Generic[T]):
    """Base error for all api errors in the service.
    """
    code: T
    def __init__(self, message: str):
        super().__init__(message)
        self.message = message

class UnknownApiError(ApiError[Literal['Unknown']]):
    """Error representing any unknown api errors
    """
    code: Literal['Unknown'] = 'Unknown'

class AlreadyExistsException(ApiError[Literal["AlreadyExistsException"]]):
    code: Literal["AlreadyExistsException"] = "AlreadyExistsException"
    message: str
    def __init__(
        self,
        *,
        message: str,
    ):
        """<p>The request was rejected because it attempted to create a resource that
        already
              exists.</p>
        :param message: A message associated with the specific error.

        """
        super().__init__(message)

    def as_dict(self) -> Dict[str, Any]:
        """Converts the AlreadyExistsException to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        return {
            'message': self.message,
            'code': self.code,
        }

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "AlreadyExistsException":
        """Creates a AlreadyExistsException from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {
            'message': d['message'],
        }

        return AlreadyExistsException(**kwargs)

    def __repr__(self) -> str:
        result = "AlreadyExistsException("
        result += f'message={self.message},'
        if self.message is not None:
            result += f"message={repr(self.message)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, AlreadyExistsException):
            return False
        attributes: list[str] = ['message','message',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class DependencyTimeoutException(ApiError[Literal["DependencyTimeoutException"]]):
    code: Literal["DependencyTimeoutException"] = "DependencyTimeoutException"
    message: str
    def __init__(
        self,
        *,
        message: str,
    ):
        """<p>The system timed out while trying to fulfill the request. The request can be

        retried.</p>
        :param message: A message associated with the specific error.

        """
        super().__init__(message)

    def as_dict(self) -> Dict[str, Any]:
        """Converts the DependencyTimeoutException to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        return {
            'message': self.message,
            'code': self.code,
        }

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "DependencyTimeoutException":
        """Creates a DependencyTimeoutException from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {
            'message': d['message'],
        }

        return DependencyTimeoutException(**kwargs)

    def __repr__(self) -> str:
        result = "DependencyTimeoutException("
        result += f'message={self.message},'
        if self.message is not None:
            result += f"message={repr(self.message)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, DependencyTimeoutException):
            return False
        attributes: list[str] = ['message','message',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class InvalidArnException(ApiError[Literal["InvalidArnException"]]):
    code: Literal["InvalidArnException"] = "InvalidArnException"
    message: str
    def __init__(
        self,
        *,
        message: str,
    ):
        """<p>The request was rejected because a specified ARN, or an ARN in a key policy,
        is not
              valid.</p>
        :param message: A message associated with the specific error.

        """
        super().__init__(message)

    def as_dict(self) -> Dict[str, Any]:
        """Converts the InvalidArnException to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        return {
            'message': self.message,
            'code': self.code,
        }

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "InvalidArnException":
        """Creates a InvalidArnException from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {
            'message': d['message'],
        }

        return InvalidArnException(**kwargs)

    def __repr__(self) -> str:
        result = "InvalidArnException("
        result += f'message={self.message},'
        if self.message is not None:
            result += f"message={repr(self.message)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, InvalidArnException):
            return False
        attributes: list[str] = ['message','message',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class KMSInternalException(ApiError[Literal["KMSInternalException"]]):
    code: Literal["KMSInternalException"] = "KMSInternalException"
    message: str
    def __init__(
        self,
        *,
        message: str,
    ):
        """<p>The request was rejected because an internal exception occurred. The request
        can be
              retried.</p>
        :param message: A message associated with the specific error.

        """
        super().__init__(message)

    def as_dict(self) -> Dict[str, Any]:
        """Converts the KMSInternalException to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        return {
            'message': self.message,
            'code': self.code,
        }

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "KMSInternalException":
        """Creates a KMSInternalException from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {
            'message': d['message'],
        }

        return KMSInternalException(**kwargs)

    def __repr__(self) -> str:
        result = "KMSInternalException("
        result += f'message={self.message},'
        if self.message is not None:
            result += f"message={repr(self.message)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, KMSInternalException):
            return False
        attributes: list[str] = ['message','message',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class KMSInvalidStateException(ApiError[Literal["KMSInvalidStateException"]]):
    code: Literal["KMSInvalidStateException"] = "KMSInvalidStateException"
    message: str
    def __init__(
        self,
        *,
        message: str,
    ):
        """<p>The request was rejected because the state of the specified resource is not
        valid for this
              request.</p>
                 <p>For more information about how key
        state affects the use of a KMS key, see <a
        href="https://docs.aws.amazon.com/kms/latest/developerguide/key-state.html">Key
        state: Effect on your KMS
                key</a> in the <i>
                       <i>Key
        Management Service Developer Guide</i>
                    </i>.</p>
        :param message: A message associated with the specific error.

        """
        super().__init__(message)

    def as_dict(self) -> Dict[str, Any]:
        """Converts the KMSInvalidStateException to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        return {
            'message': self.message,
            'code': self.code,
        }

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "KMSInvalidStateException":
        """Creates a KMSInvalidStateException from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {
            'message': d['message'],
        }

        return KMSInvalidStateException(**kwargs)

    def __repr__(self) -> str:
        result = "KMSInvalidStateException("
        result += f'message={self.message},'
        if self.message is not None:
            result += f"message={repr(self.message)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, KMSInvalidStateException):
            return False
        attributes: list[str] = ['message','message',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class NotFoundException(ApiError[Literal["NotFoundException"]]):
    code: Literal["NotFoundException"] = "NotFoundException"
    message: str
    def __init__(
        self,
        *,
        message: str,
    ):
        """<p>The request was rejected because the specified entity or resource could not
        be
              found.</p>
        :param message: A message associated with the specific error.

        """
        super().__init__(message)

    def as_dict(self) -> Dict[str, Any]:
        """Converts the NotFoundException to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        return {
            'message': self.message,
            'code': self.code,
        }

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "NotFoundException":
        """Creates a NotFoundException from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {
            'message': d['message'],
        }

        return NotFoundException(**kwargs)

    def __repr__(self) -> str:
        result = "NotFoundException("
        result += f'message={self.message},'
        if self.message is not None:
            result += f"message={repr(self.message)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, NotFoundException):
            return False
        attributes: list[str] = ['message','message',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class CloudHsmClusterInUseException(ApiError[Literal["CloudHsmClusterInUseException"]]):
    code: Literal["CloudHsmClusterInUseException"] = "CloudHsmClusterInUseException"
    message: str
    def __init__(
        self,
        *,
        message: str,
    ):
        """<p>The request was rejected because the specified CloudHSM cluster is already
        associated with a
              custom key store or it shares a backup history with a
        cluster that is associated with a custom
              key store. Each custom key store
        must be associated with a different CloudHSM cluster.</p>
                 <p>Clusters
        that share a backup history have the same cluster certificate. To view the

        cluster certificate of a cluster, use the <a
        href="https://docs.aws.amazon.com/cloudhsm/latest/APIReference/API_DescribeClusters.html">DescribeClusters</a>
        operation.</p>
        :param message: A message associated with the specific error.

        """
        super().__init__(message)

    def as_dict(self) -> Dict[str, Any]:
        """Converts the CloudHsmClusterInUseException to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        return {
            'message': self.message,
            'code': self.code,
        }

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "CloudHsmClusterInUseException":
        """Creates a CloudHsmClusterInUseException from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {
            'message': d['message'],
        }

        return CloudHsmClusterInUseException(**kwargs)

    def __repr__(self) -> str:
        result = "CloudHsmClusterInUseException("
        result += f'message={self.message},'
        if self.message is not None:
            result += f"message={repr(self.message)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, CloudHsmClusterInUseException):
            return False
        attributes: list[str] = ['message','message',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class CloudHsmClusterInvalidConfigurationException(ApiError[Literal["CloudHsmClusterInvalidConfigurationException"]]):
    code: Literal["CloudHsmClusterInvalidConfigurationException"] = "CloudHsmClusterInvalidConfigurationException"
    message: str
    def __init__(
        self,
        *,
        message: str,
    ):
        """<p>The request was rejected because the associated CloudHSM cluster did not meet
        the
              configuration requirements for a custom key store.</p>

                 <ul>

        <li>
                       <p>The cluster must be configured with private subnets in at
        least two different
                  Availability Zones in the Region.</p>

        </li>
                    <li>
                       <p>The <a
        href="https://docs.aws.amazon.com/cloudhsm/latest/userguide/configure-sg.html">security
        group for
                    the cluster</a> (cloudhsm-cluster-<i><cluster-id></i>-sg)
        must
                  include inbound rules and outbound rules that allow TCP traffic
        on ports 2223-2225. The
                    <b>Source</b> in the inbound rules and the
        <b>Destination</b> in the outbound rules must match the security group

        ID. These rules are set by default when you create the cluster. Do not delete or
        change
                  them. To get information about a particular security group, use
        the <a
        href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeSecurityGroups.html">DescribeSecurityGroups</a>
        operation.</p>
                    </li>
                    <li>
                       <p>The cluster
        must contain at least as many HSMs as the operation requires. To add HSMs,

        use the CloudHSM <a
        href="https://docs.aws.amazon.com/cloudhsm/latest/APIReference/API_CreateHsm.html">CreateHsm</a>
        operation.</p>
                       <p>For the <a>CreateCustomKeyStore</a>,
        <a>UpdateCustomKeyStore</a>, and <a>CreateKey</a> operations, the CloudHSM
        cluster must have at least two
                  active HSMs, each in a different
        Availability Zone. For the <a>ConnectCustomKeyStore</a> operation, the CloudHSM
        must contain at least one active
                  HSM.</p>
                    </li>

        </ul>
                 <p>For information about the requirements for an CloudHSM cluster
        that is associated with a
              custom key store, see <a
        href="https://docs.aws.amazon.com/kms/latest/developerguide/create-keystore.html#before-keystore">Assemble
        the Prerequisites</a>
              in the <i>Key Management Service Developer
        Guide</i>. For information about creating a private subnet for an CloudHSM
        cluster,
              see <a
        href="https://docs.aws.amazon.com/cloudhsm/latest/userguide/create-subnets.html">Create
        a Private
                Subnet</a> in the <i>CloudHSM User Guide</i>. For information
        about cluster security groups, see
                <a
        href="https://docs.aws.amazon.com/cloudhsm/latest/userguide/configure-sg.html">Configure
        a Default Security
                Group</a> in the <i>
                       <i>CloudHSM User
        Guide</i>
                    </i>. </p>
        :param message: A message associated with the specific error.

        """
        super().__init__(message)

    def as_dict(self) -> Dict[str, Any]:
        """Converts the CloudHsmClusterInvalidConfigurationException to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        return {
            'message': self.message,
            'code': self.code,
        }

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "CloudHsmClusterInvalidConfigurationException":
        """Creates a CloudHsmClusterInvalidConfigurationException from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {
            'message': d['message'],
        }

        return CloudHsmClusterInvalidConfigurationException(**kwargs)

    def __repr__(self) -> str:
        result = "CloudHsmClusterInvalidConfigurationException("
        result += f'message={self.message},'
        if self.message is not None:
            result += f"message={repr(self.message)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, CloudHsmClusterInvalidConfigurationException):
            return False
        attributes: list[str] = ['message','message',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class CloudHsmClusterNotActiveException(ApiError[Literal["CloudHsmClusterNotActiveException"]]):
    code: Literal["CloudHsmClusterNotActiveException"] = "CloudHsmClusterNotActiveException"
    message: str
    def __init__(
        self,
        *,
        message: str,
    ):
        """<p>The request was rejected because the CloudHSM cluster that is associated with
        the custom key
              store is not active. Initialize and activate the cluster
        and try the command again. For
              detailed instructions, see <a
        href="https://docs.aws.amazon.com/cloudhsm/latest/userguide/getting-started.html">Getting
        Started</a> in the <i>CloudHSM User Guide</i>.</p>
        :param message: A message associated with the specific error.

        """
        super().__init__(message)

    def as_dict(self) -> Dict[str, Any]:
        """Converts the CloudHsmClusterNotActiveException to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        return {
            'message': self.message,
            'code': self.code,
        }

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "CloudHsmClusterNotActiveException":
        """Creates a CloudHsmClusterNotActiveException from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {
            'message': d['message'],
        }

        return CloudHsmClusterNotActiveException(**kwargs)

    def __repr__(self) -> str:
        result = "CloudHsmClusterNotActiveException("
        result += f'message={self.message},'
        if self.message is not None:
            result += f"message={repr(self.message)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, CloudHsmClusterNotActiveException):
            return False
        attributes: list[str] = ['message','message',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class CloudHsmClusterNotFoundException(ApiError[Literal["CloudHsmClusterNotFoundException"]]):
    code: Literal["CloudHsmClusterNotFoundException"] = "CloudHsmClusterNotFoundException"
    message: str
    def __init__(
        self,
        *,
        message: str,
    ):
        """<p>The request was rejected because KMS cannot find the CloudHSM cluster with
        the specified
              cluster ID. Retry the request with a different cluster
        ID.</p>
        :param message: A message associated with the specific error.

        """
        super().__init__(message)

    def as_dict(self) -> Dict[str, Any]:
        """Converts the CloudHsmClusterNotFoundException to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        return {
            'message': self.message,
            'code': self.code,
        }

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "CloudHsmClusterNotFoundException":
        """Creates a CloudHsmClusterNotFoundException from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {
            'message': d['message'],
        }

        return CloudHsmClusterNotFoundException(**kwargs)

    def __repr__(self) -> str:
        result = "CloudHsmClusterNotFoundException("
        result += f'message={self.message},'
        if self.message is not None:
            result += f"message={repr(self.message)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, CloudHsmClusterNotFoundException):
            return False
        attributes: list[str] = ['message','message',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class CloudHsmClusterNotRelatedException(ApiError[Literal["CloudHsmClusterNotRelatedException"]]):
    code: Literal["CloudHsmClusterNotRelatedException"] = "CloudHsmClusterNotRelatedException"
    message: str
    def __init__(
        self,
        *,
        message: str,
    ):
        """<p>The request was rejected because the specified CloudHSM cluster has a
        different cluster
              certificate than the original cluster. You cannot use
        the operation to specify an unrelated
              cluster.</p>
                 <p>Specify a
        cluster that shares a backup history with the original cluster. This includes

        clusters that were created from a backup of the current cluster, and clusters
        that were
              created from the same backup that produced the current
        cluster.</p>
                 <p>Clusters that share a backup history have the same
        cluster certificate. To view the
              cluster certificate of a cluster, use the
        <a
        href="https://docs.aws.amazon.com/cloudhsm/latest/APIReference/API_DescribeClusters.html">DescribeClusters</a>
        operation.</p>
        :param message: A message associated with the specific error.

        """
        super().__init__(message)

    def as_dict(self) -> Dict[str, Any]:
        """Converts the CloudHsmClusterNotRelatedException to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        return {
            'message': self.message,
            'code': self.code,
        }

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "CloudHsmClusterNotRelatedException":
        """Creates a CloudHsmClusterNotRelatedException from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {
            'message': d['message'],
        }

        return CloudHsmClusterNotRelatedException(**kwargs)

    def __repr__(self) -> str:
        result = "CloudHsmClusterNotRelatedException("
        result += f'message={self.message},'
        if self.message is not None:
            result += f"message={repr(self.message)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, CloudHsmClusterNotRelatedException):
            return False
        attributes: list[str] = ['message','message',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class CustomKeyStoreInvalidStateException(ApiError[Literal["CustomKeyStoreInvalidStateException"]]):
    code: Literal["CustomKeyStoreInvalidStateException"] = "CustomKeyStoreInvalidStateException"
    message: str
    def __init__(
        self,
        *,
        message: str,
    ):
        """<p>The request was rejected because of the <code>ConnectionState</code> of the
        custom key
              store. To get the <code>ConnectionState</code> of a custom key
        store, use the <a>DescribeCustomKeyStores</a> operation.</p>
                 <p>This
        exception is thrown under the following conditions:</p>
                 <ul>

        <li>
                       <p>You requested the <a>CreateKey</a> or
        <a>GenerateRandom</a>
                  operation in a custom key store that is not
        connected. These operations are valid only
                  when the custom key store
        <code>ConnectionState</code> is <code>CONNECTED</code>.</p>
                    </li>

        <li>
                       <p>You requested the <a>UpdateCustomKeyStore</a> or
        <a>DeleteCustomKeyStore</a> operation on a custom key store that is not

        disconnected. This operation is valid only when the custom key store

        <code>ConnectionState</code> is <code>DISCONNECTED</code>.</p>

        </li>
                    <li>
                       <p>You requested the
        <a>ConnectCustomKeyStore</a> operation on a custom key
                  store with a
        <code>ConnectionState</code> of <code>DISCONNECTING</code> or

        <code>FAILED</code>. This operation is valid for all other
        <code>ConnectionState</code>
                  values.</p>
                    </li>

        </ul>
        :param message: A message associated with the specific error.

        """
        super().__init__(message)

    def as_dict(self) -> Dict[str, Any]:
        """Converts the CustomKeyStoreInvalidStateException to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        return {
            'message': self.message,
            'code': self.code,
        }

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "CustomKeyStoreInvalidStateException":
        """Creates a CustomKeyStoreInvalidStateException from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {
            'message': d['message'],
        }

        return CustomKeyStoreInvalidStateException(**kwargs)

    def __repr__(self) -> str:
        result = "CustomKeyStoreInvalidStateException("
        result += f'message={self.message},'
        if self.message is not None:
            result += f"message={repr(self.message)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, CustomKeyStoreInvalidStateException):
            return False
        attributes: list[str] = ['message','message',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class CustomKeyStoreNotFoundException(ApiError[Literal["CustomKeyStoreNotFoundException"]]):
    code: Literal["CustomKeyStoreNotFoundException"] = "CustomKeyStoreNotFoundException"
    message: str
    def __init__(
        self,
        *,
        message: str,
    ):
        """<p>The request was rejected because KMS cannot find a custom key store with the
        specified
              key store name or ID.</p>
        :param message: A message associated with the specific error.

        """
        super().__init__(message)

    def as_dict(self) -> Dict[str, Any]:
        """Converts the CustomKeyStoreNotFoundException to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        return {
            'message': self.message,
            'code': self.code,
        }

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "CustomKeyStoreNotFoundException":
        """Creates a CustomKeyStoreNotFoundException from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {
            'message': d['message'],
        }

        return CustomKeyStoreNotFoundException(**kwargs)

    def __repr__(self) -> str:
        result = "CustomKeyStoreNotFoundException("
        result += f'message={self.message},'
        if self.message is not None:
            result += f"message={repr(self.message)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, CustomKeyStoreNotFoundException):
            return False
        attributes: list[str] = ['message','message',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class InvalidAliasNameException(ApiError[Literal["InvalidAliasNameException"]]):
    code: Literal["InvalidAliasNameException"] = "InvalidAliasNameException"
    message: str
    def __init__(
        self,
        *,
        message: str,
    ):
        """<p>The request was rejected because the specified alias name is not valid.</p>
        :param message: A message associated with the specific error.

        """
        super().__init__(message)

    def as_dict(self) -> Dict[str, Any]:
        """Converts the InvalidAliasNameException to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        return {
            'message': self.message,
            'code': self.code,
        }

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "InvalidAliasNameException":
        """Creates a InvalidAliasNameException from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {
            'message': d['message'],
        }

        return InvalidAliasNameException(**kwargs)

    def __repr__(self) -> str:
        result = "InvalidAliasNameException("
        result += f'message={self.message},'
        if self.message is not None:
            result += f"message={repr(self.message)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, InvalidAliasNameException):
            return False
        attributes: list[str] = ['message','message',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class LimitExceededException(ApiError[Literal["LimitExceededException"]]):
    code: Literal["LimitExceededException"] = "LimitExceededException"
    message: str
    def __init__(
        self,
        *,
        message: str,
    ):
        """<p>The request was rejected because a quota was exceeded. For more information,
        see <a
        href="https://docs.aws.amazon.com/kms/latest/developerguide/limits.html">Quotas</a>
        in the
              <i>Key Management Service Developer Guide</i>.</p>
        :param message: A message associated with the specific error.

        """
        super().__init__(message)

    def as_dict(self) -> Dict[str, Any]:
        """Converts the LimitExceededException to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        return {
            'message': self.message,
            'code': self.code,
        }

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "LimitExceededException":
        """Creates a LimitExceededException from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {
            'message': d['message'],
        }

        return LimitExceededException(**kwargs)

    def __repr__(self) -> str:
        result = "LimitExceededException("
        result += f'message={self.message},'
        if self.message is not None:
            result += f"message={repr(self.message)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, LimitExceededException):
            return False
        attributes: list[str] = ['message','message',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class CustomKeyStoreNameInUseException(ApiError[Literal["CustomKeyStoreNameInUseException"]]):
    code: Literal["CustomKeyStoreNameInUseException"] = "CustomKeyStoreNameInUseException"
    message: str
    def __init__(
        self,
        *,
        message: str,
    ):
        """<p>The request was rejected because the specified custom key store name is
        already assigned
              to another custom key store in the account. Try again
        with a custom key store name that is
              unique in the account.</p>
        :param message: A message associated with the specific error.

        """
        super().__init__(message)

    def as_dict(self) -> Dict[str, Any]:
        """Converts the CustomKeyStoreNameInUseException to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        return {
            'message': self.message,
            'code': self.code,
        }

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "CustomKeyStoreNameInUseException":
        """Creates a CustomKeyStoreNameInUseException from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {
            'message': d['message'],
        }

        return CustomKeyStoreNameInUseException(**kwargs)

    def __repr__(self) -> str:
        result = "CustomKeyStoreNameInUseException("
        result += f'message={self.message},'
        if self.message is not None:
            result += f"message={repr(self.message)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, CustomKeyStoreNameInUseException):
            return False
        attributes: list[str] = ['message','message',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class IncorrectTrustAnchorException(ApiError[Literal["IncorrectTrustAnchorException"]]):
    code: Literal["IncorrectTrustAnchorException"] = "IncorrectTrustAnchorException"
    message: str
    def __init__(
        self,
        *,
        message: str,
    ):
        """<p>The request was rejected because the trust anchor certificate in the request
        is not the
              trust anchor certificate for the specified CloudHSM
        cluster.</p>
                 <p>When you <a
        href="https://docs.aws.amazon.com/cloudhsm/latest/userguide/initialize-cluster.html#sign-csr">initialize
        the cluster</a>, you create the trust anchor certificate and save it in the

        <code>customerCA.crt</code> file.</p>
        :param message: A message associated with the specific error.

        """
        super().__init__(message)

    def as_dict(self) -> Dict[str, Any]:
        """Converts the IncorrectTrustAnchorException to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        return {
            'message': self.message,
            'code': self.code,
        }

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "IncorrectTrustAnchorException":
        """Creates a IncorrectTrustAnchorException from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {
            'message': d['message'],
        }

        return IncorrectTrustAnchorException(**kwargs)

    def __repr__(self) -> str:
        result = "IncorrectTrustAnchorException("
        result += f'message={self.message},'
        if self.message is not None:
            result += f"message={repr(self.message)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, IncorrectTrustAnchorException):
            return False
        attributes: list[str] = ['message','message',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class DisabledException(ApiError[Literal["DisabledException"]]):
    code: Literal["DisabledException"] = "DisabledException"
    message: str
    def __init__(
        self,
        *,
        message: str,
    ):
        """<p>The request was rejected because the specified KMS key is not enabled.</p>
        :param message: A message associated with the specific error.

        """
        super().__init__(message)

    def as_dict(self) -> Dict[str, Any]:
        """Converts the DisabledException to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        return {
            'message': self.message,
            'code': self.code,
        }

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "DisabledException":
        """Creates a DisabledException from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {
            'message': d['message'],
        }

        return DisabledException(**kwargs)

    def __repr__(self) -> str:
        result = "DisabledException("
        result += f'message={self.message},'
        if self.message is not None:
            result += f"message={repr(self.message)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, DisabledException):
            return False
        attributes: list[str] = ['message','message',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class InvalidGrantTokenException(ApiError[Literal["InvalidGrantTokenException"]]):
    code: Literal["InvalidGrantTokenException"] = "InvalidGrantTokenException"
    message: str
    def __init__(
        self,
        *,
        message: str,
    ):
        """<p>The request was rejected because the specified grant token is not valid.</p>
        :param message: A message associated with the specific error.

        """
        super().__init__(message)

    def as_dict(self) -> Dict[str, Any]:
        """Converts the InvalidGrantTokenException to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        return {
            'message': self.message,
            'code': self.code,
        }

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "InvalidGrantTokenException":
        """Creates a InvalidGrantTokenException from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {
            'message': d['message'],
        }

        return InvalidGrantTokenException(**kwargs)

    def __repr__(self) -> str:
        result = "InvalidGrantTokenException("
        result += f'message={self.message},'
        if self.message is not None:
            result += f"message={repr(self.message)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, InvalidGrantTokenException):
            return False
        attributes: list[str] = ['message','message',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class MalformedPolicyDocumentException(ApiError[Literal["MalformedPolicyDocumentException"]]):
    code: Literal["MalformedPolicyDocumentException"] = "MalformedPolicyDocumentException"
    message: str
    def __init__(
        self,
        *,
        message: str,
    ):
        """<p>The request was rejected because the specified policy is not syntactically or
        semantically
              correct.</p>
        :param message: A message associated with the specific error.

        """
        super().__init__(message)

    def as_dict(self) -> Dict[str, Any]:
        """Converts the MalformedPolicyDocumentException to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        return {
            'message': self.message,
            'code': self.code,
        }

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "MalformedPolicyDocumentException":
        """Creates a MalformedPolicyDocumentException from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {
            'message': d['message'],
        }

        return MalformedPolicyDocumentException(**kwargs)

    def __repr__(self) -> str:
        result = "MalformedPolicyDocumentException("
        result += f'message={self.message},'
        if self.message is not None:
            result += f"message={repr(self.message)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, MalformedPolicyDocumentException):
            return False
        attributes: list[str] = ['message','message',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class TagException(ApiError[Literal["TagException"]]):
    code: Literal["TagException"] = "TagException"
    message: str
    def __init__(
        self,
        *,
        message: str,
    ):
        """<p>The request was rejected because one or more tags are not valid.</p>
        :param message: A message associated with the specific error.

        """
        super().__init__(message)

    def as_dict(self) -> Dict[str, Any]:
        """Converts the TagException to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        return {
            'message': self.message,
            'code': self.code,
        }

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "TagException":
        """Creates a TagException from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {
            'message': d['message'],
        }

        return TagException(**kwargs)

    def __repr__(self) -> str:
        result = "TagException("
        result += f'message={self.message},'
        if self.message is not None:
            result += f"message={repr(self.message)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, TagException):
            return False
        attributes: list[str] = ['message','message',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class UnsupportedOperationException(ApiError[Literal["UnsupportedOperationException"]]):
    code: Literal["UnsupportedOperationException"] = "UnsupportedOperationException"
    message: str
    def __init__(
        self,
        *,
        message: str,
    ):
        """<p>The request was rejected because a specified parameter is not supported or a
        specified
              resource is not valid for this operation.</p>
        :param message: A message associated with the specific error.

        """
        super().__init__(message)

    def as_dict(self) -> Dict[str, Any]:
        """Converts the UnsupportedOperationException to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        return {
            'message': self.message,
            'code': self.code,
        }

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "UnsupportedOperationException":
        """Creates a UnsupportedOperationException from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {
            'message': d['message'],
        }

        return UnsupportedOperationException(**kwargs)

    def __repr__(self) -> str:
        result = "UnsupportedOperationException("
        result += f'message={self.message},'
        if self.message is not None:
            result += f"message={repr(self.message)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, UnsupportedOperationException):
            return False
        attributes: list[str] = ['message','message',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class CustomKeyStoreHasCMKsException(ApiError[Literal["CustomKeyStoreHasCMKsException"]]):
    code: Literal["CustomKeyStoreHasCMKsException"] = "CustomKeyStoreHasCMKsException"
    message: str
    def __init__(
        self,
        *,
        message: str,
    ):
        """<p>The request was rejected because the custom key store contains KMS keys.
        After verifying
              that you do not need to use the KMS keys, use the
        <a>ScheduleKeyDeletion</a>
              operation to delete the KMS keys. After they
        are deleted, you can delete the custom key
              store.</p>
        :param message: A message associated with the specific error.

        """
        super().__init__(message)

    def as_dict(self) -> Dict[str, Any]:
        """Converts the CustomKeyStoreHasCMKsException to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        return {
            'message': self.message,
            'code': self.code,
        }

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "CustomKeyStoreHasCMKsException":
        """Creates a CustomKeyStoreHasCMKsException from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {
            'message': d['message'],
        }

        return CustomKeyStoreHasCMKsException(**kwargs)

    def __repr__(self) -> str:
        result = "CustomKeyStoreHasCMKsException("
        result += f'message={self.message},'
        if self.message is not None:
            result += f"message={repr(self.message)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, CustomKeyStoreHasCMKsException):
            return False
        attributes: list[str] = ['message','message',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class IncorrectKeyException(ApiError[Literal["IncorrectKeyException"]]):
    code: Literal["IncorrectKeyException"] = "IncorrectKeyException"
    message: str
    def __init__(
        self,
        *,
        message: str,
    ):
        """<p>The request was rejected because the specified KMS key cannot decrypt the
        data. The
                <code>KeyId</code> in a <a>Decrypt</a> request and the
        <code>SourceKeyId</code>
              in a <a>ReEncrypt</a> request must identify the
        same KMS key that was used to
              encrypt the ciphertext.</p>
        :param message: A message associated with the specific error.

        """
        super().__init__(message)

    def as_dict(self) -> Dict[str, Any]:
        """Converts the IncorrectKeyException to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        return {
            'message': self.message,
            'code': self.code,
        }

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "IncorrectKeyException":
        """Creates a IncorrectKeyException from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {
            'message': d['message'],
        }

        return IncorrectKeyException(**kwargs)

    def __repr__(self) -> str:
        result = "IncorrectKeyException("
        result += f'message={self.message},'
        if self.message is not None:
            result += f"message={repr(self.message)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, IncorrectKeyException):
            return False
        attributes: list[str] = ['message','message',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class InvalidCiphertextException(ApiError[Literal["InvalidCiphertextException"]]):
    code: Literal["InvalidCiphertextException"] = "InvalidCiphertextException"
    message: str
    def __init__(
        self,
        *,
        message: str,
    ):
        """<p>From the <a>Decrypt</a> or <a>ReEncrypt</a> operation, the request
              was
        rejected because the specified ciphertext, or additional authenticated data
        incorporated
              into the ciphertext, such as the encryption context, is
        corrupted, missing, or otherwise
              invalid.</p>
                 <p>From the
        <a>ImportKeyMaterial</a> operation, the request was rejected because
              KMS
        could not decrypt the encrypted (wrapped) key material. </p>
        :param message: A message associated with the specific error.

        """
        super().__init__(message)

    def as_dict(self) -> Dict[str, Any]:
        """Converts the InvalidCiphertextException to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        return {
            'message': self.message,
            'code': self.code,
        }

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "InvalidCiphertextException":
        """Creates a InvalidCiphertextException from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {
            'message': d['message'],
        }

        return InvalidCiphertextException(**kwargs)

    def __repr__(self) -> str:
        result = "InvalidCiphertextException("
        result += f'message={self.message},'
        if self.message is not None:
            result += f"message={repr(self.message)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, InvalidCiphertextException):
            return False
        attributes: list[str] = ['message','message',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class InvalidKeyUsageException(ApiError[Literal["InvalidKeyUsageException"]]):
    code: Literal["InvalidKeyUsageException"] = "InvalidKeyUsageException"
    message: str
    def __init__(
        self,
        *,
        message: str,
    ):
        """<p>The request was rejected for one of the following reasons: </p>

        <ul>
                    <li>
                       <p>The <code>KeyUsage</code> value of the
        KMS key is incompatible with the API
                  operation.</p>
                    </li>

        <li>
                       <p>The encryption algorithm or signing algorithm specified
        for the operation is
                  incompatible with the type of key material in the
        KMS key <code>(KeySpec</code>).</p>
                    </li>
                 </ul>

        <p>For encrypting, decrypting, re-encrypting, and generating data keys, the

        <code>KeyUsage</code> must be <code>ENCRYPT_DECRYPT</code>. For signing and
        verifying, the
                <code>KeyUsage</code> must be <code>SIGN_VERIFY</code>.
        To find the <code>KeyUsage</code> of
              a KMS key, use the <a>DescribeKey</a>
        operation.</p>
                 <p>To find the encryption or signing algorithms
        supported for a particular KMS key, use the
                <a>DescribeKey</a>
        operation.</p>
        :param message: A message associated with the specific error.

        """
        super().__init__(message)

    def as_dict(self) -> Dict[str, Any]:
        """Converts the InvalidKeyUsageException to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        return {
            'message': self.message,
            'code': self.code,
        }

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "InvalidKeyUsageException":
        """Creates a InvalidKeyUsageException from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {
            'message': d['message'],
        }

        return InvalidKeyUsageException(**kwargs)

    def __repr__(self) -> str:
        result = "InvalidKeyUsageException("
        result += f'message={self.message},'
        if self.message is not None:
            result += f"message={repr(self.message)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, InvalidKeyUsageException):
            return False
        attributes: list[str] = ['message','message',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class KeyUnavailableException(ApiError[Literal["KeyUnavailableException"]]):
    code: Literal["KeyUnavailableException"] = "KeyUnavailableException"
    message: str
    def __init__(
        self,
        *,
        message: str,
    ):
        """<p>The request was rejected because the specified KMS key was not available. You
        can retry
              the request.</p>
        :param message: A message associated with the specific error.

        """
        super().__init__(message)

    def as_dict(self) -> Dict[str, Any]:
        """Converts the KeyUnavailableException to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        return {
            'message': self.message,
            'code': self.code,
        }

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "KeyUnavailableException":
        """Creates a KeyUnavailableException from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {
            'message': d['message'],
        }

        return KeyUnavailableException(**kwargs)

    def __repr__(self) -> str:
        result = "KeyUnavailableException("
        result += f'message={self.message},'
        if self.message is not None:
            result += f"message={repr(self.message)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, KeyUnavailableException):
            return False
        attributes: list[str] = ['message','message',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class InvalidMarkerException(ApiError[Literal["InvalidMarkerException"]]):
    code: Literal["InvalidMarkerException"] = "InvalidMarkerException"
    message: str
    def __init__(
        self,
        *,
        message: str,
    ):
        """<p>The request was rejected because the marker that specifies where pagination
        should next
              begin is not valid.</p>
        :param message: A message associated with the specific error.

        """
        super().__init__(message)

    def as_dict(self) -> Dict[str, Any]:
        """Converts the InvalidMarkerException to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        return {
            'message': self.message,
            'code': self.code,
        }

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "InvalidMarkerException":
        """Creates a InvalidMarkerException from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {
            'message': d['message'],
        }

        return InvalidMarkerException(**kwargs)

    def __repr__(self) -> str:
        result = "InvalidMarkerException("
        result += f'message={self.message},'
        if self.message is not None:
            result += f"message={repr(self.message)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, InvalidMarkerException):
            return False
        attributes: list[str] = ['message','message',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class ExpiredImportTokenException(ApiError[Literal["ExpiredImportTokenException"]]):
    code: Literal["ExpiredImportTokenException"] = "ExpiredImportTokenException"
    message: str
    def __init__(
        self,
        *,
        message: str,
    ):
        """<p>The request was rejected because the specified import token is expired. Use
        <a>GetParametersForImport</a> to get a new import token and public key, use the
        new
              public key to encrypt the key material, and then try the request
        again.</p>
        :param message: A message associated with the specific error.

        """
        super().__init__(message)

    def as_dict(self) -> Dict[str, Any]:
        """Converts the ExpiredImportTokenException to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        return {
            'message': self.message,
            'code': self.code,
        }

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "ExpiredImportTokenException":
        """Creates a ExpiredImportTokenException from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {
            'message': d['message'],
        }

        return ExpiredImportTokenException(**kwargs)

    def __repr__(self) -> str:
        result = "ExpiredImportTokenException("
        result += f'message={self.message},'
        if self.message is not None:
            result += f"message={repr(self.message)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, ExpiredImportTokenException):
            return False
        attributes: list[str] = ['message','message',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class IncorrectKeyMaterialException(ApiError[Literal["IncorrectKeyMaterialException"]]):
    code: Literal["IncorrectKeyMaterialException"] = "IncorrectKeyMaterialException"
    message: str
    def __init__(
        self,
        *,
        message: str,
    ):
        """<p>The request was rejected because the key material in the request is, expired,
        invalid, or
              is not the same key material that was previously imported into
        this KMS key.</p>
        :param message: A message associated with the specific error.

        """
        super().__init__(message)

    def as_dict(self) -> Dict[str, Any]:
        """Converts the IncorrectKeyMaterialException to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        return {
            'message': self.message,
            'code': self.code,
        }

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "IncorrectKeyMaterialException":
        """Creates a IncorrectKeyMaterialException from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {
            'message': d['message'],
        }

        return IncorrectKeyMaterialException(**kwargs)

    def __repr__(self) -> str:
        result = "IncorrectKeyMaterialException("
        result += f'message={self.message},'
        if self.message is not None:
            result += f"message={repr(self.message)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, IncorrectKeyMaterialException):
            return False
        attributes: list[str] = ['message','message',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class InvalidImportTokenException(ApiError[Literal["InvalidImportTokenException"]]):
    code: Literal["InvalidImportTokenException"] = "InvalidImportTokenException"
    message: str
    def __init__(
        self,
        *,
        message: str,
    ):
        """<p>The request was rejected because the provided import token is invalid or is
        associated
              with a different KMS key.</p>
        :param message: A message associated with the specific error.

        """
        super().__init__(message)

    def as_dict(self) -> Dict[str, Any]:
        """Converts the InvalidImportTokenException to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        return {
            'message': self.message,
            'code': self.code,
        }

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "InvalidImportTokenException":
        """Creates a InvalidImportTokenException from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {
            'message': d['message'],
        }

        return InvalidImportTokenException(**kwargs)

    def __repr__(self) -> str:
        result = "InvalidImportTokenException("
        result += f'message={self.message},'
        if self.message is not None:
            result += f"message={repr(self.message)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, InvalidImportTokenException):
            return False
        attributes: list[str] = ['message','message',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class InvalidGrantIdException(ApiError[Literal["InvalidGrantIdException"]]):
    code: Literal["InvalidGrantIdException"] = "InvalidGrantIdException"
    message: str
    def __init__(
        self,
        *,
        message: str,
    ):
        """<p>The request was rejected because the specified <code>GrantId</code> is not
        valid.</p>
        :param message: A message associated with the specific error.

        """
        super().__init__(message)

    def as_dict(self) -> Dict[str, Any]:
        """Converts the InvalidGrantIdException to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        return {
            'message': self.message,
            'code': self.code,
        }

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "InvalidGrantIdException":
        """Creates a InvalidGrantIdException from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {
            'message': d['message'],
        }

        return InvalidGrantIdException(**kwargs)

    def __repr__(self) -> str:
        result = "InvalidGrantIdException("
        result += f'message={self.message},'
        if self.message is not None:
            result += f"message={repr(self.message)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, InvalidGrantIdException):
            return False
        attributes: list[str] = ['message','message',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class KMSInvalidSignatureException(ApiError[Literal["KMSInvalidSignatureException"]]):
    code: Literal["KMSInvalidSignatureException"] = "KMSInvalidSignatureException"
    message: str
    def __init__(
        self,
        *,
        message: str,
    ):
        """<p>The request was rejected because the signature verification failed. Signature
        verification
              fails when it cannot confirm that signature was produced by
        signing the specified message with
              the specified KMS key and signing
        algorithm.</p>
        :param message: A message associated with the specific error.

        """
        super().__init__(message)

    def as_dict(self) -> Dict[str, Any]:
        """Converts the KMSInvalidSignatureException to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        return {
            'message': self.message,
            'code': self.code,
        }

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "KMSInvalidSignatureException":
        """Creates a KMSInvalidSignatureException from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {
            'message': d['message'],
        }

        return KMSInvalidSignatureException(**kwargs)

    def __repr__(self) -> str:
        result = "KMSInvalidSignatureException("
        result += f'message={self.message},'
        if self.message is not None:
            result += f"message={repr(self.message)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, KMSInvalidSignatureException):
            return False
        attributes: list[str] = ['message','message',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )
