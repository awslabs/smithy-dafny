# Code generated by smithy-python-codegen DO NOT EDIT.

from software_amazon_cryptography_services_kms_internaldafny_types import (
    CancelKeyDeletionResponse_CancelKeyDeletionResponse as DafnyCancelKeyDeletionResponse,
    ConnectCustomKeyStoreResponse_ConnectCustomKeyStoreResponse as DafnyConnectCustomKeyStoreResponse,
    CreateCustomKeyStoreResponse_CreateCustomKeyStoreResponse as DafnyCreateCustomKeyStoreResponse,
    CreateGrantResponse_CreateGrantResponse as DafnyCreateGrantResponse,
    CreateKeyResponse_CreateKeyResponse as DafnyCreateKeyResponse,
    DecryptResponse_DecryptResponse as DafnyDecryptResponse,
    DeleteCustomKeyStoreResponse_DeleteCustomKeyStoreResponse as DafnyDeleteCustomKeyStoreResponse,
    DescribeCustomKeyStoresResponse_DescribeCustomKeyStoresResponse as DafnyDescribeCustomKeyStoresResponse,
    DescribeKeyResponse_DescribeKeyResponse as DafnyDescribeKeyResponse,
    DisconnectCustomKeyStoreResponse_DisconnectCustomKeyStoreResponse as DafnyDisconnectCustomKeyStoreResponse,
    EncryptResponse_EncryptResponse as DafnyEncryptResponse,
    Error,
    Error_AlreadyExistsException,
    Error_CloudHsmClusterInUseException,
    Error_CloudHsmClusterInvalidConfigurationException,
    Error_CloudHsmClusterNotActiveException,
    Error_CloudHsmClusterNotFoundException,
    Error_CloudHsmClusterNotRelatedException,
    Error_CustomKeyStoreHasCMKsException,
    Error_CustomKeyStoreInvalidStateException,
    Error_CustomKeyStoreNameInUseException,
    Error_CustomKeyStoreNotFoundException,
    Error_DependencyTimeoutException,
    Error_DisabledException,
    Error_ExpiredImportTokenException,
    Error_IncorrectKeyException,
    Error_IncorrectKeyMaterialException,
    Error_IncorrectTrustAnchorException,
    Error_InvalidAliasNameException,
    Error_InvalidArnException,
    Error_InvalidCiphertextException,
    Error_InvalidGrantIdException,
    Error_InvalidGrantTokenException,
    Error_InvalidImportTokenException,
    Error_InvalidKeyUsageException,
    Error_InvalidMarkerException,
    Error_KMSInternalException,
    Error_KMSInvalidSignatureException,
    Error_KMSInvalidStateException,
    Error_KeyUnavailableException,
    Error_LimitExceededException,
    Error_MalformedPolicyDocumentException,
    Error_NotFoundException,
    Error_TagException,
    Error_UnsupportedOperationException,
    GenerateDataKeyPairResponse_GenerateDataKeyPairResponse as DafnyGenerateDataKeyPairResponse,
    GenerateDataKeyPairWithoutPlaintextResponse_GenerateDataKeyPairWithoutPlaintextResponse as DafnyGenerateDataKeyPairWithoutPlaintextResponse,
    GenerateDataKeyResponse_GenerateDataKeyResponse as DafnyGenerateDataKeyResponse,
    GenerateDataKeyWithoutPlaintextResponse_GenerateDataKeyWithoutPlaintextResponse as DafnyGenerateDataKeyWithoutPlaintextResponse,
    GenerateRandomResponse_GenerateRandomResponse as DafnyGenerateRandomResponse,
    GetKeyPolicyResponse_GetKeyPolicyResponse as DafnyGetKeyPolicyResponse,
    GetKeyRotationStatusResponse_GetKeyRotationStatusResponse as DafnyGetKeyRotationStatusResponse,
    GetParametersForImportResponse_GetParametersForImportResponse as DafnyGetParametersForImportResponse,
    GetPublicKeyResponse_GetPublicKeyResponse as DafnyGetPublicKeyResponse,
    ImportKeyMaterialResponse_ImportKeyMaterialResponse as DafnyImportKeyMaterialResponse,
    ListAliasesResponse_ListAliasesResponse as DafnyListAliasesResponse,
    ListGrantsResponse_ListGrantsResponse as DafnyListGrantsResponse,
    ListKeyPoliciesResponse_ListKeyPoliciesResponse as DafnyListKeyPoliciesResponse,
    ListResourceTagsResponse_ListResourceTagsResponse as DafnyListResourceTagsResponse,
    ReEncryptResponse_ReEncryptResponse as DafnyReEncryptResponse,
    ReplicateKeyResponse_ReplicateKeyResponse as DafnyReplicateKeyResponse,
    ScheduleKeyDeletionResponse_ScheduleKeyDeletionResponse as DafnyScheduleKeyDeletionResponse,
    SignResponse_SignResponse as DafnySignResponse,
    UpdateCustomKeyStoreResponse_UpdateCustomKeyStoreResponse as DafnyUpdateCustomKeyStoreResponse,
    VerifyResponse_VerifyResponse as DafnyVerifyResponse,
)
import module_
from typing import Any

from .dafny_protocol import DafnyResponse
from .errors import (
    AlreadyExistsException,
    CloudHsmClusterInUseException,
    CloudHsmClusterInvalidConfigurationException,
    CloudHsmClusterNotActiveException,
    CloudHsmClusterNotFoundException,
    CloudHsmClusterNotRelatedException,
    CollectionOfErrors,
    CustomKeyStoreHasCMKsException,
    CustomKeyStoreInvalidStateException,
    CustomKeyStoreNameInUseException,
    CustomKeyStoreNotFoundException,
    DependencyTimeoutException,
    DisabledException,
    ExpiredImportTokenException,
    IncorrectKeyException,
    IncorrectKeyMaterialException,
    IncorrectTrustAnchorException,
    InvalidAliasNameException,
    InvalidArnException,
    InvalidCiphertextException,
    InvalidGrantIdException,
    InvalidGrantTokenException,
    InvalidImportTokenException,
    InvalidKeyUsageException,
    InvalidMarkerException,
    KMSInternalException,
    KMSInvalidSignatureException,
    KMSInvalidStateException,
    KeyUnavailableException,
    LimitExceededException,
    MalformedPolicyDocumentException,
    NotFoundException,
    OpaqueError,
    ServiceError,
    TagException,
    UnsupportedOperationException,
)
from .models import (
    AliasListEntry,
    CancelKeyDeletionResponse,
    ConnectCustomKeyStoreResponse,
    CreateCustomKeyStoreResponse,
    CreateGrantResponse,
    CreateKeyResponse,
    CustomKeyStoresListEntry,
    DecryptResponse,
    DeleteCustomKeyStoreResponse,
    DescribeCustomKeyStoresResponse,
    DescribeKeyResponse,
    DisconnectCustomKeyStoreResponse,
    EncryptResponse,
    GenerateDataKeyPairResponse,
    GenerateDataKeyPairWithoutPlaintextResponse,
    GenerateDataKeyResponse,
    GenerateDataKeyWithoutPlaintextResponse,
    GenerateRandomResponse,
    GetKeyPolicyResponse,
    GetKeyRotationStatusResponse,
    GetParametersForImportResponse,
    GetPublicKeyResponse,
    GrantConstraints,
    GrantListEntry,
    ImportKeyMaterialResponse,
    KeyMetadata,
    ListAliasesResponse,
    ListGrantsResponse,
    ListKeyPoliciesResponse,
    ListResourceTagsResponse,
    MultiRegionConfiguration,
    MultiRegionKey,
    ReEncryptResponse,
    ReplicateKeyResponse,
    ScheduleKeyDeletionResponse,
    SignResponse,
    Tag,
    UpdateCustomKeyStoreResponse,
    Unit,
    VerifyResponse,
)

from .config import Config


async def _deserialize_describe_custom_key_stores(input: DafnyResponse, config: Config) -> DescribeCustomKeyStoresResponse:

  if input.IsFailure():
    return await _deserialize_error(input.error)
  return DescribeCustomKeyStoresResponse(custom_key_stores=[CustomKeyStoresListEntry(custom_key_store_id=list_element.CustomKeyStoreId.UnwrapOr(None),
  custom_key_store_name=list_element.CustomKeyStoreName.UnwrapOr(None),
  cloud_hsm_cluster_id=list_element.CloudHsmClusterId.UnwrapOr(None),
  trust_anchor_certificate=list_element.TrustAnchorCertificate.UnwrapOr(None),
  connection_state=list_element.ConnectionState.UnwrapOr(None),
  connection_error_code=list_element.ConnectionErrorCode.UnwrapOr(None),
  creation_date=list_element.CreationDate.UnwrapOr(None),
  ) for list_element in input.value.CustomKeyStores.UnwrapOr(None)],
  next_marker=input.value.NextMarker.UnwrapOr(None),
  truncated=input.value.Truncated.UnwrapOr(None),
  )

async def _deserialize_get_public_key(input: DafnyResponse, config: Config) -> GetPublicKeyResponse:

  if input.IsFailure():
    return await _deserialize_error(input.error)
  return GetPublicKeyResponse(key_id=input.value.KeyId.UnwrapOr(None),
  public_key=input.value.PublicKey.UnwrapOr(None),
  customer_master_key_spec=input.value.CustomerMasterKeySpec.UnwrapOr(None),
  key_spec=input.value.KeySpec.UnwrapOr(None),
  key_usage=input.value.KeyUsage.UnwrapOr(None),
  encryption_algorithms=[list_element for list_element in input.value.EncryptionAlgorithms.UnwrapOr(None)],
  signing_algorithms=[list_element for list_element in input.value.SigningAlgorithms.UnwrapOr(None)],
  )

async def _deserialize_update_key_description(input: DafnyResponse, config: Config) -> Unit:

  return None

async def _deserialize_generate_data_key(input: DafnyResponse, config: Config) -> GenerateDataKeyResponse:

  if input.IsFailure():
    return await _deserialize_error(input.error)
  return GenerateDataKeyResponse(ciphertext_blob=input.value.CiphertextBlob.UnwrapOr(None),
  plaintext=input.value.Plaintext.UnwrapOr(None),
  key_id=input.value.KeyId.UnwrapOr(None),
  )

async def _deserialize_generate_random(input: DafnyResponse, config: Config) -> GenerateRandomResponse:

  if input.IsFailure():
    return await _deserialize_error(input.error)
  return GenerateRandomResponse(plaintext=input.value.Plaintext.UnwrapOr(None),
  )

async def _deserialize_disconnect_custom_key_store(input: DafnyResponse, config: Config) -> DisconnectCustomKeyStoreResponse:

  if input.IsFailure():
    return await _deserialize_error(input.error)
  return DisconnectCustomKeyStoreResponse()

async def _deserialize_replicate_key(input: DafnyResponse, config: Config) -> ReplicateKeyResponse:

  if input.IsFailure():
    return await _deserialize_error(input.error)
  return ReplicateKeyResponse(replica_key_metadata=KeyMetadata(aws_account_id=input.value.ReplicaKeyMetadata.UnwrapOr(None).AWSAccountId.UnwrapOr(None),
  key_id=input.value.ReplicaKeyMetadata.UnwrapOr(None).KeyId,
  arn=input.value.ReplicaKeyMetadata.UnwrapOr(None).Arn.UnwrapOr(None),
  creation_date=input.value.ReplicaKeyMetadata.UnwrapOr(None).CreationDate.UnwrapOr(None),
  enabled=input.value.ReplicaKeyMetadata.UnwrapOr(None).Enabled.UnwrapOr(None),
  description=input.value.ReplicaKeyMetadata.UnwrapOr(None).Description.UnwrapOr(None),
  key_usage=input.value.ReplicaKeyMetadata.UnwrapOr(None).KeyUsage.UnwrapOr(None),
  key_state=input.value.ReplicaKeyMetadata.UnwrapOr(None).KeyState.UnwrapOr(None),
  deletion_date=input.value.ReplicaKeyMetadata.UnwrapOr(None).DeletionDate.UnwrapOr(None),
  valid_to=input.value.ReplicaKeyMetadata.UnwrapOr(None).ValidTo.UnwrapOr(None),
  origin=input.value.ReplicaKeyMetadata.UnwrapOr(None).Origin.UnwrapOr(None),
  custom_key_store_id=input.value.ReplicaKeyMetadata.UnwrapOr(None).CustomKeyStoreId.UnwrapOr(None),
  cloud_hsm_cluster_id=input.value.ReplicaKeyMetadata.UnwrapOr(None).CloudHsmClusterId.UnwrapOr(None),
  expiration_model=input.value.ReplicaKeyMetadata.UnwrapOr(None).ExpirationModel.UnwrapOr(None),
  key_manager=input.value.ReplicaKeyMetadata.UnwrapOr(None).KeyManager.UnwrapOr(None),
  customer_master_key_spec=input.value.ReplicaKeyMetadata.UnwrapOr(None).CustomerMasterKeySpec.UnwrapOr(None),
  key_spec=input.value.ReplicaKeyMetadata.UnwrapOr(None).KeySpec.UnwrapOr(None),
  encryption_algorithms=[list_element for list_element in input.value.ReplicaKeyMetadata.UnwrapOr(None).EncryptionAlgorithms.UnwrapOr(None)],
  signing_algorithms=[list_element for list_element in input.value.ReplicaKeyMetadata.UnwrapOr(None).SigningAlgorithms.UnwrapOr(None)],
  multi_region=input.value.ReplicaKeyMetadata.UnwrapOr(None).MultiRegion.UnwrapOr(None),
  multi_region_configuration=MultiRegionConfiguration(multi_region_key_type=input.value.ReplicaKeyMetadata.UnwrapOr(None).MultiRegionConfiguration.UnwrapOr(None).MultiRegionKeyType.UnwrapOr(None),
  primary_key=MultiRegionKey(arn=input.value.ReplicaKeyMetadata.UnwrapOr(None).MultiRegionConfiguration.UnwrapOr(None).PrimaryKey.UnwrapOr(None).Arn.UnwrapOr(None),
  region=input.value.ReplicaKeyMetadata.UnwrapOr(None).MultiRegionConfiguration.UnwrapOr(None).PrimaryKey.UnwrapOr(None).Region.UnwrapOr(None),
  ),
  replica_keys=[MultiRegionKey(arn=list_element.Arn.UnwrapOr(None),
  region=list_element.Region.UnwrapOr(None),
  ) for list_element in input.value.ReplicaKeyMetadata.UnwrapOr(None).MultiRegionConfiguration.UnwrapOr(None).ReplicaKeys.UnwrapOr(None)],
  ),
  pending_deletion_window_in_days=input.value.ReplicaKeyMetadata.UnwrapOr(None).PendingDeletionWindowInDays.UnwrapOr(None),
  ),
  replica_policy=input.value.ReplicaPolicy.UnwrapOr(None),
  replica_tags=[Tag(tag_key=list_element.TagKey,
  tag_value=list_element.TagValue,
  ) for list_element in input.value.ReplicaTags.UnwrapOr(None)],
  )

async def _deserialize_generate_data_key_pair(input: DafnyResponse, config: Config) -> GenerateDataKeyPairResponse:

  if input.IsFailure():
    return await _deserialize_error(input.error)
  return GenerateDataKeyPairResponse(private_key_ciphertext_blob=input.value.PrivateKeyCiphertextBlob.UnwrapOr(None),
  private_key_plaintext=input.value.PrivateKeyPlaintext.UnwrapOr(None),
  public_key=input.value.PublicKey.UnwrapOr(None),
  key_id=input.value.KeyId.UnwrapOr(None),
  key_pair_spec=input.value.KeyPairSpec.UnwrapOr(None),
  )

async def _deserialize_enable_key(input: DafnyResponse, config: Config) -> Unit:

  return None

async def _deserialize_describe_key(input: DafnyResponse, config: Config) -> DescribeKeyResponse:

  if input.IsFailure():
    return await _deserialize_error(input.error)
  return DescribeKeyResponse(key_metadata=KeyMetadata(aws_account_id=input.value.KeyMetadata.UnwrapOr(None).AWSAccountId.UnwrapOr(None),
  key_id=input.value.KeyMetadata.UnwrapOr(None).KeyId,
  arn=input.value.KeyMetadata.UnwrapOr(None).Arn.UnwrapOr(None),
  creation_date=input.value.KeyMetadata.UnwrapOr(None).CreationDate.UnwrapOr(None),
  enabled=input.value.KeyMetadata.UnwrapOr(None).Enabled.UnwrapOr(None),
  description=input.value.KeyMetadata.UnwrapOr(None).Description.UnwrapOr(None),
  key_usage=input.value.KeyMetadata.UnwrapOr(None).KeyUsage.UnwrapOr(None),
  key_state=input.value.KeyMetadata.UnwrapOr(None).KeyState.UnwrapOr(None),
  deletion_date=input.value.KeyMetadata.UnwrapOr(None).DeletionDate.UnwrapOr(None),
  valid_to=input.value.KeyMetadata.UnwrapOr(None).ValidTo.UnwrapOr(None),
  origin=input.value.KeyMetadata.UnwrapOr(None).Origin.UnwrapOr(None),
  custom_key_store_id=input.value.KeyMetadata.UnwrapOr(None).CustomKeyStoreId.UnwrapOr(None),
  cloud_hsm_cluster_id=input.value.KeyMetadata.UnwrapOr(None).CloudHsmClusterId.UnwrapOr(None),
  expiration_model=input.value.KeyMetadata.UnwrapOr(None).ExpirationModel.UnwrapOr(None),
  key_manager=input.value.KeyMetadata.UnwrapOr(None).KeyManager.UnwrapOr(None),
  customer_master_key_spec=input.value.KeyMetadata.UnwrapOr(None).CustomerMasterKeySpec.UnwrapOr(None),
  key_spec=input.value.KeyMetadata.UnwrapOr(None).KeySpec.UnwrapOr(None),
  encryption_algorithms=[list_element for list_element in input.value.KeyMetadata.UnwrapOr(None).EncryptionAlgorithms.UnwrapOr(None)],
  signing_algorithms=[list_element for list_element in input.value.KeyMetadata.UnwrapOr(None).SigningAlgorithms.UnwrapOr(None)],
  multi_region=input.value.KeyMetadata.UnwrapOr(None).MultiRegion.UnwrapOr(None),
  multi_region_configuration=MultiRegionConfiguration(multi_region_key_type=input.value.KeyMetadata.UnwrapOr(None).MultiRegionConfiguration.UnwrapOr(None).MultiRegionKeyType.UnwrapOr(None),
  primary_key=MultiRegionKey(arn=input.value.KeyMetadata.UnwrapOr(None).MultiRegionConfiguration.UnwrapOr(None).PrimaryKey.UnwrapOr(None).Arn.UnwrapOr(None),
  region=input.value.KeyMetadata.UnwrapOr(None).MultiRegionConfiguration.UnwrapOr(None).PrimaryKey.UnwrapOr(None).Region.UnwrapOr(None),
  ),
  replica_keys=[MultiRegionKey(arn=list_element.Arn.UnwrapOr(None),
  region=list_element.Region.UnwrapOr(None),
  ) for list_element in input.value.KeyMetadata.UnwrapOr(None).MultiRegionConfiguration.UnwrapOr(None).ReplicaKeys.UnwrapOr(None)],
  ),
  pending_deletion_window_in_days=input.value.KeyMetadata.UnwrapOr(None).PendingDeletionWindowInDays.UnwrapOr(None),
  ),
  )

async def _deserialize_put_key_policy(input: DafnyResponse, config: Config) -> Unit:

  return None

async def _deserialize_list_grants(input: DafnyResponse, config: Config) -> ListGrantsResponse:

  if input.IsFailure():
    return await _deserialize_error(input.error)
  return ListGrantsResponse(grants=[GrantListEntry(key_id=list_element.KeyId.UnwrapOr(None),
  grant_id=list_element.GrantId.UnwrapOr(None),
  name=list_element.Name.UnwrapOr(None),
  creation_date=list_element.CreationDate.UnwrapOr(None),
  grantee_principal=list_element.GranteePrincipal.UnwrapOr(None),
  retiring_principal=list_element.RetiringPrincipal.UnwrapOr(None),
  issuing_account=list_element.IssuingAccount.UnwrapOr(None),
  operations=[list_element for list_element in list_element.Operations.UnwrapOr(None)],
  constraints=GrantConstraints(encryption_context_subset={key: value for (key, value) in list_element.Constraints.UnwrapOr(None).EncryptionContextSubset.UnwrapOr(None).items },
  encryption_context_equals={key: value for (key, value) in list_element.Constraints.UnwrapOr(None).EncryptionContextEquals.UnwrapOr(None).items },
  ),
  ) for list_element in input.value.Grants.UnwrapOr(None)],
  next_marker=input.value.NextMarker.UnwrapOr(None),
  truncated=input.value.Truncated.UnwrapOr(None),
  )

async def _deserialize_list_key_policies(input: DafnyResponse, config: Config) -> ListKeyPoliciesResponse:

  if input.IsFailure():
    return await _deserialize_error(input.error)
  return ListKeyPoliciesResponse(policy_names=[list_element for list_element in input.value.PolicyNames.UnwrapOr(None)],
  next_marker=input.value.NextMarker.UnwrapOr(None),
  truncated=input.value.Truncated.UnwrapOr(None),
  )

async def _deserialize_create_grant(input: DafnyResponse, config: Config) -> CreateGrantResponse:

  if input.IsFailure():
    return await _deserialize_error(input.error)
  return CreateGrantResponse(grant_token=input.value.GrantToken.UnwrapOr(None),
  grant_id=input.value.GrantId.UnwrapOr(None),
  )

async def _deserialize_get_key_rotation_status(input: DafnyResponse, config: Config) -> GetKeyRotationStatusResponse:

  if input.IsFailure():
    return await _deserialize_error(input.error)
  return GetKeyRotationStatusResponse(key_rotation_enabled=input.value.KeyRotationEnabled.UnwrapOr(None),
  )

async def _deserialize_update_alias(input: DafnyResponse, config: Config) -> Unit:

  return None

async def _deserialize_generate_data_key_without_plaintext(input: DafnyResponse, config: Config) -> GenerateDataKeyWithoutPlaintextResponse:

  if input.IsFailure():
    return await _deserialize_error(input.error)
  return GenerateDataKeyWithoutPlaintextResponse(ciphertext_blob=input.value.CiphertextBlob.UnwrapOr(None),
  key_id=input.value.KeyId.UnwrapOr(None),
  )

async def _deserialize_revoke_grant(input: DafnyResponse, config: Config) -> Unit:

  return None

async def _deserialize_get_parameters_for_import(input: DafnyResponse, config: Config) -> GetParametersForImportResponse:

  if input.IsFailure():
    return await _deserialize_error(input.error)
  return GetParametersForImportResponse(key_id=input.value.KeyId.UnwrapOr(None),
  import_token=input.value.ImportToken.UnwrapOr(None),
  public_key=input.value.PublicKey.UnwrapOr(None),
  parameters_valid_to=input.value.ParametersValidTo.UnwrapOr(None),
  )

async def _deserialize_create_key(input: DafnyResponse, config: Config) -> CreateKeyResponse:

  if input.IsFailure():
    return await _deserialize_error(input.error)
  return CreateKeyResponse(key_metadata=KeyMetadata(aws_account_id=input.value.KeyMetadata.UnwrapOr(None).AWSAccountId.UnwrapOr(None),
  key_id=input.value.KeyMetadata.UnwrapOr(None).KeyId,
  arn=input.value.KeyMetadata.UnwrapOr(None).Arn.UnwrapOr(None),
  creation_date=input.value.KeyMetadata.UnwrapOr(None).CreationDate.UnwrapOr(None),
  enabled=input.value.KeyMetadata.UnwrapOr(None).Enabled.UnwrapOr(None),
  description=input.value.KeyMetadata.UnwrapOr(None).Description.UnwrapOr(None),
  key_usage=input.value.KeyMetadata.UnwrapOr(None).KeyUsage.UnwrapOr(None),
  key_state=input.value.KeyMetadata.UnwrapOr(None).KeyState.UnwrapOr(None),
  deletion_date=input.value.KeyMetadata.UnwrapOr(None).DeletionDate.UnwrapOr(None),
  valid_to=input.value.KeyMetadata.UnwrapOr(None).ValidTo.UnwrapOr(None),
  origin=input.value.KeyMetadata.UnwrapOr(None).Origin.UnwrapOr(None),
  custom_key_store_id=input.value.KeyMetadata.UnwrapOr(None).CustomKeyStoreId.UnwrapOr(None),
  cloud_hsm_cluster_id=input.value.KeyMetadata.UnwrapOr(None).CloudHsmClusterId.UnwrapOr(None),
  expiration_model=input.value.KeyMetadata.UnwrapOr(None).ExpirationModel.UnwrapOr(None),
  key_manager=input.value.KeyMetadata.UnwrapOr(None).KeyManager.UnwrapOr(None),
  customer_master_key_spec=input.value.KeyMetadata.UnwrapOr(None).CustomerMasterKeySpec.UnwrapOr(None),
  key_spec=input.value.KeyMetadata.UnwrapOr(None).KeySpec.UnwrapOr(None),
  encryption_algorithms=[list_element for list_element in input.value.KeyMetadata.UnwrapOr(None).EncryptionAlgorithms.UnwrapOr(None)],
  signing_algorithms=[list_element for list_element in input.value.KeyMetadata.UnwrapOr(None).SigningAlgorithms.UnwrapOr(None)],
  multi_region=input.value.KeyMetadata.UnwrapOr(None).MultiRegion.UnwrapOr(None),
  multi_region_configuration=MultiRegionConfiguration(multi_region_key_type=input.value.KeyMetadata.UnwrapOr(None).MultiRegionConfiguration.UnwrapOr(None).MultiRegionKeyType.UnwrapOr(None),
  primary_key=MultiRegionKey(arn=input.value.KeyMetadata.UnwrapOr(None).MultiRegionConfiguration.UnwrapOr(None).PrimaryKey.UnwrapOr(None).Arn.UnwrapOr(None),
  region=input.value.KeyMetadata.UnwrapOr(None).MultiRegionConfiguration.UnwrapOr(None).PrimaryKey.UnwrapOr(None).Region.UnwrapOr(None),
  ),
  replica_keys=[MultiRegionKey(arn=list_element.Arn.UnwrapOr(None),
  region=list_element.Region.UnwrapOr(None),
  ) for list_element in input.value.KeyMetadata.UnwrapOr(None).MultiRegionConfiguration.UnwrapOr(None).ReplicaKeys.UnwrapOr(None)],
  ),
  pending_deletion_window_in_days=input.value.KeyMetadata.UnwrapOr(None).PendingDeletionWindowInDays.UnwrapOr(None),
  ),
  )

async def _deserialize_tag_resource(input: DafnyResponse, config: Config) -> Unit:

  return None

async def _deserialize_retire_grant(input: DafnyResponse, config: Config) -> Unit:

  return None

async def _deserialize_create_alias(input: DafnyResponse, config: Config) -> Unit:

  return None

async def _deserialize_disable_key(input: DafnyResponse, config: Config) -> Unit:

  return None

async def _deserialize_list_aliases(input: DafnyResponse, config: Config) -> ListAliasesResponse:

  if input.IsFailure():
    return await _deserialize_error(input.error)
  return ListAliasesResponse(aliases=[AliasListEntry(alias_name=list_element.AliasName.UnwrapOr(None),
  alias_arn=list_element.AliasArn.UnwrapOr(None),
  target_key_id=list_element.TargetKeyId.UnwrapOr(None),
  creation_date=list_element.CreationDate.UnwrapOr(None),
  last_updated_date=list_element.LastUpdatedDate.UnwrapOr(None),
  ) for list_element in input.value.Aliases.UnwrapOr(None)],
  next_marker=input.value.NextMarker.UnwrapOr(None),
  truncated=input.value.Truncated.UnwrapOr(None),
  )

async def _deserialize_enable_key_rotation(input: DafnyResponse, config: Config) -> Unit:

  return None

async def _deserialize_cancel_key_deletion(input: DafnyResponse, config: Config) -> CancelKeyDeletionResponse:

  if input.IsFailure():
    return await _deserialize_error(input.error)
  return CancelKeyDeletionResponse(key_id=input.value.KeyId.UnwrapOr(None),
  )

async def _deserialize_delete_alias(input: DafnyResponse, config: Config) -> Unit:

  return None

async def _deserialize_update_custom_key_store(input: DafnyResponse, config: Config) -> UpdateCustomKeyStoreResponse:

  if input.IsFailure():
    return await _deserialize_error(input.error)
  return UpdateCustomKeyStoreResponse()

async def _deserialize_create_custom_key_store(input: DafnyResponse, config: Config) -> CreateCustomKeyStoreResponse:

  if input.IsFailure():
    return await _deserialize_error(input.error)
  return CreateCustomKeyStoreResponse(custom_key_store_id=input.value.CustomKeyStoreId.UnwrapOr(None),
  )

async def _deserialize_re_encrypt(input: DafnyResponse, config: Config) -> ReEncryptResponse:

  if input.IsFailure():
    return await _deserialize_error(input.error)
  return ReEncryptResponse(ciphertext_blob=input.value.CiphertextBlob.UnwrapOr(None),
  source_key_id=input.value.SourceKeyId.UnwrapOr(None),
  key_id=input.value.KeyId.UnwrapOr(None),
  source_encryption_algorithm=input.value.SourceEncryptionAlgorithm.UnwrapOr(None),
  destination_encryption_algorithm=input.value.DestinationEncryptionAlgorithm.UnwrapOr(None),
  )

async def _deserialize_list_resource_tags(input: DafnyResponse, config: Config) -> ListResourceTagsResponse:

  if input.IsFailure():
    return await _deserialize_error(input.error)
  return ListResourceTagsResponse(tags=[Tag(tag_key=list_element.TagKey,
  tag_value=list_element.TagValue,
  ) for list_element in input.value.Tags.UnwrapOr(None)],
  next_marker=input.value.NextMarker.UnwrapOr(None),
  truncated=input.value.Truncated.UnwrapOr(None),
  )

async def _deserialize_update_primary_region(input: DafnyResponse, config: Config) -> Unit:

  return None

async def _deserialize_get_key_policy(input: DafnyResponse, config: Config) -> GetKeyPolicyResponse:

  if input.IsFailure():
    return await _deserialize_error(input.error)
  return GetKeyPolicyResponse(policy=input.value.Policy.UnwrapOr(None),
  )

async def _deserialize_untag_resource(input: DafnyResponse, config: Config) -> Unit:

  return None

async def _deserialize_delete_custom_key_store(input: DafnyResponse, config: Config) -> DeleteCustomKeyStoreResponse:

  if input.IsFailure():
    return await _deserialize_error(input.error)
  return DeleteCustomKeyStoreResponse()

async def _deserialize_schedule_key_deletion(input: DafnyResponse, config: Config) -> ScheduleKeyDeletionResponse:

  if input.IsFailure():
    return await _deserialize_error(input.error)
  return ScheduleKeyDeletionResponse(key_id=input.value.KeyId.UnwrapOr(None),
  deletion_date=input.value.DeletionDate.UnwrapOr(None),
  key_state=input.value.KeyState.UnwrapOr(None),
  pending_window_in_days=input.value.PendingWindowInDays.UnwrapOr(None),
  )

async def _deserialize_encrypt(input: DafnyResponse, config: Config) -> EncryptResponse:

  if input.IsFailure():
    return await _deserialize_error(input.error)
  return EncryptResponse(ciphertext_blob=input.value.CiphertextBlob.UnwrapOr(None),
  key_id=input.value.KeyId.UnwrapOr(None),
  encryption_algorithm=input.value.EncryptionAlgorithm.UnwrapOr(None),
  )

async def _deserialize_verify(input: DafnyResponse, config: Config) -> VerifyResponse:

  if input.IsFailure():
    return await _deserialize_error(input.error)
  return VerifyResponse(key_id=input.value.KeyId.UnwrapOr(None),
  signature_valid=input.value.SignatureValid.UnwrapOr(None),
  signing_algorithm=input.value.SigningAlgorithm.UnwrapOr(None),
  )

async def _deserialize_delete_imported_key_material(input: DafnyResponse, config: Config) -> Unit:

  return None

async def _deserialize_decrypt(input: DafnyResponse, config: Config) -> DecryptResponse:

  if input.IsFailure():
    return await _deserialize_error(input.error)
  return DecryptResponse(key_id=input.value.KeyId.UnwrapOr(None),
  plaintext=input.value.Plaintext.UnwrapOr(None),
  encryption_algorithm=input.value.EncryptionAlgorithm.UnwrapOr(None),
  )

async def _deserialize_generate_data_key_pair_without_plaintext(input: DafnyResponse, config: Config) -> GenerateDataKeyPairWithoutPlaintextResponse:

  if input.IsFailure():
    return await _deserialize_error(input.error)
  return GenerateDataKeyPairWithoutPlaintextResponse(private_key_ciphertext_blob=input.value.PrivateKeyCiphertextBlob.UnwrapOr(None),
  public_key=input.value.PublicKey.UnwrapOr(None),
  key_id=input.value.KeyId.UnwrapOr(None),
  key_pair_spec=input.value.KeyPairSpec.UnwrapOr(None),
  )

async def _deserialize_disable_key_rotation(input: DafnyResponse, config: Config) -> Unit:

  return None

async def _deserialize_import_key_material(input: DafnyResponse, config: Config) -> ImportKeyMaterialResponse:

  if input.IsFailure():
    return await _deserialize_error(input.error)
  return ImportKeyMaterialResponse()

async def _deserialize_connect_custom_key_store(input: DafnyResponse, config: Config) -> ConnectCustomKeyStoreResponse:

  if input.IsFailure():
    return await _deserialize_error(input.error)
  return ConnectCustomKeyStoreResponse()

async def _deserialize_sign(input: DafnyResponse, config: Config) -> SignResponse:

  if input.IsFailure():
    return await _deserialize_error(input.error)
  return SignResponse(key_id=input.value.KeyId.UnwrapOr(None),
  signature=input.value.Signature.UnwrapOr(None),
  signing_algorithm=input.value.SigningAlgorithm.UnwrapOr(None),
  )

async def _deserialize_error(
    error: Error
) -> ServiceError:
  if error.is_Opaque:
    return OpaqueError(obj=error.obj)
  if error.is_CollectionOfErrors:
    return CollectionOfErrors(message=error.message, list=error.list)
  if error.is_AlreadyExistsException:
    return AlreadyExistsException(message=error.message)

  if error.is_CloudHsmClusterInUseException:
    return CloudHsmClusterInUseException(message=error.message)

  if error.is_CloudHsmClusterInvalidConfigurationException:
    return CloudHsmClusterInvalidConfigurationException(message=error.message)

  if error.is_CloudHsmClusterNotActiveException:
    return CloudHsmClusterNotActiveException(message=error.message)

  if error.is_CloudHsmClusterNotFoundException:
    return CloudHsmClusterNotFoundException(message=error.message)

  if error.is_CloudHsmClusterNotRelatedException:
    return CloudHsmClusterNotRelatedException(message=error.message)

  if error.is_CustomKeyStoreHasCMKsException:
    return CustomKeyStoreHasCMKsException(message=error.message)

  if error.is_CustomKeyStoreInvalidStateException:
    return CustomKeyStoreInvalidStateException(message=error.message)

  if error.is_CustomKeyStoreNameInUseException:
    return CustomKeyStoreNameInUseException(message=error.message)

  if error.is_CustomKeyStoreNotFoundException:
    return CustomKeyStoreNotFoundException(message=error.message)

  if error.is_DependencyTimeoutException:
    return DependencyTimeoutException(message=error.message)

  if error.is_DisabledException:
    return DisabledException(message=error.message)

  if error.is_ExpiredImportTokenException:
    return ExpiredImportTokenException(message=error.message)

  if error.is_IncorrectKeyException:
    return IncorrectKeyException(message=error.message)

  if error.is_IncorrectKeyMaterialException:
    return IncorrectKeyMaterialException(message=error.message)

  if error.is_IncorrectTrustAnchorException:
    return IncorrectTrustAnchorException(message=error.message)

  if error.is_InvalidAliasNameException:
    return InvalidAliasNameException(message=error.message)

  if error.is_InvalidArnException:
    return InvalidArnException(message=error.message)

  if error.is_InvalidCiphertextException:
    return InvalidCiphertextException(message=error.message)

  if error.is_InvalidGrantIdException:
    return InvalidGrantIdException(message=error.message)

  if error.is_InvalidGrantTokenException:
    return InvalidGrantTokenException(message=error.message)

  if error.is_InvalidImportTokenException:
    return InvalidImportTokenException(message=error.message)

  if error.is_InvalidKeyUsageException:
    return InvalidKeyUsageException(message=error.message)

  if error.is_InvalidMarkerException:
    return InvalidMarkerException(message=error.message)

  if error.is_KeyUnavailableException:
    return KeyUnavailableException(message=error.message)

  if error.is_KMSInternalException:
    return KMSInternalException(message=error.message)

  if error.is_KMSInvalidSignatureException:
    return KMSInvalidSignatureException(message=error.message)

  if error.is_KMSInvalidStateException:
    return KMSInvalidStateException(message=error.message)

  if error.is_LimitExceededException:
    return LimitExceededException(message=error.message)

  if error.is_MalformedPolicyDocumentException:
    return MalformedPolicyDocumentException(message=error.message)

  if error.is_NotFoundException:
    return NotFoundException(message=error.message)

  if error.is_TagException:
    return TagException(message=error.message)

  if error.is_UnsupportedOperationException:
    return UnsupportedOperationException(message=error.message)
