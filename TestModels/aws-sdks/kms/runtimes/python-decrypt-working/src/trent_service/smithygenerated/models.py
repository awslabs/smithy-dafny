# Code generated by smithy-python-codegen DO NOT EDIT.

from typing import Any, Dict, List, Optional


class AliasListEntry:
    alias_name: Optional[str]
    alias_arn: Optional[str]
    target_key_id: Optional[str]
    creation_date: int
    last_updated_date: int
    def __init__(
        self,
        *,
        alias_name: Optional[str] = None,
        alias_arn: Optional[str] = None,
        target_key_id: Optional[str] = None,
        creation_date: int = 0,
        last_updated_date: int = 0,
    ):
        """<p>Contains information about an alias.</p>

        :param alias_name: <p>String that contains the alias. This value begins with
        <code>alias/</code>.</p>
        :param alias_arn: <p>String that contains the key ARN.</p>
        :param target_key_id: <p>String that contains the key identifier of the KMS key
        associated with the alias.</p>
        :param creation_date: <p>Date and time that the alias was most recently created
        in the account and Region.
              Formatted as Unix time.</p>
        :param last_updated_date: <p>Date and time that the alias was most recently
        associated with a KMS key in the account
              and Region. Formatted as Unix
        time.</p>
        """
        self.alias_name = alias_name
        self.alias_arn = alias_arn
        self.target_key_id = target_key_id
        self.creation_date = creation_date
        self.last_updated_date = last_updated_date

    def as_dict(self) -> Dict[str, Any]:
        """Converts the AliasListEntry to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        d: Dict[str, Any] = {}

        if self.alias_name is not None:
            d["AliasName"] = self.alias_name

        if self.alias_arn is not None:
            d["AliasArn"] = self.alias_arn

        if self.target_key_id is not None:
            d["TargetKeyId"] = self.target_key_id

        if self.creation_date is not None:
            d["CreationDate"] = self.creation_date

        if self.last_updated_date is not None:
            d["LastUpdatedDate"] = self.last_updated_date

        return d

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "AliasListEntry":
        """Creates a AliasListEntry from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {}

        if "AliasName" in d:
            kwargs["alias_name"] = d["AliasName"]

        if "AliasArn" in d:
            kwargs["alias_arn"] = d["AliasArn"]

        if "TargetKeyId" in d:
            kwargs["target_key_id"] = d["TargetKeyId"]

        if "CreationDate" in d:
            kwargs["creation_date"] = d["CreationDate"]

        if "LastUpdatedDate" in d:
            kwargs["last_updated_date"] = d["LastUpdatedDate"]

        return AliasListEntry(**kwargs)

    def __repr__(self) -> str:
        result = "AliasListEntry("
        if self.alias_name is not None:
            result += f"alias_name={repr(self.alias_name)}, "

        if self.alias_arn is not None:
            result += f"alias_arn={repr(self.alias_arn)}, "

        if self.target_key_id is not None:
            result += f"target_key_id={repr(self.target_key_id)}, "

        if self.creation_date is not None:
            result += f"creation_date={repr(self.creation_date)}, "

        if self.last_updated_date is not None:
            result += f"last_updated_date={repr(self.last_updated_date)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, AliasListEntry):
            return False
        attributes: list[str] = ['alias_name','alias_arn','target_key_id','creation_date','last_updated_date',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class CancelKeyDeletionRequest:
    key_id: str
    def __init__(
        self,
        *,
        key_id: str,
    ):
        """
        :param key_id: <p>Identifies the KMS key whose deletion is being canceled.</p>

                 <p>Specify the key ID or key ARN of the KMS key.</p>
                 <p>For
        example:</p>
                 <ul>
                    <li>
                       <p>Key ID:
        <code>1234abcd-12ab-34cd-56ef-1234567890ab</code>
                       </p>

        </li>
                    <li>
                       <p>Key ARN:
        <code>arn:aws:kms:us-east-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab</code>

        </p>
                    </li>
                 </ul>
                 <p>To get the key ID and key
        ARN for a KMS key, use <a>ListKeys</a> or <a>DescribeKey</a>.</p>
        """
        self.key_id = key_id

    def as_dict(self) -> Dict[str, Any]:
        """Converts the CancelKeyDeletionRequest to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        return {
            "KeyId": self.key_id,
        }

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "CancelKeyDeletionRequest":
        """Creates a CancelKeyDeletionRequest from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {
            "key_id": d["KeyId"],
        }

        return CancelKeyDeletionRequest(**kwargs)

    def __repr__(self) -> str:
        result = "CancelKeyDeletionRequest("
        if self.key_id is not None:
            result += f"key_id={repr(self.key_id)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, CancelKeyDeletionRequest):
            return False
        attributes: list[str] = ['key_id',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class CancelKeyDeletionResponse:
    key_id: Optional[str]
    def __init__(
        self,
        *,
        key_id: Optional[str] = None,
    ):
        """
        :param key_id: <p>The Amazon Resource Name (<a
        href="https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#key-id-key-ARN">key
        ARN</a>) of the KMS key whose deletion is canceled.</p>
        """
        self.key_id = key_id

    def as_dict(self) -> Dict[str, Any]:
        """Converts the CancelKeyDeletionResponse to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        d: Dict[str, Any] = {}

        if self.key_id is not None:
            d["KeyId"] = self.key_id

        return d

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "CancelKeyDeletionResponse":
        """Creates a CancelKeyDeletionResponse from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {}

        if "KeyId" in d:
            kwargs["key_id"] = d["KeyId"]

        return CancelKeyDeletionResponse(**kwargs)

    def __repr__(self) -> str:
        result = "CancelKeyDeletionResponse("
        if self.key_id is not None:
            result += f"key_id={repr(self.key_id)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, CancelKeyDeletionResponse):
            return False
        attributes: list[str] = ['key_id',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class ConnectCustomKeyStoreRequest:
    custom_key_store_id: str
    def __init__(
        self,
        *,
        custom_key_store_id: str,
    ):
        """
        :param custom_key_store_id: <p>Enter the key store ID of the custom key store
        that you want to connect.
              To find the ID of a custom key store, use the
        <a>DescribeCustomKeyStores</a> operation.</p>
        """
        self.custom_key_store_id = custom_key_store_id

    def as_dict(self) -> Dict[str, Any]:
        """Converts the ConnectCustomKeyStoreRequest to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        return {
            "CustomKeyStoreId": self.custom_key_store_id,
        }

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "ConnectCustomKeyStoreRequest":
        """Creates a ConnectCustomKeyStoreRequest from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {
            "custom_key_store_id": d["CustomKeyStoreId"],
        }

        return ConnectCustomKeyStoreRequest(**kwargs)

    def __repr__(self) -> str:
        result = "ConnectCustomKeyStoreRequest("
        if self.custom_key_store_id is not None:
            result += f"custom_key_store_id={repr(self.custom_key_store_id)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, ConnectCustomKeyStoreRequest):
            return False
        attributes: list[str] = ['custom_key_store_id',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class ConnectCustomKeyStoreResponse:
    def as_dict(self) -> Dict[str, Any]:
        """Converts the ConnectCustomKeyStoreResponse to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        return {}

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "ConnectCustomKeyStoreResponse":
        """Creates a ConnectCustomKeyStoreResponse from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        return ConnectCustomKeyStoreResponse()

    def __repr__(self) -> str:
        result = "ConnectCustomKeyStoreResponse("

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        return isinstance(other, ConnectCustomKeyStoreResponse)

class CreateAliasRequest:
    alias_name: str
    target_key_id: str
    def __init__(
        self,
        *,
        alias_name: str,
        target_key_id: str,
    ):
        """
        :param alias_name: <p>Specifies the alias name. This value must begin with
        <code>alias/</code> followed by a
              name, such as
        <code>alias/ExampleAlias</code>. </p>
                 <p>The <code>AliasName</code>
        value must be string of 1-256 characters. It can contain only
              alphanumeric
        characters, forward slashes (/), underscores (_), and dashes (-). The alias
        name
              cannot begin with <code>alias/aws/</code>. The
        <code>alias/aws/</code> prefix is reserved for
                <a
        href="https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#aws-managed-cmk">Amazon
        Web Services managed
                keys</a>.</p>
        :param target_key_id: <p>Associates the alias with the specified <a
        href="https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#customer-cmk">customer
        managed key</a>. The KMS key must
              be in the same Amazon Web Services
        Region. </p>
                 <p>A valid key ID is required. If you supply a null or
        empty string value, this operation
              returns an error.</p>
                 <p>For
        help finding the key ID and ARN, see <a
        href="https://docs.aws.amazon.com/kms/latest/developerguide/viewing-keys.html#find-cmk-id-arn">Finding
        the Key ID and
                ARN</a> in the <i>
                       <i>Key Management
        Service Developer Guide</i>
                    </i>.</p>
                 <p>Specify the key
        ID or key ARN of the KMS key.</p>
                 <p>For example:</p>
                 <ul>

        <li>
                       <p>Key ID:
        <code>1234abcd-12ab-34cd-56ef-1234567890ab</code>
                       </p>

        </li>
                    <li>
                       <p>Key ARN:
        <code>arn:aws:kms:us-east-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab</code>

        </p>
                    </li>
                 </ul>
                 <p>To get the key ID and key
        ARN for a KMS key, use <a>ListKeys</a> or <a>DescribeKey</a>.</p>
        """
        self.alias_name = alias_name
        self.target_key_id = target_key_id

    def as_dict(self) -> Dict[str, Any]:
        """Converts the CreateAliasRequest to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        return {
            "AliasName": self.alias_name,
            "TargetKeyId": self.target_key_id,
        }

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "CreateAliasRequest":
        """Creates a CreateAliasRequest from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {
            "alias_name": d["AliasName"],
            "target_key_id": d["TargetKeyId"],
        }

        return CreateAliasRequest(**kwargs)

    def __repr__(self) -> str:
        result = "CreateAliasRequest("
        if self.alias_name is not None:
            result += f"alias_name={repr(self.alias_name)}, "

        if self.target_key_id is not None:
            result += f"target_key_id={repr(self.target_key_id)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, CreateAliasRequest):
            return False
        attributes: list[str] = ['alias_name','target_key_id',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class CreateCustomKeyStoreRequest:
    custom_key_store_name: str
    cloud_hsm_cluster_id: str
    trust_anchor_certificate: str
    key_store_password: str
    def __init__(
        self,
        *,
        custom_key_store_name: str,
        cloud_hsm_cluster_id: str,
        trust_anchor_certificate: str,
        key_store_password: str,
    ):
        """
        :param custom_key_store_name: <p>Specifies a friendly name for the custom key
        store. The name must be unique in your
              Amazon Web Services account.</p>
        :param cloud_hsm_cluster_id: <p>Identifies the CloudHSM cluster for the custom
        key store. Enter the cluster ID of any active
              CloudHSM cluster that is not
        already associated with a custom key store. To find the cluster ID,
              use
        the <a
        href="https://docs.aws.amazon.com/cloudhsm/latest/APIReference/API_DescribeClusters.html">DescribeClusters</a>
        operation.</p>
        :param trust_anchor_certificate: <p>Enter the content of the trust anchor
        certificate for the cluster. This is the content of
              the
        <code>customerCA.crt</code> file that you created when you <a
        href="https://docs.aws.amazon.com/cloudhsm/latest/userguide/initialize-cluster.html">initialized
        the cluster</a>.</p>
        :param key_store_password: <p>Enter the password of the <a
        href="https://docs.aws.amazon.com/kms/latest/developerguide/key-store-concepts.html#concept-kmsuser">

        <code>kmsuser</code> crypto user
                (CU) account</a> in the specified
        CloudHSM cluster. KMS logs into the cluster as this
              user to manage key
        material on your behalf.</p>
                 <p>The password must be a string of 7 to
        32 characters. Its value is case sensitive.</p>
                 <p>This parameter tells
        KMS the <code>kmsuser</code> account password; it does not change
              the
        password in the CloudHSM cluster.</p>
        """
        self.custom_key_store_name = custom_key_store_name
        self.cloud_hsm_cluster_id = cloud_hsm_cluster_id
        self.trust_anchor_certificate = trust_anchor_certificate
        self.key_store_password = key_store_password

    def as_dict(self) -> Dict[str, Any]:
        """Converts the CreateCustomKeyStoreRequest to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        return {
            "CustomKeyStoreName": self.custom_key_store_name,
            "CloudHsmClusterId": self.cloud_hsm_cluster_id,
            "TrustAnchorCertificate": self.trust_anchor_certificate,
            "KeyStorePassword": self.key_store_password,
        }

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "CreateCustomKeyStoreRequest":
        """Creates a CreateCustomKeyStoreRequest from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {
            "custom_key_store_name": d["CustomKeyStoreName"],
            "cloud_hsm_cluster_id": d["CloudHsmClusterId"],
            "trust_anchor_certificate": d["TrustAnchorCertificate"],
            "key_store_password": d["KeyStorePassword"],
        }

        return CreateCustomKeyStoreRequest(**kwargs)

    def __repr__(self) -> str:
        result = "CreateCustomKeyStoreRequest("
        if self.custom_key_store_name is not None:
            result += f"custom_key_store_name={repr(self.custom_key_store_name)}, "

        if self.cloud_hsm_cluster_id is not None:
            result += f"cloud_hsm_cluster_id={repr(self.cloud_hsm_cluster_id)}, "

        if self.trust_anchor_certificate is not None:
            result += f"trust_anchor_certificate={repr(self.trust_anchor_certificate)}, "

        if self.key_store_password is not None:
            result += f"key_store_password={repr(self.key_store_password)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, CreateCustomKeyStoreRequest):
            return False
        attributes: list[str] = ['custom_key_store_name','cloud_hsm_cluster_id','trust_anchor_certificate','key_store_password',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class CreateCustomKeyStoreResponse:
    custom_key_store_id: Optional[str]
    def __init__(
        self,
        *,
        custom_key_store_id: Optional[str] = None,
    ):
        """
        :param custom_key_store_id: <p>A unique identifier for the new custom key
        store.</p>
        """
        self.custom_key_store_id = custom_key_store_id

    def as_dict(self) -> Dict[str, Any]:
        """Converts the CreateCustomKeyStoreResponse to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        d: Dict[str, Any] = {}

        if self.custom_key_store_id is not None:
            d["CustomKeyStoreId"] = self.custom_key_store_id

        return d

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "CreateCustomKeyStoreResponse":
        """Creates a CreateCustomKeyStoreResponse from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {}

        if "CustomKeyStoreId" in d:
            kwargs["custom_key_store_id"] = d["CustomKeyStoreId"]

        return CreateCustomKeyStoreResponse(**kwargs)

    def __repr__(self) -> str:
        result = "CreateCustomKeyStoreResponse("
        if self.custom_key_store_id is not None:
            result += f"custom_key_store_id={repr(self.custom_key_store_id)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, CreateCustomKeyStoreResponse):
            return False
        attributes: list[str] = ['custom_key_store_id',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class GrantConstraints:
    encryption_context_subset: Optional[dict[str, str]]
    encryption_context_equals: Optional[dict[str, str]]
    def __init__(
        self,
        *,
        encryption_context_subset: Optional[dict[str, str]] = None,
        encryption_context_equals: Optional[dict[str, str]] = None,
    ):
        """<p>Use this structure to allow <a
        href="https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#cryptographic-operations">cryptographic
        operations</a> in the grant only when the operation request
              includes the
        specified <a
        href="https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#encrypt_context">encryption
        context</a>. </p>
                 <p>KMS applies the grant constraints only to
        cryptographic operations that support an
              encryption context, that is, all
        cryptographic operations with a <a
        href="https://docs.aws.amazon.com/kms/latest/developerguide/symm-asymm-concepts.html#symmetric-cmks">symmetric
        KMS key</a>. Grant
              constraints are not applied to operations that do not
        support an encryption context, such as
              cryptographic operations with
        asymmetric KMS keys and management operations, such as <a>DescribeKey</a> or
        <a>RetireGrant</a>.</p>
                 <important>
                    <p>In a cryptographic
        operation, the encryption context in the decryption operation must be
                an
        exact, case-sensitive match for the keys and values in the encryption context of
        the
                encryption operation. Only the order of the pairs can vary.</p>

        <p>However, in a grant constraint, the key in each key-value pair is not case
        sensitive,
                but the value is case sensitive.</p>
                    <p>To avoid
        confusion, do not use multiple encryption context pairs that differ only by

        case. To require a fully case-sensitive encryption context, use the

        <code>kms:EncryptionContext:</code> and <code>kms:EncryptionContextKeys</code>
        conditions
                in an IAM or key policy. For details, see <a
        href="https://docs.aws.amazon.com/kms/latest/developerguide/policy-conditions.html#conditions-kms-encryption-context">kms:EncryptionContext:</a>
        in the <i>
                          <i>Key Management Service Developer Guide</i>

        </i>.</p>
                 </important>

        :param encryption_context_subset: <p>A list of key-value pairs that must be
        included in the encryption context of the
              <a
        href="https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#cryptographic-operations">cryptographic
        operation</a> request. The grant allows the cryptographic operation only when
        the encryption
              context in the request includes the key-value pairs
        specified in this constraint, although it
              can include additional key-value
        pairs.</p>
        :param encryption_context_equals: <p>A list of key-value pairs that must match
        the encryption context in the <a
        href="https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#cryptographic-operations">cryptographic
        operation</a>
              request. The grant allows the operation only when the
        encryption context in the request is the
              same as the encryption context
        specified in this constraint.</p>
        """
        self.encryption_context_subset = encryption_context_subset
        self.encryption_context_equals = encryption_context_equals

    def as_dict(self) -> Dict[str, Any]:
        """Converts the GrantConstraints to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        d: Dict[str, Any] = {}

        if self.encryption_context_subset is not None:
            d["EncryptionContextSubset"] = self.encryption_context_subset

        if self.encryption_context_equals is not None:
            d["EncryptionContextEquals"] = self.encryption_context_equals

        return d

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "GrantConstraints":
        """Creates a GrantConstraints from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {}

        if "EncryptionContextSubset" in d:
            kwargs["encryption_context_subset"] = d["EncryptionContextSubset"]

        if "EncryptionContextEquals" in d:
            kwargs["encryption_context_equals"] = d["EncryptionContextEquals"]

        return GrantConstraints(**kwargs)

    def __repr__(self) -> str:
        result = "GrantConstraints("
        if self.encryption_context_subset is not None:
            result += f"encryption_context_subset={repr(self.encryption_context_subset)}, "

        if self.encryption_context_equals is not None:
            result += f"encryption_context_equals={repr(self.encryption_context_equals)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, GrantConstraints):
            return False
        attributes: list[str] = ['encryption_context_subset','encryption_context_equals',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class CreateGrantRequest:
    key_id: str
    grantee_principal: str
    retiring_principal: Optional[str]
    operations: list[str]
    constraints: Optional[GrantConstraints]
    grant_tokens: Optional[list[str]]
    name: Optional[str]
    def __init__(
        self,
        *,
        key_id: str,
        grantee_principal: str,
        operations: list[str],
        retiring_principal: Optional[str] = None,
        constraints: Optional[GrantConstraints] = None,
        grant_tokens: Optional[list[str]] = None,
        name: Optional[str] = None,
    ):
        """
        :param key_id: <p>Identifies the KMS key for the grant. The grant gives
        principals permission to use this
              KMS key.</p>
                 <p>Specify the
        key ID or key ARN of the KMS key. To specify a KMS key in a
        different Amazon Web
        Services account, you must use the key ARN.</p>
                 <p>For example:</p>

        <ul>
                    <li>
                       <p>Key ID:
        <code>1234abcd-12ab-34cd-56ef-1234567890ab</code>
                       </p>

        </li>
                    <li>
                       <p>Key ARN:
        <code>arn:aws:kms:us-east-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab</code>

        </p>
                    </li>
                 </ul>
                 <p>To get the key ID and key
        ARN for a KMS key, use <a>ListKeys</a> or <a>DescribeKey</a>.</p>
        :param grantee_principal: <p>The identity that gets the permissions specified in
        the grant.</p>
                 <p>To specify the principal, use the <a
        href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">Amazon
        Resource Name (ARN)</a> of an
              Amazon Web Services principal. Valid Amazon
        Web Services principals include Amazon Web Services accounts (root), IAM users,
        IAM roles,
              federated users, and assumed role users. For examples of the
        ARN syntax to use for specifying
              a principal, see <a
        href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html#arn-syntax-iam">Amazon
        Web Services Identity and Access
                Management (IAM)</a> in the Example
        ARNs section of the <i>Amazon Web Services General
                Reference</i>.</p>
        :param operations: <p>A list of operations that the grant permits. </p>

        <p>The operation must be supported on the KMS key. For example, you cannot
        create a grant for
              a symmetric KMS key that allows the <a>Sign</a>
        operation, or a grant for an
              asymmetric KMS key that allows the
        <a>GenerateDataKey</a> operation. If you try,
              KMS returns a
        <code>ValidationError</code> exception. For details, see <a
        href="https://docs.aws.amazon.com/kms/latest/developerguide/grants.html#terms-grant-operations">Grant

        operations</a> in the <i>Key Management Service Developer Guide</i>.</p>
        :param retiring_principal: <p>The principal that has permission to use the
        <a>RetireGrant</a> operation to
              retire the grant. </p>
                 <p>To
        specify the principal, use the <a
        href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">Amazon
        Resource Name (ARN)</a> of an
              Amazon Web Services principal. Valid Amazon
        Web Services principals include Amazon Web Services accounts (root), IAM users,
        federated
              users, and assumed role users. For examples of the ARN syntax to
        use for specifying a
              principal, see <a
        href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html#arn-syntax-iam">Amazon
        Web Services Identity and Access
                Management (IAM)</a> in the Example
        ARNs section of the <i>Amazon Web Services General
                Reference</i>.</p>

        <p>The grant determines the retiring principal. Other principals might have
        permission to
              retire the grant or revoke the grant. For details, see
        <a>RevokeGrant</a> and
                <a
        href="https://docs.aws.amazon.com/kms/latest/developerguide/grant-manage.html#grant-delete">Retiring
        and
                revoking grants</a> in the <i>Key Management Service Developer
        Guide</i>. </p>
        :param constraints: <p>Specifies a grant constraint. </p>
                 <p>KMS
        supports the <code>EncryptionContextEquals</code> and

        <code>EncryptionContextSubset</code> grant constraints. Each constraint value
        can include up
              to 8 encryption context pairs. The encryption context value
        in each constraint cannot exceed
              384 characters.</p>
                 <p>These
        grant constraints allow the permissions in the grant only when the encryption

        context in the request matches (<code>EncryptionContextEquals</code>) or
        includes
                (<code>EncryptionContextSubset</code>) the encryption context
        specified in this structure.
              For information about grant constraints, see
        <a
        href="https://docs.aws.amazon.com/kms/latest/developerguide/create-grant-overview.html#grant-constraints">Using
        grant
                constraints</a> in the <i>Key Management Service Developer
        Guide</i>. For more information about encryption context,
              see <a
        href="https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#encrypt_context">Encryption

        Context</a> in the <i>
                       <i>Key Management Service Developer
        Guide</i>
                    </i>. </p>
                 <p>The encryption context grant
        constraints are supported only on operations that include an
              encryption
        context. You cannot use an encryption context grant constraint for
        cryptographic
              operations with asymmetric KMS keys or for management
        operations, such as <a>DescribeKey</a> or <a>RetireGrant</a>.</p>
        :param grant_tokens: <p>A list of grant tokens. </p>
                 <p>Use a grant
        token when your permission to call this operation comes from a new grant that
        has not yet achieved <i>eventual consistency</i>. For more information, see <a
        href="https://docs.aws.amazon.com/kms/latest/developerguide/grants.html#grant_token">Grant
        token</a> and <a
        href="https://docs.aws.amazon.com/kms/latest/developerguide/grant-manage.html#using-grant-token">Using
        a grant token</a> in the
            <i>Key Management Service Developer Guide</i>.</p>
        :param name: <p>A friendly name for the grant. Use this value to prevent the
        unintended creation of
              duplicate grants when retrying this request.</p>

        <p>When this value is absent, all <code>CreateGrant</code> requests result in a
        new grant
              with a unique <code>GrantId</code> even if all the supplied
        parameters are identical. This can
              result in unintended duplicates when
        you retry the <code>CreateGrant</code> request.</p>
                 <p>When this value
        is present, you can retry a <code>CreateGrant</code> request with

        identical parameters; if the grant already exists, the original
        <code>GrantId</code> is
              returned without creating a new grant. Note that
        the returned grant token is unique with every
                <code>CreateGrant</code>
        request, even when a duplicate <code>GrantId</code> is returned.
              All grant
        tokens for the same grant ID can be used interchangeably.</p>
        """
        self.key_id = key_id
        self.grantee_principal = grantee_principal
        self.operations = operations
        self.retiring_principal = retiring_principal
        self.constraints = constraints
        self.grant_tokens = grant_tokens
        self.name = name

    def as_dict(self) -> Dict[str, Any]:
        """Converts the CreateGrantRequest to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        d: Dict[str, Any] = {
            "KeyId": self.key_id,
            "GranteePrincipal": self.grantee_principal,
            "Operations": self.operations,
        }

        if self.retiring_principal is not None:
            d["RetiringPrincipal"] = self.retiring_principal

        if self.constraints is not None:
            d["Constraints"] = self.constraints.as_dict()

        if self.grant_tokens is not None:
            d["GrantTokens"] = self.grant_tokens

        if self.name is not None:
            d["Name"] = self.name

        return d

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "CreateGrantRequest":
        """Creates a CreateGrantRequest from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {
            "key_id": d["KeyId"],
            "grantee_principal": d["GranteePrincipal"],
            "operations": d["Operations"],
        }

        if "RetiringPrincipal" in d:
            kwargs["retiring_principal"] = d["RetiringPrincipal"]

        if "Constraints" in d:
            kwargs["constraints"] = GrantConstraints.from_dict(d["Constraints"])

        if "GrantTokens" in d:
            kwargs["grant_tokens"] = d["GrantTokens"]

        if "Name" in d:
            kwargs["name"] = d["Name"]

        return CreateGrantRequest(**kwargs)

    def __repr__(self) -> str:
        result = "CreateGrantRequest("
        if self.key_id is not None:
            result += f"key_id={repr(self.key_id)}, "

        if self.grantee_principal is not None:
            result += f"grantee_principal={repr(self.grantee_principal)}, "

        if self.retiring_principal is not None:
            result += f"retiring_principal={repr(self.retiring_principal)}, "

        if self.operations is not None:
            result += f"operations={repr(self.operations)}, "

        if self.constraints is not None:
            result += f"constraints={repr(self.constraints)}, "

        if self.grant_tokens is not None:
            result += f"grant_tokens={repr(self.grant_tokens)}, "

        if self.name is not None:
            result += f"name={repr(self.name)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, CreateGrantRequest):
            return False
        attributes: list[str] = ['key_id','grantee_principal','retiring_principal','operations','constraints','grant_tokens','name',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class CreateGrantResponse:
    grant_token: Optional[str]
    grant_id: Optional[str]
    def __init__(
        self,
        *,
        grant_token: Optional[str] = None,
        grant_id: Optional[str] = None,
    ):
        """
        :param grant_token: <p>The grant token.</p>
                 <p>Use a grant token when
        your permission to call this operation comes from a new grant that has not yet
        achieved <i>eventual consistency</i>. For more information, see <a
        href="https://docs.aws.amazon.com/kms/latest/developerguide/grants.html#grant_token">Grant
        token</a> and <a
        href="https://docs.aws.amazon.com/kms/latest/developerguide/grant-manage.html#using-grant-token">Using
        a grant token</a> in the
            <i>Key Management Service Developer Guide</i>.</p>
        :param grant_id: <p>The unique identifier for the grant.</p>
                 <p>You can
        use the <code>GrantId</code> in a <a>ListGrants</a>, <a>RetireGrant</a>, or
        <a>RevokeGrant</a> operation.</p>
        """
        self.grant_token = grant_token
        self.grant_id = grant_id

    def as_dict(self) -> Dict[str, Any]:
        """Converts the CreateGrantResponse to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        d: Dict[str, Any] = {}

        if self.grant_token is not None:
            d["GrantToken"] = self.grant_token

        if self.grant_id is not None:
            d["GrantId"] = self.grant_id

        return d

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "CreateGrantResponse":
        """Creates a CreateGrantResponse from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {}

        if "GrantToken" in d:
            kwargs["grant_token"] = d["GrantToken"]

        if "GrantId" in d:
            kwargs["grant_id"] = d["GrantId"]

        return CreateGrantResponse(**kwargs)

    def __repr__(self) -> str:
        result = "CreateGrantResponse("
        if self.grant_token is not None:
            result += f"grant_token={repr(self.grant_token)}, "

        if self.grant_id is not None:
            result += f"grant_id={repr(self.grant_id)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, CreateGrantResponse):
            return False
        attributes: list[str] = ['grant_token','grant_id',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class Tag:
    tag_key: str
    tag_value: str
    def __init__(
        self,
        *,
        tag_key: str,
        tag_value: str,
    ):
        """<p>A key-value pair. A tag consists of a tag key and a tag value. Tag keys and
        tag values are
              both required, but tag values can be empty (null)
        strings.</p>
                 <p>For information about the rules that apply to tag keys
        and tag values, see <a
        href="https://docs.aws.amazon.com/awsaccountbilling/latest/aboutv2/allocation-tag-restrictions.html">User-Defined
        Tag Restrictions</a> in the <i>Amazon Web Services Billing and Cost Management

        User Guide</i>.</p>

        :param tag_key: <p>The key of the tag.</p>
        :param tag_value: <p>The value of the tag.</p>
        """
        self.tag_key = tag_key
        self.tag_value = tag_value

    def as_dict(self) -> Dict[str, Any]:
        """Converts the Tag to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        return {
            "TagKey": self.tag_key,
            "TagValue": self.tag_value,
        }

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "Tag":
        """Creates a Tag from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {
            "tag_key": d["TagKey"],
            "tag_value": d["TagValue"],
        }

        return Tag(**kwargs)

    def __repr__(self) -> str:
        result = "Tag("
        if self.tag_key is not None:
            result += f"tag_key={repr(self.tag_key)}, "

        if self.tag_value is not None:
            result += f"tag_value={repr(self.tag_value)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, Tag):
            return False
        attributes: list[str] = ['tag_key','tag_value',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class CreateKeyRequest:
    policy: Optional[str]
    description: Optional[str]
    key_usage: Optional[str]
    customer_master_key_spec: Optional[str]
    key_spec: Optional[str]
    origin: Optional[str]
    custom_key_store_id: Optional[str]
    bypass_policy_lockout_safety_check: bool
    tags: Optional[list[Tag]]
    multi_region: Optional[bool]
    def __init__(
        self,
        *,
        policy: Optional[str] = None,
        description: Optional[str] = None,
        key_usage: Optional[str] = None,
        customer_master_key_spec: Optional[str] = None,
        key_spec: Optional[str] = None,
        origin: Optional[str] = None,
        custom_key_store_id: Optional[str] = None,
        bypass_policy_lockout_safety_check: bool = False,
        tags: Optional[list[Tag]] = None,
        multi_region: Optional[bool] = None,
    ):
        """
        :param policy: <p>The key policy to attach to the KMS key.</p>
                 <p>If
        you provide a key policy, it must meet the following criteria:</p>

        <ul>
                    <li>
                       <p>If you don't set
        <code>BypassPolicyLockoutSafetyCheck</code> to true, the key policy

        must allow the principal that is making the <code>CreateKey</code> request to
        make a
                  subsequent <a>PutKeyPolicy</a> request on the KMS key. This
        reduces the risk
                  that the KMS key becomes unmanageable. For more
        information, refer to the scenario in the
                    <a
        href="https://docs.aws.amazon.com/kms/latest/developerguide/key-policies.html#key-policy-default-allow-root-enable-iam">Default
        Key Policy</a> section of the <i>
                             <i>Key Management Service
        Developer Guide</i>
                          </i>.</p>
                    </li>

        <li>
                       <p>Each statement in the key policy must contain one or more
        principals. The principals
                  in the key policy must exist and be visible
        to KMS. When you create a new Amazon Web Services
                  principal (for
        example, an IAM user or role), you might need to enforce a delay before

        including the new principal in a key policy because the new principal might not
        be
                  immediately visible to KMS. For more information, see <a
        href="https://docs.aws.amazon.com/IAM/latest/UserGuide/troubleshoot_general.html#troubleshoot_general_eventual-consistency">Changes
        that I make are not always immediately visible</a> in the <i>Amazon Web
        Services
                    Identity and Access Management User Guide</i>.</p>

        </li>
                 </ul>
                 <p>If you do not provide a key policy, KMS
        attaches a default key policy to the KMS key.
              For more information, see <a
        href="https://docs.aws.amazon.com/kms/latest/developerguide/key-policies.html#key-policy-default">Default
        Key Policy</a> in the
              <i>Key Management Service Developer Guide</i>. </p>

        <p>The key policy size quota is 32 kilobytes (32768 bytes).</p>
                 <p>For
        help writing and formatting a JSON policy document, see the <a
        href="https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_policies.html">IAM
        JSON Policy Reference</a> in the <i>
                       <i>Identity and Access
        Management User Guide</i>
                    </i>.</p>
        :param description: <p>A description of the KMS key.</p>
                 <p>Use a
        description that helps you decide whether the KMS key is appropriate for a task.
        The
              default value is an empty string (no description).</p>
                 <p>To
        set or change the description after the key is created, use
        <a>UpdateKeyDescription</a>.</p>
        :param key_usage: <p>Determines the <a
        href="https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#cryptographic-operations">cryptographic
        operations</a> for which you can use the KMS key. The default value is

        <code>ENCRYPT_DECRYPT</code>. This parameter is required only for asymmetric KMS
        keys. You
              can't change the <code>KeyUsage</code> value after the KMS key
        is created.</p>
                 <p>Select only one valid value.</p>
                 <ul>

        <li>
                       <p>For symmetric KMS keys, omit the parameter or specify

        <code>ENCRYPT_DECRYPT</code>.</p>
                    </li>
                    <li>

        <p>For asymmetric KMS keys with RSA key material, specify
        <code>ENCRYPT_DECRYPT</code> or
                    <code>SIGN_VERIFY</code>.</p>

        </li>
                    <li>
                       <p>For asymmetric KMS keys with ECC key
        material, specify
                  <code>SIGN_VERIFY</code>.</p>
                    </li>

        </ul>
        :param customer_master_key_spec: <p>Instead, use the <code>KeySpec</code>
        parameter.</p>
                 <p>The <code>KeySpec</code> and
        <code>CustomerMasterKeySpec</code> parameters work the same
              way. Only the
        names differ. We recommend that you use <code>KeySpec</code> parameter in your

        code. However, to avoid breaking changes, KMS will support both parameters.</p>
        :param key_spec: <p>Specifies the type of KMS key to create. The default value,

        <code>SYMMETRIC_DEFAULT</code>, creates a KMS key with a 256-bit symmetric key
        for encryption
              and decryption. For help choosing a key spec for your KMS
        key, see <a
        href="https://docs.aws.amazon.com/kms/latest/developerguide/symm-asymm-choose.html">How
        to Choose Your KMS key
                Configuration</a> in the <i>

        <i>Key Management Service Developer Guide</i>
                    </i>.</p>

        <p>The <code>KeySpec</code> determines whether the KMS key contains a symmetric
        key or an
              asymmetric key pair. It also determines the encryption
        algorithms or signing algorithms that
              the KMS key supports. You can't
        change the <code>KeySpec</code> after the KMS key is created.
              To further
        restrict the algorithms that can be used with the KMS key, use a condition key
        in
              its key policy or IAM policy. For more information, see <a
        href="https://docs.aws.amazon.com/kms/latest/developerguide/policy-conditions.html#conditions-kms-encryption-algorithm">kms:EncryptionAlgorithm</a>
        or <a
        href="https://docs.aws.amazon.com/kms/latest/developerguide/policy-conditions.html#conditions-kms-signing-algorithm">kms:Signing
        Algorithm</a> in the <i>
                       <i>Key Management Service Developer
        Guide</i>
                    </i>.</p>
                 <important>
                    <p>

        <a href="http://aws.amazon.com/kms/features/#AWS_Service_Integration">Amazon Web
        Services services that
                  are integrated with KMS</a> use symmetric KMS
        keys to protect your data. These
                services do not support asymmetric KMS
        keys. For help determining whether a KMS key is
                symmetric or asymmetric,
        see <a
        href="https://docs.aws.amazon.com/kms/latest/developerguide/find-symm-asymm.html">Identifying
        Symmetric and Asymmetric
                  KMS keys</a> in the <i>Key Management Service
        Developer Guide</i>.</p>
                 </important>
                 <p>KMS supports the
        following key specs for KMS keys:</p>
                 <ul>
                    <li>

        <p>Symmetric key (default)</p>
                       <ul>
                          <li>

        <p>
                                <code>SYMMETRIC_DEFAULT</code> (AES-256-GCM)</p>

        </li>
                       </ul>
                    </li>
                    <li>

        <p>Asymmetric RSA key pairs</p>
                       <ul>
                          <li>

        <p>
                                <code>RSA_2048</code>
                             </p>

        </li>
                          <li>
                             <p>

        <code>RSA_3072</code>
                             </p>
                          </li>

        <li>
                             <p>
                                <code>RSA_4096</code>

        </p>
                          </li>
                       </ul>
                    </li>

        <li>
                       <p>Asymmetric NIST-recommended elliptic curve key pairs</p>

        <ul>
                          <li>
                             <p>

        <code>ECC_NIST_P256</code> (secp256r1)</p>
                          </li>

        <li>
                             <p>
                                <code>ECC_NIST_P384</code>
        (secp384r1)</p>
                          </li>
                          <li>

        <p>
                                <code>ECC_NIST_P521</code> (secp521r1)</p>

        </li>
                       </ul>
                    </li>
                    <li>

        <p>Other asymmetric elliptic curve key pairs</p>
                       <ul>

        <li>
                             <p>

        <code>ECC_SECG_P256K1</code> (secp256k1), commonly used for

        cryptocurrencies.</p>
                          </li>
                       </ul>

        </li>
                 </ul>
        :param origin: <p>The source of the key material for the KMS key. You cannot
        change the origin after you
              create the KMS key. The default is
        <code>AWS_KMS</code>, which means that KMS creates the
              key material.</p>

        <p>To create a KMS key with no key material (for imported key material), set the
        value to
                <code>EXTERNAL</code>. For more information about importing key
        material into KMS, see
                <a
        href="https://docs.aws.amazon.com/kms/latest/developerguide/importing-keys.html">Importing
        Key
                Material</a> in the <i>Key Management Service Developer Guide</i>.
        This value is valid only for symmetric KMS
              keys.</p>
                 <p>To create
        a KMS key in an KMS <a
        href="https://docs.aws.amazon.com/kms/latest/developerguide/custom-key-store-overview.html">custom
        key store</a> and create its key material in the
              associated CloudHSM
        cluster, set this value to <code>AWS_CLOUDHSM</code>. You must also use the

        <code>CustomKeyStoreId</code> parameter to identify the custom key store. This
        value is
              valid only for symmetric KMS keys.</p>
        :param custom_key_store_id: <p>Creates the KMS key in the specified <a
        href="https://docs.aws.amazon.com/kms/latest/developerguide/custom-key-store-overview.html">custom
        key store</a> and the key material in its
              associated CloudHSM cluster. To
        create a KMS key in a custom key store, you must also specify the

        <code>Origin</code> parameter with a value of <code>AWS_CLOUDHSM</code>. The
        CloudHSM cluster
              that is associated with the custom key store must have at
        least two active HSMs, each in a
              different Availability Zone in the
        Region.</p>
                 <p>This parameter is valid only for symmetric KMS keys and
        regional KMS keys. You cannot
              create an asymmetric KMS key or a
        multi-Region key in a custom key store.</p>
                 <p>To find the ID of a
        custom key store, use the <a>DescribeCustomKeyStores</a> operation.</p>

        <p>The response includes the custom key store ID and the ID of the CloudHSM
        cluster.</p>
                 <p>This operation is part of the <a
        href="https://docs.aws.amazon.com/kms/latest/developerguide/custom-key-store-overview.html">Custom
        Key Store feature</a> feature in KMS, which
        combines the convenience and
        extensive integration of KMS with the isolation and control of a
        single-tenant
        key store.</p>
        :param bypass_policy_lockout_safety_check: <p>A flag to indicate whether to
        bypass the key policy lockout safety check.</p>
                 <important>

        <p>Setting this value to true increases the risk that the KMS key becomes
        unmanageable. Do
                not set this value to true indiscriminately.</p>

        <p>For more information, refer to the scenario in the <a
        href="https://docs.aws.amazon.com/kms/latest/developerguide/key-policies.html#key-policy-default-allow-root-enable-iam">Default
        Key Policy</a> section in the <i>
                          <i>Key Management Service
        Developer Guide</i>
                       </i>.</p>
                 </important>

        <p>Use this parameter only when you include a policy in the request and you
        intend to prevent
              the principal that is making the request from making a
        subsequent <a>PutKeyPolicy</a> request on the KMS key.</p>
                 <p>The
        default value is false.</p>
        :param tags: <p>Assigns one or more tags to the KMS key. Use this parameter to
        tag the KMS key when it is
              created. To tag an existing KMS key, use the
        <a>TagResource</a> operation.</p>
                 <note>
                    <p>Tagging or
        untagging a KMS key can allow or deny permission to the KMS key. For details,
        see <a
        href="https://docs.aws.amazon.com/kms/latest/developerguide/abac.html">Using
        ABAC in KMS</a> in the <i>Key Management Service Developer Guide</i>.</p>

        </note>
                 <p>To use this parameter, you must have <a
        href="https://docs.aws.amazon.com/kms/latest/developerguide/kms-api-permissions-reference.html">kms:TagResource</a>
        permission in an IAM policy.</p>
                 <p>Each tag consists of a tag key and
        a tag value. Both the tag key and the tag value are
              required, but the tag
        value can be an empty (null) string. You cannot have more than one tag
              on
        a KMS key with the same tag key. If you specify an existing tag key with a
        different tag
              value, KMS replaces the current tag value with the specified
        one.</p>
                 <p>When you add tags to an Amazon Web Services resource,
        Amazon Web Services generates a cost allocation
                      report with usage
        and costs aggregated by tags. Tags can also be used to control access to a KMS
        key. For details,
                      see <a
        href="https://docs.aws.amazon.com/kms/latest/developerguide/tagging-keys.html">Tagging
        Keys</a>.</p>
        :param multi_region: <p>Creates a multi-Region primary key that you can
        replicate into other Amazon Web Services Regions. You
              cannot change this
        value after you create the KMS key. </p>
                 <p>For a multi-Region key, set
        this parameter to <code>True</code>. For a single-Region KMS
              key, omit
        this parameter or set it to <code>False</code>. The default value is

        <code>False</code>.</p>
                 <p>This operation supports <i>multi-Region
        keys</i>, an KMS feature that lets you create multiple
              interoperable KMS
        keys in different Amazon Web Services Regions. Because these KMS keys have the
        same key ID, key
              material, and other metadata, you can use them
        interchangeably to encrypt data in one Amazon Web Services Region and decrypt

        it in a different Amazon Web Services Region without re-encrypting the data or
        making a cross-Region call. For more information about multi-Region keys, see <a
        href="https://docs.aws.amazon.com/kms/latest/developerguide/multi-region-keys-overview.html">Using
        multi-Region keys</a> in the <i>Key Management Service Developer Guide</i>.</p>

        <p>This value creates a <i>primary key</i>, not a replica. To create a

        <i>replica key</i>, use the <a>ReplicateKey</a> operation. </p>
                 <p>You
        can create a symmetric or asymmetric multi-Region key, and you can create a

        multi-Region key with imported key material. However, you cannot create a
        multi-Region key in
              a custom key store.</p>
        """
        self.policy = policy
        self.description = description
        self.key_usage = key_usage
        self.customer_master_key_spec = customer_master_key_spec
        self.key_spec = key_spec
        self.origin = origin
        self.custom_key_store_id = custom_key_store_id
        self.bypass_policy_lockout_safety_check = bypass_policy_lockout_safety_check
        self.tags = tags
        self.multi_region = multi_region

    def as_dict(self) -> Dict[str, Any]:
        """Converts the CreateKeyRequest to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        d: Dict[str, Any] = {}

        if self.policy is not None:
            d["Policy"] = self.policy

        if self.description is not None:
            d["Description"] = self.description

        if self.key_usage is not None:
            d["KeyUsage"] = self.key_usage

        if self.customer_master_key_spec is not None:
            d["CustomerMasterKeySpec"] = self.customer_master_key_spec

        if self.key_spec is not None:
            d["KeySpec"] = self.key_spec

        if self.origin is not None:
            d["Origin"] = self.origin

        if self.custom_key_store_id is not None:
            d["CustomKeyStoreId"] = self.custom_key_store_id

        if self.bypass_policy_lockout_safety_check is not None:
            d["BypassPolicyLockoutSafetyCheck"] = self.bypass_policy_lockout_safety_check

        if self.tags is not None:
            d["Tags"] = _tag_list_as_dict(self.tags),

        if self.multi_region is not None:
            d["MultiRegion"] = self.multi_region

        return d

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "CreateKeyRequest":
        """Creates a CreateKeyRequest from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {}

        if "Policy" in d:
            kwargs["policy"] = d["Policy"]

        if "Description" in d:
            kwargs["description"] = d["Description"]

        if "KeyUsage" in d:
            kwargs["key_usage"] = d["KeyUsage"]

        if "CustomerMasterKeySpec" in d:
            kwargs["customer_master_key_spec"] = d["CustomerMasterKeySpec"]

        if "KeySpec" in d:
            kwargs["key_spec"] = d["KeySpec"]

        if "Origin" in d:
            kwargs["origin"] = d["Origin"]

        if "CustomKeyStoreId" in d:
            kwargs["custom_key_store_id"] = d["CustomKeyStoreId"]

        if "BypassPolicyLockoutSafetyCheck" in d:
            kwargs["bypass_policy_lockout_safety_check"] = d["BypassPolicyLockoutSafetyCheck"]

        if "Tags" in d:
            kwargs["tags"] = _tag_list_from_dict(d["Tags"]),

        if "MultiRegion" in d:
            kwargs["multi_region"] = d["MultiRegion"]

        return CreateKeyRequest(**kwargs)

    def __repr__(self) -> str:
        result = "CreateKeyRequest("
        if self.policy is not None:
            result += f"policy={repr(self.policy)}, "

        if self.description is not None:
            result += f"description={repr(self.description)}, "

        if self.key_usage is not None:
            result += f"key_usage={repr(self.key_usage)}, "

        if self.customer_master_key_spec is not None:
            result += f"customer_master_key_spec={repr(self.customer_master_key_spec)}, "

        if self.key_spec is not None:
            result += f"key_spec={repr(self.key_spec)}, "

        if self.origin is not None:
            result += f"origin={repr(self.origin)}, "

        if self.custom_key_store_id is not None:
            result += f"custom_key_store_id={repr(self.custom_key_store_id)}, "

        if self.bypass_policy_lockout_safety_check is not None:
            result += f"bypass_policy_lockout_safety_check={repr(self.bypass_policy_lockout_safety_check)}, "

        if self.tags is not None:
            result += f"tags={repr(self.tags)}, "

        if self.multi_region is not None:
            result += f"multi_region={repr(self.multi_region)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, CreateKeyRequest):
            return False
        attributes: list[str] = ['policy','description','key_usage','customer_master_key_spec','key_spec','origin','custom_key_store_id','bypass_policy_lockout_safety_check','tags','multi_region',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class MultiRegionKey:
    arn: Optional[str]
    region: Optional[str]
    def __init__(
        self,
        *,
        arn: Optional[str] = None,
        region: Optional[str] = None,
    ):
        """<p>Describes the primary or replica key in a multi-Region key.</p>

        :param arn: <p>Displays the key ARN of a primary or replica key of a
        multi-Region key.</p>
        :param region: <p>Displays the Amazon Web Services Region of a primary or
        replica key in a multi-Region key.</p>
        """
        self.arn = arn
        self.region = region

    def as_dict(self) -> Dict[str, Any]:
        """Converts the MultiRegionKey to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        d: Dict[str, Any] = {}

        if self.arn is not None:
            d["Arn"] = self.arn

        if self.region is not None:
            d["Region"] = self.region

        return d

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "MultiRegionKey":
        """Creates a MultiRegionKey from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {}

        if "Arn" in d:
            kwargs["arn"] = d["Arn"]

        if "Region" in d:
            kwargs["region"] = d["Region"]

        return MultiRegionKey(**kwargs)

    def __repr__(self) -> str:
        result = "MultiRegionKey("
        if self.arn is not None:
            result += f"arn={repr(self.arn)}, "

        if self.region is not None:
            result += f"region={repr(self.region)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, MultiRegionKey):
            return False
        attributes: list[str] = ['arn','region',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class MultiRegionConfiguration:
    multi_region_key_type: Optional[str]
    primary_key: Optional[MultiRegionKey]
    replica_keys: Optional[list[MultiRegionKey]]
    def __init__(
        self,
        *,
        multi_region_key_type: Optional[str] = None,
        primary_key: Optional[MultiRegionKey] = None,
        replica_keys: Optional[list[MultiRegionKey]] = None,
    ):
        """<p>Describes the configuration of this multi-Region key. This field appears only
        when the KMS
              key is a primary or replica of a multi-Region key.</p>

        <p>For more information about any listed KMS key, use the <a>DescribeKey</a>

        operation.</p>

        :param multi_region_key_type: <p>Indicates whether the KMS key is a
        <code>PRIMARY</code> or <code>REPLICA</code>
              key.</p>
        :param primary_key: <p>Displays the key ARN and Region of the primary key. This
        field includes the current KMS
              key if it is the primary key.</p>
        :param replica_keys: <p>displays the key ARNs and Regions of all replica keys.
        This field includes the current KMS
              key if it is a replica key.</p>
        """
        self.multi_region_key_type = multi_region_key_type
        self.primary_key = primary_key
        self.replica_keys = replica_keys

    def as_dict(self) -> Dict[str, Any]:
        """Converts the MultiRegionConfiguration to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        d: Dict[str, Any] = {}

        if self.multi_region_key_type is not None:
            d["MultiRegionKeyType"] = self.multi_region_key_type

        if self.primary_key is not None:
            d["PrimaryKey"] = self.primary_key.as_dict()

        if self.replica_keys is not None:
            d["ReplicaKeys"] = _multi_region_key_list_as_dict(self.replica_keys),

        return d

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "MultiRegionConfiguration":
        """Creates a MultiRegionConfiguration from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {}

        if "MultiRegionKeyType" in d:
            kwargs["multi_region_key_type"] = d["MultiRegionKeyType"]

        if "PrimaryKey" in d:
            kwargs["primary_key"] = MultiRegionKey.from_dict(d["PrimaryKey"])

        if "ReplicaKeys" in d:
            kwargs["replica_keys"] = _multi_region_key_list_from_dict(d["ReplicaKeys"]),

        return MultiRegionConfiguration(**kwargs)

    def __repr__(self) -> str:
        result = "MultiRegionConfiguration("
        if self.multi_region_key_type is not None:
            result += f"multi_region_key_type={repr(self.multi_region_key_type)}, "

        if self.primary_key is not None:
            result += f"primary_key={repr(self.primary_key)}, "

        if self.replica_keys is not None:
            result += f"replica_keys={repr(self.replica_keys)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, MultiRegionConfiguration):
            return False
        attributes: list[str] = ['multi_region_key_type','primary_key','replica_keys',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class KeyMetadata:
    aws_account_id: Optional[str]
    key_id: str
    arn: Optional[str]
    creation_date: int
    enabled: bool
    description: Optional[str]
    key_usage: Optional[str]
    key_state: Optional[str]
    deletion_date: int
    valid_to: int
    origin: Optional[str]
    custom_key_store_id: Optional[str]
    cloud_hsm_cluster_id: Optional[str]
    expiration_model: Optional[str]
    key_manager: Optional[str]
    customer_master_key_spec: Optional[str]
    key_spec: Optional[str]
    encryption_algorithms: Optional[list[str]]
    signing_algorithms: Optional[list[str]]
    multi_region: Optional[bool]
    multi_region_configuration: Optional[MultiRegionConfiguration]
    pending_deletion_window_in_days: Optional[int]
    def __init__(
        self,
        *,
        key_id: str,
        aws_account_id: Optional[str] = None,
        arn: Optional[str] = None,
        creation_date: int = 0,
        enabled: bool = False,
        description: Optional[str] = None,
        key_usage: Optional[str] = None,
        key_state: Optional[str] = None,
        deletion_date: int = 0,
        valid_to: int = 0,
        origin: Optional[str] = None,
        custom_key_store_id: Optional[str] = None,
        cloud_hsm_cluster_id: Optional[str] = None,
        expiration_model: Optional[str] = None,
        key_manager: Optional[str] = None,
        customer_master_key_spec: Optional[str] = None,
        key_spec: Optional[str] = None,
        encryption_algorithms: Optional[list[str]] = None,
        signing_algorithms: Optional[list[str]] = None,
        multi_region: Optional[bool] = None,
        multi_region_configuration: Optional[MultiRegionConfiguration] = None,
        pending_deletion_window_in_days: Optional[int] = None,
    ):
        """<p>Contains metadata about a KMS key.</p>
                 <p>This data type is used as
        a response element for the <a>CreateKey</a> and <a>DescribeKey</a>
        operations.</p>

        :param key_id: <p>The globally unique identifier for the KMS key.</p>
        :param aws_account_id: <p>The twelve-digit account ID of the Amazon Web Services
        account that owns the KMS key.</p>
        :param arn: <p>The Amazon Resource Name (ARN) of the KMS key. For examples, see
        <a
        href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html#arn-syntax-kms">Key
        Management Service (KMS)</a> in the Example ARNs section of the <i>Amazon Web
        Services General
                Reference</i>.</p>
        :param creation_date: <p>The date and time when the KMS key was created.</p>
        :param enabled: <p>Specifies whether the KMS key is enabled. When
        <code>KeyState</code> is
                <code>Enabled</code> this value is true,
        otherwise it is false.</p>
        :param description: <p>The description of the KMS key.</p>
        :param key_usage: <p>The <a
        href="https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#cryptographic-operations">cryptographic
        operations</a> for which you can use the KMS key.</p>
        :param key_state: <p>The current status of the KMS key.</p>
                 <p>For more
        information about how key state affects the use of a KMS key, see <a
        href="https://docs.aws.amazon.com/kms/latest/developerguide/key-state.html">Key
        state: Effect on your KMS
                key</a> in the <i>Key Management Service
        Developer Guide</i>.</p>
        :param deletion_date: <p>The date and time after which KMS deletes this KMS key.
        This value is present only when
              the KMS key is scheduled for deletion,
        that is, when its <code>KeyState</code> is

        <code>PendingDeletion</code>.</p>
                 <p>When the primary key in a
        multi-Region key is scheduled for deletion but still has replica
              keys, its
        key state is <code>PendingReplicaDeletion</code> and the length of its waiting

        period is displayed in the <code>PendingDeletionWindowInDays</code> field.</p>
        :param valid_to: <p>The time at which the imported key material expires. When
        the key material expires, KMS
              deletes the key material and the KMS key
        becomes unusable. This value is present only for KMS
              keys whose
        <code>Origin</code> is <code>EXTERNAL</code> and whose
        <code>ExpirationModel</code>
              is <code>KEY_MATERIAL_EXPIRES</code>,
        otherwise this value is omitted.</p>
        :param origin: <p>The source of the key material for the KMS key. When this
        value is <code>AWS_KMS</code>,
              KMS created the key material. When this
        value is <code>EXTERNAL</code>, the key material was
              imported or the KMS
        key doesn't have any key material. When this value is

        <code>AWS_CLOUDHSM</code>, the key material was created in the CloudHSM cluster
        associated with
              a custom key store.</p>
        :param custom_key_store_id: <p>A unique identifier for the <a
        href="https://docs.aws.amazon.com/kms/latest/developerguide/custom-key-store-overview.html">custom
        key store</a> that contains the KMS key. This value is
              present only when
        the KMS key is created in a custom key store.</p>
        :param cloud_hsm_cluster_id: <p>The cluster ID of the CloudHSM cluster that
        contains the key material for the KMS key. When
              you create a KMS key in a
        <a
        href="https://docs.aws.amazon.com/kms/latest/developerguide/custom-key-store-overview.html">custom
        key store</a>, KMS creates the key material for the KMS key in
              the
        associated CloudHSM cluster. This value is present only when the KMS key is
        created in a
              custom key store.</p>
        :param expiration_model: <p>Specifies whether the KMS key's key material
        expires. This value is present only when
                <code>Origin</code> is
        <code>EXTERNAL</code>, otherwise this value is omitted.</p>
        :param key_manager: <p>The manager of the KMS key. KMS keys in your Amazon Web
        Services account are either customer managed or
              Amazon Web Services
        managed. For more information about the difference, see <a
        href="https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#kms_keys">KMS
        keys</a> in the <i>Key Management Service Developer Guide</i>.</p>
        :param customer_master_key_spec: <p>Instead, use the <code>KeySpec</code>
        field.</p>
                 <p>The <code>KeySpec</code> and
        <code>CustomerMasterKeySpec</code> fields have the same
              value. We
        recommend that you use the <code>KeySpec</code> field in your code. However, to

        avoid breaking changes, KMS will support both fields.</p>
        :param key_spec: <p>Describes the type of key material in the KMS key.</p>
        :param encryption_algorithms: <p>The encryption algorithms that the KMS key
        supports. You cannot use the KMS key with other
              encryption algorithms
        within KMS.</p>
                 <p>This value is present only when the
        <code>KeyUsage</code> of the KMS key is

        <code>ENCRYPT_DECRYPT</code>.</p>
        :param signing_algorithms: <p>The signing algorithms that the KMS key supports.
        You cannot use the KMS key with other
              signing algorithms within KMS.</p>

        <p>This field appears only when the <code>KeyUsage</code> of the KMS key is

        <code>SIGN_VERIFY</code>.</p>
        :param multi_region: <p>Indicates whether the KMS key is a multi-Region
        (<code>True</code>) or regional
                (<code>False</code>) key. This value is
        <code>True</code> for multi-Region primary and
              replica keys and
        <code>False</code> for regional KMS keys.</p>
                 <p>For more information
        about multi-Region keys, see <a
        href="https://docs.aws.amazon.com/kms/latest/developerguide/multi-region-keys-overview.html">Using
        multi-Region keys</a> in the <i>Key Management Service Developer Guide</i>.</p>
        :param multi_region_configuration: <p>Lists the primary and replica keys in same
        multi-Region key. This field is present only
              when the value of the
        <code>MultiRegion</code> field is <code>True</code>.</p>
                 <p>For more
        information about any listed KMS key, use the <a>DescribeKey</a>

        operation.</p>
                 <ul>
                    <li>
                       <p>

        <code>MultiRegionKeyType</code> indicates whether the KMS key is a

        <code>PRIMARY</code> or <code>REPLICA</code> key.</p>
                    </li>

        <li>
                       <p>
                          <code>PrimaryKey</code> displays the
        key ARN and Region of the primary key. This field
                  displays the current
        KMS key if it is the primary key.</p>
                    </li>
                    <li>

        <p>
                          <code>ReplicaKeys</code> displays the key ARNs and Regions
        of all replica keys. This
                  field includes the current KMS key if it is
        a replica key.</p>
                    </li>
                 </ul>
        :param pending_deletion_window_in_days: <p>The waiting period before the primary
        key in a multi-Region key is deleted. This waiting
              period begins when the
        last of its replica keys is deleted. This value is present only when
              the
        <code>KeyState</code> of the KMS key is <code>PendingReplicaDeletion</code>.
        That
              indicates that the KMS key is the primary key in a multi-Region key,
        it is scheduled for
              deletion, and it still has existing replica keys.</p>

        <p>When a single-Region KMS key or a multi-Region replica key is scheduled for
        deletion, its
              deletion date is displayed in the <code>DeletionDate</code>
        field. However, when the primary
              key in a multi-Region key is scheduled
        for deletion, its waiting period doesn't begin until
              all of its replica
        keys are deleted. This value displays that waiting period. When the last

        replica key in the multi-Region key is deleted, the <code>KeyState</code> of the
        scheduled
              primary key changes from <code>PendingReplicaDeletion</code> to
        <code>PendingDeletion</code>
              and the deletion date appears in the
        <code>DeletionDate</code> field.</p>
        """
        self.key_id = key_id
        self.aws_account_id = aws_account_id
        self.arn = arn
        self.creation_date = creation_date
        self.enabled = enabled
        self.description = description
        self.key_usage = key_usage
        self.key_state = key_state
        self.deletion_date = deletion_date
        self.valid_to = valid_to
        self.origin = origin
        self.custom_key_store_id = custom_key_store_id
        self.cloud_hsm_cluster_id = cloud_hsm_cluster_id
        self.expiration_model = expiration_model
        self.key_manager = key_manager
        self.customer_master_key_spec = customer_master_key_spec
        self.key_spec = key_spec
        self.encryption_algorithms = encryption_algorithms
        self.signing_algorithms = signing_algorithms
        self.multi_region = multi_region
        self.multi_region_configuration = multi_region_configuration
        self.pending_deletion_window_in_days = pending_deletion_window_in_days

    def as_dict(self) -> Dict[str, Any]:
        """Converts the KeyMetadata to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        d: Dict[str, Any] = {
            "KeyId": self.key_id,
        }

        if self.aws_account_id is not None:
            d["AWSAccountId"] = self.aws_account_id

        if self.arn is not None:
            d["Arn"] = self.arn

        if self.creation_date is not None:
            d["CreationDate"] = self.creation_date

        if self.enabled is not None:
            d["Enabled"] = self.enabled

        if self.description is not None:
            d["Description"] = self.description

        if self.key_usage is not None:
            d["KeyUsage"] = self.key_usage

        if self.key_state is not None:
            d["KeyState"] = self.key_state

        if self.deletion_date is not None:
            d["DeletionDate"] = self.deletion_date

        if self.valid_to is not None:
            d["ValidTo"] = self.valid_to

        if self.origin is not None:
            d["Origin"] = self.origin

        if self.custom_key_store_id is not None:
            d["CustomKeyStoreId"] = self.custom_key_store_id

        if self.cloud_hsm_cluster_id is not None:
            d["CloudHsmClusterId"] = self.cloud_hsm_cluster_id

        if self.expiration_model is not None:
            d["ExpirationModel"] = self.expiration_model

        if self.key_manager is not None:
            d["KeyManager"] = self.key_manager

        if self.customer_master_key_spec is not None:
            d["CustomerMasterKeySpec"] = self.customer_master_key_spec

        if self.key_spec is not None:
            d["KeySpec"] = self.key_spec

        if self.encryption_algorithms is not None:
            d["EncryptionAlgorithms"] = self.encryption_algorithms

        if self.signing_algorithms is not None:
            d["SigningAlgorithms"] = self.signing_algorithms

        if self.multi_region is not None:
            d["MultiRegion"] = self.multi_region

        if self.multi_region_configuration is not None:
            d["MultiRegionConfiguration"] = self.multi_region_configuration.as_dict()

        if self.pending_deletion_window_in_days is not None:
            d["PendingDeletionWindowInDays"] = self.pending_deletion_window_in_days

        return d

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "KeyMetadata":
        """Creates a KeyMetadata from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {
            "key_id": d["KeyId"],
        }

        if "AWSAccountId" in d:
            kwargs["aws_account_id"] = d["AWSAccountId"]

        if "Arn" in d:
            kwargs["arn"] = d["Arn"]

        if "CreationDate" in d:
            kwargs["creation_date"] = d["CreationDate"]

        if "Enabled" in d:
            kwargs["enabled"] = d["Enabled"]

        if "Description" in d:
            kwargs["description"] = d["Description"]

        if "KeyUsage" in d:
            kwargs["key_usage"] = d["KeyUsage"]

        if "KeyState" in d:
            kwargs["key_state"] = d["KeyState"]

        if "DeletionDate" in d:
            kwargs["deletion_date"] = d["DeletionDate"]

        if "ValidTo" in d:
            kwargs["valid_to"] = d["ValidTo"]

        if "Origin" in d:
            kwargs["origin"] = d["Origin"]

        if "CustomKeyStoreId" in d:
            kwargs["custom_key_store_id"] = d["CustomKeyStoreId"]

        if "CloudHsmClusterId" in d:
            kwargs["cloud_hsm_cluster_id"] = d["CloudHsmClusterId"]

        if "ExpirationModel" in d:
            kwargs["expiration_model"] = d["ExpirationModel"]

        if "KeyManager" in d:
            kwargs["key_manager"] = d["KeyManager"]

        if "CustomerMasterKeySpec" in d:
            kwargs["customer_master_key_spec"] = d["CustomerMasterKeySpec"]

        if "KeySpec" in d:
            kwargs["key_spec"] = d["KeySpec"]

        if "EncryptionAlgorithms" in d:
            kwargs["encryption_algorithms"] = d["EncryptionAlgorithms"]

        if "SigningAlgorithms" in d:
            kwargs["signing_algorithms"] = d["SigningAlgorithms"]

        if "MultiRegion" in d:
            kwargs["multi_region"] = d["MultiRegion"]

        if "MultiRegionConfiguration" in d:
            kwargs["multi_region_configuration"] = MultiRegionConfiguration.from_dict(d["MultiRegionConfiguration"])

        if "PendingDeletionWindowInDays" in d:
            kwargs["pending_deletion_window_in_days"] = d["PendingDeletionWindowInDays"]

        return KeyMetadata(**kwargs)

    def __repr__(self) -> str:
        result = "KeyMetadata("
        if self.aws_account_id is not None:
            result += f"aws_account_id={repr(self.aws_account_id)}, "

        if self.key_id is not None:
            result += f"key_id={repr(self.key_id)}, "

        if self.arn is not None:
            result += f"arn={repr(self.arn)}, "

        if self.creation_date is not None:
            result += f"creation_date={repr(self.creation_date)}, "

        if self.enabled is not None:
            result += f"enabled={repr(self.enabled)}, "

        if self.description is not None:
            result += f"description={repr(self.description)}, "

        if self.key_usage is not None:
            result += f"key_usage={repr(self.key_usage)}, "

        if self.key_state is not None:
            result += f"key_state={repr(self.key_state)}, "

        if self.deletion_date is not None:
            result += f"deletion_date={repr(self.deletion_date)}, "

        if self.valid_to is not None:
            result += f"valid_to={repr(self.valid_to)}, "

        if self.origin is not None:
            result += f"origin={repr(self.origin)}, "

        if self.custom_key_store_id is not None:
            result += f"custom_key_store_id={repr(self.custom_key_store_id)}, "

        if self.cloud_hsm_cluster_id is not None:
            result += f"cloud_hsm_cluster_id={repr(self.cloud_hsm_cluster_id)}, "

        if self.expiration_model is not None:
            result += f"expiration_model={repr(self.expiration_model)}, "

        if self.key_manager is not None:
            result += f"key_manager={repr(self.key_manager)}, "

        if self.customer_master_key_spec is not None:
            result += f"customer_master_key_spec={repr(self.customer_master_key_spec)}, "

        if self.key_spec is not None:
            result += f"key_spec={repr(self.key_spec)}, "

        if self.encryption_algorithms is not None:
            result += f"encryption_algorithms={repr(self.encryption_algorithms)}, "

        if self.signing_algorithms is not None:
            result += f"signing_algorithms={repr(self.signing_algorithms)}, "

        if self.multi_region is not None:
            result += f"multi_region={repr(self.multi_region)}, "

        if self.multi_region_configuration is not None:
            result += f"multi_region_configuration={repr(self.multi_region_configuration)}, "

        if self.pending_deletion_window_in_days is not None:
            result += f"pending_deletion_window_in_days={repr(self.pending_deletion_window_in_days)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, KeyMetadata):
            return False
        attributes: list[str] = ['aws_account_id','key_id','arn','creation_date','enabled','description','key_usage','key_state','deletion_date','valid_to','origin','custom_key_store_id','cloud_hsm_cluster_id','expiration_model','key_manager','customer_master_key_spec','key_spec','encryption_algorithms','signing_algorithms','multi_region','multi_region_configuration','pending_deletion_window_in_days',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class CreateKeyResponse:
    key_metadata: Optional[KeyMetadata]
    def __init__(
        self,
        *,
        key_metadata: Optional[KeyMetadata] = None,
    ):
        """
        :param key_metadata: <p>Metadata associated with the KMS key.</p>
        """
        self.key_metadata = key_metadata

    def as_dict(self) -> Dict[str, Any]:
        """Converts the CreateKeyResponse to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        d: Dict[str, Any] = {}

        if self.key_metadata is not None:
            d["KeyMetadata"] = self.key_metadata.as_dict()

        return d

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "CreateKeyResponse":
        """Creates a CreateKeyResponse from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {}

        if "KeyMetadata" in d:
            kwargs["key_metadata"] = KeyMetadata.from_dict(d["KeyMetadata"])

        return CreateKeyResponse(**kwargs)

    def __repr__(self) -> str:
        result = "CreateKeyResponse("
        if self.key_metadata is not None:
            result += f"key_metadata={repr(self.key_metadata)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, CreateKeyResponse):
            return False
        attributes: list[str] = ['key_metadata',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class CustomKeyStoresListEntry:
    custom_key_store_id: Optional[str]
    custom_key_store_name: Optional[str]
    cloud_hsm_cluster_id: Optional[str]
    trust_anchor_certificate: Optional[str]
    connection_state: Optional[str]
    connection_error_code: Optional[str]
    creation_date: int
    def __init__(
        self,
        *,
        custom_key_store_id: Optional[str] = None,
        custom_key_store_name: Optional[str] = None,
        cloud_hsm_cluster_id: Optional[str] = None,
        trust_anchor_certificate: Optional[str] = None,
        connection_state: Optional[str] = None,
        connection_error_code: Optional[str] = None,
        creation_date: int = 0,
    ):
        """<p>Contains information about each custom key store in the custom key store
        list.</p>

        :param custom_key_store_id: <p>A unique identifier for the custom key store.</p>
        :param custom_key_store_name: <p>The user-specified friendly name for the custom
        key store.</p>
        :param cloud_hsm_cluster_id: <p>A unique identifier for the CloudHSM cluster
        that is associated with the custom key
              store.</p>
        :param trust_anchor_certificate: <p>The trust anchor certificate of the
        associated CloudHSM cluster. When you <a
        href="https://docs.aws.amazon.com/cloudhsm/latest/userguide/initialize-cluster.html#sign-csr">initialize
        the
                cluster</a>, you create this certificate and save it in the
        <code>customerCA.crt</code>
              file.</p>
        :param connection_state: <p>Indicates whether the custom key store is connected
        to its CloudHSM cluster.</p>
                 <p>You can create and use KMS keys in your
        custom key stores only when its connection state
              is
        <code>CONNECTED</code>.</p>
                 <p>The value is <code>DISCONNECTED</code>
        if the key store has never been connected or you
              use the
        <a>DisconnectCustomKeyStore</a> operation to disconnect it. If the value is

        <code>CONNECTED</code> but you are having trouble using the custom key store,
        make sure that
              its associated CloudHSM cluster is active and contains at
        least one active HSM.</p>
                 <p>A value of <code>FAILED</code> indicates
        that an attempt to connect was unsuccessful. The

        <code>ConnectionErrorCode</code> field in the response indicates the cause of
        the failure.
              For help resolving a connection failure, see <a
        href="https://docs.aws.amazon.com/kms/latest/developerguide/fix-keystore.html">Troubleshooting
        a Custom Key Store</a> in the
              <i>Key Management Service Developer
        Guide</i>.</p>
        :param connection_error_code: <p>Describes the connection error. This field
        appears in the response only when the
                <code>ConnectionState</code> is
        <code>FAILED</code>. For help resolving these errors, see
                <a
        href="https://docs.aws.amazon.com/kms/latest/developerguide/fix-keystore.html#fix-keystore-failed">How
        to
                Fix a Connection Failure</a> in <i>Key Management Service Developer
        Guide</i>.</p>
                 <p>Valid values are:</p>
                 <ul>
                    <li>

        <p>
                          <code>CLUSTER_NOT_FOUND</code> - KMS cannot find the
        CloudHSM cluster with the
                  specified cluster ID.</p>
                    </li>

        <li>
                       <p>

        <code>INSUFFICIENT_CLOUDHSM_HSMS</code> - The associated CloudHSM cluster does
        not
                  contain any active HSMs. To connect a custom key store to its
        CloudHSM cluster, the cluster
                  must contain at least one active
        HSM.</p>
                    </li>
                    <li>
                       <p>

        <code>INTERNAL_ERROR</code> - KMS could not complete the request due to an
        internal
                  error. Retry the request. For
        <code>ConnectCustomKeyStore</code> requests, disconnect the
                  custom key
        store before trying to connect again.</p>
                    </li>
                    <li>

        <p>
                          <code>INVALID_CREDENTIALS</code> - KMS does not have the
        correct password for the
                    <code>kmsuser</code> crypto user in the
        CloudHSM cluster. Before you can connect your
                  custom key store to its
        CloudHSM cluster, you must change the <code>kmsuser</code> account

        password and update the key store password value for the custom key store.</p>

        </li>
                    <li>
                       <p>

        <code>NETWORK_ERRORS</code> - Network errors are preventing KMS from connecting
        to
                  the custom key store.</p>
                    </li>
                    <li>

        <p>
                          <code>SUBNET_NOT_FOUND</code> - A subnet in the CloudHSM
        cluster configuration was
                  deleted. If KMS cannot find all of the
        subnets in the cluster configuration, attempts to
                  connect the custom
        key store to the CloudHSM cluster fail. To fix this error, create a

        cluster from a recent backup and associate it with your custom key store. (This
        process
                  creates a new cluster configuration with a VPC and private
        subnets.) For details, see
                    <a
        href="https://docs.aws.amazon.com/kms/latest/developerguide/fix-keystore.html#fix-keystore-failed">How

        to Fix a Connection Failure</a> in the <i>Key Management Service Developer
        Guide</i>.</p>
                    </li>
                    <li>
                       <p>

        <code>USER_LOCKED_OUT</code> - The <code>kmsuser</code> CU account is locked out
        of
                  the associated CloudHSM cluster due to too many failed password
        attempts. Before you can
                  connect your custom key store to its CloudHSM
        cluster, you must change the
                    <code>kmsuser</code> account password
        and update the key store password value for the
                  custom key store.</p>

        </li>
                    <li>
                       <p>

        <code>USER_LOGGED_IN</code> - The <code>kmsuser</code> CU account is logged into
        the
                  the associated CloudHSM cluster. This prevents KMS from rotating
        the <code>kmsuser</code>
                  account password and logging into the
        cluster. Before you can connect your custom key
                  store to its CloudHSM
        cluster, you must log the <code>kmsuser</code> CU out of the cluster.

        If you changed the <code>kmsuser</code> password to log into the cluster, you
        must also
                  and update the key store password value for the custom key
        store. For help, see <a
        href="https://docs.aws.amazon.com/kms/latest/developerguide/fix-keystore.html#login-kmsuser-2">How
        to Log Out
                    and Reconnect</a> in the <i>Key Management Service
        Developer Guide</i>.</p>
                    </li>
                    <li>
                       <p>

        <code>USER_NOT_FOUND</code> - KMS cannot find a <code>kmsuser</code> CU account
        in
                  the associated CloudHSM cluster. Before you can connect your custom
        key store to its CloudHSM
                  cluster, you must create a
        <code>kmsuser</code> CU account in the cluster, and then update
                  the
        key store password value for the custom key store.</p>
                    </li>

        </ul>
        :param creation_date: <p>The date and time when the custom key store was
        created.</p>
        """
        self.custom_key_store_id = custom_key_store_id
        self.custom_key_store_name = custom_key_store_name
        self.cloud_hsm_cluster_id = cloud_hsm_cluster_id
        self.trust_anchor_certificate = trust_anchor_certificate
        self.connection_state = connection_state
        self.connection_error_code = connection_error_code
        self.creation_date = creation_date

    def as_dict(self) -> Dict[str, Any]:
        """Converts the CustomKeyStoresListEntry to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        d: Dict[str, Any] = {}

        if self.custom_key_store_id is not None:
            d["CustomKeyStoreId"] = self.custom_key_store_id

        if self.custom_key_store_name is not None:
            d["CustomKeyStoreName"] = self.custom_key_store_name

        if self.cloud_hsm_cluster_id is not None:
            d["CloudHsmClusterId"] = self.cloud_hsm_cluster_id

        if self.trust_anchor_certificate is not None:
            d["TrustAnchorCertificate"] = self.trust_anchor_certificate

        if self.connection_state is not None:
            d["ConnectionState"] = self.connection_state

        if self.connection_error_code is not None:
            d["ConnectionErrorCode"] = self.connection_error_code

        if self.creation_date is not None:
            d["CreationDate"] = self.creation_date

        return d

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "CustomKeyStoresListEntry":
        """Creates a CustomKeyStoresListEntry from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {}

        if "CustomKeyStoreId" in d:
            kwargs["custom_key_store_id"] = d["CustomKeyStoreId"]

        if "CustomKeyStoreName" in d:
            kwargs["custom_key_store_name"] = d["CustomKeyStoreName"]

        if "CloudHsmClusterId" in d:
            kwargs["cloud_hsm_cluster_id"] = d["CloudHsmClusterId"]

        if "TrustAnchorCertificate" in d:
            kwargs["trust_anchor_certificate"] = d["TrustAnchorCertificate"]

        if "ConnectionState" in d:
            kwargs["connection_state"] = d["ConnectionState"]

        if "ConnectionErrorCode" in d:
            kwargs["connection_error_code"] = d["ConnectionErrorCode"]

        if "CreationDate" in d:
            kwargs["creation_date"] = d["CreationDate"]

        return CustomKeyStoresListEntry(**kwargs)

    def __repr__(self) -> str:
        result = "CustomKeyStoresListEntry("
        if self.custom_key_store_id is not None:
            result += f"custom_key_store_id={repr(self.custom_key_store_id)}, "

        if self.custom_key_store_name is not None:
            result += f"custom_key_store_name={repr(self.custom_key_store_name)}, "

        if self.cloud_hsm_cluster_id is not None:
            result += f"cloud_hsm_cluster_id={repr(self.cloud_hsm_cluster_id)}, "

        if self.trust_anchor_certificate is not None:
            result += f"trust_anchor_certificate={repr(self.trust_anchor_certificate)}, "

        if self.connection_state is not None:
            result += f"connection_state={repr(self.connection_state)}, "

        if self.connection_error_code is not None:
            result += f"connection_error_code={repr(self.connection_error_code)}, "

        if self.creation_date is not None:
            result += f"creation_date={repr(self.creation_date)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, CustomKeyStoresListEntry):
            return False
        attributes: list[str] = ['custom_key_store_id','custom_key_store_name','cloud_hsm_cluster_id','trust_anchor_certificate','connection_state','connection_error_code','creation_date',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class DecryptRequest:
    ciphertext_blob: bytes | bytearray
    encryption_context: Optional[dict[str, str]]
    grant_tokens: Optional[list[str]]
    key_id: Optional[str]
    encryption_algorithm: Optional[str]
    def __init__(
        self,
        *,
        ciphertext_blob: bytes | bytearray,
        encryption_context: Optional[dict[str, str]] = None,
        grant_tokens: Optional[list[str]] = None,
        key_id: Optional[str] = None,
        encryption_algorithm: Optional[str] = None,
    ):
        """
        :param ciphertext_blob: <p>Ciphertext to be decrypted. The blob includes
        metadata.</p>
        :param encryption_context: <p>Specifies the encryption context to use when
        decrypting the data.
              An encryption context is valid only for <a
        href="https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#cryptographic-operations">cryptographic
        operations</a> with a symmetric KMS key. The standard asymmetric encryption
        algorithms that KMS uses do not support an encryption context.</p>

        <p>An <i>encryption context</i> is a collection of non-secret key-value pairs
        that represents additional authenticated data. When you use an encryption
        context to encrypt data, you must specify the same (an exact case-sensitive
        match) encryption context to decrypt the data. An encryption context is optional
        when encrypting with a symmetric KMS key, but it is highly recommended.</p>

        <p>For more information, see
                <a
        href="https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#encrypt_context">Encryption

        Context</a> in the <i>Key Management Service Developer Guide</i>.</p>
        :param grant_tokens: <p>A list of grant tokens. </p>
                 <p>Use a grant
        token when your permission to call this operation comes from a new grant that
        has not yet achieved <i>eventual consistency</i>. For more information, see <a
        href="https://docs.aws.amazon.com/kms/latest/developerguide/grants.html#grant_token">Grant
        token</a> and <a
        href="https://docs.aws.amazon.com/kms/latest/developerguide/grant-manage.html#using-grant-token">Using
        a grant token</a> in the
            <i>Key Management Service Developer Guide</i>.</p>
        :param key_id: <p>Specifies the KMS key that KMS uses to decrypt the ciphertext.
        Enter a key ID of the KMS
              key that was used to encrypt the ciphertext.
        </p>

                 <p>This parameter is required only when the ciphertext was
        encrypted under an asymmetric KMS
              key. If you used a symmetric KMS key,
        KMS can get the KMS key from metadata that it adds to
              the symmetric
        ciphertext blob. However, it is always recommended as a best practice. This

        practice ensures that you use the KMS key that you intend.</p>

        <p>To specify a KMS key, use its key ID, key ARN, alias name, or alias ARN. When
        using an alias name, prefix it with <code>"alias/"</code>. To specify a KMS key
        in a different Amazon Web Services account, you must use the key ARN or alias
        ARN.</p>
                 <p>For example:</p>
                 <ul>
                    <li>

        <p>Key ID: <code>1234abcd-12ab-34cd-56ef-1234567890ab</code>

        </p>
                    </li>
                    <li>
                       <p>Key ARN:
        <code>arn:aws:kms:us-east-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab</code>

        </p>
                    </li>
                    <li>
                       <p>Alias name:
        <code>alias/ExampleAlias</code>
                       </p>
                    </li>

        <li>
                       <p>Alias ARN:
        <code>arn:aws:kms:us-east-2:111122223333:alias/ExampleAlias</code>

        </p>
                    </li>
                 </ul>
                 <p>To get the key ID and key ARN
        for a KMS key, use <a>ListKeys</a> or <a>DescribeKey</a>. To get the alias name
        and alias ARN, use <a>ListAliases</a>.</p>
        :param encryption_algorithm: <p>Specifies the encryption algorithm that will be
        used to decrypt the ciphertext. Specify
              the same algorithm that was used
        to encrypt the data. If you specify a different algorithm,
              the
        <code>Decrypt</code> operation fails.</p>
                 <p>This parameter is required
        only when the ciphertext was encrypted under an asymmetric KMS
              key. The
        default value, <code>SYMMETRIC_DEFAULT</code>, represents the only supported

        algorithm that is valid for symmetric KMS keys.</p>
        """
        self.ciphertext_blob = ciphertext_blob
        self.encryption_context = encryption_context
        self.grant_tokens = grant_tokens
        self.key_id = key_id
        self.encryption_algorithm = encryption_algorithm

    def as_dict(self) -> Dict[str, Any]:
        """Converts the DecryptRequest to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        d: Dict[str, Any] = {
            "CiphertextBlob": self.ciphertext_blob,
        }

        if self.encryption_context is not None:
            d["EncryptionContext"] = self.encryption_context

        if self.grant_tokens is not None:
            d["GrantTokens"] = self.grant_tokens

        if self.key_id is not None:
            d["KeyId"] = self.key_id

        if self.encryption_algorithm is not None:
            d["EncryptionAlgorithm"] = self.encryption_algorithm

        return d

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "DecryptRequest":
        """Creates a DecryptRequest from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {
            "ciphertext_blob": d["CiphertextBlob"],
        }

        if "EncryptionContext" in d:
            kwargs["encryption_context"] = d["EncryptionContext"]

        if "GrantTokens" in d:
            kwargs["grant_tokens"] = d["GrantTokens"]

        if "KeyId" in d:
            kwargs["key_id"] = d["KeyId"]

        if "EncryptionAlgorithm" in d:
            kwargs["encryption_algorithm"] = d["EncryptionAlgorithm"]

        return DecryptRequest(**kwargs)

    def __repr__(self) -> str:
        result = "DecryptRequest("
        if self.ciphertext_blob is not None:
            result += f"ciphertext_blob={repr(self.ciphertext_blob)}, "

        if self.encryption_context is not None:
            result += f"encryption_context={repr(self.encryption_context)}, "

        if self.grant_tokens is not None:
            result += f"grant_tokens={repr(self.grant_tokens)}, "

        if self.key_id is not None:
            result += f"key_id={repr(self.key_id)}, "

        if self.encryption_algorithm is not None:
            result += f"encryption_algorithm={repr(self.encryption_algorithm)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, DecryptRequest):
            return False
        attributes: list[str] = ['ciphertext_blob','encryption_context','grant_tokens','key_id','encryption_algorithm',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class DecryptResponse:
    key_id: Optional[str]
    plaintext: Optional[bytes | bytearray]
    encryption_algorithm: Optional[str]
    def __init__(
        self,
        *,
        key_id: Optional[str] = None,
        plaintext: Optional[bytes | bytearray] = None,
        encryption_algorithm: Optional[str] = None,
    ):
        """
        :param key_id: <p>The Amazon Resource Name (<a
        href="https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#key-id-key-ARN">key
        ARN</a>) of the KMS key that was used to decrypt the ciphertext.</p>
        :param plaintext: <p>Decrypted plaintext data. When you use the HTTP API or the
        Amazon Web Services CLI, the value is Base64-encoded. Otherwise, it is not
        Base64-encoded.</p>
        :param encryption_algorithm: <p>The encryption algorithm that was used to
        decrypt the ciphertext.</p>
        """
        self.key_id = key_id
        self.plaintext = plaintext
        self.encryption_algorithm = encryption_algorithm

    def as_dict(self) -> Dict[str, Any]:
        """Converts the DecryptResponse to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        d: Dict[str, Any] = {}

        if self.key_id is not None:
            d["KeyId"] = self.key_id

        if self.plaintext is not None:
            d["Plaintext"] = self.plaintext

        if self.encryption_algorithm is not None:
            d["EncryptionAlgorithm"] = self.encryption_algorithm

        return d

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "DecryptResponse":
        """Creates a DecryptResponse from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {}

        if "KeyId" in d:
            kwargs["key_id"] = d["KeyId"]

        if "Plaintext" in d:
            kwargs["plaintext"] = d["Plaintext"]

        if "EncryptionAlgorithm" in d:
            kwargs["encryption_algorithm"] = d["EncryptionAlgorithm"]

        return DecryptResponse(**kwargs)

    def __repr__(self) -> str:
        result = "DecryptResponse("
        if self.key_id is not None:
            result += f"key_id={repr(self.key_id)}, "

        if self.plaintext is not None:
            result += f"plaintext={repr(self.plaintext)}, "

        if self.encryption_algorithm is not None:
            result += f"encryption_algorithm={repr(self.encryption_algorithm)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, DecryptResponse):
            return False
        attributes: list[str] = ['key_id','plaintext','encryption_algorithm',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class DeleteAliasRequest:
    alias_name: str
    def __init__(
        self,
        *,
        alias_name: str,
    ):
        """
        :param alias_name: <p>The alias to be deleted. The alias name must begin with
        <code>alias/</code> followed by
              the alias name, such as
        <code>alias/ExampleAlias</code>.</p>
        """
        self.alias_name = alias_name

    def as_dict(self) -> Dict[str, Any]:
        """Converts the DeleteAliasRequest to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        return {
            "AliasName": self.alias_name,
        }

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "DeleteAliasRequest":
        """Creates a DeleteAliasRequest from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {
            "alias_name": d["AliasName"],
        }

        return DeleteAliasRequest(**kwargs)

    def __repr__(self) -> str:
        result = "DeleteAliasRequest("
        if self.alias_name is not None:
            result += f"alias_name={repr(self.alias_name)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, DeleteAliasRequest):
            return False
        attributes: list[str] = ['alias_name',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class DeleteCustomKeyStoreRequest:
    custom_key_store_id: str
    def __init__(
        self,
        *,
        custom_key_store_id: str,
    ):
        """
        :param custom_key_store_id: <p>Enter the ID of the custom key store you want to
        delete. To find the ID of a custom key store, use the
        <a>DescribeCustomKeyStores</a> operation.</p>
        """
        self.custom_key_store_id = custom_key_store_id

    def as_dict(self) -> Dict[str, Any]:
        """Converts the DeleteCustomKeyStoreRequest to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        return {
            "CustomKeyStoreId": self.custom_key_store_id,
        }

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "DeleteCustomKeyStoreRequest":
        """Creates a DeleteCustomKeyStoreRequest from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {
            "custom_key_store_id": d["CustomKeyStoreId"],
        }

        return DeleteCustomKeyStoreRequest(**kwargs)

    def __repr__(self) -> str:
        result = "DeleteCustomKeyStoreRequest("
        if self.custom_key_store_id is not None:
            result += f"custom_key_store_id={repr(self.custom_key_store_id)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, DeleteCustomKeyStoreRequest):
            return False
        attributes: list[str] = ['custom_key_store_id',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class DeleteCustomKeyStoreResponse:
    def as_dict(self) -> Dict[str, Any]:
        """Converts the DeleteCustomKeyStoreResponse to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        return {}

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "DeleteCustomKeyStoreResponse":
        """Creates a DeleteCustomKeyStoreResponse from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        return DeleteCustomKeyStoreResponse()

    def __repr__(self) -> str:
        result = "DeleteCustomKeyStoreResponse("

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        return isinstance(other, DeleteCustomKeyStoreResponse)

class DeleteImportedKeyMaterialRequest:
    key_id: str
    def __init__(
        self,
        *,
        key_id: str,
    ):
        """
        :param key_id: <p>Identifies the KMS key from which you are deleting imported
        key material. The
                <code>Origin</code> of the KMS key must be
        <code>EXTERNAL</code>.</p>

                 <p>Specify the key ID or key ARN of the
        KMS key.</p>
                 <p>For example:</p>
                 <ul>
                    <li>

        <p>Key ID: <code>1234abcd-12ab-34cd-56ef-1234567890ab</code>

        </p>
                    </li>
                    <li>
                       <p>Key ARN:
        <code>arn:aws:kms:us-east-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab</code>

        </p>
                    </li>
                 </ul>
                 <p>To get the key ID and key
        ARN for a KMS key, use <a>ListKeys</a> or <a>DescribeKey</a>.</p>
        """
        self.key_id = key_id

    def as_dict(self) -> Dict[str, Any]:
        """Converts the DeleteImportedKeyMaterialRequest to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        return {
            "KeyId": self.key_id,
        }

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "DeleteImportedKeyMaterialRequest":
        """Creates a DeleteImportedKeyMaterialRequest from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {
            "key_id": d["KeyId"],
        }

        return DeleteImportedKeyMaterialRequest(**kwargs)

    def __repr__(self) -> str:
        result = "DeleteImportedKeyMaterialRequest("
        if self.key_id is not None:
            result += f"key_id={repr(self.key_id)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, DeleteImportedKeyMaterialRequest):
            return False
        attributes: list[str] = ['key_id',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class DescribeCustomKeyStoresRequest:
    custom_key_store_id: Optional[str]
    custom_key_store_name: Optional[str]
    limit: Optional[int]
    marker: Optional[str]
    def __init__(
        self,
        *,
        custom_key_store_id: Optional[str] = None,
        custom_key_store_name: Optional[str] = None,
        limit: Optional[int] = None,
        marker: Optional[str] = None,
    ):
        """
        :param custom_key_store_id: <p>Gets only information about the specified custom
        key store. Enter the key store ID.</p>
                 <p>By default, this operation
        gets information about all custom key stores in the account and
              Region. To
        limit the output to a particular custom key store, you can use either the

        <code>CustomKeyStoreId</code> or <code>CustomKeyStoreName</code> parameter, but
        not
              both.</p>
        :param custom_key_store_name: <p>Gets only information about the specified
        custom key store. Enter the friendly name of the
              custom key store.</p>

        <p>By default, this operation gets information about all custom key stores in
        the account and
              Region. To limit the output to a particular custom key
        store, you can use either the
                <code>CustomKeyStoreId</code> or
        <code>CustomKeyStoreName</code> parameter, but not
              both.</p>
        :param limit: <p>Use this parameter to specify the maximum number of items to
        return. When this
            value is present, KMS does not return more than the
        specified number of items, but it might
            return fewer.</p>
        :param marker: <p>Use this parameter in a subsequent request after you receive a
        response with
            truncated results. Set it to the value of
        <code>NextMarker</code> from the truncated response
            you just received.</p>
        """
        self.custom_key_store_id = custom_key_store_id
        self.custom_key_store_name = custom_key_store_name
        self.limit = limit
        self.marker = marker

    def as_dict(self) -> Dict[str, Any]:
        """Converts the DescribeCustomKeyStoresRequest to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        d: Dict[str, Any] = {}

        if self.custom_key_store_id is not None:
            d["CustomKeyStoreId"] = self.custom_key_store_id

        if self.custom_key_store_name is not None:
            d["CustomKeyStoreName"] = self.custom_key_store_name

        if self.limit is not None:
            d["Limit"] = self.limit

        if self.marker is not None:
            d["Marker"] = self.marker

        return d

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "DescribeCustomKeyStoresRequest":
        """Creates a DescribeCustomKeyStoresRequest from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {}

        if "CustomKeyStoreId" in d:
            kwargs["custom_key_store_id"] = d["CustomKeyStoreId"]

        if "CustomKeyStoreName" in d:
            kwargs["custom_key_store_name"] = d["CustomKeyStoreName"]

        if "Limit" in d:
            kwargs["limit"] = d["Limit"]

        if "Marker" in d:
            kwargs["marker"] = d["Marker"]

        return DescribeCustomKeyStoresRequest(**kwargs)

    def __repr__(self) -> str:
        result = "DescribeCustomKeyStoresRequest("
        if self.custom_key_store_id is not None:
            result += f"custom_key_store_id={repr(self.custom_key_store_id)}, "

        if self.custom_key_store_name is not None:
            result += f"custom_key_store_name={repr(self.custom_key_store_name)}, "

        if self.limit is not None:
            result += f"limit={repr(self.limit)}, "

        if self.marker is not None:
            result += f"marker={repr(self.marker)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, DescribeCustomKeyStoresRequest):
            return False
        attributes: list[str] = ['custom_key_store_id','custom_key_store_name','limit','marker',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class DescribeCustomKeyStoresResponse:
    custom_key_stores: Optional[list[CustomKeyStoresListEntry]]
    next_marker: Optional[str]
    truncated: bool
    def __init__(
        self,
        *,
        custom_key_stores: Optional[list[CustomKeyStoresListEntry]] = None,
        next_marker: Optional[str] = None,
        truncated: bool = False,
    ):
        """
        :param custom_key_stores: <p>Contains metadata about each custom key store.</p>
        :param next_marker: <p>When <code>Truncated</code> is true, this element is
        present and contains the
            value to use for the <code>Marker</code> parameter
        in a subsequent request.</p>
        :param truncated: <p>A flag that indicates whether there are more items in the
        list. When this
            value is true, the list in this response is truncated. To
        get more items, pass the value of
            the <code>NextMarker</code> element in
        thisresponse to the <code>Marker</code> parameter in a
            subsequent
        request.</p>
        """
        self.custom_key_stores = custom_key_stores
        self.next_marker = next_marker
        self.truncated = truncated

    def as_dict(self) -> Dict[str, Any]:
        """Converts the DescribeCustomKeyStoresResponse to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        d: Dict[str, Any] = {}

        if self.custom_key_stores is not None:
            d["CustomKeyStores"] = _custom_key_stores_list_as_dict(self.custom_key_stores),

        if self.next_marker is not None:
            d["NextMarker"] = self.next_marker

        if self.truncated is not None:
            d["Truncated"] = self.truncated

        return d

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "DescribeCustomKeyStoresResponse":
        """Creates a DescribeCustomKeyStoresResponse from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {}

        if "CustomKeyStores" in d:
            kwargs["custom_key_stores"] = _custom_key_stores_list_from_dict(d["CustomKeyStores"]),

        if "NextMarker" in d:
            kwargs["next_marker"] = d["NextMarker"]

        if "Truncated" in d:
            kwargs["truncated"] = d["Truncated"]

        return DescribeCustomKeyStoresResponse(**kwargs)

    def __repr__(self) -> str:
        result = "DescribeCustomKeyStoresResponse("
        if self.custom_key_stores is not None:
            result += f"custom_key_stores={repr(self.custom_key_stores)}, "

        if self.next_marker is not None:
            result += f"next_marker={repr(self.next_marker)}, "

        if self.truncated is not None:
            result += f"truncated={repr(self.truncated)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, DescribeCustomKeyStoresResponse):
            return False
        attributes: list[str] = ['custom_key_stores','next_marker','truncated',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class DescribeKeyRequest:
    key_id: str
    grant_tokens: Optional[list[str]]
    def __init__(
        self,
        *,
        key_id: str,
        grant_tokens: Optional[list[str]] = None,
    ):
        """
        :param key_id: <p>Describes the specified KMS key. </p>
                 <p>If you
        specify a predefined Amazon Web Services alias (an Amazon Web Services alias
        with no key ID), KMS associates
              the alias with an <a
        href="https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html##aws-managed-cmk">Amazon
        Web Services managed key</a> and returns its
                <code>KeyId</code> and
        <code>Arn</code> in the response.</p>

                 <p>To specify a KMS key, use
        its key ID, key ARN, alias name, or alias ARN. When using an alias name, prefix
        it with <code>"alias/"</code>. To specify a KMS key in a different Amazon Web
        Services account, you must use the key ARN or alias ARN.</p>
                 <p>For
        example:</p>
                 <ul>
                    <li>
                       <p>Key ID:
        <code>1234abcd-12ab-34cd-56ef-1234567890ab</code>
                       </p>

        </li>
                    <li>
                       <p>Key ARN:
        <code>arn:aws:kms:us-east-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab</code>

        </p>
                    </li>
                    <li>
                       <p>Alias name:
        <code>alias/ExampleAlias</code>
                       </p>
                    </li>

        <li>
                       <p>Alias ARN:
        <code>arn:aws:kms:us-east-2:111122223333:alias/ExampleAlias</code>

        </p>
                    </li>
                 </ul>
                 <p>To get the key ID and key ARN
        for a KMS key, use <a>ListKeys</a> or <a>DescribeKey</a>. To get the alias name
        and alias ARN, use <a>ListAliases</a>.</p>
        :param grant_tokens: <p>A list of grant tokens.</p>
                 <p>Use a grant
        token when your permission to call this operation comes from a new grant that
        has not yet achieved <i>eventual consistency</i>. For more information, see <a
        href="https://docs.aws.amazon.com/kms/latest/developerguide/grants.html#grant_token">Grant
        token</a> and <a
        href="https://docs.aws.amazon.com/kms/latest/developerguide/grant-manage.html#using-grant-token">Using
        a grant token</a> in the
            <i>Key Management Service Developer Guide</i>.</p>
        """
        self.key_id = key_id
        self.grant_tokens = grant_tokens

    def as_dict(self) -> Dict[str, Any]:
        """Converts the DescribeKeyRequest to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        d: Dict[str, Any] = {
            "KeyId": self.key_id,
        }

        if self.grant_tokens is not None:
            d["GrantTokens"] = self.grant_tokens

        return d

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "DescribeKeyRequest":
        """Creates a DescribeKeyRequest from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {
            "key_id": d["KeyId"],
        }

        if "GrantTokens" in d:
            kwargs["grant_tokens"] = d["GrantTokens"]

        return DescribeKeyRequest(**kwargs)

    def __repr__(self) -> str:
        result = "DescribeKeyRequest("
        if self.key_id is not None:
            result += f"key_id={repr(self.key_id)}, "

        if self.grant_tokens is not None:
            result += f"grant_tokens={repr(self.grant_tokens)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, DescribeKeyRequest):
            return False
        attributes: list[str] = ['key_id','grant_tokens',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class DescribeKeyResponse:
    key_metadata: Optional[KeyMetadata]
    def __init__(
        self,
        *,
        key_metadata: Optional[KeyMetadata] = None,
    ):
        """
        :param key_metadata: <p>Metadata associated with the key.</p>
        """
        self.key_metadata = key_metadata

    def as_dict(self) -> Dict[str, Any]:
        """Converts the DescribeKeyResponse to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        d: Dict[str, Any] = {}

        if self.key_metadata is not None:
            d["KeyMetadata"] = self.key_metadata.as_dict()

        return d

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "DescribeKeyResponse":
        """Creates a DescribeKeyResponse from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {}

        if "KeyMetadata" in d:
            kwargs["key_metadata"] = KeyMetadata.from_dict(d["KeyMetadata"])

        return DescribeKeyResponse(**kwargs)

    def __repr__(self) -> str:
        result = "DescribeKeyResponse("
        if self.key_metadata is not None:
            result += f"key_metadata={repr(self.key_metadata)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, DescribeKeyResponse):
            return False
        attributes: list[str] = ['key_metadata',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class DisableKeyRequest:
    key_id: str
    def __init__(
        self,
        *,
        key_id: str,
    ):
        """
        :param key_id: <p>Identifies the KMS key to disable.</p>
                 <p>Specify
        the key ID or key ARN of the KMS key.</p>
                 <p>For example:</p>

        <ul>
                    <li>
                       <p>Key ID:
        <code>1234abcd-12ab-34cd-56ef-1234567890ab</code>
                       </p>

        </li>
                    <li>
                       <p>Key ARN:
        <code>arn:aws:kms:us-east-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab</code>

        </p>
                    </li>
                 </ul>
                 <p>To get the key ID and key
        ARN for a KMS key, use <a>ListKeys</a> or <a>DescribeKey</a>.</p>
        """
        self.key_id = key_id

    def as_dict(self) -> Dict[str, Any]:
        """Converts the DisableKeyRequest to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        return {
            "KeyId": self.key_id,
        }

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "DisableKeyRequest":
        """Creates a DisableKeyRequest from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {
            "key_id": d["KeyId"],
        }

        return DisableKeyRequest(**kwargs)

    def __repr__(self) -> str:
        result = "DisableKeyRequest("
        if self.key_id is not None:
            result += f"key_id={repr(self.key_id)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, DisableKeyRequest):
            return False
        attributes: list[str] = ['key_id',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class DisableKeyRotationRequest:
    key_id: str
    def __init__(
        self,
        *,
        key_id: str,
    ):
        """
        :param key_id: <p>Identifies a symmetric KMS key. You cannot enable or disable
        automatic rotation of <a
        href="https://docs.aws.amazon.com/kms/latest/developerguide/symmetric-asymmetric.html#asymmetric-cmks">asymmetric

        KMS keys</a>, KMS keys with <a
        href="https://docs.aws.amazon.com/kms/latest/developerguide/importing-keys.html">imported
        key material</a>, or KMS keys in a
              <a
        href="https://docs.aws.amazon.com/kms/latest/developerguide/custom-key-store-overview.html">custom
        key store</a>.</p>
                 <p>Specify the key ID or key ARN of the KMS
        key.</p>
                 <p>For example:</p>
                 <ul>
                    <li>

        <p>Key ID: <code>1234abcd-12ab-34cd-56ef-1234567890ab</code>

        </p>
                    </li>
                    <li>
                       <p>Key ARN:
        <code>arn:aws:kms:us-east-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab</code>

        </p>
                    </li>
                 </ul>
                 <p>To get the key ID and key
        ARN for a KMS key, use <a>ListKeys</a> or <a>DescribeKey</a>.</p>
        """
        self.key_id = key_id

    def as_dict(self) -> Dict[str, Any]:
        """Converts the DisableKeyRotationRequest to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        return {
            "KeyId": self.key_id,
        }

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "DisableKeyRotationRequest":
        """Creates a DisableKeyRotationRequest from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {
            "key_id": d["KeyId"],
        }

        return DisableKeyRotationRequest(**kwargs)

    def __repr__(self) -> str:
        result = "DisableKeyRotationRequest("
        if self.key_id is not None:
            result += f"key_id={repr(self.key_id)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, DisableKeyRotationRequest):
            return False
        attributes: list[str] = ['key_id',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class DisconnectCustomKeyStoreRequest:
    custom_key_store_id: str
    def __init__(
        self,
        *,
        custom_key_store_id: str,
    ):
        """
        :param custom_key_store_id: <p>Enter the ID of the custom key store you want to
        disconnect. To find the ID of a custom key store, use the
        <a>DescribeCustomKeyStores</a> operation.</p>
        """
        self.custom_key_store_id = custom_key_store_id

    def as_dict(self) -> Dict[str, Any]:
        """Converts the DisconnectCustomKeyStoreRequest to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        return {
            "CustomKeyStoreId": self.custom_key_store_id,
        }

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "DisconnectCustomKeyStoreRequest":
        """Creates a DisconnectCustomKeyStoreRequest from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {
            "custom_key_store_id": d["CustomKeyStoreId"],
        }

        return DisconnectCustomKeyStoreRequest(**kwargs)

    def __repr__(self) -> str:
        result = "DisconnectCustomKeyStoreRequest("
        if self.custom_key_store_id is not None:
            result += f"custom_key_store_id={repr(self.custom_key_store_id)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, DisconnectCustomKeyStoreRequest):
            return False
        attributes: list[str] = ['custom_key_store_id',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class DisconnectCustomKeyStoreResponse:
    def as_dict(self) -> Dict[str, Any]:
        """Converts the DisconnectCustomKeyStoreResponse to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        return {}

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "DisconnectCustomKeyStoreResponse":
        """Creates a DisconnectCustomKeyStoreResponse from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        return DisconnectCustomKeyStoreResponse()

    def __repr__(self) -> str:
        result = "DisconnectCustomKeyStoreResponse("

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        return isinstance(other, DisconnectCustomKeyStoreResponse)

class EnableKeyRequest:
    key_id: str
    def __init__(
        self,
        *,
        key_id: str,
    ):
        """
        :param key_id: <p>Identifies the KMS key to enable.</p>
                 <p>Specify the
        key ID or key ARN of the KMS key.</p>
                 <p>For example:</p>

        <ul>
                    <li>
                       <p>Key ID:
        <code>1234abcd-12ab-34cd-56ef-1234567890ab</code>
                       </p>

        </li>
                    <li>
                       <p>Key ARN:
        <code>arn:aws:kms:us-east-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab</code>

        </p>
                    </li>
                 </ul>
                 <p>To get the key ID and key
        ARN for a KMS key, use <a>ListKeys</a> or <a>DescribeKey</a>.</p>
        """
        self.key_id = key_id

    def as_dict(self) -> Dict[str, Any]:
        """Converts the EnableKeyRequest to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        return {
            "KeyId": self.key_id,
        }

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "EnableKeyRequest":
        """Creates a EnableKeyRequest from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {
            "key_id": d["KeyId"],
        }

        return EnableKeyRequest(**kwargs)

    def __repr__(self) -> str:
        result = "EnableKeyRequest("
        if self.key_id is not None:
            result += f"key_id={repr(self.key_id)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, EnableKeyRequest):
            return False
        attributes: list[str] = ['key_id',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class EnableKeyRotationRequest:
    key_id: str
    def __init__(
        self,
        *,
        key_id: str,
    ):
        """
        :param key_id: <p>Identifies a symmetric KMS key. You cannot enable automatic
        rotation of <a
        href="https://docs.aws.amazon.com/kms/latest/developerguide/symm-asymm-concepts.html#asymmetric-cmks">asymmetric
        KMS keys</a>, KMS keys with <a
        href="https://docs.aws.amazon.com/kms/latest/developerguide/importing-keys.html">imported
        key material</a>, or KMS keys in a <a
        href="https://docs.aws.amazon.com/kms/latest/developerguide/custom-key-store-overview.html">custom
        key store</a>. To enable or disable automatic rotation of a set of related <a
        href="https://docs.aws.amazon.com/kms/latest/developerguide/multi-region-keys-overview.html#mrk-replica-key">multi-Region
        keys</a>, set the property on the primary key.</p>
                 <p>Specify the key
        ID or key ARN of the KMS key.</p>
                 <p>For example:</p>
                 <ul>

        <li>
                       <p>Key ID:
        <code>1234abcd-12ab-34cd-56ef-1234567890ab</code>
                       </p>

        </li>
                    <li>
                       <p>Key ARN:
        <code>arn:aws:kms:us-east-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab</code>

        </p>
                    </li>
                 </ul>
                 <p>To get the key ID and key
        ARN for a KMS key, use <a>ListKeys</a> or <a>DescribeKey</a>.</p>
        """
        self.key_id = key_id

    def as_dict(self) -> Dict[str, Any]:
        """Converts the EnableKeyRotationRequest to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        return {
            "KeyId": self.key_id,
        }

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "EnableKeyRotationRequest":
        """Creates a EnableKeyRotationRequest from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {
            "key_id": d["KeyId"],
        }

        return EnableKeyRotationRequest(**kwargs)

    def __repr__(self) -> str:
        result = "EnableKeyRotationRequest("
        if self.key_id is not None:
            result += f"key_id={repr(self.key_id)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, EnableKeyRotationRequest):
            return False
        attributes: list[str] = ['key_id',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class EncryptRequest:
    key_id: str
    plaintext: bytes | bytearray
    encryption_context: Optional[dict[str, str]]
    grant_tokens: Optional[list[str]]
    encryption_algorithm: Optional[str]
    def __init__(
        self,
        *,
        key_id: str,
        plaintext: bytes | bytearray,
        encryption_context: Optional[dict[str, str]] = None,
        grant_tokens: Optional[list[str]] = None,
        encryption_algorithm: Optional[str] = None,
    ):
        """
        :param key_id: <p>Identifies the KMS key to use in the encryption
        operation.</p>

                 <p>To specify a KMS key, use its key ID, key ARN,
        alias name, or alias ARN. When using an alias name, prefix it with
        <code>"alias/"</code>. To specify a KMS key in a different Amazon Web Services
        account, you must use the key ARN or alias ARN.</p>
                 <p>For
        example:</p>
                 <ul>
                    <li>
                       <p>Key ID:
        <code>1234abcd-12ab-34cd-56ef-1234567890ab</code>
                       </p>

        </li>
                    <li>
                       <p>Key ARN:
        <code>arn:aws:kms:us-east-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab</code>

        </p>
                    </li>
                    <li>
                       <p>Alias name:
        <code>alias/ExampleAlias</code>
                       </p>
                    </li>

        <li>
                       <p>Alias ARN:
        <code>arn:aws:kms:us-east-2:111122223333:alias/ExampleAlias</code>

        </p>
                    </li>
                 </ul>
                 <p>To get the key ID and key ARN
        for a KMS key, use <a>ListKeys</a> or <a>DescribeKey</a>. To get the alias name
        and alias ARN, use <a>ListAliases</a>.</p>
        :param plaintext: <p>Data to be encrypted.</p>
        :param encryption_context: <p>Specifies the encryption context that will be used
        to encrypt the data.
              An encryption context is valid only for <a
        href="https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#cryptographic-operations">cryptographic
        operations</a> with a symmetric KMS key. The standard asymmetric encryption
        algorithms that KMS uses do not support an encryption context. </p>

        <p>An <i>encryption context</i> is a collection of non-secret key-value pairs
        that represents additional authenticated data. When you use an encryption
        context to encrypt data, you must specify the same (an exact case-sensitive
        match) encryption context to decrypt the data. An encryption context is optional
        when encrypting with a symmetric KMS key, but it is highly recommended.</p>

        <p>For more information, see
                <a
        href="https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#encrypt_context">Encryption

        Context</a> in the <i>Key Management Service Developer Guide</i>.</p>
        :param grant_tokens: <p>A list of grant tokens.</p>
                 <p>Use a grant
        token when your permission to call this operation comes from a new grant that
        has not yet achieved <i>eventual consistency</i>. For more information, see <a
        href="https://docs.aws.amazon.com/kms/latest/developerguide/grants.html#grant_token">Grant
        token</a> and <a
        href="https://docs.aws.amazon.com/kms/latest/developerguide/grant-manage.html#using-grant-token">Using
        a grant token</a> in the
            <i>Key Management Service Developer Guide</i>.</p>
        :param encryption_algorithm: <p>Specifies the encryption algorithm that KMS will
        use to encrypt the plaintext message.
              The algorithm must be compatible
        with the KMS key that you specify.</p>
                 <p>This parameter is required
        only for asymmetric KMS keys. The default value,

        <code>SYMMETRIC_DEFAULT</code>, is the algorithm used for symmetric KMS keys. If
        you are
              using an asymmetric KMS key, we recommend RSAES_OAEP_SHA_256.</p>
        """
        self.key_id = key_id
        self.plaintext = plaintext
        self.encryption_context = encryption_context
        self.grant_tokens = grant_tokens
        self.encryption_algorithm = encryption_algorithm

    def as_dict(self) -> Dict[str, Any]:
        """Converts the EncryptRequest to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        d: Dict[str, Any] = {
            "KeyId": self.key_id,
            "Plaintext": self.plaintext,
        }

        if self.encryption_context is not None:
            d["EncryptionContext"] = self.encryption_context

        if self.grant_tokens is not None:
            d["GrantTokens"] = self.grant_tokens

        if self.encryption_algorithm is not None:
            d["EncryptionAlgorithm"] = self.encryption_algorithm

        return d

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "EncryptRequest":
        """Creates a EncryptRequest from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {
            "key_id": d["KeyId"],
            "plaintext": d["Plaintext"],
        }

        if "EncryptionContext" in d:
            kwargs["encryption_context"] = d["EncryptionContext"]

        if "GrantTokens" in d:
            kwargs["grant_tokens"] = d["GrantTokens"]

        if "EncryptionAlgorithm" in d:
            kwargs["encryption_algorithm"] = d["EncryptionAlgorithm"]

        return EncryptRequest(**kwargs)

    def __repr__(self) -> str:
        result = "EncryptRequest("
        if self.key_id is not None:
            result += f"key_id={repr(self.key_id)}, "

        if self.plaintext is not None:
            result += f"plaintext={repr(self.plaintext)}, "

        if self.encryption_context is not None:
            result += f"encryption_context={repr(self.encryption_context)}, "

        if self.grant_tokens is not None:
            result += f"grant_tokens={repr(self.grant_tokens)}, "

        if self.encryption_algorithm is not None:
            result += f"encryption_algorithm={repr(self.encryption_algorithm)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, EncryptRequest):
            return False
        attributes: list[str] = ['key_id','plaintext','encryption_context','grant_tokens','encryption_algorithm',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class EncryptResponse:
    ciphertext_blob: Optional[bytes | bytearray]
    key_id: Optional[str]
    encryption_algorithm: Optional[str]
    def __init__(
        self,
        *,
        ciphertext_blob: Optional[bytes | bytearray] = None,
        key_id: Optional[str] = None,
        encryption_algorithm: Optional[str] = None,
    ):
        """
        :param ciphertext_blob: <p>The encrypted plaintext. When you use the HTTP API or
        the Amazon Web Services CLI, the value is Base64-encoded. Otherwise, it is not
        Base64-encoded.</p>
        :param key_id: <p>The Amazon Resource Name (<a
        href="https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#key-id-key-ARN">key
        ARN</a>) of the KMS key that was used to encrypt the plaintext.</p>
        :param encryption_algorithm: <p>The encryption algorithm that was used to
        encrypt the plaintext.</p>
        """
        self.ciphertext_blob = ciphertext_blob
        self.key_id = key_id
        self.encryption_algorithm = encryption_algorithm

    def as_dict(self) -> Dict[str, Any]:
        """Converts the EncryptResponse to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        d: Dict[str, Any] = {}

        if self.ciphertext_blob is not None:
            d["CiphertextBlob"] = self.ciphertext_blob

        if self.key_id is not None:
            d["KeyId"] = self.key_id

        if self.encryption_algorithm is not None:
            d["EncryptionAlgorithm"] = self.encryption_algorithm

        return d

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "EncryptResponse":
        """Creates a EncryptResponse from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {}

        if "CiphertextBlob" in d:
            kwargs["ciphertext_blob"] = d["CiphertextBlob"]

        if "KeyId" in d:
            kwargs["key_id"] = d["KeyId"]

        if "EncryptionAlgorithm" in d:
            kwargs["encryption_algorithm"] = d["EncryptionAlgorithm"]

        return EncryptResponse(**kwargs)

    def __repr__(self) -> str:
        result = "EncryptResponse("
        if self.ciphertext_blob is not None:
            result += f"ciphertext_blob={repr(self.ciphertext_blob)}, "

        if self.key_id is not None:
            result += f"key_id={repr(self.key_id)}, "

        if self.encryption_algorithm is not None:
            result += f"encryption_algorithm={repr(self.encryption_algorithm)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, EncryptResponse):
            return False
        attributes: list[str] = ['ciphertext_blob','key_id','encryption_algorithm',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class GenerateDataKeyRequest:
    key_id: str
    encryption_context: Optional[dict[str, str]]
    number_of_bytes: Optional[int]
    key_spec: Optional[str]
    grant_tokens: Optional[list[str]]
    def __init__(
        self,
        *,
        key_id: str,
        encryption_context: Optional[dict[str, str]] = None,
        number_of_bytes: Optional[int] = None,
        key_spec: Optional[str] = None,
        grant_tokens: Optional[list[str]] = None,
    ):
        """
        :param key_id: <p>Identifies the symmetric KMS key that encrypts the data
        key.</p>

                 <p>To specify a KMS key, use its key ID, key ARN, alias
        name, or alias ARN. When using an alias name, prefix it with
        <code>"alias/"</code>. To specify a KMS key in a different Amazon Web Services
        account, you must use the key ARN or alias ARN.</p>
                 <p>For
        example:</p>
                 <ul>
                    <li>
                       <p>Key ID:
        <code>1234abcd-12ab-34cd-56ef-1234567890ab</code>
                       </p>

        </li>
                    <li>
                       <p>Key ARN:
        <code>arn:aws:kms:us-east-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab</code>

        </p>
                    </li>
                    <li>
                       <p>Alias name:
        <code>alias/ExampleAlias</code>
                       </p>
                    </li>

        <li>
                       <p>Alias ARN:
        <code>arn:aws:kms:us-east-2:111122223333:alias/ExampleAlias</code>

        </p>
                    </li>
                 </ul>
                 <p>To get the key ID and key ARN
        for a KMS key, use <a>ListKeys</a> or <a>DescribeKey</a>. To get the alias name
        and alias ARN, use <a>ListAliases</a>.</p>
        :param encryption_context: <p>Specifies the encryption context that will be used
        when encrypting the data key.</p>
                 <p>An <i>encryption context</i> is a
        collection of non-secret key-value pairs that represents additional
        authenticated data. When you use an encryption context to encrypt data, you must
        specify the same (an exact case-sensitive match) encryption context to decrypt
        the data. An encryption context is optional when encrypting with a symmetric KMS
        key, but it is highly recommended.</p>
                 <p>For more information, see

        <a
        href="https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#encrypt_context">Encryption

        Context</a> in the <i>Key Management Service Developer Guide</i>.</p>
        :param number_of_bytes: <p>Specifies the length of the data key in bytes. For
        example, use the value 64 to generate a
              512-bit data key (64 bytes is 512
        bits). For 128-bit (16-byte) and 256-bit (32-byte) data
              keys, use the
        <code>KeySpec</code> parameter.</p>
                 <p>You must specify either the
        <code>KeySpec</code> or the <code>NumberOfBytes</code>
              parameter (but not
        both) in every <code>GenerateDataKey</code> request.</p>
        :param key_spec: <p>Specifies the length of the data key. Use
        <code>AES_128</code> to generate a 128-bit
              symmetric key, or
        <code>AES_256</code> to generate a 256-bit symmetric key.</p>
                 <p>You
        must specify either the <code>KeySpec</code> or the <code>NumberOfBytes</code>

        parameter (but not both) in every <code>GenerateDataKey</code> request.</p>
        :param grant_tokens: <p>A list of grant tokens.</p>
                 <p>Use a grant
        token when your permission to call this operation comes from a new grant that
        has not yet achieved <i>eventual consistency</i>. For more information, see <a
        href="https://docs.aws.amazon.com/kms/latest/developerguide/grants.html#grant_token">Grant
        token</a> and <a
        href="https://docs.aws.amazon.com/kms/latest/developerguide/grant-manage.html#using-grant-token">Using
        a grant token</a> in the
            <i>Key Management Service Developer Guide</i>.</p>
        """
        self.key_id = key_id
        self.encryption_context = encryption_context
        self.number_of_bytes = number_of_bytes
        self.key_spec = key_spec
        self.grant_tokens = grant_tokens

    def as_dict(self) -> Dict[str, Any]:
        """Converts the GenerateDataKeyRequest to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        d: Dict[str, Any] = {
            "KeyId": self.key_id,
        }

        if self.encryption_context is not None:
            d["EncryptionContext"] = self.encryption_context

        if self.number_of_bytes is not None:
            d["NumberOfBytes"] = self.number_of_bytes

        if self.key_spec is not None:
            d["KeySpec"] = self.key_spec

        if self.grant_tokens is not None:
            d["GrantTokens"] = self.grant_tokens

        return d

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "GenerateDataKeyRequest":
        """Creates a GenerateDataKeyRequest from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {
            "key_id": d["KeyId"],
        }

        if "EncryptionContext" in d:
            kwargs["encryption_context"] = d["EncryptionContext"]

        if "NumberOfBytes" in d:
            kwargs["number_of_bytes"] = d["NumberOfBytes"]

        if "KeySpec" in d:
            kwargs["key_spec"] = d["KeySpec"]

        if "GrantTokens" in d:
            kwargs["grant_tokens"] = d["GrantTokens"]

        return GenerateDataKeyRequest(**kwargs)

    def __repr__(self) -> str:
        result = "GenerateDataKeyRequest("
        if self.key_id is not None:
            result += f"key_id={repr(self.key_id)}, "

        if self.encryption_context is not None:
            result += f"encryption_context={repr(self.encryption_context)}, "

        if self.number_of_bytes is not None:
            result += f"number_of_bytes={repr(self.number_of_bytes)}, "

        if self.key_spec is not None:
            result += f"key_spec={repr(self.key_spec)}, "

        if self.grant_tokens is not None:
            result += f"grant_tokens={repr(self.grant_tokens)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, GenerateDataKeyRequest):
            return False
        attributes: list[str] = ['key_id','encryption_context','number_of_bytes','key_spec','grant_tokens',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class GenerateDataKeyResponse:
    ciphertext_blob: Optional[bytes | bytearray]
    plaintext: Optional[bytes | bytearray]
    key_id: Optional[str]
    def __init__(
        self,
        *,
        ciphertext_blob: Optional[bytes | bytearray] = None,
        plaintext: Optional[bytes | bytearray] = None,
        key_id: Optional[str] = None,
    ):
        """
        :param ciphertext_blob: <p>The encrypted copy of the data key. When you use the
        HTTP API or the Amazon Web Services CLI, the value is Base64-encoded. Otherwise,
        it is not Base64-encoded.</p>
        :param plaintext: <p>The plaintext data key. When you use the HTTP API or the
        Amazon Web Services CLI, the value is Base64-encoded. Otherwise, it is not
        Base64-encoded. Use this data key to encrypt your data outside of
              KMS.
        Then, remove it from memory as soon as possible.</p>
        :param key_id: <p>The Amazon Resource Name (<a
        href="https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#key-id-key-ARN">key
        ARN</a>) of the KMS key that encrypted the data key.</p>
        """
        self.ciphertext_blob = ciphertext_blob
        self.plaintext = plaintext
        self.key_id = key_id

    def as_dict(self) -> Dict[str, Any]:
        """Converts the GenerateDataKeyResponse to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        d: Dict[str, Any] = {}

        if self.ciphertext_blob is not None:
            d["CiphertextBlob"] = self.ciphertext_blob

        if self.plaintext is not None:
            d["Plaintext"] = self.plaintext

        if self.key_id is not None:
            d["KeyId"] = self.key_id

        return d

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "GenerateDataKeyResponse":
        """Creates a GenerateDataKeyResponse from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {}

        if "CiphertextBlob" in d:
            kwargs["ciphertext_blob"] = d["CiphertextBlob"]

        if "Plaintext" in d:
            kwargs["plaintext"] = d["Plaintext"]

        if "KeyId" in d:
            kwargs["key_id"] = d["KeyId"]

        return GenerateDataKeyResponse(**kwargs)

    def __repr__(self) -> str:
        result = "GenerateDataKeyResponse("
        if self.ciphertext_blob is not None:
            result += f"ciphertext_blob={repr(self.ciphertext_blob)}, "

        if self.plaintext is not None:
            result += f"plaintext={repr(self.plaintext)}, "

        if self.key_id is not None:
            result += f"key_id={repr(self.key_id)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, GenerateDataKeyResponse):
            return False
        attributes: list[str] = ['ciphertext_blob','plaintext','key_id',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class GenerateDataKeyPairRequest:
    encryption_context: Optional[dict[str, str]]
    key_id: str
    key_pair_spec: str
    grant_tokens: Optional[list[str]]
    def __init__(
        self,
        *,
        key_id: str,
        key_pair_spec: str,
        encryption_context: Optional[dict[str, str]] = None,
        grant_tokens: Optional[list[str]] = None,
    ):
        """
        :param key_id: <p>Specifies the symmetric KMS key that encrypts the private key
        in the data key pair. You
              cannot specify an asymmetric KMS key or a KMS
        key in a custom key store. To get the type and
              origin of your KMS key, use
        the <a>DescribeKey</a> operation.</p>

                 <p>To specify a KMS key, use
        its key ID, key ARN, alias name, or alias ARN. When using an alias name, prefix
        it with <code>"alias/"</code>. To specify a KMS key in a different Amazon Web
        Services account, you must use the key ARN or alias ARN.</p>
                 <p>For
        example:</p>
                 <ul>
                    <li>
                       <p>Key ID:
        <code>1234abcd-12ab-34cd-56ef-1234567890ab</code>
                       </p>

        </li>
                    <li>
                       <p>Key ARN:
        <code>arn:aws:kms:us-east-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab</code>

        </p>
                    </li>
                    <li>
                       <p>Alias name:
        <code>alias/ExampleAlias</code>
                       </p>
                    </li>

        <li>
                       <p>Alias ARN:
        <code>arn:aws:kms:us-east-2:111122223333:alias/ExampleAlias</code>

        </p>
                    </li>
                 </ul>
                 <p>To get the key ID and key ARN
        for a KMS key, use <a>ListKeys</a> or <a>DescribeKey</a>. To get the alias name
        and alias ARN, use <a>ListAliases</a>.</p>
        :param key_pair_spec: <p>Determines the type of data key pair that is generated.
        </p>
                 <p>The KMS rule that restricts the use of asymmetric RSA KMS keys
        to encrypt and decrypt or to sign and verify (but not both), and the rule that
        permits you to use ECC KMS keys only to sign and verify, are not effective on
        data key pairs, which are used outside of KMS.</p>
        :param encryption_context: <p>Specifies the encryption context that will be used
        when encrypting the private key in the
              data key pair.</p>
                 <p>An
        <i>encryption context</i> is a collection of non-secret key-value pairs that
        represents additional authenticated data. When you use an encryption context to
        encrypt data, you must specify the same (an exact case-sensitive match)
        encryption context to decrypt the data. An encryption context is optional when
        encrypting with a symmetric KMS key, but it is highly recommended.</p>

        <p>For more information, see
                <a
        href="https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#encrypt_context">Encryption

        Context</a> in the <i>Key Management Service Developer Guide</i>.</p>
        :param grant_tokens: <p>A list of grant tokens.</p>
                 <p>Use a grant
        token when your permission to call this operation comes from a new grant that
        has not yet achieved <i>eventual consistency</i>. For more information, see <a
        href="https://docs.aws.amazon.com/kms/latest/developerguide/grants.html#grant_token">Grant
        token</a> and <a
        href="https://docs.aws.amazon.com/kms/latest/developerguide/grant-manage.html#using-grant-token">Using
        a grant token</a> in the
            <i>Key Management Service Developer Guide</i>.</p>
        """
        self.key_id = key_id
        self.key_pair_spec = key_pair_spec
        self.encryption_context = encryption_context
        self.grant_tokens = grant_tokens

    def as_dict(self) -> Dict[str, Any]:
        """Converts the GenerateDataKeyPairRequest to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        d: Dict[str, Any] = {
            "KeyId": self.key_id,
            "KeyPairSpec": self.key_pair_spec,
        }

        if self.encryption_context is not None:
            d["EncryptionContext"] = self.encryption_context

        if self.grant_tokens is not None:
            d["GrantTokens"] = self.grant_tokens

        return d

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "GenerateDataKeyPairRequest":
        """Creates a GenerateDataKeyPairRequest from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {
            "key_id": d["KeyId"],
            "key_pair_spec": d["KeyPairSpec"],
        }

        if "EncryptionContext" in d:
            kwargs["encryption_context"] = d["EncryptionContext"]

        if "GrantTokens" in d:
            kwargs["grant_tokens"] = d["GrantTokens"]

        return GenerateDataKeyPairRequest(**kwargs)

    def __repr__(self) -> str:
        result = "GenerateDataKeyPairRequest("
        if self.encryption_context is not None:
            result += f"encryption_context={repr(self.encryption_context)}, "

        if self.key_id is not None:
            result += f"key_id={repr(self.key_id)}, "

        if self.key_pair_spec is not None:
            result += f"key_pair_spec={repr(self.key_pair_spec)}, "

        if self.grant_tokens is not None:
            result += f"grant_tokens={repr(self.grant_tokens)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, GenerateDataKeyPairRequest):
            return False
        attributes: list[str] = ['encryption_context','key_id','key_pair_spec','grant_tokens',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class GenerateDataKeyPairResponse:
    private_key_ciphertext_blob: Optional[bytes | bytearray]
    private_key_plaintext: Optional[bytes | bytearray]
    public_key: Optional[bytes | bytearray]
    key_id: Optional[str]
    key_pair_spec: Optional[str]
    def __init__(
        self,
        *,
        private_key_ciphertext_blob: Optional[bytes | bytearray] = None,
        private_key_plaintext: Optional[bytes | bytearray] = None,
        public_key: Optional[bytes | bytearray] = None,
        key_id: Optional[str] = None,
        key_pair_spec: Optional[str] = None,
    ):
        """
        :param private_key_ciphertext_blob: <p>The encrypted copy of the private key.
        When you use the HTTP API or the Amazon Web Services CLI, the value is
        Base64-encoded. Otherwise, it is not Base64-encoded.</p>
        :param private_key_plaintext: <p>The plaintext copy of the private key. When you
        use the HTTP API or the Amazon Web Services CLI, the value is Base64-encoded.
        Otherwise, it is not Base64-encoded.</p>
        :param public_key: <p>The public key (in plaintext).</p>
        :param key_id: <p>The Amazon Resource Name (<a
        href="https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#key-id-key-ARN">key
        ARN</a>) of the KMS key that encrypted the private key.</p>
        :param key_pair_spec: <p>The type of data key pair that was generated.</p>
        """
        self.private_key_ciphertext_blob = private_key_ciphertext_blob
        self.private_key_plaintext = private_key_plaintext
        self.public_key = public_key
        self.key_id = key_id
        self.key_pair_spec = key_pair_spec

    def as_dict(self) -> Dict[str, Any]:
        """Converts the GenerateDataKeyPairResponse to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        d: Dict[str, Any] = {}

        if self.private_key_ciphertext_blob is not None:
            d["PrivateKeyCiphertextBlob"] = self.private_key_ciphertext_blob

        if self.private_key_plaintext is not None:
            d["PrivateKeyPlaintext"] = self.private_key_plaintext

        if self.public_key is not None:
            d["PublicKey"] = self.public_key

        if self.key_id is not None:
            d["KeyId"] = self.key_id

        if self.key_pair_spec is not None:
            d["KeyPairSpec"] = self.key_pair_spec

        return d

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "GenerateDataKeyPairResponse":
        """Creates a GenerateDataKeyPairResponse from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {}

        if "PrivateKeyCiphertextBlob" in d:
            kwargs["private_key_ciphertext_blob"] = d["PrivateKeyCiphertextBlob"]

        if "PrivateKeyPlaintext" in d:
            kwargs["private_key_plaintext"] = d["PrivateKeyPlaintext"]

        if "PublicKey" in d:
            kwargs["public_key"] = d["PublicKey"]

        if "KeyId" in d:
            kwargs["key_id"] = d["KeyId"]

        if "KeyPairSpec" in d:
            kwargs["key_pair_spec"] = d["KeyPairSpec"]

        return GenerateDataKeyPairResponse(**kwargs)

    def __repr__(self) -> str:
        result = "GenerateDataKeyPairResponse("
        if self.private_key_ciphertext_blob is not None:
            result += f"private_key_ciphertext_blob={repr(self.private_key_ciphertext_blob)}, "

        if self.private_key_plaintext is not None:
            result += f"private_key_plaintext={repr(self.private_key_plaintext)}, "

        if self.public_key is not None:
            result += f"public_key={repr(self.public_key)}, "

        if self.key_id is not None:
            result += f"key_id={repr(self.key_id)}, "

        if self.key_pair_spec is not None:
            result += f"key_pair_spec={repr(self.key_pair_spec)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, GenerateDataKeyPairResponse):
            return False
        attributes: list[str] = ['private_key_ciphertext_blob','private_key_plaintext','public_key','key_id','key_pair_spec',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class GenerateDataKeyPairWithoutPlaintextRequest:
    encryption_context: Optional[dict[str, str]]
    key_id: str
    key_pair_spec: str
    grant_tokens: Optional[list[str]]
    def __init__(
        self,
        *,
        key_id: str,
        key_pair_spec: str,
        encryption_context: Optional[dict[str, str]] = None,
        grant_tokens: Optional[list[str]] = None,
    ):
        """
        :param key_id: <p>Specifies the KMS key that encrypts the private key in the
        data key pair. You must specify
              a symmetric KMS key. You cannot use an
        asymmetric KMS key or a KMS key in a custom key store.
              To get the type and
        origin of your KMS key, use the <a>DescribeKey</a> operation.
            </p>

        <p>To specify a KMS key, use its key ID, key ARN, alias name, or alias ARN. When
        using an alias name, prefix it with <code>"alias/"</code>. To specify a KMS key
        in a different Amazon Web Services account, you must use the key ARN or alias
        ARN.</p>
                 <p>For example:</p>
                 <ul>
                    <li>

        <p>Key ID: <code>1234abcd-12ab-34cd-56ef-1234567890ab</code>

        </p>
                    </li>
                    <li>
                       <p>Key ARN:
        <code>arn:aws:kms:us-east-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab</code>

        </p>
                    </li>
                    <li>
                       <p>Alias name:
        <code>alias/ExampleAlias</code>
                       </p>
                    </li>

        <li>
                       <p>Alias ARN:
        <code>arn:aws:kms:us-east-2:111122223333:alias/ExampleAlias</code>

        </p>
                    </li>
                 </ul>
                 <p>To get the key ID and key ARN
        for a KMS key, use <a>ListKeys</a> or <a>DescribeKey</a>. To get the alias name
        and alias ARN, use <a>ListAliases</a>.</p>
        :param key_pair_spec: <p>Determines the type of data key pair that is
        generated.</p>
                 <p>The KMS rule that restricts the use of asymmetric RSA
        KMS keys to encrypt and decrypt or to sign and verify (but not both), and the
        rule that permits you to use ECC KMS keys only to sign and verify, are not
        effective on data key pairs, which are used outside of KMS.</p>
        :param encryption_context: <p>Specifies the encryption context that will be used
        when encrypting the private key in the
              data key pair.</p>
                 <p>An
        <i>encryption context</i> is a collection of non-secret key-value pairs that
        represents additional authenticated data. When you use an encryption context to
        encrypt data, you must specify the same (an exact case-sensitive match)
        encryption context to decrypt the data. An encryption context is optional when
        encrypting with a symmetric KMS key, but it is highly recommended.</p>

        <p>For more information, see
                <a
        href="https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#encrypt_context">Encryption

        Context</a> in the <i>Key Management Service Developer Guide</i>.</p>
        :param grant_tokens: <p>A list of grant tokens.</p>
                 <p>Use a grant
        token when your permission to call this operation comes from a new grant that
        has not yet achieved <i>eventual consistency</i>. For more information, see <a
        href="https://docs.aws.amazon.com/kms/latest/developerguide/grants.html#grant_token">Grant
        token</a> and <a
        href="https://docs.aws.amazon.com/kms/latest/developerguide/grant-manage.html#using-grant-token">Using
        a grant token</a> in the
            <i>Key Management Service Developer Guide</i>.</p>
        """
        self.key_id = key_id
        self.key_pair_spec = key_pair_spec
        self.encryption_context = encryption_context
        self.grant_tokens = grant_tokens

    def as_dict(self) -> Dict[str, Any]:
        """Converts the GenerateDataKeyPairWithoutPlaintextRequest to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        d: Dict[str, Any] = {
            "KeyId": self.key_id,
            "KeyPairSpec": self.key_pair_spec,
        }

        if self.encryption_context is not None:
            d["EncryptionContext"] = self.encryption_context

        if self.grant_tokens is not None:
            d["GrantTokens"] = self.grant_tokens

        return d

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "GenerateDataKeyPairWithoutPlaintextRequest":
        """Creates a GenerateDataKeyPairWithoutPlaintextRequest from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {
            "key_id": d["KeyId"],
            "key_pair_spec": d["KeyPairSpec"],
        }

        if "EncryptionContext" in d:
            kwargs["encryption_context"] = d["EncryptionContext"]

        if "GrantTokens" in d:
            kwargs["grant_tokens"] = d["GrantTokens"]

        return GenerateDataKeyPairWithoutPlaintextRequest(**kwargs)

    def __repr__(self) -> str:
        result = "GenerateDataKeyPairWithoutPlaintextRequest("
        if self.encryption_context is not None:
            result += f"encryption_context={repr(self.encryption_context)}, "

        if self.key_id is not None:
            result += f"key_id={repr(self.key_id)}, "

        if self.key_pair_spec is not None:
            result += f"key_pair_spec={repr(self.key_pair_spec)}, "

        if self.grant_tokens is not None:
            result += f"grant_tokens={repr(self.grant_tokens)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, GenerateDataKeyPairWithoutPlaintextRequest):
            return False
        attributes: list[str] = ['encryption_context','key_id','key_pair_spec','grant_tokens',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class GenerateDataKeyPairWithoutPlaintextResponse:
    private_key_ciphertext_blob: Optional[bytes | bytearray]
    public_key: Optional[bytes | bytearray]
    key_id: Optional[str]
    key_pair_spec: Optional[str]
    def __init__(
        self,
        *,
        private_key_ciphertext_blob: Optional[bytes | bytearray] = None,
        public_key: Optional[bytes | bytearray] = None,
        key_id: Optional[str] = None,
        key_pair_spec: Optional[str] = None,
    ):
        """
        :param private_key_ciphertext_blob: <p>The encrypted copy of the private key.
        When you use the HTTP API or the Amazon Web Services CLI, the value is
        Base64-encoded. Otherwise, it is not Base64-encoded.</p>
        :param public_key: <p>The public key (in plaintext).</p>
        :param key_id: <p>The Amazon Resource Name (<a
        href="https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#key-id-key-ARN">key
        ARN</a>) of the KMS key that encrypted the private key.</p>
        :param key_pair_spec: <p>The type of data key pair that was generated.</p>
        """
        self.private_key_ciphertext_blob = private_key_ciphertext_blob
        self.public_key = public_key
        self.key_id = key_id
        self.key_pair_spec = key_pair_spec

    def as_dict(self) -> Dict[str, Any]:
        """Converts the GenerateDataKeyPairWithoutPlaintextResponse to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        d: Dict[str, Any] = {}

        if self.private_key_ciphertext_blob is not None:
            d["PrivateKeyCiphertextBlob"] = self.private_key_ciphertext_blob

        if self.public_key is not None:
            d["PublicKey"] = self.public_key

        if self.key_id is not None:
            d["KeyId"] = self.key_id

        if self.key_pair_spec is not None:
            d["KeyPairSpec"] = self.key_pair_spec

        return d

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "GenerateDataKeyPairWithoutPlaintextResponse":
        """Creates a GenerateDataKeyPairWithoutPlaintextResponse from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {}

        if "PrivateKeyCiphertextBlob" in d:
            kwargs["private_key_ciphertext_blob"] = d["PrivateKeyCiphertextBlob"]

        if "PublicKey" in d:
            kwargs["public_key"] = d["PublicKey"]

        if "KeyId" in d:
            kwargs["key_id"] = d["KeyId"]

        if "KeyPairSpec" in d:
            kwargs["key_pair_spec"] = d["KeyPairSpec"]

        return GenerateDataKeyPairWithoutPlaintextResponse(**kwargs)

    def __repr__(self) -> str:
        result = "GenerateDataKeyPairWithoutPlaintextResponse("
        if self.private_key_ciphertext_blob is not None:
            result += f"private_key_ciphertext_blob={repr(self.private_key_ciphertext_blob)}, "

        if self.public_key is not None:
            result += f"public_key={repr(self.public_key)}, "

        if self.key_id is not None:
            result += f"key_id={repr(self.key_id)}, "

        if self.key_pair_spec is not None:
            result += f"key_pair_spec={repr(self.key_pair_spec)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, GenerateDataKeyPairWithoutPlaintextResponse):
            return False
        attributes: list[str] = ['private_key_ciphertext_blob','public_key','key_id','key_pair_spec',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class GenerateDataKeyWithoutPlaintextRequest:
    key_id: str
    encryption_context: Optional[dict[str, str]]
    key_spec: Optional[str]
    number_of_bytes: Optional[int]
    grant_tokens: Optional[list[str]]
    def __init__(
        self,
        *,
        key_id: str,
        encryption_context: Optional[dict[str, str]] = None,
        key_spec: Optional[str] = None,
        number_of_bytes: Optional[int] = None,
        grant_tokens: Optional[list[str]] = None,
    ):
        """
        :param key_id: <p>The identifier of the symmetric KMS key that encrypts the data
        key.</p>

                 <p>To specify a KMS key, use its key ID, key ARN, alias
        name, or alias ARN. When using an alias name, prefix it with
        <code>"alias/"</code>. To specify a KMS key in a different Amazon Web Services
        account, you must use the key ARN or alias ARN.</p>
                 <p>For
        example:</p>
                 <ul>
                    <li>
                       <p>Key ID:
        <code>1234abcd-12ab-34cd-56ef-1234567890ab</code>
                       </p>

        </li>
                    <li>
                       <p>Key ARN:
        <code>arn:aws:kms:us-east-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab</code>

        </p>
                    </li>
                    <li>
                       <p>Alias name:
        <code>alias/ExampleAlias</code>
                       </p>
                    </li>

        <li>
                       <p>Alias ARN:
        <code>arn:aws:kms:us-east-2:111122223333:alias/ExampleAlias</code>

        </p>
                    </li>
                 </ul>
                 <p>To get the key ID and key ARN
        for a KMS key, use <a>ListKeys</a> or <a>DescribeKey</a>. To get the alias name
        and alias ARN, use <a>ListAliases</a>.</p>
        :param encryption_context: <p>Specifies the encryption context that will be used
        when encrypting the data key.</p>
                 <p>An <i>encryption context</i> is a
        collection of non-secret key-value pairs that represents additional
        authenticated data. When you use an encryption context to encrypt data, you must
        specify the same (an exact case-sensitive match) encryption context to decrypt
        the data. An encryption context is optional when encrypting with a symmetric KMS
        key, but it is highly recommended.</p>
                 <p>For more information, see

        <a
        href="https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#encrypt_context">Encryption

        Context</a> in the <i>Key Management Service Developer Guide</i>.</p>
        :param key_spec: <p>The length of the data key. Use <code>AES_128</code> to
        generate a 128-bit symmetric key,
              or <code>AES_256</code> to generate a
        256-bit symmetric key.</p>
        :param number_of_bytes: <p>The length of the data key in bytes. For example, use
        the value 64 to generate a 512-bit
              data key (64 bytes is 512 bits). For
        common key lengths (128-bit and 256-bit symmetric keys),
              we recommend that
        you use the <code>KeySpec</code> field instead of this one.</p>
        :param grant_tokens: <p>A list of grant tokens.</p>
                 <p>Use a grant
        token when your permission to call this operation comes from a new grant that
        has not yet achieved <i>eventual consistency</i>. For more information, see <a
        href="https://docs.aws.amazon.com/kms/latest/developerguide/grants.html#grant_token">Grant
        token</a> and <a
        href="https://docs.aws.amazon.com/kms/latest/developerguide/grant-manage.html#using-grant-token">Using
        a grant token</a> in the
            <i>Key Management Service Developer Guide</i>.</p>
        """
        self.key_id = key_id
        self.encryption_context = encryption_context
        self.key_spec = key_spec
        self.number_of_bytes = number_of_bytes
        self.grant_tokens = grant_tokens

    def as_dict(self) -> Dict[str, Any]:
        """Converts the GenerateDataKeyWithoutPlaintextRequest to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        d: Dict[str, Any] = {
            "KeyId": self.key_id,
        }

        if self.encryption_context is not None:
            d["EncryptionContext"] = self.encryption_context

        if self.key_spec is not None:
            d["KeySpec"] = self.key_spec

        if self.number_of_bytes is not None:
            d["NumberOfBytes"] = self.number_of_bytes

        if self.grant_tokens is not None:
            d["GrantTokens"] = self.grant_tokens

        return d

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "GenerateDataKeyWithoutPlaintextRequest":
        """Creates a GenerateDataKeyWithoutPlaintextRequest from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {
            "key_id": d["KeyId"],
        }

        if "EncryptionContext" in d:
            kwargs["encryption_context"] = d["EncryptionContext"]

        if "KeySpec" in d:
            kwargs["key_spec"] = d["KeySpec"]

        if "NumberOfBytes" in d:
            kwargs["number_of_bytes"] = d["NumberOfBytes"]

        if "GrantTokens" in d:
            kwargs["grant_tokens"] = d["GrantTokens"]

        return GenerateDataKeyWithoutPlaintextRequest(**kwargs)

    def __repr__(self) -> str:
        result = "GenerateDataKeyWithoutPlaintextRequest("
        if self.key_id is not None:
            result += f"key_id={repr(self.key_id)}, "

        if self.encryption_context is not None:
            result += f"encryption_context={repr(self.encryption_context)}, "

        if self.key_spec is not None:
            result += f"key_spec={repr(self.key_spec)}, "

        if self.number_of_bytes is not None:
            result += f"number_of_bytes={repr(self.number_of_bytes)}, "

        if self.grant_tokens is not None:
            result += f"grant_tokens={repr(self.grant_tokens)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, GenerateDataKeyWithoutPlaintextRequest):
            return False
        attributes: list[str] = ['key_id','encryption_context','key_spec','number_of_bytes','grant_tokens',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class GenerateDataKeyWithoutPlaintextResponse:
    ciphertext_blob: Optional[bytes | bytearray]
    key_id: Optional[str]
    def __init__(
        self,
        *,
        ciphertext_blob: Optional[bytes | bytearray] = None,
        key_id: Optional[str] = None,
    ):
        """
        :param ciphertext_blob: <p>The encrypted data key. When you use the HTTP API or
        the Amazon Web Services CLI, the value is Base64-encoded. Otherwise, it is not
        Base64-encoded.</p>
        :param key_id: <p>The Amazon Resource Name (<a
        href="https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#key-id-key-ARN">key
        ARN</a>) of the KMS key that encrypted the data key.</p>
        """
        self.ciphertext_blob = ciphertext_blob
        self.key_id = key_id

    def as_dict(self) -> Dict[str, Any]:
        """Converts the GenerateDataKeyWithoutPlaintextResponse to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        d: Dict[str, Any] = {}

        if self.ciphertext_blob is not None:
            d["CiphertextBlob"] = self.ciphertext_blob

        if self.key_id is not None:
            d["KeyId"] = self.key_id

        return d

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "GenerateDataKeyWithoutPlaintextResponse":
        """Creates a GenerateDataKeyWithoutPlaintextResponse from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {}

        if "CiphertextBlob" in d:
            kwargs["ciphertext_blob"] = d["CiphertextBlob"]

        if "KeyId" in d:
            kwargs["key_id"] = d["KeyId"]

        return GenerateDataKeyWithoutPlaintextResponse(**kwargs)

    def __repr__(self) -> str:
        result = "GenerateDataKeyWithoutPlaintextResponse("
        if self.ciphertext_blob is not None:
            result += f"ciphertext_blob={repr(self.ciphertext_blob)}, "

        if self.key_id is not None:
            result += f"key_id={repr(self.key_id)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, GenerateDataKeyWithoutPlaintextResponse):
            return False
        attributes: list[str] = ['ciphertext_blob','key_id',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class GenerateRandomRequest:
    number_of_bytes: Optional[int]
    custom_key_store_id: Optional[str]
    def __init__(
        self,
        *,
        number_of_bytes: Optional[int] = None,
        custom_key_store_id: Optional[str] = None,
    ):
        """
        :param number_of_bytes: <p>The length of the byte string.</p>
        :param custom_key_store_id: <p>Generates the random byte string in the CloudHSM
        cluster that is associated with the
              specified <a
        href="https://docs.aws.amazon.com/kms/latest/developerguide/custom-key-store-overview.html">custom
        key store</a>. To find the ID of a custom key store, use the
        <a>DescribeCustomKeyStores</a> operation.</p>
        """
        self.number_of_bytes = number_of_bytes
        self.custom_key_store_id = custom_key_store_id

    def as_dict(self) -> Dict[str, Any]:
        """Converts the GenerateRandomRequest to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        d: Dict[str, Any] = {}

        if self.number_of_bytes is not None:
            d["NumberOfBytes"] = self.number_of_bytes

        if self.custom_key_store_id is not None:
            d["CustomKeyStoreId"] = self.custom_key_store_id

        return d

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "GenerateRandomRequest":
        """Creates a GenerateRandomRequest from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {}

        if "NumberOfBytes" in d:
            kwargs["number_of_bytes"] = d["NumberOfBytes"]

        if "CustomKeyStoreId" in d:
            kwargs["custom_key_store_id"] = d["CustomKeyStoreId"]

        return GenerateRandomRequest(**kwargs)

    def __repr__(self) -> str:
        result = "GenerateRandomRequest("
        if self.number_of_bytes is not None:
            result += f"number_of_bytes={repr(self.number_of_bytes)}, "

        if self.custom_key_store_id is not None:
            result += f"custom_key_store_id={repr(self.custom_key_store_id)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, GenerateRandomRequest):
            return False
        attributes: list[str] = ['number_of_bytes','custom_key_store_id',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class GenerateRandomResponse:
    plaintext: Optional[bytes | bytearray]
    def __init__(
        self,
        *,
        plaintext: Optional[bytes | bytearray] = None,
    ):
        """
        :param plaintext: <p>The random byte string. When you use the HTTP API or the
        Amazon Web Services CLI, the value is Base64-encoded. Otherwise, it is not
        Base64-encoded.</p>
        """
        self.plaintext = plaintext

    def as_dict(self) -> Dict[str, Any]:
        """Converts the GenerateRandomResponse to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        d: Dict[str, Any] = {}

        if self.plaintext is not None:
            d["Plaintext"] = self.plaintext

        return d

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "GenerateRandomResponse":
        """Creates a GenerateRandomResponse from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {}

        if "Plaintext" in d:
            kwargs["plaintext"] = d["Plaintext"]

        return GenerateRandomResponse(**kwargs)

    def __repr__(self) -> str:
        result = "GenerateRandomResponse("
        if self.plaintext is not None:
            result += f"plaintext={repr(self.plaintext)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, GenerateRandomResponse):
            return False
        attributes: list[str] = ['plaintext',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class GetKeyPolicyRequest:
    key_id: str
    policy_name: str
    def __init__(
        self,
        *,
        key_id: str,
        policy_name: str,
    ):
        """
        :param key_id: <p>Gets the key policy for the specified KMS key.</p>

        <p>Specify the key ID or key ARN of the KMS key.</p>
                 <p>For
        example:</p>
                 <ul>
                    <li>
                       <p>Key ID:
        <code>1234abcd-12ab-34cd-56ef-1234567890ab</code>
                       </p>

        </li>
                    <li>
                       <p>Key ARN:
        <code>arn:aws:kms:us-east-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab</code>

        </p>
                    </li>
                 </ul>
                 <p>To get the key ID and key
        ARN for a KMS key, use <a>ListKeys</a> or <a>DescribeKey</a>.</p>
        :param policy_name: <p>Specifies the name of the key policy. The only valid name
        is <code>default</code>. To get
              the names of key policies, use
        <a>ListKeyPolicies</a>.</p>
        """
        self.key_id = key_id
        self.policy_name = policy_name

    def as_dict(self) -> Dict[str, Any]:
        """Converts the GetKeyPolicyRequest to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        return {
            "KeyId": self.key_id,
            "PolicyName": self.policy_name,
        }

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "GetKeyPolicyRequest":
        """Creates a GetKeyPolicyRequest from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {
            "key_id": d["KeyId"],
            "policy_name": d["PolicyName"],
        }

        return GetKeyPolicyRequest(**kwargs)

    def __repr__(self) -> str:
        result = "GetKeyPolicyRequest("
        if self.key_id is not None:
            result += f"key_id={repr(self.key_id)}, "

        if self.policy_name is not None:
            result += f"policy_name={repr(self.policy_name)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, GetKeyPolicyRequest):
            return False
        attributes: list[str] = ['key_id','policy_name',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class GetKeyPolicyResponse:
    policy: Optional[str]
    def __init__(
        self,
        *,
        policy: Optional[str] = None,
    ):
        """
        :param policy: <p>A key policy document in JSON format.</p>
        """
        self.policy = policy

    def as_dict(self) -> Dict[str, Any]:
        """Converts the GetKeyPolicyResponse to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        d: Dict[str, Any] = {}

        if self.policy is not None:
            d["Policy"] = self.policy

        return d

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "GetKeyPolicyResponse":
        """Creates a GetKeyPolicyResponse from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {}

        if "Policy" in d:
            kwargs["policy"] = d["Policy"]

        return GetKeyPolicyResponse(**kwargs)

    def __repr__(self) -> str:
        result = "GetKeyPolicyResponse("
        if self.policy is not None:
            result += f"policy={repr(self.policy)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, GetKeyPolicyResponse):
            return False
        attributes: list[str] = ['policy',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class GetKeyRotationStatusRequest:
    key_id: str
    def __init__(
        self,
        *,
        key_id: str,
    ):
        """
        :param key_id: <p>Gets the rotation status for the specified KMS key.</p>

        <p>Specify the key ID or key ARN of the KMS key. To specify a KMS key in
        a
        different Amazon Web Services account, you must use the key ARN.</p>

        <p>For example:</p>
                 <ul>
                    <li>
                       <p>Key ID:
        <code>1234abcd-12ab-34cd-56ef-1234567890ab</code>
                       </p>

        </li>
                    <li>
                       <p>Key ARN:
        <code>arn:aws:kms:us-east-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab</code>

        </p>
                    </li>
                 </ul>
                 <p>To get the key ID and key
        ARN for a KMS key, use <a>ListKeys</a> or <a>DescribeKey</a>.</p>
        """
        self.key_id = key_id

    def as_dict(self) -> Dict[str, Any]:
        """Converts the GetKeyRotationStatusRequest to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        return {
            "KeyId": self.key_id,
        }

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "GetKeyRotationStatusRequest":
        """Creates a GetKeyRotationStatusRequest from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {
            "key_id": d["KeyId"],
        }

        return GetKeyRotationStatusRequest(**kwargs)

    def __repr__(self) -> str:
        result = "GetKeyRotationStatusRequest("
        if self.key_id is not None:
            result += f"key_id={repr(self.key_id)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, GetKeyRotationStatusRequest):
            return False
        attributes: list[str] = ['key_id',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class GetKeyRotationStatusResponse:
    key_rotation_enabled: bool
    def __init__(
        self,
        *,
        key_rotation_enabled: bool = False,
    ):
        """
        :param key_rotation_enabled: <p>A Boolean value that specifies whether key
        rotation is enabled.</p>
        """
        self.key_rotation_enabled = key_rotation_enabled

    def as_dict(self) -> Dict[str, Any]:
        """Converts the GetKeyRotationStatusResponse to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        d: Dict[str, Any] = {}

        if self.key_rotation_enabled is not None:
            d["KeyRotationEnabled"] = self.key_rotation_enabled

        return d

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "GetKeyRotationStatusResponse":
        """Creates a GetKeyRotationStatusResponse from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {}

        if "KeyRotationEnabled" in d:
            kwargs["key_rotation_enabled"] = d["KeyRotationEnabled"]

        return GetKeyRotationStatusResponse(**kwargs)

    def __repr__(self) -> str:
        result = "GetKeyRotationStatusResponse("
        if self.key_rotation_enabled is not None:
            result += f"key_rotation_enabled={repr(self.key_rotation_enabled)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, GetKeyRotationStatusResponse):
            return False
        attributes: list[str] = ['key_rotation_enabled',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class GetParametersForImportRequest:
    key_id: str
    wrapping_algorithm: str
    wrapping_key_spec: str
    def __init__(
        self,
        *,
        key_id: str,
        wrapping_algorithm: str,
        wrapping_key_spec: str,
    ):
        """
        :param key_id: <p>The identifier of the symmetric KMS key into which you will
        import key material. The
                <code>Origin</code> of the KMS key must be
        <code>EXTERNAL</code>.</p>

                 <p>Specify the key ID or key ARN of the
        KMS key.</p>
                 <p>For example:</p>
                 <ul>
                    <li>

        <p>Key ID: <code>1234abcd-12ab-34cd-56ef-1234567890ab</code>

        </p>
                    </li>
                    <li>
                       <p>Key ARN:
        <code>arn:aws:kms:us-east-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab</code>

        </p>
                    </li>
                 </ul>
                 <p>To get the key ID and key
        ARN for a KMS key, use <a>ListKeys</a> or <a>DescribeKey</a>.</p>
        :param wrapping_algorithm: <p>The algorithm you will use to encrypt the key
        material before importing it with <a>ImportKeyMaterial</a>. For more
        information, see <a
        href="https://docs.aws.amazon.com/kms/latest/developerguide/importing-keys-encrypt-key-material.html">Encrypt
        the Key Material</a>
              in the <i>Key Management Service Developer
        Guide</i>.</p>
        :param wrapping_key_spec: <p>The type of wrapping key (public key) to return in
        the response. Only 2048-bit RSA public
              keys are supported.</p>
        """
        self.key_id = key_id
        self.wrapping_algorithm = wrapping_algorithm
        self.wrapping_key_spec = wrapping_key_spec

    def as_dict(self) -> Dict[str, Any]:
        """Converts the GetParametersForImportRequest to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        return {
            "KeyId": self.key_id,
            "WrappingAlgorithm": self.wrapping_algorithm,
            "WrappingKeySpec": self.wrapping_key_spec,
        }

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "GetParametersForImportRequest":
        """Creates a GetParametersForImportRequest from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {
            "key_id": d["KeyId"],
            "wrapping_algorithm": d["WrappingAlgorithm"],
            "wrapping_key_spec": d["WrappingKeySpec"],
        }

        return GetParametersForImportRequest(**kwargs)

    def __repr__(self) -> str:
        result = "GetParametersForImportRequest("
        if self.key_id is not None:
            result += f"key_id={repr(self.key_id)}, "

        if self.wrapping_algorithm is not None:
            result += f"wrapping_algorithm={repr(self.wrapping_algorithm)}, "

        if self.wrapping_key_spec is not None:
            result += f"wrapping_key_spec={repr(self.wrapping_key_spec)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, GetParametersForImportRequest):
            return False
        attributes: list[str] = ['key_id','wrapping_algorithm','wrapping_key_spec',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class GetParametersForImportResponse:
    key_id: Optional[str]
    import_token: Optional[bytes | bytearray]
    public_key: Optional[bytes | bytearray]
    parameters_valid_to: int
    def __init__(
        self,
        *,
        key_id: Optional[str] = None,
        import_token: Optional[bytes | bytearray] = None,
        public_key: Optional[bytes | bytearray] = None,
        parameters_valid_to: int = 0,
    ):
        """
        :param key_id: <p>The Amazon Resource Name (<a
        href="https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#key-id-key-ARN">key
        ARN</a>) of the KMS key to use in a subsequent <a>ImportKeyMaterial</a> request.
        This is the same KMS key specified in the <code>GetParametersForImport</code>

        request.</p>
        :param import_token: <p>The import token to send in a subsequent
        <a>ImportKeyMaterial</a>
              request.</p>
        :param public_key: <p>The public key to use to encrypt the key material before
        importing it with <a>ImportKeyMaterial</a>.</p>
        :param parameters_valid_to: <p>The time at which the import token and public key
        are no longer valid. After this time,
              you cannot use them to make an
        <a>ImportKeyMaterial</a> request and you must send
              another
        <code>GetParametersForImport</code> request to get new ones.</p>
        """
        self.key_id = key_id
        self.import_token = import_token
        self.public_key = public_key
        self.parameters_valid_to = parameters_valid_to

    def as_dict(self) -> Dict[str, Any]:
        """Converts the GetParametersForImportResponse to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        d: Dict[str, Any] = {}

        if self.key_id is not None:
            d["KeyId"] = self.key_id

        if self.import_token is not None:
            d["ImportToken"] = self.import_token

        if self.public_key is not None:
            d["PublicKey"] = self.public_key

        if self.parameters_valid_to is not None:
            d["ParametersValidTo"] = self.parameters_valid_to

        return d

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "GetParametersForImportResponse":
        """Creates a GetParametersForImportResponse from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {}

        if "KeyId" in d:
            kwargs["key_id"] = d["KeyId"]

        if "ImportToken" in d:
            kwargs["import_token"] = d["ImportToken"]

        if "PublicKey" in d:
            kwargs["public_key"] = d["PublicKey"]

        if "ParametersValidTo" in d:
            kwargs["parameters_valid_to"] = d["ParametersValidTo"]

        return GetParametersForImportResponse(**kwargs)

    def __repr__(self) -> str:
        result = "GetParametersForImportResponse("
        if self.key_id is not None:
            result += f"key_id={repr(self.key_id)}, "

        if self.import_token is not None:
            result += f"import_token={repr(self.import_token)}, "

        if self.public_key is not None:
            result += f"public_key={repr(self.public_key)}, "

        if self.parameters_valid_to is not None:
            result += f"parameters_valid_to={repr(self.parameters_valid_to)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, GetParametersForImportResponse):
            return False
        attributes: list[str] = ['key_id','import_token','public_key','parameters_valid_to',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class GetPublicKeyRequest:
    key_id: str
    grant_tokens: Optional[list[str]]
    def __init__(
        self,
        *,
        key_id: str,
        grant_tokens: Optional[list[str]] = None,
    ):
        """
        :param key_id: <p>Identifies the asymmetric KMS key that includes the public
        key.</p>

                 <p>To specify a KMS key, use its key ID, key ARN, alias
        name, or alias ARN. When using an alias name, prefix it with
        <code>"alias/"</code>. To specify a KMS key in a different Amazon Web Services
        account, you must use the key ARN or alias ARN.</p>
                 <p>For
        example:</p>
                 <ul>
                    <li>
                       <p>Key ID:
        <code>1234abcd-12ab-34cd-56ef-1234567890ab</code>
                       </p>

        </li>
                    <li>
                       <p>Key ARN:
        <code>arn:aws:kms:us-east-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab</code>

        </p>
                    </li>
                    <li>
                       <p>Alias name:
        <code>alias/ExampleAlias</code>
                       </p>
                    </li>

        <li>
                       <p>Alias ARN:
        <code>arn:aws:kms:us-east-2:111122223333:alias/ExampleAlias</code>

        </p>
                    </li>
                 </ul>
                 <p>To get the key ID and key ARN
        for a KMS key, use <a>ListKeys</a> or <a>DescribeKey</a>. To get the alias name
        and alias ARN, use <a>ListAliases</a>.</p>
        :param grant_tokens: <p>A list of grant tokens.</p>
                 <p>Use a grant
        token when your permission to call this operation comes from a new grant that
        has not yet achieved <i>eventual consistency</i>. For more information, see <a
        href="https://docs.aws.amazon.com/kms/latest/developerguide/grants.html#grant_token">Grant
        token</a> and <a
        href="https://docs.aws.amazon.com/kms/latest/developerguide/grant-manage.html#using-grant-token">Using
        a grant token</a> in the
            <i>Key Management Service Developer Guide</i>.</p>
        """
        self.key_id = key_id
        self.grant_tokens = grant_tokens

    def as_dict(self) -> Dict[str, Any]:
        """Converts the GetPublicKeyRequest to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        d: Dict[str, Any] = {
            "KeyId": self.key_id,
        }

        if self.grant_tokens is not None:
            d["GrantTokens"] = self.grant_tokens

        return d

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "GetPublicKeyRequest":
        """Creates a GetPublicKeyRequest from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {
            "key_id": d["KeyId"],
        }

        if "GrantTokens" in d:
            kwargs["grant_tokens"] = d["GrantTokens"]

        return GetPublicKeyRequest(**kwargs)

    def __repr__(self) -> str:
        result = "GetPublicKeyRequest("
        if self.key_id is not None:
            result += f"key_id={repr(self.key_id)}, "

        if self.grant_tokens is not None:
            result += f"grant_tokens={repr(self.grant_tokens)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, GetPublicKeyRequest):
            return False
        attributes: list[str] = ['key_id','grant_tokens',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class GetPublicKeyResponse:
    key_id: Optional[str]
    public_key: Optional[bytes | bytearray]
    customer_master_key_spec: Optional[str]
    key_spec: Optional[str]
    key_usage: Optional[str]
    encryption_algorithms: Optional[list[str]]
    signing_algorithms: Optional[list[str]]
    def __init__(
        self,
        *,
        key_id: Optional[str] = None,
        public_key: Optional[bytes | bytearray] = None,
        customer_master_key_spec: Optional[str] = None,
        key_spec: Optional[str] = None,
        key_usage: Optional[str] = None,
        encryption_algorithms: Optional[list[str]] = None,
        signing_algorithms: Optional[list[str]] = None,
    ):
        """
        :param key_id: <p>The Amazon Resource Name (<a
        href="https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#key-id-key-ARN">key
        ARN</a>) of the asymmetric KMS key from which the public key was

        downloaded.</p>
        :param public_key: <p>The exported public key. </p>
                 <p>The value is a
        DER-encoded X.509 public key, also known as

        <code>SubjectPublicKeyInfo</code> (SPKI), as defined in <a
        href="https://tools.ietf.org/html/rfc5280">RFC 5280</a>. When you use the HTTP
        API or the Amazon Web Services CLI, the value is Base64-encoded. Otherwise, it
        is not Base64-encoded.</p>
                 <p></p>
        :param customer_master_key_spec: <p>Instead, use the <code>KeySpec</code> field
        in the <code>GetPublicKey</code>
              response.</p>
                 <p>The
        <code>KeySpec</code> and <code>CustomerMasterKeySpec</code> fields have the
        same
              value. We recommend that you use the <code>KeySpec</code> field in
        your code. However, to
              avoid breaking changes, KMS will support both
        fields.</p>
        :param key_spec: <p>The type of the of the public key that was downloaded.</p>
        :param key_usage: <p>The permitted use of the public key. Valid values are
        <code>ENCRYPT_DECRYPT</code> or
                <code>SIGN_VERIFY</code>. </p>

        <p>This information is critical. If a public key with <code>SIGN_VERIFY</code>
        key usage
              encrypts data outside of KMS, the ciphertext cannot be
        decrypted. </p>
        :param encryption_algorithms: <p>The encryption algorithms that KMS supports for
        this key. </p>
                 <p>This information is critical. If a public key
        encrypts data outside of KMS by using an
              unsupported encryption algorithm,
        the ciphertext cannot be decrypted. </p>
                 <p>This field appears in the
        response only when the <code>KeyUsage</code> of the public key
              is
        <code>ENCRYPT_DECRYPT</code>.</p>
        :param signing_algorithms: <p>The signing algorithms that KMS supports for this
        key.</p>
                 <p>This field appears in the response only when the
        <code>KeyUsage</code> of the public key
              is <code>SIGN_VERIFY</code>.</p>
        """
        self.key_id = key_id
        self.public_key = public_key
        self.customer_master_key_spec = customer_master_key_spec
        self.key_spec = key_spec
        self.key_usage = key_usage
        self.encryption_algorithms = encryption_algorithms
        self.signing_algorithms = signing_algorithms

    def as_dict(self) -> Dict[str, Any]:
        """Converts the GetPublicKeyResponse to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        d: Dict[str, Any] = {}

        if self.key_id is not None:
            d["KeyId"] = self.key_id

        if self.public_key is not None:
            d["PublicKey"] = self.public_key

        if self.customer_master_key_spec is not None:
            d["CustomerMasterKeySpec"] = self.customer_master_key_spec

        if self.key_spec is not None:
            d["KeySpec"] = self.key_spec

        if self.key_usage is not None:
            d["KeyUsage"] = self.key_usage

        if self.encryption_algorithms is not None:
            d["EncryptionAlgorithms"] = self.encryption_algorithms

        if self.signing_algorithms is not None:
            d["SigningAlgorithms"] = self.signing_algorithms

        return d

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "GetPublicKeyResponse":
        """Creates a GetPublicKeyResponse from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {}

        if "KeyId" in d:
            kwargs["key_id"] = d["KeyId"]

        if "PublicKey" in d:
            kwargs["public_key"] = d["PublicKey"]

        if "CustomerMasterKeySpec" in d:
            kwargs["customer_master_key_spec"] = d["CustomerMasterKeySpec"]

        if "KeySpec" in d:
            kwargs["key_spec"] = d["KeySpec"]

        if "KeyUsage" in d:
            kwargs["key_usage"] = d["KeyUsage"]

        if "EncryptionAlgorithms" in d:
            kwargs["encryption_algorithms"] = d["EncryptionAlgorithms"]

        if "SigningAlgorithms" in d:
            kwargs["signing_algorithms"] = d["SigningAlgorithms"]

        return GetPublicKeyResponse(**kwargs)

    def __repr__(self) -> str:
        result = "GetPublicKeyResponse("
        if self.key_id is not None:
            result += f"key_id={repr(self.key_id)}, "

        if self.public_key is not None:
            result += f"public_key={repr(self.public_key)}, "

        if self.customer_master_key_spec is not None:
            result += f"customer_master_key_spec={repr(self.customer_master_key_spec)}, "

        if self.key_spec is not None:
            result += f"key_spec={repr(self.key_spec)}, "

        if self.key_usage is not None:
            result += f"key_usage={repr(self.key_usage)}, "

        if self.encryption_algorithms is not None:
            result += f"encryption_algorithms={repr(self.encryption_algorithms)}, "

        if self.signing_algorithms is not None:
            result += f"signing_algorithms={repr(self.signing_algorithms)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, GetPublicKeyResponse):
            return False
        attributes: list[str] = ['key_id','public_key','customer_master_key_spec','key_spec','key_usage','encryption_algorithms','signing_algorithms',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class GrantListEntry:
    key_id: Optional[str]
    grant_id: Optional[str]
    name: Optional[str]
    creation_date: int
    grantee_principal: Optional[str]
    retiring_principal: Optional[str]
    issuing_account: Optional[str]
    operations: Optional[list[str]]
    constraints: Optional[GrantConstraints]
    def __init__(
        self,
        *,
        key_id: Optional[str] = None,
        grant_id: Optional[str] = None,
        name: Optional[str] = None,
        creation_date: int = 0,
        grantee_principal: Optional[str] = None,
        retiring_principal: Optional[str] = None,
        issuing_account: Optional[str] = None,
        operations: Optional[list[str]] = None,
        constraints: Optional[GrantConstraints] = None,
    ):
        """<p>Contains information about a grant.</p>

        :param key_id: <p>The unique identifier for the KMS key to which the grant
        applies.</p>
        :param grant_id: <p>The unique identifier for the grant.</p>
        :param name: <p>The friendly name that identifies the grant. If a name was
        provided in the <a>CreateGrant</a> request, that name is returned. Otherwise
        this value is null.</p>
        :param creation_date: <p>The date and time when the grant was created.</p>
        :param grantee_principal: <p>The identity that gets the permissions in the
        grant.</p>
                 <p>The <code>GranteePrincipal</code> field in the
        <code>ListGrants</code> response usually contains the
                user or role
        designated as the grantee principal in the grant. However, when the grantee

        principal in the grant is an Amazon Web Services service, the
        <code>GranteePrincipal</code> field contains
                the <a
        href="https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_policies_elements_principal.html#principal-services">service

        principal</a>, which might represent several different grantee principals.</p>
        :param retiring_principal: <p>The principal that can retire the grant.</p>
        :param issuing_account: <p>The Amazon Web Services account under which the grant
        was issued.</p>
        :param operations: <p>The list of operations permitted by the grant.</p>
        :param constraints: <p>A list of key-value pairs that must be present in the
        encryption context of certain
              subsequent operations that the grant
        allows.</p>
        """
        self.key_id = key_id
        self.grant_id = grant_id
        self.name = name
        self.creation_date = creation_date
        self.grantee_principal = grantee_principal
        self.retiring_principal = retiring_principal
        self.issuing_account = issuing_account
        self.operations = operations
        self.constraints = constraints

    def as_dict(self) -> Dict[str, Any]:
        """Converts the GrantListEntry to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        d: Dict[str, Any] = {}

        if self.key_id is not None:
            d["KeyId"] = self.key_id

        if self.grant_id is not None:
            d["GrantId"] = self.grant_id

        if self.name is not None:
            d["Name"] = self.name

        if self.creation_date is not None:
            d["CreationDate"] = self.creation_date

        if self.grantee_principal is not None:
            d["GranteePrincipal"] = self.grantee_principal

        if self.retiring_principal is not None:
            d["RetiringPrincipal"] = self.retiring_principal

        if self.issuing_account is not None:
            d["IssuingAccount"] = self.issuing_account

        if self.operations is not None:
            d["Operations"] = self.operations

        if self.constraints is not None:
            d["Constraints"] = self.constraints.as_dict()

        return d

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "GrantListEntry":
        """Creates a GrantListEntry from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {}

        if "KeyId" in d:
            kwargs["key_id"] = d["KeyId"]

        if "GrantId" in d:
            kwargs["grant_id"] = d["GrantId"]

        if "Name" in d:
            kwargs["name"] = d["Name"]

        if "CreationDate" in d:
            kwargs["creation_date"] = d["CreationDate"]

        if "GranteePrincipal" in d:
            kwargs["grantee_principal"] = d["GranteePrincipal"]

        if "RetiringPrincipal" in d:
            kwargs["retiring_principal"] = d["RetiringPrincipal"]

        if "IssuingAccount" in d:
            kwargs["issuing_account"] = d["IssuingAccount"]

        if "Operations" in d:
            kwargs["operations"] = d["Operations"]

        if "Constraints" in d:
            kwargs["constraints"] = GrantConstraints.from_dict(d["Constraints"])

        return GrantListEntry(**kwargs)

    def __repr__(self) -> str:
        result = "GrantListEntry("
        if self.key_id is not None:
            result += f"key_id={repr(self.key_id)}, "

        if self.grant_id is not None:
            result += f"grant_id={repr(self.grant_id)}, "

        if self.name is not None:
            result += f"name={repr(self.name)}, "

        if self.creation_date is not None:
            result += f"creation_date={repr(self.creation_date)}, "

        if self.grantee_principal is not None:
            result += f"grantee_principal={repr(self.grantee_principal)}, "

        if self.retiring_principal is not None:
            result += f"retiring_principal={repr(self.retiring_principal)}, "

        if self.issuing_account is not None:
            result += f"issuing_account={repr(self.issuing_account)}, "

        if self.operations is not None:
            result += f"operations={repr(self.operations)}, "

        if self.constraints is not None:
            result += f"constraints={repr(self.constraints)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, GrantListEntry):
            return False
        attributes: list[str] = ['key_id','grant_id','name','creation_date','grantee_principal','retiring_principal','issuing_account','operations','constraints',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class ImportKeyMaterialRequest:
    key_id: str
    import_token: bytes | bytearray
    encrypted_key_material: bytes | bytearray
    valid_to: int
    expiration_model: Optional[str]
    def __init__(
        self,
        *,
        key_id: str,
        import_token: bytes | bytearray,
        encrypted_key_material: bytes | bytearray,
        valid_to: int = 0,
        expiration_model: Optional[str] = None,
    ):
        """
        :param key_id: <p>The identifier of the symmetric KMS key that receives the
        imported key material. The KMS
              key's <code>Origin</code> must be
        <code>EXTERNAL</code>. This must be the same KMS key
              specified in the
        <code>KeyID</code> parameter of the corresponding <a>GetParametersForImport</a>
        request.</p>
                 <p>Specify the key ID or key ARN of the KMS key.</p>

        <p>For example:</p>
                 <ul>
                    <li>
                       <p>Key ID:
        <code>1234abcd-12ab-34cd-56ef-1234567890ab</code>
                       </p>

        </li>
                    <li>
                       <p>Key ARN:
        <code>arn:aws:kms:us-east-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab</code>

        </p>
                    </li>
                 </ul>
                 <p>To get the key ID and key
        ARN for a KMS key, use <a>ListKeys</a> or <a>DescribeKey</a>.</p>
        :param import_token: <p>The import token that you received in the response to a
        previous <a>GetParametersForImport</a> request. It must be from the same
        response that contained
              the public key that you used to encrypt the key
        material.</p>
        :param encrypted_key_material: <p>The encrypted key material to import. The key
        material must be encrypted with the public
              wrapping key that
        <a>GetParametersForImport</a> returned, using the wrapping
              algorithm that
        you specified in the same <code>GetParametersForImport</code> request.</p>
        :param valid_to: <p>The time at which the imported key material expires. When
        the key material expires, KMS
              deletes the key material and the KMS key
        becomes unusable. You must omit this parameter when
              the
        <code>ExpirationModel</code> parameter is set to

        <code>KEY_MATERIAL_DOES_NOT_EXPIRE</code>. Otherwise it is required.</p>
        :param expiration_model: <p>Specifies whether the key material expires. The
        default is
                <code>KEY_MATERIAL_EXPIRES</code>, in which case you must
        include the <code>ValidTo</code>
              parameter. When this parameter is set to
        <code>KEY_MATERIAL_DOES_NOT_EXPIRE</code>, you must
              omit the
        <code>ValidTo</code> parameter.</p>
        """
        self.key_id = key_id
        self.import_token = import_token
        self.encrypted_key_material = encrypted_key_material
        self.valid_to = valid_to
        self.expiration_model = expiration_model

    def as_dict(self) -> Dict[str, Any]:
        """Converts the ImportKeyMaterialRequest to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        d: Dict[str, Any] = {
            "KeyId": self.key_id,
            "ImportToken": self.import_token,
            "EncryptedKeyMaterial": self.encrypted_key_material,
        }

        if self.valid_to is not None:
            d["ValidTo"] = self.valid_to

        if self.expiration_model is not None:
            d["ExpirationModel"] = self.expiration_model

        return d

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "ImportKeyMaterialRequest":
        """Creates a ImportKeyMaterialRequest from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {
            "key_id": d["KeyId"],
            "import_token": d["ImportToken"],
            "encrypted_key_material": d["EncryptedKeyMaterial"],
        }

        if "ValidTo" in d:
            kwargs["valid_to"] = d["ValidTo"]

        if "ExpirationModel" in d:
            kwargs["expiration_model"] = d["ExpirationModel"]

        return ImportKeyMaterialRequest(**kwargs)

    def __repr__(self) -> str:
        result = "ImportKeyMaterialRequest("
        if self.key_id is not None:
            result += f"key_id={repr(self.key_id)}, "

        if self.import_token is not None:
            result += f"import_token={repr(self.import_token)}, "

        if self.encrypted_key_material is not None:
            result += f"encrypted_key_material={repr(self.encrypted_key_material)}, "

        if self.valid_to is not None:
            result += f"valid_to={repr(self.valid_to)}, "

        if self.expiration_model is not None:
            result += f"expiration_model={repr(self.expiration_model)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, ImportKeyMaterialRequest):
            return False
        attributes: list[str] = ['key_id','import_token','encrypted_key_material','valid_to','expiration_model',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class ImportKeyMaterialResponse:
    def as_dict(self) -> Dict[str, Any]:
        """Converts the ImportKeyMaterialResponse to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        return {}

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "ImportKeyMaterialResponse":
        """Creates a ImportKeyMaterialResponse from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        return ImportKeyMaterialResponse()

    def __repr__(self) -> str:
        result = "ImportKeyMaterialResponse("

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        return isinstance(other, ImportKeyMaterialResponse)

class ListAliasesRequest:
    key_id: Optional[str]
    limit: Optional[int]
    marker: Optional[str]
    def __init__(
        self,
        *,
        key_id: Optional[str] = None,
        limit: Optional[int] = None,
        marker: Optional[str] = None,
    ):
        """
        :param key_id: <p>Lists only aliases that are associated with the specified KMS
        key. Enter a KMS key in your
              Amazon Web Services account. </p>

        <p>This parameter is optional. If you omit it, <code>ListAliases</code> returns
        all aliases
              in the account and Region.</p>
                 <p>Specify the key ID
        or key ARN of the KMS key.</p>
                 <p>For example:</p>
                 <ul>

        <li>
                       <p>Key ID:
        <code>1234abcd-12ab-34cd-56ef-1234567890ab</code>
                       </p>

        </li>
                    <li>
                       <p>Key ARN:
        <code>arn:aws:kms:us-east-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab</code>

        </p>
                    </li>
                 </ul>
                 <p>To get the key ID and key
        ARN for a KMS key, use <a>ListKeys</a> or <a>DescribeKey</a>.</p>
        :param limit: <p>Use this parameter to specify the maximum number of items to
        return. When this
            value is present, KMS does not return more than the
        specified number of items, but it might
            return fewer.</p>
                 <p>This
        value is optional. If you include a value, it must be between 1
            and 100,
        inclusive. If you do not include a value, it defaults to 50.</p>
        :param marker: <p>Use this parameter in a subsequent request after you receive a
        response with
            truncated results. Set it to the value of
        <code>NextMarker</code> from the truncated response
            you just received.</p>
        """
        self.key_id = key_id
        self.limit = limit
        self.marker = marker

    def as_dict(self) -> Dict[str, Any]:
        """Converts the ListAliasesRequest to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        d: Dict[str, Any] = {}

        if self.key_id is not None:
            d["KeyId"] = self.key_id

        if self.limit is not None:
            d["Limit"] = self.limit

        if self.marker is not None:
            d["Marker"] = self.marker

        return d

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "ListAliasesRequest":
        """Creates a ListAliasesRequest from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {}

        if "KeyId" in d:
            kwargs["key_id"] = d["KeyId"]

        if "Limit" in d:
            kwargs["limit"] = d["Limit"]

        if "Marker" in d:
            kwargs["marker"] = d["Marker"]

        return ListAliasesRequest(**kwargs)

    def __repr__(self) -> str:
        result = "ListAliasesRequest("
        if self.key_id is not None:
            result += f"key_id={repr(self.key_id)}, "

        if self.limit is not None:
            result += f"limit={repr(self.limit)}, "

        if self.marker is not None:
            result += f"marker={repr(self.marker)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, ListAliasesRequest):
            return False
        attributes: list[str] = ['key_id','limit','marker',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class ListAliasesResponse:
    aliases: Optional[list[AliasListEntry]]
    next_marker: Optional[str]
    truncated: bool
    def __init__(
        self,
        *,
        aliases: Optional[list[AliasListEntry]] = None,
        next_marker: Optional[str] = None,
        truncated: bool = False,
    ):
        """
        :param aliases: <p>A list of aliases.</p>
        :param next_marker: <p>When <code>Truncated</code> is true, this element is
        present and contains the
            value to use for the <code>Marker</code> parameter
        in a subsequent request.</p>
        :param truncated: <p>A flag that indicates whether there are more items in the
        list. When this
            value is true, the list in this response is truncated. To
        get more items, pass the value of
            the <code>NextMarker</code> element in
        thisresponse to the <code>Marker</code> parameter in a
            subsequent
        request.</p>
        """
        self.aliases = aliases
        self.next_marker = next_marker
        self.truncated = truncated

    def as_dict(self) -> Dict[str, Any]:
        """Converts the ListAliasesResponse to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        d: Dict[str, Any] = {}

        if self.aliases is not None:
            d["Aliases"] = _alias_list_as_dict(self.aliases),

        if self.next_marker is not None:
            d["NextMarker"] = self.next_marker

        if self.truncated is not None:
            d["Truncated"] = self.truncated

        return d

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "ListAliasesResponse":
        """Creates a ListAliasesResponse from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {}

        if "Aliases" in d:
            kwargs["aliases"] = _alias_list_from_dict(d["Aliases"]),

        if "NextMarker" in d:
            kwargs["next_marker"] = d["NextMarker"]

        if "Truncated" in d:
            kwargs["truncated"] = d["Truncated"]

        return ListAliasesResponse(**kwargs)

    def __repr__(self) -> str:
        result = "ListAliasesResponse("
        if self.aliases is not None:
            result += f"aliases={repr(self.aliases)}, "

        if self.next_marker is not None:
            result += f"next_marker={repr(self.next_marker)}, "

        if self.truncated is not None:
            result += f"truncated={repr(self.truncated)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, ListAliasesResponse):
            return False
        attributes: list[str] = ['aliases','next_marker','truncated',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class ListGrantsRequest:
    limit: Optional[int]
    marker: Optional[str]
    key_id: str
    grant_id: Optional[str]
    grantee_principal: Optional[str]
    def __init__(
        self,
        *,
        key_id: str,
        limit: Optional[int] = None,
        marker: Optional[str] = None,
        grant_id: Optional[str] = None,
        grantee_principal: Optional[str] = None,
    ):
        """
        :param key_id: <p>Returns only grants for the specified KMS key. This parameter
        is required.</p>

                 <p>Specify the key ID or key ARN of the KMS key.
        To specify a KMS key in a
        different Amazon Web Services account, you must use
        the key ARN.</p>
                 <p>For example:</p>
                 <ul>
                    <li>

        <p>Key ID: <code>1234abcd-12ab-34cd-56ef-1234567890ab</code>

        </p>
                    </li>
                    <li>
                       <p>Key ARN:
        <code>arn:aws:kms:us-east-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab</code>

        </p>
                    </li>
                 </ul>
                 <p>To get the key ID and key
        ARN for a KMS key, use <a>ListKeys</a> or <a>DescribeKey</a>.</p>
        :param limit: <p>Use this parameter to specify the maximum number of items to
        return. When this
            value is present, KMS does not return more than the
        specified number of items, but it might
            return fewer.</p>
                 <p>This
        value is optional. If you include a value, it must be between 1
            and 100,
        inclusive. If you do not include a value, it defaults to 50.</p>
        :param marker: <p>Use this parameter in a subsequent request after you receive a
        response with
            truncated results. Set it to the value of
        <code>NextMarker</code> from the truncated response
            you just received.</p>
        :param grant_id: <p>Returns only the grant with the specified grant ID. The
        grant ID uniquely identifies the
              grant. </p>
        :param grantee_principal: <p>Returns only grants where the specified principal
        is the grantee principal for the
              grant.</p>
        """
        self.key_id = key_id
        self.limit = limit
        self.marker = marker
        self.grant_id = grant_id
        self.grantee_principal = grantee_principal

    def as_dict(self) -> Dict[str, Any]:
        """Converts the ListGrantsRequest to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        d: Dict[str, Any] = {
            "KeyId": self.key_id,
        }

        if self.limit is not None:
            d["Limit"] = self.limit

        if self.marker is not None:
            d["Marker"] = self.marker

        if self.grant_id is not None:
            d["GrantId"] = self.grant_id

        if self.grantee_principal is not None:
            d["GranteePrincipal"] = self.grantee_principal

        return d

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "ListGrantsRequest":
        """Creates a ListGrantsRequest from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {
            "key_id": d["KeyId"],
        }

        if "Limit" in d:
            kwargs["limit"] = d["Limit"]

        if "Marker" in d:
            kwargs["marker"] = d["Marker"]

        if "GrantId" in d:
            kwargs["grant_id"] = d["GrantId"]

        if "GranteePrincipal" in d:
            kwargs["grantee_principal"] = d["GranteePrincipal"]

        return ListGrantsRequest(**kwargs)

    def __repr__(self) -> str:
        result = "ListGrantsRequest("
        if self.limit is not None:
            result += f"limit={repr(self.limit)}, "

        if self.marker is not None:
            result += f"marker={repr(self.marker)}, "

        if self.key_id is not None:
            result += f"key_id={repr(self.key_id)}, "

        if self.grant_id is not None:
            result += f"grant_id={repr(self.grant_id)}, "

        if self.grantee_principal is not None:
            result += f"grantee_principal={repr(self.grantee_principal)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, ListGrantsRequest):
            return False
        attributes: list[str] = ['limit','marker','key_id','grant_id','grantee_principal',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class ListGrantsResponse:
    grants: Optional[list[GrantListEntry]]
    next_marker: Optional[str]
    truncated: bool
    def __init__(
        self,
        *,
        grants: Optional[list[GrantListEntry]] = None,
        next_marker: Optional[str] = None,
        truncated: bool = False,
    ):
        """
        :param grants: <p>A list of grants.</p>
        :param next_marker: <p>When <code>Truncated</code> is true, this element is
        present and contains the
            value to use for the <code>Marker</code> parameter
        in a subsequent request.</p>
        :param truncated: <p>A flag that indicates whether there are more items in the
        list. When this
            value is true, the list in this response is truncated. To
        get more items, pass the value of
            the <code>NextMarker</code> element in
        thisresponse to the <code>Marker</code> parameter in a
            subsequent
        request.</p>
        """
        self.grants = grants
        self.next_marker = next_marker
        self.truncated = truncated

    def as_dict(self) -> Dict[str, Any]:
        """Converts the ListGrantsResponse to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        d: Dict[str, Any] = {}

        if self.grants is not None:
            d["Grants"] = _grant_list_as_dict(self.grants),

        if self.next_marker is not None:
            d["NextMarker"] = self.next_marker

        if self.truncated is not None:
            d["Truncated"] = self.truncated

        return d

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "ListGrantsResponse":
        """Creates a ListGrantsResponse from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {}

        if "Grants" in d:
            kwargs["grants"] = _grant_list_from_dict(d["Grants"]),

        if "NextMarker" in d:
            kwargs["next_marker"] = d["NextMarker"]

        if "Truncated" in d:
            kwargs["truncated"] = d["Truncated"]

        return ListGrantsResponse(**kwargs)

    def __repr__(self) -> str:
        result = "ListGrantsResponse("
        if self.grants is not None:
            result += f"grants={repr(self.grants)}, "

        if self.next_marker is not None:
            result += f"next_marker={repr(self.next_marker)}, "

        if self.truncated is not None:
            result += f"truncated={repr(self.truncated)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, ListGrantsResponse):
            return False
        attributes: list[str] = ['grants','next_marker','truncated',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class ListKeyPoliciesRequest:
    key_id: str
    limit: Optional[int]
    marker: Optional[str]
    def __init__(
        self,
        *,
        key_id: str,
        limit: Optional[int] = None,
        marker: Optional[str] = None,
    ):
        """
        :param key_id: <p>Gets the names of key policies for the specified KMS key.</p>

                 <p>Specify the key ID or key ARN of the KMS key.</p>
                 <p>For
        example:</p>
                 <ul>
                    <li>
                       <p>Key ID:
        <code>1234abcd-12ab-34cd-56ef-1234567890ab</code>
                       </p>

        </li>
                    <li>
                       <p>Key ARN:
        <code>arn:aws:kms:us-east-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab</code>

        </p>
                    </li>
                 </ul>
                 <p>To get the key ID and key
        ARN for a KMS key, use <a>ListKeys</a> or <a>DescribeKey</a>.</p>
        :param limit: <p>Use this parameter to specify the maximum number of items to
        return. When this
            value is present, KMS does not return more than the
        specified number of items, but it might
            return fewer.</p>
                 <p>This
        value is optional. If you include a value, it must be between
            1 and 1000,
        inclusive. If you do not include a value, it defaults to 100.</p>

        <p>Only one policy can be attached to a key.</p>
        :param marker: <p>Use this parameter in a subsequent request after you receive a
        response with
            truncated results. Set it to the value of
        <code>NextMarker</code> from the truncated response
            you just received.</p>
        """
        self.key_id = key_id
        self.limit = limit
        self.marker = marker

    def as_dict(self) -> Dict[str, Any]:
        """Converts the ListKeyPoliciesRequest to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        d: Dict[str, Any] = {
            "KeyId": self.key_id,
        }

        if self.limit is not None:
            d["Limit"] = self.limit

        if self.marker is not None:
            d["Marker"] = self.marker

        return d

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "ListKeyPoliciesRequest":
        """Creates a ListKeyPoliciesRequest from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {
            "key_id": d["KeyId"],
        }

        if "Limit" in d:
            kwargs["limit"] = d["Limit"]

        if "Marker" in d:
            kwargs["marker"] = d["Marker"]

        return ListKeyPoliciesRequest(**kwargs)

    def __repr__(self) -> str:
        result = "ListKeyPoliciesRequest("
        if self.key_id is not None:
            result += f"key_id={repr(self.key_id)}, "

        if self.limit is not None:
            result += f"limit={repr(self.limit)}, "

        if self.marker is not None:
            result += f"marker={repr(self.marker)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, ListKeyPoliciesRequest):
            return False
        attributes: list[str] = ['key_id','limit','marker',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class ListKeyPoliciesResponse:
    policy_names: Optional[list[str]]
    next_marker: Optional[str]
    truncated: bool
    def __init__(
        self,
        *,
        policy_names: Optional[list[str]] = None,
        next_marker: Optional[str] = None,
        truncated: bool = False,
    ):
        """
        :param policy_names: <p>A list of key policy names. The only valid value is
        <code>default</code>.</p>
        :param next_marker: <p>When <code>Truncated</code> is true, this element is
        present and contains the
            value to use for the <code>Marker</code> parameter
        in a subsequent request.</p>
        :param truncated: <p>A flag that indicates whether there are more items in the
        list. When this
            value is true, the list in this response is truncated. To
        get more items, pass the value of
            the <code>NextMarker</code> element in
        thisresponse to the <code>Marker</code> parameter in a
            subsequent
        request.</p>
        """
        self.policy_names = policy_names
        self.next_marker = next_marker
        self.truncated = truncated

    def as_dict(self) -> Dict[str, Any]:
        """Converts the ListKeyPoliciesResponse to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        d: Dict[str, Any] = {}

        if self.policy_names is not None:
            d["PolicyNames"] = self.policy_names

        if self.next_marker is not None:
            d["NextMarker"] = self.next_marker

        if self.truncated is not None:
            d["Truncated"] = self.truncated

        return d

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "ListKeyPoliciesResponse":
        """Creates a ListKeyPoliciesResponse from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {}

        if "PolicyNames" in d:
            kwargs["policy_names"] = d["PolicyNames"]

        if "NextMarker" in d:
            kwargs["next_marker"] = d["NextMarker"]

        if "Truncated" in d:
            kwargs["truncated"] = d["Truncated"]

        return ListKeyPoliciesResponse(**kwargs)

    def __repr__(self) -> str:
        result = "ListKeyPoliciesResponse("
        if self.policy_names is not None:
            result += f"policy_names={repr(self.policy_names)}, "

        if self.next_marker is not None:
            result += f"next_marker={repr(self.next_marker)}, "

        if self.truncated is not None:
            result += f"truncated={repr(self.truncated)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, ListKeyPoliciesResponse):
            return False
        attributes: list[str] = ['policy_names','next_marker','truncated',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class ListResourceTagsRequest:
    key_id: str
    limit: Optional[int]
    marker: Optional[str]
    def __init__(
        self,
        *,
        key_id: str,
        limit: Optional[int] = None,
        marker: Optional[str] = None,
    ):
        """
        :param key_id: <p>Gets tags on the specified KMS key.</p>
                 <p>Specify
        the key ID or key ARN of the KMS key.</p>
                 <p>For example:</p>

        <ul>
                    <li>
                       <p>Key ID:
        <code>1234abcd-12ab-34cd-56ef-1234567890ab</code>
                       </p>

        </li>
                    <li>
                       <p>Key ARN:
        <code>arn:aws:kms:us-east-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab</code>

        </p>
                    </li>
                 </ul>
                 <p>To get the key ID and key
        ARN for a KMS key, use <a>ListKeys</a> or <a>DescribeKey</a>.</p>
        :param limit: <p>Use this parameter to specify the maximum number of items to
        return. When this
            value is present, KMS does not return more than the
        specified number of items, but it might
            return fewer.</p>
                 <p>This
        value is optional. If you include a value, it must be between 1 and 50,
        inclusive. If
              you do not include a value, it defaults to 50.</p>
        :param marker: <p>Use this parameter in a subsequent request after you receive a
        response with
            truncated results. Set it to the value of
        <code>NextMarker</code> from the truncated response
            you just received.</p>

        <p>Do not attempt to construct this value. Use only the value of
        <code>NextMarker</code> from
              the truncated response you just received.</p>
        """
        self.key_id = key_id
        self.limit = limit
        self.marker = marker

    def as_dict(self) -> Dict[str, Any]:
        """Converts the ListResourceTagsRequest to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        d: Dict[str, Any] = {
            "KeyId": self.key_id,
        }

        if self.limit is not None:
            d["Limit"] = self.limit

        if self.marker is not None:
            d["Marker"] = self.marker

        return d

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "ListResourceTagsRequest":
        """Creates a ListResourceTagsRequest from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {
            "key_id": d["KeyId"],
        }

        if "Limit" in d:
            kwargs["limit"] = d["Limit"]

        if "Marker" in d:
            kwargs["marker"] = d["Marker"]

        return ListResourceTagsRequest(**kwargs)

    def __repr__(self) -> str:
        result = "ListResourceTagsRequest("
        if self.key_id is not None:
            result += f"key_id={repr(self.key_id)}, "

        if self.limit is not None:
            result += f"limit={repr(self.limit)}, "

        if self.marker is not None:
            result += f"marker={repr(self.marker)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, ListResourceTagsRequest):
            return False
        attributes: list[str] = ['key_id','limit','marker',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class ListResourceTagsResponse:
    tags: Optional[list[Tag]]
    next_marker: Optional[str]
    truncated: bool
    def __init__(
        self,
        *,
        tags: Optional[list[Tag]] = None,
        next_marker: Optional[str] = None,
        truncated: bool = False,
    ):
        """
        :param tags: <p>A list of tags. Each tag consists of a tag key and a tag
        value.</p>
                 <note>
                    <p>Tagging or untagging a KMS key can
        allow or deny permission to the KMS key. For details, see <a
        href="https://docs.aws.amazon.com/kms/latest/developerguide/abac.html">Using
        ABAC in KMS</a> in the <i>Key Management Service Developer Guide</i>.</p>

        </note>
        :param next_marker: <p>When <code>Truncated</code> is true, this element is
        present and contains the
            value to use for the <code>Marker</code> parameter
        in a subsequent request.</p>
                 <p>Do not assume or infer any information
        from this value.</p>
        :param truncated: <p>A flag that indicates whether there are more items in the
        list. When this
            value is true, the list in this response is truncated. To
        get more items, pass the value of
            the <code>NextMarker</code> element in
        thisresponse to the <code>Marker</code> parameter in a
            subsequent
        request.</p>
        """
        self.tags = tags
        self.next_marker = next_marker
        self.truncated = truncated

    def as_dict(self) -> Dict[str, Any]:
        """Converts the ListResourceTagsResponse to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        d: Dict[str, Any] = {}

        if self.tags is not None:
            d["Tags"] = _tag_list_as_dict(self.tags),

        if self.next_marker is not None:
            d["NextMarker"] = self.next_marker

        if self.truncated is not None:
            d["Truncated"] = self.truncated

        return d

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "ListResourceTagsResponse":
        """Creates a ListResourceTagsResponse from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {}

        if "Tags" in d:
            kwargs["tags"] = _tag_list_from_dict(d["Tags"]),

        if "NextMarker" in d:
            kwargs["next_marker"] = d["NextMarker"]

        if "Truncated" in d:
            kwargs["truncated"] = d["Truncated"]

        return ListResourceTagsResponse(**kwargs)

    def __repr__(self) -> str:
        result = "ListResourceTagsResponse("
        if self.tags is not None:
            result += f"tags={repr(self.tags)}, "

        if self.next_marker is not None:
            result += f"next_marker={repr(self.next_marker)}, "

        if self.truncated is not None:
            result += f"truncated={repr(self.truncated)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, ListResourceTagsResponse):
            return False
        attributes: list[str] = ['tags','next_marker','truncated',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class PutKeyPolicyRequest:
    key_id: str
    policy_name: str
    policy: str
    bypass_policy_lockout_safety_check: bool
    def __init__(
        self,
        *,
        key_id: str,
        policy_name: str,
        policy: str,
        bypass_policy_lockout_safety_check: bool = False,
    ):
        """
        :param key_id: <p>Sets the key policy on the specified KMS key.</p>

        <p>Specify the key ID or key ARN of the KMS key.</p>
                 <p>For
        example:</p>
                 <ul>
                    <li>
                       <p>Key ID:
        <code>1234abcd-12ab-34cd-56ef-1234567890ab</code>
                       </p>

        </li>
                    <li>
                       <p>Key ARN:
        <code>arn:aws:kms:us-east-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab</code>

        </p>
                    </li>
                 </ul>
                 <p>To get the key ID and key
        ARN for a KMS key, use <a>ListKeys</a> or <a>DescribeKey</a>.</p>
        :param policy_name: <p>The name of the key policy. The only valid value is
        <code>default</code>.</p>
        :param policy: <p>The key policy to attach to the KMS key.</p>
                 <p>The
        key policy must meet the following criteria:</p>
                 <ul>
                    <li>

        <p>If you don't set <code>BypassPolicyLockoutSafetyCheck</code> to true, the key
        policy
                  must allow the principal that is making the
        <code>PutKeyPolicy</code> request to make a
                  subsequent
        <code>PutKeyPolicy</code> request on the KMS key. This reduces the risk that

        the KMS key becomes unmanageable. For more information, refer to the scenario in
        the
                    <a
        href="https://docs.aws.amazon.com/kms/latest/developerguide/key-policies.html#key-policy-default-allow-root-enable-iam">Default
        Key Policy</a> section of the <i>Key Management Service Developer
        Guide</i>.</p>
                    </li>
                    <li>
                       <p>Each
        statement in the key policy must contain one or more principals. The principals

        in the key policy must exist and be visible to KMS. When you create a new Amazon
        Web Services
                  principal (for example, an IAM user or role), you might
        need to enforce a delay before
                  including the new principal in a key
        policy because the new principal might not be
                  immediately visible to
        KMS. For more information, see <a
        href="https://docs.aws.amazon.com/IAM/latest/UserGuide/troubleshoot_general.html#troubleshoot_general_eventual-consistency">Changes
        that I make are not always immediately visible</a> in the <i>Amazon Web
        Services
                    Identity and Access Management User Guide</i>.</p>

        </li>
                 </ul>
                 <p>The key policy cannot exceed 32 kilobytes
        (32768 bytes). For more information, see <a
        href="https://docs.aws.amazon.com/kms/latest/developerguide/resource-limits.html">Resource
        Quotas</a> in the
              <i>Key Management Service Developer Guide</i>.</p>
        :param bypass_policy_lockout_safety_check: <p>A flag to indicate whether to
        bypass the key policy lockout safety check.</p>
                 <important>

        <p>Setting this value to true increases the risk that the KMS key becomes
        unmanageable. Do
                not set this value to true indiscriminately.</p>

        <p>For more information, refer to the scenario in the <a
        href="https://docs.aws.amazon.com/kms/latest/developerguide/key-policies.html#key-policy-default-allow-root-enable-iam">Default
        Key Policy</a> section in the <i>Key Management Service Developer
        Guide</i>.</p>
                 </important>
                 <p>Use this parameter only when
        you intend to prevent the principal that is making the
              request from making
        a subsequent <code>PutKeyPolicy</code> request on the KMS key.</p>

        <p>The default value is false.</p>
        """
        self.key_id = key_id
        self.policy_name = policy_name
        self.policy = policy
        self.bypass_policy_lockout_safety_check = bypass_policy_lockout_safety_check

    def as_dict(self) -> Dict[str, Any]:
        """Converts the PutKeyPolicyRequest to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        d: Dict[str, Any] = {
            "KeyId": self.key_id,
            "PolicyName": self.policy_name,
            "Policy": self.policy,
        }

        if self.bypass_policy_lockout_safety_check is not None:
            d["BypassPolicyLockoutSafetyCheck"] = self.bypass_policy_lockout_safety_check

        return d

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "PutKeyPolicyRequest":
        """Creates a PutKeyPolicyRequest from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {
            "key_id": d["KeyId"],
            "policy_name": d["PolicyName"],
            "policy": d["Policy"],
        }

        if "BypassPolicyLockoutSafetyCheck" in d:
            kwargs["bypass_policy_lockout_safety_check"] = d["BypassPolicyLockoutSafetyCheck"]

        return PutKeyPolicyRequest(**kwargs)

    def __repr__(self) -> str:
        result = "PutKeyPolicyRequest("
        if self.key_id is not None:
            result += f"key_id={repr(self.key_id)}, "

        if self.policy_name is not None:
            result += f"policy_name={repr(self.policy_name)}, "

        if self.policy is not None:
            result += f"policy={repr(self.policy)}, "

        if self.bypass_policy_lockout_safety_check is not None:
            result += f"bypass_policy_lockout_safety_check={repr(self.bypass_policy_lockout_safety_check)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, PutKeyPolicyRequest):
            return False
        attributes: list[str] = ['key_id','policy_name','policy','bypass_policy_lockout_safety_check',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class ReEncryptRequest:
    ciphertext_blob: bytes | bytearray
    source_encryption_context: Optional[dict[str, str]]
    source_key_id: Optional[str]
    destination_key_id: str
    destination_encryption_context: Optional[dict[str, str]]
    source_encryption_algorithm: Optional[str]
    destination_encryption_algorithm: Optional[str]
    grant_tokens: Optional[list[str]]
    def __init__(
        self,
        *,
        ciphertext_blob: bytes | bytearray,
        destination_key_id: str,
        source_encryption_context: Optional[dict[str, str]] = None,
        source_key_id: Optional[str] = None,
        destination_encryption_context: Optional[dict[str, str]] = None,
        source_encryption_algorithm: Optional[str] = None,
        destination_encryption_algorithm: Optional[str] = None,
        grant_tokens: Optional[list[str]] = None,
    ):
        """
        :param ciphertext_blob: <p>Ciphertext of the data to reencrypt.</p>
        :param destination_key_id: <p>A unique identifier for the KMS key that is used
        to reencrypt the data. Specify a
              symmetric or asymmetric KMS key with a
        <code>KeyUsage</code> value of
                <code>ENCRYPT_DECRYPT</code>. To find the
        <code>KeyUsage</code> value of a KMS key, use the
                <a>DescribeKey</a>
        operation.</p>
                 <p>To specify a KMS key, use its key ID, key ARN, alias
        name, or alias ARN. When using an alias name, prefix it with
        <code>"alias/"</code>. To specify a KMS key in a different Amazon Web Services
        account, you must use the key ARN or alias ARN.</p>
                 <p>For
        example:</p>
                 <ul>
                    <li>
                       <p>Key ID:
        <code>1234abcd-12ab-34cd-56ef-1234567890ab</code>
                       </p>

        </li>
                    <li>
                       <p>Key ARN:
        <code>arn:aws:kms:us-east-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab</code>

        </p>
                    </li>
                    <li>
                       <p>Alias name:
        <code>alias/ExampleAlias</code>
                       </p>
                    </li>

        <li>
                       <p>Alias ARN:
        <code>arn:aws:kms:us-east-2:111122223333:alias/ExampleAlias</code>

        </p>
                    </li>
                 </ul>
                 <p>To get the key ID and key ARN
        for a KMS key, use <a>ListKeys</a> or <a>DescribeKey</a>. To get the alias name
        and alias ARN, use <a>ListAliases</a>.</p>
        :param source_encryption_context: <p>Specifies the encryption context to use to
        decrypt the ciphertext. Enter the same
              encryption context that was used to
        encrypt the ciphertext.</p>
                 <p>An <i>encryption context</i> is a
        collection of non-secret key-value pairs that represents additional
        authenticated data. When you use an encryption context to encrypt data, you must
        specify the same (an exact case-sensitive match) encryption context to decrypt
        the data. An encryption context is optional when encrypting with a symmetric KMS
        key, but it is highly recommended.</p>
                 <p>For more information, see

        <a
        href="https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#encrypt_context">Encryption

        Context</a> in the <i>Key Management Service Developer Guide</i>.</p>
        :param source_key_id: <p>Specifies the KMS key that KMS will use to decrypt the
        ciphertext before it is
              re-encrypted. Enter a key ID of the KMS key that
        was used to encrypt the ciphertext.</p>
                 <p>This parameter is required
        only when the ciphertext was encrypted under an asymmetric KMS
              key. If you
        used a symmetric KMS key, KMS can get the KMS key from metadata that it adds to

        the symmetric ciphertext blob. However, it is always recommended as a best
        practice. This
              practice ensures that you use the KMS key that you
        intend.</p>

                 <p>To specify a KMS key, use its key ID, key ARN,
        alias name, or alias ARN. When using an alias name, prefix it with
        <code>"alias/"</code>. To specify a KMS key in a different Amazon Web Services
        account, you must use the key ARN or alias ARN.</p>
                 <p>For
        example:</p>
                 <ul>
                    <li>
                       <p>Key ID:
        <code>1234abcd-12ab-34cd-56ef-1234567890ab</code>
                       </p>

        </li>
                    <li>
                       <p>Key ARN:
        <code>arn:aws:kms:us-east-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab</code>

        </p>
                    </li>
                    <li>
                       <p>Alias name:
        <code>alias/ExampleAlias</code>
                       </p>
                    </li>

        <li>
                       <p>Alias ARN:
        <code>arn:aws:kms:us-east-2:111122223333:alias/ExampleAlias</code>

        </p>
                    </li>
                 </ul>
                 <p>To get the key ID and key ARN
        for a KMS key, use <a>ListKeys</a> or <a>DescribeKey</a>. To get the alias name
        and alias ARN, use <a>ListAliases</a>.</p>
        :param destination_encryption_context: <p>Specifies that encryption context to
        use when the reencrypting the data.</p>
                 <p>A destination encryption
        context is valid only when the destination KMS key is a symmetric
              KMS key.
        The standard ciphertext format for asymmetric KMS keys does not include fields
        for
              metadata.</p>
                 <p>An <i>encryption context</i> is a
        collection of non-secret key-value pairs that represents additional
        authenticated data. When you use an encryption context to encrypt data, you must
        specify the same (an exact case-sensitive match) encryption context to decrypt
        the data. An encryption context is optional when encrypting with a symmetric KMS
        key, but it is highly recommended.</p>
                 <p>For more information, see

        <a
        href="https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#encrypt_context">Encryption

        Context</a> in the <i>Key Management Service Developer Guide</i>.</p>
        :param source_encryption_algorithm: <p>Specifies the encryption algorithm that
        KMS will use to decrypt the ciphertext before it
              is reencrypted. The
        default value, <code>SYMMETRIC_DEFAULT</code>, represents the algorithm

        used for symmetric KMS keys.</p>
                 <p>Specify the same algorithm that was
        used to encrypt the ciphertext. If you specify a
              different algorithm, the
        decrypt attempt fails.</p>
                 <p>This parameter is required only when the
        ciphertext was encrypted under an asymmetric KMS
              key.</p>
        :param destination_encryption_algorithm: <p>Specifies the encryption algorithm
        that KMS will use to reecrypt the data after it has
              decrypted it. The
        default value, <code>SYMMETRIC_DEFAULT</code>, represents the encryption

        algorithm used for symmetric KMS keys.</p>
                 <p>This parameter is
        required only when the destination KMS key is an asymmetric KMS
              key.</p>
        :param grant_tokens: <p>A list of grant tokens.</p>
                 <p>Use a grant
        token when your permission to call this operation comes from a new grant that
        has not yet achieved <i>eventual consistency</i>. For more information, see <a
        href="https://docs.aws.amazon.com/kms/latest/developerguide/grants.html#grant_token">Grant
        token</a> and <a
        href="https://docs.aws.amazon.com/kms/latest/developerguide/grant-manage.html#using-grant-token">Using
        a grant token</a> in the
            <i>Key Management Service Developer Guide</i>.</p>
        """
        self.ciphertext_blob = ciphertext_blob
        self.destination_key_id = destination_key_id
        self.source_encryption_context = source_encryption_context
        self.source_key_id = source_key_id
        self.destination_encryption_context = destination_encryption_context
        self.source_encryption_algorithm = source_encryption_algorithm
        self.destination_encryption_algorithm = destination_encryption_algorithm
        self.grant_tokens = grant_tokens

    def as_dict(self) -> Dict[str, Any]:
        """Converts the ReEncryptRequest to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        d: Dict[str, Any] = {
            "CiphertextBlob": self.ciphertext_blob,
            "DestinationKeyId": self.destination_key_id,
        }

        if self.source_encryption_context is not None:
            d["SourceEncryptionContext"] = self.source_encryption_context

        if self.source_key_id is not None:
            d["SourceKeyId"] = self.source_key_id

        if self.destination_encryption_context is not None:
            d["DestinationEncryptionContext"] = self.destination_encryption_context

        if self.source_encryption_algorithm is not None:
            d["SourceEncryptionAlgorithm"] = self.source_encryption_algorithm

        if self.destination_encryption_algorithm is not None:
            d["DestinationEncryptionAlgorithm"] = self.destination_encryption_algorithm

        if self.grant_tokens is not None:
            d["GrantTokens"] = self.grant_tokens

        return d

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "ReEncryptRequest":
        """Creates a ReEncryptRequest from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {
            "ciphertext_blob": d["CiphertextBlob"],
            "destination_key_id": d["DestinationKeyId"],
        }

        if "SourceEncryptionContext" in d:
            kwargs["source_encryption_context"] = d["SourceEncryptionContext"]

        if "SourceKeyId" in d:
            kwargs["source_key_id"] = d["SourceKeyId"]

        if "DestinationEncryptionContext" in d:
            kwargs["destination_encryption_context"] = d["DestinationEncryptionContext"]

        if "SourceEncryptionAlgorithm" in d:
            kwargs["source_encryption_algorithm"] = d["SourceEncryptionAlgorithm"]

        if "DestinationEncryptionAlgorithm" in d:
            kwargs["destination_encryption_algorithm"] = d["DestinationEncryptionAlgorithm"]

        if "GrantTokens" in d:
            kwargs["grant_tokens"] = d["GrantTokens"]

        return ReEncryptRequest(**kwargs)

    def __repr__(self) -> str:
        result = "ReEncryptRequest("
        if self.ciphertext_blob is not None:
            result += f"ciphertext_blob={repr(self.ciphertext_blob)}, "

        if self.source_encryption_context is not None:
            result += f"source_encryption_context={repr(self.source_encryption_context)}, "

        if self.source_key_id is not None:
            result += f"source_key_id={repr(self.source_key_id)}, "

        if self.destination_key_id is not None:
            result += f"destination_key_id={repr(self.destination_key_id)}, "

        if self.destination_encryption_context is not None:
            result += f"destination_encryption_context={repr(self.destination_encryption_context)}, "

        if self.source_encryption_algorithm is not None:
            result += f"source_encryption_algorithm={repr(self.source_encryption_algorithm)}, "

        if self.destination_encryption_algorithm is not None:
            result += f"destination_encryption_algorithm={repr(self.destination_encryption_algorithm)}, "

        if self.grant_tokens is not None:
            result += f"grant_tokens={repr(self.grant_tokens)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, ReEncryptRequest):
            return False
        attributes: list[str] = ['ciphertext_blob','source_encryption_context','source_key_id','destination_key_id','destination_encryption_context','source_encryption_algorithm','destination_encryption_algorithm','grant_tokens',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class ReEncryptResponse:
    ciphertext_blob: Optional[bytes | bytearray]
    source_key_id: Optional[str]
    key_id: Optional[str]
    source_encryption_algorithm: Optional[str]
    destination_encryption_algorithm: Optional[str]
    def __init__(
        self,
        *,
        ciphertext_blob: Optional[bytes | bytearray] = None,
        source_key_id: Optional[str] = None,
        key_id: Optional[str] = None,
        source_encryption_algorithm: Optional[str] = None,
        destination_encryption_algorithm: Optional[str] = None,
    ):
        """
        :param ciphertext_blob: <p>The reencrypted data. When you use the HTTP API or
        the Amazon Web Services CLI, the value is Base64-encoded. Otherwise, it is not
        Base64-encoded.</p>
        :param source_key_id: <p>Unique identifier of the KMS key used to originally
        encrypt the data.</p>
        :param key_id: <p>The Amazon Resource Name (<a
        href="https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#key-id-key-ARN">key
        ARN</a>) of the KMS key that was used to reencrypt the data.</p>
        :param source_encryption_algorithm: <p>The encryption algorithm that was used to
        decrypt the ciphertext before it was
              reencrypted.</p>
        :param destination_encryption_algorithm: <p>The encryption algorithm that was
        used to reencrypt the data.</p>
        """
        self.ciphertext_blob = ciphertext_blob
        self.source_key_id = source_key_id
        self.key_id = key_id
        self.source_encryption_algorithm = source_encryption_algorithm
        self.destination_encryption_algorithm = destination_encryption_algorithm

    def as_dict(self) -> Dict[str, Any]:
        """Converts the ReEncryptResponse to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        d: Dict[str, Any] = {}

        if self.ciphertext_blob is not None:
            d["CiphertextBlob"] = self.ciphertext_blob

        if self.source_key_id is not None:
            d["SourceKeyId"] = self.source_key_id

        if self.key_id is not None:
            d["KeyId"] = self.key_id

        if self.source_encryption_algorithm is not None:
            d["SourceEncryptionAlgorithm"] = self.source_encryption_algorithm

        if self.destination_encryption_algorithm is not None:
            d["DestinationEncryptionAlgorithm"] = self.destination_encryption_algorithm

        return d

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "ReEncryptResponse":
        """Creates a ReEncryptResponse from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {}

        if "CiphertextBlob" in d:
            kwargs["ciphertext_blob"] = d["CiphertextBlob"]

        if "SourceKeyId" in d:
            kwargs["source_key_id"] = d["SourceKeyId"]

        if "KeyId" in d:
            kwargs["key_id"] = d["KeyId"]

        if "SourceEncryptionAlgorithm" in d:
            kwargs["source_encryption_algorithm"] = d["SourceEncryptionAlgorithm"]

        if "DestinationEncryptionAlgorithm" in d:
            kwargs["destination_encryption_algorithm"] = d["DestinationEncryptionAlgorithm"]

        return ReEncryptResponse(**kwargs)

    def __repr__(self) -> str:
        result = "ReEncryptResponse("
        if self.ciphertext_blob is not None:
            result += f"ciphertext_blob={repr(self.ciphertext_blob)}, "

        if self.source_key_id is not None:
            result += f"source_key_id={repr(self.source_key_id)}, "

        if self.key_id is not None:
            result += f"key_id={repr(self.key_id)}, "

        if self.source_encryption_algorithm is not None:
            result += f"source_encryption_algorithm={repr(self.source_encryption_algorithm)}, "

        if self.destination_encryption_algorithm is not None:
            result += f"destination_encryption_algorithm={repr(self.destination_encryption_algorithm)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, ReEncryptResponse):
            return False
        attributes: list[str] = ['ciphertext_blob','source_key_id','key_id','source_encryption_algorithm','destination_encryption_algorithm',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class ReplicateKeyRequest:
    key_id: str
    replica_region: str
    policy: Optional[str]
    bypass_policy_lockout_safety_check: bool
    description: Optional[str]
    tags: Optional[list[Tag]]
    def __init__(
        self,
        *,
        key_id: str,
        replica_region: str,
        policy: Optional[str] = None,
        bypass_policy_lockout_safety_check: bool = False,
        description: Optional[str] = None,
        tags: Optional[list[Tag]] = None,
    ):
        """
        :param key_id: <p>Identifies the multi-Region primary key that is being
        replicated. To determine whether a
              KMS key is a multi-Region primary key,
        use the <a>DescribeKey</a> operation to
              check the value of the
        <code>MultiRegionKeyType</code> property.</p>

                 <p>Specify the key
        ID or key ARN of a multi-Region primary key.</p>
                 <p>For example:</p>

        <ul>
                    <li>
                       <p>Key ID:
        <code>mrk-1234abcd12ab34cd56ef1234567890ab</code>
                       </p>

        </li>
                    <li>
                       <p>Key ARN:
        <code>arn:aws:kms:us-east-2:111122223333:key/mrk-1234abcd12ab34cd56ef1234567890ab</code>

        </p>
                    </li>
                 </ul>
                 <p>To get the key ID and key
        ARN for a KMS key, use <a>ListKeys</a> or <a>DescribeKey</a>.</p>
        :param replica_region: <p>The Region ID of the Amazon Web Services Region for
        this replica key. </p>
                 <p>Enter the Region ID, such as
        <code>us-east-1</code> or <code>ap-southeast-2</code>. For a
              list of
        Amazon Web Services Regions in which KMS is supported, see <a
        href="https://docs.aws.amazon.com/general/latest/gr/kms.html#kms_region">KMS
        service endpoints</a> in the
              <i>Amazon Web Services General
        Reference</i>.</p>
                 <p>The replica must be in a different Amazon Web
        Services Region than its primary key and other replicas of
              that primary
        key, but in the same Amazon Web Services partition. KMS must be available in the
        replica
              Region. If the Region is not enabled by default, the Amazon Web
        Services account must be enabled in the
              Region. </p>
                 <p>For
        information about Amazon Web Services partitions, see <a
        href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">Amazon
        Resource Names (ARNs) in the
                <i>Amazon Web Services General
        Reference</i>.</a> For information about enabling and disabling Regions, see <a
        href="https://docs.aws.amazon.com/general/latest/gr/rande-manage.html#rande-manage-enable">Enabling
        a
                Region</a> and <a
        href="https://docs.aws.amazon.com/general/latest/gr/rande-manage.html#rande-manage-disable">Disabling
        a Region</a> in the
              <i>Amazon Web Services General Reference</i>.</p>
        :param policy: <p>The key policy to attach to the KMS key. This parameter is
        optional. If you do not provide
              a key policy, KMS attaches the <a
        href="https://docs.aws.amazon.com/kms/latest/developerguide/key-policies.html#key-policy-default">default
        key policy</a> to the
              KMS key.</p>
                 <p>The key policy is not a
        shared property of multi-Region keys. You can specify the same key
              policy
        or a different key policy for each key in a set of related multi-Region keys.
        KMS
              does not synchronize this property.</p>
                 <p>If you provide a
        key policy, it must meet the following criteria:</p>
                 <ul>

        <li>
                       <p>If you don't set
        <code>BypassPolicyLockoutSafetyCheck</code> to true, the key policy

        must give the caller <code>kms:PutKeyPolicy</code> permission on the replica
        key. This
                  reduces the risk that the KMS key becomes unmanageable. For
        more information, refer to the
                  scenario in the <a
        href="https://docs.aws.amazon.com/kms/latest/developerguide/key-policies.html#key-policy-default-allow-root-enable-iam">Default
        Key Policy</a> section of the <i>
                             <i>Key Management Service
        Developer Guide</i>
                          </i>.</p>
                    </li>

        <li>
                       <p>Each statement in the key policy must contain one or more
        principals. The principals
                  in the key policy must exist and be visible
        to KMS. When you create a new Amazon Web Services
                  principal (for
        example, an IAM user or role), you might need to enforce a delay before

        including the new principal in a key policy because the new principal might not
        be
                  immediately visible to KMS. For more information, see <a
        href="https://docs.aws.amazon.com/IAM/latest/UserGuide/troubleshoot_general.html#troubleshoot_general_eventual-consistency">Changes
        that I make are not always immediately visible</a> in the
                    <i>

        <i>Identity and Access Management User Guide</i>
                          </i>.</p>

        </li>
                    <li>
                       <p>The key policy size quota is 32
        kilobytes (32768 bytes).</p>
                    </li>
                 </ul>
        :param bypass_policy_lockout_safety_check: <p>A flag to indicate whether to
        bypass the key policy lockout safety check.</p>
                 <important>

        <p>Setting this value to true increases the risk that the KMS key becomes
        unmanageable. Do
                not set this value to true indiscriminately.</p>

        <p>For more information, refer to the scenario in the <a
        href="https://docs.aws.amazon.com/kms/latest/developerguide/key-policies.html#key-policy-default-allow-root-enable-iam">Default
        Key Policy</a> section in the <i>Key Management Service Developer
        Guide</i>.</p>
                 </important>
                 <p>Use this parameter only when
        you intend to prevent the principal that is making the
              request from making
        a subsequent <code>PutKeyPolicy</code> request on the KMS key.</p>

        <p>The default value is false.</p>
        :param description: <p>A description of the KMS key. The default value is an
        empty string (no
              description).</p>
                 <p>The description is not a
        shared property of multi-Region keys. You can specify the same
              description
        or a different description for each key in a set of related multi-Region keys.

        KMS does not synchronize this property.</p>
        :param tags: <p>Assigns one or more tags to the replica key. Use this parameter
        to tag the KMS key when it
              is created. To tag an existing KMS key, use the
        <a>TagResource</a>
              operation.</p>
                 <note>
                    <p>Tagging
        or untagging a KMS key can allow or deny permission to the KMS key. For details,
        see <a
        href="https://docs.aws.amazon.com/kms/latest/developerguide/abac.html">Using
        ABAC in KMS</a> in the <i>Key Management Service Developer Guide</i>.</p>

        </note>
                 <p>To use this parameter, you must have <a
        href="https://docs.aws.amazon.com/kms/latest/developerguide/kms-api-permissions-reference.html">kms:TagResource</a>
        permission in an IAM policy.</p>
                 <p>Tags are not a shared property of
        multi-Region keys. You can specify the same tags or
              different tags for
        each key in a set of related multi-Region keys. KMS does not synchronize

        this property.</p>
                 <p>Each tag consists of a tag key and a tag value.
        Both the tag key and the tag value are
              required, but the tag value can be
        an empty (null) string. You cannot have more than one tag
              on a KMS key
        with the same tag key. If you specify an existing tag key with a different tag

        value, KMS replaces the current tag value with the specified one.</p>

        <p>When you add tags to an Amazon Web Services resource, Amazon Web Services
        generates a cost allocation
                      report with usage and costs aggregated
        by tags. Tags can also be used to control access to a KMS key. For details,

        see <a
        href="https://docs.aws.amazon.com/kms/latest/developerguide/tagging-keys.html">Tagging
        Keys</a>.</p>
        """
        self.key_id = key_id
        self.replica_region = replica_region
        self.policy = policy
        self.bypass_policy_lockout_safety_check = bypass_policy_lockout_safety_check
        self.description = description
        self.tags = tags

    def as_dict(self) -> Dict[str, Any]:
        """Converts the ReplicateKeyRequest to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        d: Dict[str, Any] = {
            "KeyId": self.key_id,
            "ReplicaRegion": self.replica_region,
        }

        if self.policy is not None:
            d["Policy"] = self.policy

        if self.bypass_policy_lockout_safety_check is not None:
            d["BypassPolicyLockoutSafetyCheck"] = self.bypass_policy_lockout_safety_check

        if self.description is not None:
            d["Description"] = self.description

        if self.tags is not None:
            d["Tags"] = _tag_list_as_dict(self.tags),

        return d

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "ReplicateKeyRequest":
        """Creates a ReplicateKeyRequest from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {
            "key_id": d["KeyId"],
            "replica_region": d["ReplicaRegion"],
        }

        if "Policy" in d:
            kwargs["policy"] = d["Policy"]

        if "BypassPolicyLockoutSafetyCheck" in d:
            kwargs["bypass_policy_lockout_safety_check"] = d["BypassPolicyLockoutSafetyCheck"]

        if "Description" in d:
            kwargs["description"] = d["Description"]

        if "Tags" in d:
            kwargs["tags"] = _tag_list_from_dict(d["Tags"]),

        return ReplicateKeyRequest(**kwargs)

    def __repr__(self) -> str:
        result = "ReplicateKeyRequest("
        if self.key_id is not None:
            result += f"key_id={repr(self.key_id)}, "

        if self.replica_region is not None:
            result += f"replica_region={repr(self.replica_region)}, "

        if self.policy is not None:
            result += f"policy={repr(self.policy)}, "

        if self.bypass_policy_lockout_safety_check is not None:
            result += f"bypass_policy_lockout_safety_check={repr(self.bypass_policy_lockout_safety_check)}, "

        if self.description is not None:
            result += f"description={repr(self.description)}, "

        if self.tags is not None:
            result += f"tags={repr(self.tags)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, ReplicateKeyRequest):
            return False
        attributes: list[str] = ['key_id','replica_region','policy','bypass_policy_lockout_safety_check','description','tags',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class ReplicateKeyResponse:
    replica_key_metadata: Optional[KeyMetadata]
    replica_policy: Optional[str]
    replica_tags: Optional[list[Tag]]
    def __init__(
        self,
        *,
        replica_key_metadata: Optional[KeyMetadata] = None,
        replica_policy: Optional[str] = None,
        replica_tags: Optional[list[Tag]] = None,
    ):
        """
        :param replica_key_metadata: <p>Displays details about the new replica key,
        including its Amazon Resource Name (<a
        href="https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#key-id-key-ARN">key
        ARN</a>) and
                <a
        href="https://docs.aws.amazon.com/kms/latest/developerguide/key-state.html">key
        state</a>. It also
              includes the ARN and Amazon Web Services Region of its
        primary key and other replica keys.</p>
        :param replica_policy: <p>The key policy of the new replica key. The value is a
        key policy document in JSON
              format.</p>
        :param replica_tags: <p>The tags on the new replica key. The value is a list of
        tag key and tag value
              pairs.</p>
        """
        self.replica_key_metadata = replica_key_metadata
        self.replica_policy = replica_policy
        self.replica_tags = replica_tags

    def as_dict(self) -> Dict[str, Any]:
        """Converts the ReplicateKeyResponse to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        d: Dict[str, Any] = {}

        if self.replica_key_metadata is not None:
            d["ReplicaKeyMetadata"] = self.replica_key_metadata.as_dict()

        if self.replica_policy is not None:
            d["ReplicaPolicy"] = self.replica_policy

        if self.replica_tags is not None:
            d["ReplicaTags"] = _tag_list_as_dict(self.replica_tags),

        return d

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "ReplicateKeyResponse":
        """Creates a ReplicateKeyResponse from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {}

        if "ReplicaKeyMetadata" in d:
            kwargs["replica_key_metadata"] = KeyMetadata.from_dict(d["ReplicaKeyMetadata"])

        if "ReplicaPolicy" in d:
            kwargs["replica_policy"] = d["ReplicaPolicy"]

        if "ReplicaTags" in d:
            kwargs["replica_tags"] = _tag_list_from_dict(d["ReplicaTags"]),

        return ReplicateKeyResponse(**kwargs)

    def __repr__(self) -> str:
        result = "ReplicateKeyResponse("
        if self.replica_key_metadata is not None:
            result += f"replica_key_metadata={repr(self.replica_key_metadata)}, "

        if self.replica_policy is not None:
            result += f"replica_policy={repr(self.replica_policy)}, "

        if self.replica_tags is not None:
            result += f"replica_tags={repr(self.replica_tags)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, ReplicateKeyResponse):
            return False
        attributes: list[str] = ['replica_key_metadata','replica_policy','replica_tags',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class RetireGrantRequest:
    grant_token: Optional[str]
    key_id: Optional[str]
    grant_id: Optional[str]
    def __init__(
        self,
        *,
        grant_token: Optional[str] = None,
        key_id: Optional[str] = None,
        grant_id: Optional[str] = None,
    ):
        """
        :param grant_token: <p>Identifies the grant to be retired. You can use a grant
        token to identify a new grant even
              before it has achieved eventual
        consistency.</p>
                 <p>Only the <a>CreateGrant</a> operation returns a
        grant token. For details, see
                <a
        href="https://docs.aws.amazon.com/kms/latest/developerguide/grants.html#grant_token">Grant
        token</a>
              and <a
        href="https://docs.aws.amazon.com/kms/latest/developerguide/grants.html#terms-eventual-consistency">Eventual
        consistency</a> in the <i>Key Management Service Developer Guide</i>.</p>
        :param key_id: <p>The key ARN KMS key associated with the grant. To find the key
        ARN, use the <a>ListKeys</a> operation.</p>
                 <p>For example:
        <code>arn:aws:kms:us-east-2:444455556666:key/1234abcd-12ab-34cd-56ef-1234567890ab</code>

        </p>
        :param grant_id: <p>Identifies the grant to retire. To get the grant ID, use
        <a>CreateGrant</a>,
                <a>ListGrants</a>, or
        <a>ListRetirableGrants</a>.</p>
                 <ul>
                    <li>

        <p>Grant ID Example -

        0123456789012345678901234567890123456789012345678901234567890123</p>

        </li>
                 </ul>
        """
        self.grant_token = grant_token
        self.key_id = key_id
        self.grant_id = grant_id

    def as_dict(self) -> Dict[str, Any]:
        """Converts the RetireGrantRequest to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        d: Dict[str, Any] = {}

        if self.grant_token is not None:
            d["GrantToken"] = self.grant_token

        if self.key_id is not None:
            d["KeyId"] = self.key_id

        if self.grant_id is not None:
            d["GrantId"] = self.grant_id

        return d

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "RetireGrantRequest":
        """Creates a RetireGrantRequest from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {}

        if "GrantToken" in d:
            kwargs["grant_token"] = d["GrantToken"]

        if "KeyId" in d:
            kwargs["key_id"] = d["KeyId"]

        if "GrantId" in d:
            kwargs["grant_id"] = d["GrantId"]

        return RetireGrantRequest(**kwargs)

    def __repr__(self) -> str:
        result = "RetireGrantRequest("
        if self.grant_token is not None:
            result += f"grant_token={repr(self.grant_token)}, "

        if self.key_id is not None:
            result += f"key_id={repr(self.key_id)}, "

        if self.grant_id is not None:
            result += f"grant_id={repr(self.grant_id)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, RetireGrantRequest):
            return False
        attributes: list[str] = ['grant_token','key_id','grant_id',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class RevokeGrantRequest:
    key_id: str
    grant_id: str
    def __init__(
        self,
        *,
        key_id: str,
        grant_id: str,
    ):
        """
        :param key_id: <p>A unique identifier for the KMS key associated with the grant.
        To get the key ID and key
              ARN for a KMS key, use <a>ListKeys</a> or
        <a>DescribeKey</a>.</p>

                 <p>Specify the key ID or key ARN of the
        KMS key. To specify a KMS key in a
        different Amazon Web Services account, you
        must use the key ARN.</p>
                 <p>For example:</p>
                 <ul>

        <li>
                       <p>Key ID:
        <code>1234abcd-12ab-34cd-56ef-1234567890ab</code>
                       </p>

        </li>
                    <li>
                       <p>Key ARN:
        <code>arn:aws:kms:us-east-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab</code>

        </p>
                    </li>
                 </ul>
                 <p>To get the key ID and key
        ARN for a KMS key, use <a>ListKeys</a> or <a>DescribeKey</a>.</p>
        :param grant_id: <p>Identifies the grant to revoke. To get the grant ID, use
        <a>CreateGrant</a>,
                <a>ListGrants</a>, or
        <a>ListRetirableGrants</a>.</p>
        """
        self.key_id = key_id
        self.grant_id = grant_id

    def as_dict(self) -> Dict[str, Any]:
        """Converts the RevokeGrantRequest to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        return {
            "KeyId": self.key_id,
            "GrantId": self.grant_id,
        }

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "RevokeGrantRequest":
        """Creates a RevokeGrantRequest from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {
            "key_id": d["KeyId"],
            "grant_id": d["GrantId"],
        }

        return RevokeGrantRequest(**kwargs)

    def __repr__(self) -> str:
        result = "RevokeGrantRequest("
        if self.key_id is not None:
            result += f"key_id={repr(self.key_id)}, "

        if self.grant_id is not None:
            result += f"grant_id={repr(self.grant_id)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, RevokeGrantRequest):
            return False
        attributes: list[str] = ['key_id','grant_id',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class ScheduleKeyDeletionRequest:
    key_id: str
    pending_window_in_days: Optional[int]
    def __init__(
        self,
        *,
        key_id: str,
        pending_window_in_days: Optional[int] = None,
    ):
        """
        :param key_id: <p>The unique identifier of the KMS key to delete.</p>

        <p>Specify the key ID or key ARN of the KMS key.</p>
                 <p>For
        example:</p>
                 <ul>
                    <li>
                       <p>Key ID:
        <code>1234abcd-12ab-34cd-56ef-1234567890ab</code>
                       </p>

        </li>
                    <li>
                       <p>Key ARN:
        <code>arn:aws:kms:us-east-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab</code>

        </p>
                    </li>
                 </ul>
                 <p>To get the key ID and key
        ARN for a KMS key, use <a>ListKeys</a> or <a>DescribeKey</a>.</p>
        :param pending_window_in_days: <p>The waiting period, specified in number of
        days. After the waiting period ends, KMS
              deletes the KMS key.</p>

        <p>If the KMS key is a multi-Region primary key with replicas, the waiting
        period begins when
              the last of its replica keys is deleted. Otherwise, the
        waiting period begins
              immediately.</p>
                 <p>This value is optional.
        If you include a value, it must be between 7 and 30, inclusive. If
              you do
        not include a value, it defaults to 30.</p>
        """
        self.key_id = key_id
        self.pending_window_in_days = pending_window_in_days

    def as_dict(self) -> Dict[str, Any]:
        """Converts the ScheduleKeyDeletionRequest to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        d: Dict[str, Any] = {
            "KeyId": self.key_id,
        }

        if self.pending_window_in_days is not None:
            d["PendingWindowInDays"] = self.pending_window_in_days

        return d

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "ScheduleKeyDeletionRequest":
        """Creates a ScheduleKeyDeletionRequest from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {
            "key_id": d["KeyId"],
        }

        if "PendingWindowInDays" in d:
            kwargs["pending_window_in_days"] = d["PendingWindowInDays"]

        return ScheduleKeyDeletionRequest(**kwargs)

    def __repr__(self) -> str:
        result = "ScheduleKeyDeletionRequest("
        if self.key_id is not None:
            result += f"key_id={repr(self.key_id)}, "

        if self.pending_window_in_days is not None:
            result += f"pending_window_in_days={repr(self.pending_window_in_days)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, ScheduleKeyDeletionRequest):
            return False
        attributes: list[str] = ['key_id','pending_window_in_days',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class ScheduleKeyDeletionResponse:
    key_id: Optional[str]
    deletion_date: int
    key_state: Optional[str]
    pending_window_in_days: Optional[int]
    def __init__(
        self,
        *,
        key_id: Optional[str] = None,
        deletion_date: int = 0,
        key_state: Optional[str] = None,
        pending_window_in_days: Optional[int] = None,
    ):
        """
        :param key_id: <p>The Amazon Resource Name (<a
        href="https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#key-id-key-ARN">key
        ARN</a>) of the KMS key whose deletion is scheduled.</p>
        :param deletion_date: <p>The date and time after which KMS deletes the KMS
        key.</p>
                 <p>If the KMS key is a multi-Region primary key with replica
        keys, this field does not
              appear. The deletion date for the primary key
        isn't known until its last replica key is
              deleted.</p>
        :param key_state: <p>The current status of the KMS key.</p>
                 <p>For more
        information about how key state affects the use of a KMS key, see <a
        href="https://docs.aws.amazon.com/kms/latest/developerguide/key-state.html">Key
        state: Effect on your KMS
                key</a> in the <i>Key Management Service
        Developer Guide</i>.</p>
        :param pending_window_in_days: <p>The waiting period before the KMS key is
        deleted. </p>
                 <p>If the KMS key is a multi-Region primary key with
        replicas, the waiting period begins when
              the last of its replica keys is
        deleted. Otherwise, the waiting period begins
              immediately.</p>
        """
        self.key_id = key_id
        self.deletion_date = deletion_date
        self.key_state = key_state
        self.pending_window_in_days = pending_window_in_days

    def as_dict(self) -> Dict[str, Any]:
        """Converts the ScheduleKeyDeletionResponse to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        d: Dict[str, Any] = {}

        if self.key_id is not None:
            d["KeyId"] = self.key_id

        if self.deletion_date is not None:
            d["DeletionDate"] = self.deletion_date

        if self.key_state is not None:
            d["KeyState"] = self.key_state

        if self.pending_window_in_days is not None:
            d["PendingWindowInDays"] = self.pending_window_in_days

        return d

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "ScheduleKeyDeletionResponse":
        """Creates a ScheduleKeyDeletionResponse from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {}

        if "KeyId" in d:
            kwargs["key_id"] = d["KeyId"]

        if "DeletionDate" in d:
            kwargs["deletion_date"] = d["DeletionDate"]

        if "KeyState" in d:
            kwargs["key_state"] = d["KeyState"]

        if "PendingWindowInDays" in d:
            kwargs["pending_window_in_days"] = d["PendingWindowInDays"]

        return ScheduleKeyDeletionResponse(**kwargs)

    def __repr__(self) -> str:
        result = "ScheduleKeyDeletionResponse("
        if self.key_id is not None:
            result += f"key_id={repr(self.key_id)}, "

        if self.deletion_date is not None:
            result += f"deletion_date={repr(self.deletion_date)}, "

        if self.key_state is not None:
            result += f"key_state={repr(self.key_state)}, "

        if self.pending_window_in_days is not None:
            result += f"pending_window_in_days={repr(self.pending_window_in_days)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, ScheduleKeyDeletionResponse):
            return False
        attributes: list[str] = ['key_id','deletion_date','key_state','pending_window_in_days',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class SignRequest:
    key_id: str
    message: bytes | bytearray
    message_type: Optional[str]
    grant_tokens: Optional[list[str]]
    signing_algorithm: str
    def __init__(
        self,
        *,
        key_id: str,
        message: bytes | bytearray,
        signing_algorithm: str,
        message_type: Optional[str] = None,
        grant_tokens: Optional[list[str]] = None,
    ):
        """
        :param key_id: <p>Identifies an asymmetric KMS key. KMS uses the private key in
        the asymmetric KMS key to
              sign the message. The <code>KeyUsage</code> type
        of the KMS key must be
                <code>SIGN_VERIFY</code>. To find the
        <code>KeyUsage</code> of a KMS key, use the <a>DescribeKey</a> operation.</p>

        <p>To specify a KMS key, use its key ID, key ARN, alias name, or alias ARN. When
        using an alias name, prefix it with <code>"alias/"</code>. To specify a KMS key
        in a different Amazon Web Services account, you must use the key ARN or alias
        ARN.</p>
                 <p>For example:</p>
                 <ul>
                    <li>

        <p>Key ID: <code>1234abcd-12ab-34cd-56ef-1234567890ab</code>

        </p>
                    </li>
                    <li>
                       <p>Key ARN:
        <code>arn:aws:kms:us-east-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab</code>

        </p>
                    </li>
                    <li>
                       <p>Alias name:
        <code>alias/ExampleAlias</code>
                       </p>
                    </li>

        <li>
                       <p>Alias ARN:
        <code>arn:aws:kms:us-east-2:111122223333:alias/ExampleAlias</code>

        </p>
                    </li>
                 </ul>
                 <p>To get the key ID and key ARN
        for a KMS key, use <a>ListKeys</a> or <a>DescribeKey</a>. To get the alias name
        and alias ARN, use <a>ListAliases</a>.</p>
        :param message: <p>Specifies the message or message digest to sign. Messages can
        be 0-4096 bytes. To sign a
              larger message, provide the message
        digest.</p>
                 <p>If you provide a message, KMS generates a hash digest of
        the message and then signs
              it.</p>
        :param signing_algorithm: <p>Specifies the signing algorithm to use when signing
        the message. </p>
                 <p>Choose an algorithm that is compatible with the
        type and size of the specified asymmetric
              KMS key.</p>
        :param message_type: <p>Tells KMS whether the value of the <code>Message</code>
        parameter is a message or
              message digest. The default value, RAW,
        indicates a message. To indicate a message digest,
              enter
        <code>DIGEST</code>.</p>
        :param grant_tokens: <p>A list of grant tokens.</p>
                 <p>Use a grant
        token when your permission to call this operation comes from a new grant that
        has not yet achieved <i>eventual consistency</i>. For more information, see <a
        href="https://docs.aws.amazon.com/kms/latest/developerguide/grants.html#grant_token">Grant
        token</a> and <a
        href="https://docs.aws.amazon.com/kms/latest/developerguide/grant-manage.html#using-grant-token">Using
        a grant token</a> in the
            <i>Key Management Service Developer Guide</i>.</p>
        """
        self.key_id = key_id
        self.message = message
        self.signing_algorithm = signing_algorithm
        self.message_type = message_type
        self.grant_tokens = grant_tokens

    def as_dict(self) -> Dict[str, Any]:
        """Converts the SignRequest to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        d: Dict[str, Any] = {
            "KeyId": self.key_id,
            "Message": self.message,
            "SigningAlgorithm": self.signing_algorithm,
        }

        if self.message_type is not None:
            d["MessageType"] = self.message_type

        if self.grant_tokens is not None:
            d["GrantTokens"] = self.grant_tokens

        return d

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "SignRequest":
        """Creates a SignRequest from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {
            "key_id": d["KeyId"],
            "message": d["Message"],
            "signing_algorithm": d["SigningAlgorithm"],
        }

        if "MessageType" in d:
            kwargs["message_type"] = d["MessageType"]

        if "GrantTokens" in d:
            kwargs["grant_tokens"] = d["GrantTokens"]

        return SignRequest(**kwargs)

    def __repr__(self) -> str:
        result = "SignRequest("
        if self.key_id is not None:
            result += f"key_id={repr(self.key_id)}, "

        if self.message is not None:
            result += f"message={repr(self.message)}, "

        if self.message_type is not None:
            result += f"message_type={repr(self.message_type)}, "

        if self.grant_tokens is not None:
            result += f"grant_tokens={repr(self.grant_tokens)}, "

        if self.signing_algorithm is not None:
            result += f"signing_algorithm={repr(self.signing_algorithm)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, SignRequest):
            return False
        attributes: list[str] = ['key_id','message','message_type','grant_tokens','signing_algorithm',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class SignResponse:
    key_id: Optional[str]
    signature: Optional[bytes | bytearray]
    signing_algorithm: Optional[str]
    def __init__(
        self,
        *,
        key_id: Optional[str] = None,
        signature: Optional[bytes | bytearray] = None,
        signing_algorithm: Optional[str] = None,
    ):
        """
        :param key_id: <p>The Amazon Resource Name (<a
        href="https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#key-id-key-ARN">key
        ARN</a>) of the asymmetric KMS key that was used to sign the message.</p>
        :param signature: <p>The cryptographic signature that was generated for the
        message. </p>
                 <ul>
                    <li>
                       <p>When used with
        the supported RSA signing algorithms, the encoding of this value is

        defined by <a href="https://tools.ietf.org/html/rfc8017">PKCS #1 in RFC

        8017</a>.</p>
                    </li>
                    <li>
                       <p>When used
        with the <code>ECDSA_SHA_256</code>, <code>ECDSA_SHA_384</code>, or

        <code>ECDSA_SHA_512</code> signing algorithms, this value is a DER-encoded
        object as
                  defined by ANS X9.62–2005 and <a
        href="https://tools.ietf.org/html/rfc3279#section-2.2.3">RFC 3279 Section
        2.2.3</a>.
                  This is the most commonly used signature format and is
        appropriate for most uses.
                  </p>
                    </li>
                 </ul>

        <p>When you use the HTTP API or the Amazon Web Services CLI, the value is
        Base64-encoded. Otherwise, it is not Base64-encoded.</p>
        :param signing_algorithm: <p>The signing algorithm that was used to sign the
        message.</p>
        """
        self.key_id = key_id
        self.signature = signature
        self.signing_algorithm = signing_algorithm

    def as_dict(self) -> Dict[str, Any]:
        """Converts the SignResponse to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        d: Dict[str, Any] = {}

        if self.key_id is not None:
            d["KeyId"] = self.key_id

        if self.signature is not None:
            d["Signature"] = self.signature

        if self.signing_algorithm is not None:
            d["SigningAlgorithm"] = self.signing_algorithm

        return d

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "SignResponse":
        """Creates a SignResponse from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {}

        if "KeyId" in d:
            kwargs["key_id"] = d["KeyId"]

        if "Signature" in d:
            kwargs["signature"] = d["Signature"]

        if "SigningAlgorithm" in d:
            kwargs["signing_algorithm"] = d["SigningAlgorithm"]

        return SignResponse(**kwargs)

    def __repr__(self) -> str:
        result = "SignResponse("
        if self.key_id is not None:
            result += f"key_id={repr(self.key_id)}, "

        if self.signature is not None:
            result += f"signature={repr(self.signature)}, "

        if self.signing_algorithm is not None:
            result += f"signing_algorithm={repr(self.signing_algorithm)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, SignResponse):
            return False
        attributes: list[str] = ['key_id','signature','signing_algorithm',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class TagResourceRequest:
    key_id: str
    tags: list[Tag]
    def __init__(
        self,
        *,
        key_id: str,
        tags: list[Tag],
    ):
        """
        :param key_id: <p>Identifies a customer managed key in the account and
        Region.</p>

                 <p>Specify the key ID or key ARN of the KMS key.</p>

        <p>For example:</p>
                 <ul>
                    <li>
                       <p>Key ID:
        <code>1234abcd-12ab-34cd-56ef-1234567890ab</code>
                       </p>

        </li>
                    <li>
                       <p>Key ARN:
        <code>arn:aws:kms:us-east-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab</code>

        </p>
                    </li>
                 </ul>
                 <p>To get the key ID and key
        ARN for a KMS key, use <a>ListKeys</a> or <a>DescribeKey</a>.</p>
        :param tags: <p>One or more tags. </p>
                 <p>Each tag consists of a tag
        key and a tag value. The tag value can be an empty (null)
              string. </p>

        <p>You cannot have more than one tag on a KMS key with the same tag key. If you
        specify an
              existing tag key with a different tag value, KMS replaces the
        current tag value with the
              specified one.</p>
        """
        self.key_id = key_id
        self.tags = tags

    def as_dict(self) -> Dict[str, Any]:
        """Converts the TagResourceRequest to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        return {
            "KeyId": self.key_id,
            "Tags": _tag_list_as_dict(self.tags),
        }

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "TagResourceRequest":
        """Creates a TagResourceRequest from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {
            "key_id": d["KeyId"],
            "tags": _tag_list_from_dict(d["Tags"]),
        }

        return TagResourceRequest(**kwargs)

    def __repr__(self) -> str:
        result = "TagResourceRequest("
        if self.key_id is not None:
            result += f"key_id={repr(self.key_id)}, "

        if self.tags is not None:
            result += f"tags={repr(self.tags)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, TagResourceRequest):
            return False
        attributes: list[str] = ['key_id','tags',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class UntagResourceRequest:
    key_id: str
    tag_keys: list[str]
    def __init__(
        self,
        *,
        key_id: str,
        tag_keys: list[str],
    ):
        """
        :param key_id: <p>Identifies the KMS key from which you are removing tags.</p>

                 <p>Specify the key ID or key ARN of the KMS key.</p>
                 <p>For
        example:</p>
                 <ul>
                    <li>
                       <p>Key ID:
        <code>1234abcd-12ab-34cd-56ef-1234567890ab</code>
                       </p>

        </li>
                    <li>
                       <p>Key ARN:
        <code>arn:aws:kms:us-east-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab</code>

        </p>
                    </li>
                 </ul>
                 <p>To get the key ID and key
        ARN for a KMS key, use <a>ListKeys</a> or <a>DescribeKey</a>.</p>
        :param tag_keys: <p>One or more tag keys. Specify only the tag keys, not the tag
        values.</p>
        """
        self.key_id = key_id
        self.tag_keys = tag_keys

    def as_dict(self) -> Dict[str, Any]:
        """Converts the UntagResourceRequest to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        return {
            "KeyId": self.key_id,
            "TagKeys": self.tag_keys,
        }

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "UntagResourceRequest":
        """Creates a UntagResourceRequest from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {
            "key_id": d["KeyId"],
            "tag_keys": d["TagKeys"],
        }

        return UntagResourceRequest(**kwargs)

    def __repr__(self) -> str:
        result = "UntagResourceRequest("
        if self.key_id is not None:
            result += f"key_id={repr(self.key_id)}, "

        if self.tag_keys is not None:
            result += f"tag_keys={repr(self.tag_keys)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, UntagResourceRequest):
            return False
        attributes: list[str] = ['key_id','tag_keys',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class UpdateAliasRequest:
    alias_name: str
    target_key_id: str
    def __init__(
        self,
        *,
        alias_name: str,
        target_key_id: str,
    ):
        """
        :param alias_name: <p>Identifies the alias that is changing its KMS key. This
        value must begin with
                <code>alias/</code> followed by the alias name,
        such as <code>alias/ExampleAlias</code>. You
              cannot use UpdateAlias to
        change the alias name.</p>
        :param target_key_id: <p>Identifies the <a
        href="https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#customer-cmk">customer
        managed key</a> to associate with the alias. You don't have permission to

        associate an alias with an <a
        href="https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#aws-managed-cmk">Amazon
        Web Services managed key</a>.</p>
                 <p>The KMS key must be in the same
        Amazon Web Services account and Region as the alias. Also, the new
              target
        KMS key must be the same type as the current target KMS key (both symmetric or
        both
              asymmetric) and they must have the same key usage. </p>

        <p>Specify the key ID or key ARN of the KMS key.</p>
                 <p>For
        example:</p>
                 <ul>
                    <li>
                       <p>Key ID:
        <code>1234abcd-12ab-34cd-56ef-1234567890ab</code>
                       </p>

        </li>
                    <li>
                       <p>Key ARN:
        <code>arn:aws:kms:us-east-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab</code>

        </p>
                    </li>
                 </ul>
                 <p>To get the key ID and key
        ARN for a KMS key, use <a>ListKeys</a> or <a>DescribeKey</a>.</p>

        <p>To
              verify that the alias is mapped to the correct KMS key, use
        <a>ListAliases</a>.</p>
        """
        self.alias_name = alias_name
        self.target_key_id = target_key_id

    def as_dict(self) -> Dict[str, Any]:
        """Converts the UpdateAliasRequest to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        return {
            "AliasName": self.alias_name,
            "TargetKeyId": self.target_key_id,
        }

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "UpdateAliasRequest":
        """Creates a UpdateAliasRequest from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {
            "alias_name": d["AliasName"],
            "target_key_id": d["TargetKeyId"],
        }

        return UpdateAliasRequest(**kwargs)

    def __repr__(self) -> str:
        result = "UpdateAliasRequest("
        if self.alias_name is not None:
            result += f"alias_name={repr(self.alias_name)}, "

        if self.target_key_id is not None:
            result += f"target_key_id={repr(self.target_key_id)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, UpdateAliasRequest):
            return False
        attributes: list[str] = ['alias_name','target_key_id',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class UpdateCustomKeyStoreRequest:
    custom_key_store_id: str
    new_custom_key_store_name: Optional[str]
    key_store_password: Optional[str]
    cloud_hsm_cluster_id: Optional[str]
    def __init__(
        self,
        *,
        custom_key_store_id: str,
        new_custom_key_store_name: Optional[str] = None,
        key_store_password: Optional[str] = None,
        cloud_hsm_cluster_id: Optional[str] = None,
    ):
        """
        :param custom_key_store_id: <p>Identifies the custom key store that you want to
        update. Enter the ID of the custom key
              store. To find the ID of a custom
        key store, use the <a>DescribeCustomKeyStores</a> operation.</p>
        :param new_custom_key_store_name: <p>Changes the friendly name of the custom key
        store to the value that you specify. The
              custom key store name must be
        unique in the Amazon Web Services account.</p>
        :param key_store_password: <p>Enter the current password of the
        <code>kmsuser</code> crypto user (CU) in the CloudHSM
              cluster that is
        associated with the custom key store.</p>
                 <p>This parameter tells KMS
        the current password of the <code>kmsuser</code> crypto user
              (CU). It does
        not set or change the password of any users in the CloudHSM cluster.</p>
        :param cloud_hsm_cluster_id: <p>Associates the custom key store with a related
        CloudHSM cluster. </p>
                 <p>Enter the cluster ID of the cluster that you
        used to create the custom key store or a
              cluster that shares a backup
        history and has the same cluster certificate as the original
              cluster. You
        cannot use this parameter to associate a custom key store with an unrelated

        cluster. In addition, the replacement cluster must <a
        href="https://docs.aws.amazon.com/kms/latest/developerguide/create-keystore.html#before-keystore">fulfill
        the requirements</a> for
              a cluster associated with a custom key store. To
        view the cluster certificate of a cluster,
              use the <a
        href="https://docs.aws.amazon.com/cloudhsm/latest/APIReference/API_DescribeClusters.html">DescribeClusters</a>
        operation.</p>
        """
        self.custom_key_store_id = custom_key_store_id
        self.new_custom_key_store_name = new_custom_key_store_name
        self.key_store_password = key_store_password
        self.cloud_hsm_cluster_id = cloud_hsm_cluster_id

    def as_dict(self) -> Dict[str, Any]:
        """Converts the UpdateCustomKeyStoreRequest to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        d: Dict[str, Any] = {
            "CustomKeyStoreId": self.custom_key_store_id,
        }

        if self.new_custom_key_store_name is not None:
            d["NewCustomKeyStoreName"] = self.new_custom_key_store_name

        if self.key_store_password is not None:
            d["KeyStorePassword"] = self.key_store_password

        if self.cloud_hsm_cluster_id is not None:
            d["CloudHsmClusterId"] = self.cloud_hsm_cluster_id

        return d

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "UpdateCustomKeyStoreRequest":
        """Creates a UpdateCustomKeyStoreRequest from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {
            "custom_key_store_id": d["CustomKeyStoreId"],
        }

        if "NewCustomKeyStoreName" in d:
            kwargs["new_custom_key_store_name"] = d["NewCustomKeyStoreName"]

        if "KeyStorePassword" in d:
            kwargs["key_store_password"] = d["KeyStorePassword"]

        if "CloudHsmClusterId" in d:
            kwargs["cloud_hsm_cluster_id"] = d["CloudHsmClusterId"]

        return UpdateCustomKeyStoreRequest(**kwargs)

    def __repr__(self) -> str:
        result = "UpdateCustomKeyStoreRequest("
        if self.custom_key_store_id is not None:
            result += f"custom_key_store_id={repr(self.custom_key_store_id)}, "

        if self.new_custom_key_store_name is not None:
            result += f"new_custom_key_store_name={repr(self.new_custom_key_store_name)}, "

        if self.key_store_password is not None:
            result += f"key_store_password={repr(self.key_store_password)}, "

        if self.cloud_hsm_cluster_id is not None:
            result += f"cloud_hsm_cluster_id={repr(self.cloud_hsm_cluster_id)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, UpdateCustomKeyStoreRequest):
            return False
        attributes: list[str] = ['custom_key_store_id','new_custom_key_store_name','key_store_password','cloud_hsm_cluster_id',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class UpdateCustomKeyStoreResponse:
    def as_dict(self) -> Dict[str, Any]:
        """Converts the UpdateCustomKeyStoreResponse to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        return {}

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "UpdateCustomKeyStoreResponse":
        """Creates a UpdateCustomKeyStoreResponse from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        return UpdateCustomKeyStoreResponse()

    def __repr__(self) -> str:
        result = "UpdateCustomKeyStoreResponse("

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        return isinstance(other, UpdateCustomKeyStoreResponse)

class UpdateKeyDescriptionRequest:
    key_id: str
    description: str
    def __init__(
        self,
        *,
        key_id: str,
        description: str,
    ):
        """
        :param key_id: <p>Updates the description of the specified KMS key.</p>

        <p>Specify the key ID or key ARN of the KMS key.</p>
                 <p>For
        example:</p>
                 <ul>
                    <li>
                       <p>Key ID:
        <code>1234abcd-12ab-34cd-56ef-1234567890ab</code>
                       </p>

        </li>
                    <li>
                       <p>Key ARN:
        <code>arn:aws:kms:us-east-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab</code>

        </p>
                    </li>
                 </ul>
                 <p>To get the key ID and key
        ARN for a KMS key, use <a>ListKeys</a> or <a>DescribeKey</a>.</p>
        :param description: <p>New description for the KMS key.</p>
        """
        self.key_id = key_id
        self.description = description

    def as_dict(self) -> Dict[str, Any]:
        """Converts the UpdateKeyDescriptionRequest to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        return {
            "KeyId": self.key_id,
            "Description": self.description,
        }

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "UpdateKeyDescriptionRequest":
        """Creates a UpdateKeyDescriptionRequest from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {
            "key_id": d["KeyId"],
            "description": d["Description"],
        }

        return UpdateKeyDescriptionRequest(**kwargs)

    def __repr__(self) -> str:
        result = "UpdateKeyDescriptionRequest("
        if self.key_id is not None:
            result += f"key_id={repr(self.key_id)}, "

        if self.description is not None:
            result += f"description={repr(self.description)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, UpdateKeyDescriptionRequest):
            return False
        attributes: list[str] = ['key_id','description',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class UpdatePrimaryRegionRequest:
    key_id: str
    primary_region: str
    def __init__(
        self,
        *,
        key_id: str,
        primary_region: str,
    ):
        """
        :param key_id: <p>Identifies the current primary key. When the operation
        completes, this KMS key will be a
              replica key.</p>
                 <p>Specify
        the key ID or key ARN of a multi-Region primary key.</p>
                 <p>For
        example:</p>
                 <ul>
                    <li>
                       <p>Key ID:
        <code>mrk-1234abcd12ab34cd56ef1234567890ab</code>
                       </p>

        </li>
                    <li>
                       <p>Key ARN:
        <code>arn:aws:kms:us-east-2:111122223333:key/mrk-1234abcd12ab34cd56ef1234567890ab</code>

        </p>
                    </li>
                 </ul>
                 <p>To get the key ID and key
        ARN for a KMS key, use <a>ListKeys</a> or <a>DescribeKey</a>.</p>
        :param primary_region: <p>The Amazon Web Services Region of the new primary key.
        Enter the Region ID, such as
                <code>us-east-1</code> or
        <code>ap-southeast-2</code>. There must be an existing replica key
              in this
        Region. </p>
                 <p>When the operation completes, the multi-Region key in
        this Region will be the primary
              key.</p>
        """
        self.key_id = key_id
        self.primary_region = primary_region

    def as_dict(self) -> Dict[str, Any]:
        """Converts the UpdatePrimaryRegionRequest to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        return {
            "KeyId": self.key_id,
            "PrimaryRegion": self.primary_region,
        }

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "UpdatePrimaryRegionRequest":
        """Creates a UpdatePrimaryRegionRequest from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {
            "key_id": d["KeyId"],
            "primary_region": d["PrimaryRegion"],
        }

        return UpdatePrimaryRegionRequest(**kwargs)

    def __repr__(self) -> str:
        result = "UpdatePrimaryRegionRequest("
        if self.key_id is not None:
            result += f"key_id={repr(self.key_id)}, "

        if self.primary_region is not None:
            result += f"primary_region={repr(self.primary_region)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, UpdatePrimaryRegionRequest):
            return False
        attributes: list[str] = ['key_id','primary_region',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class VerifyRequest:
    key_id: str
    message: bytes | bytearray
    message_type: Optional[str]
    signature: bytes | bytearray
    signing_algorithm: str
    grant_tokens: Optional[list[str]]
    def __init__(
        self,
        *,
        key_id: str,
        message: bytes | bytearray,
        signature: bytes | bytearray,
        signing_algorithm: str,
        message_type: Optional[str] = None,
        grant_tokens: Optional[list[str]] = None,
    ):
        """
        :param key_id: <p>Identifies the asymmetric KMS key that will be used to verify
        the signature. This must be
              the same KMS key that was used to generate the
        signature. If you specify a different KMS key,
              the signature verification
        fails.</p>
                 <p>To specify a KMS key, use its key ID, key ARN, alias
        name, or alias ARN. When using an alias name, prefix it with
        <code>"alias/"</code>. To specify a KMS key in a different Amazon Web Services
        account, you must use the key ARN or alias ARN.</p>
                 <p>For
        example:</p>
                 <ul>
                    <li>
                       <p>Key ID:
        <code>1234abcd-12ab-34cd-56ef-1234567890ab</code>
                       </p>

        </li>
                    <li>
                       <p>Key ARN:
        <code>arn:aws:kms:us-east-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab</code>

        </p>
                    </li>
                    <li>
                       <p>Alias name:
        <code>alias/ExampleAlias</code>
                       </p>
                    </li>

        <li>
                       <p>Alias ARN:
        <code>arn:aws:kms:us-east-2:111122223333:alias/ExampleAlias</code>

        </p>
                    </li>
                 </ul>
                 <p>To get the key ID and key ARN
        for a KMS key, use <a>ListKeys</a> or <a>DescribeKey</a>. To get the alias name
        and alias ARN, use <a>ListAliases</a>.</p>
        :param message: <p>Specifies the message that was signed. You can submit a raw
        message of up to 4096 bytes,
              or a hash digest of the message. If you
        submit a digest, use the <code>MessageType</code>
              parameter with a value
        of <code>DIGEST</code>.</p>
                 <p>If the message specified here is
        different from the message that was signed, the signature
              verification
        fails. A message and its hash digest are considered to be the same

        message.</p>
        :param signature: <p>The signature that the <code>Sign</code> operation
        generated.</p>
        :param signing_algorithm: <p>The signing algorithm that was used to sign the
        message. If you submit a different
              algorithm, the signature verification
        fails.</p>
        :param message_type: <p>Tells KMS whether the value of the <code>Message</code>
        parameter is a message or
              message digest. The default value, RAW,
        indicates a message. To indicate a message digest,
              enter
        <code>DIGEST</code>.</p>
                 <important>
                    <p>Use the
        <code>DIGEST</code> value only when the value of the <code>Message</code>

        parameter is a message digest. If you use the <code>DIGEST</code> value with a
        raw message,
                the security of the verification operation can be
        compromised.</p>
                 </important>
        :param grant_tokens: <p>A list of grant tokens.</p>
                 <p>Use a grant
        token when your permission to call this operation comes from a new grant that
        has not yet achieved <i>eventual consistency</i>. For more information, see <a
        href="https://docs.aws.amazon.com/kms/latest/developerguide/grants.html#grant_token">Grant
        token</a> and <a
        href="https://docs.aws.amazon.com/kms/latest/developerguide/grant-manage.html#using-grant-token">Using
        a grant token</a> in the
            <i>Key Management Service Developer Guide</i>.</p>
        """
        self.key_id = key_id
        self.message = message
        self.signature = signature
        self.signing_algorithm = signing_algorithm
        self.message_type = message_type
        self.grant_tokens = grant_tokens

    def as_dict(self) -> Dict[str, Any]:
        """Converts the VerifyRequest to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        d: Dict[str, Any] = {
            "KeyId": self.key_id,
            "Message": self.message,
            "Signature": self.signature,
            "SigningAlgorithm": self.signing_algorithm,
        }

        if self.message_type is not None:
            d["MessageType"] = self.message_type

        if self.grant_tokens is not None:
            d["GrantTokens"] = self.grant_tokens

        return d

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "VerifyRequest":
        """Creates a VerifyRequest from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {
            "key_id": d["KeyId"],
            "message": d["Message"],
            "signature": d["Signature"],
            "signing_algorithm": d["SigningAlgorithm"],
        }

        if "MessageType" in d:
            kwargs["message_type"] = d["MessageType"]

        if "GrantTokens" in d:
            kwargs["grant_tokens"] = d["GrantTokens"]

        return VerifyRequest(**kwargs)

    def __repr__(self) -> str:
        result = "VerifyRequest("
        if self.key_id is not None:
            result += f"key_id={repr(self.key_id)}, "

        if self.message is not None:
            result += f"message={repr(self.message)}, "

        if self.message_type is not None:
            result += f"message_type={repr(self.message_type)}, "

        if self.signature is not None:
            result += f"signature={repr(self.signature)}, "

        if self.signing_algorithm is not None:
            result += f"signing_algorithm={repr(self.signing_algorithm)}, "

        if self.grant_tokens is not None:
            result += f"grant_tokens={repr(self.grant_tokens)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, VerifyRequest):
            return False
        attributes: list[str] = ['key_id','message','message_type','signature','signing_algorithm','grant_tokens',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class VerifyResponse:
    key_id: Optional[str]
    signature_valid: bool
    signing_algorithm: Optional[str]
    def __init__(
        self,
        *,
        key_id: Optional[str] = None,
        signature_valid: bool = False,
        signing_algorithm: Optional[str] = None,
    ):
        """
        :param key_id: <p>The Amazon Resource Name (<a
        href="https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#key-id-key-ARN">key
        ARN</a>) of the asymmetric KMS key that was used to verify the signature.</p>
        :param signature_valid: <p>A Boolean value that indicates whether the signature
        was verified. A value of
                <code>True</code> indicates that the
        <code>Signature</code> was produced by signing the
                <code>Message</code>
        with the specified <code>KeyID</code> and
                <code>SigningAlgorithm.</code>
        If the signature is not verified, the <code>Verify</code>
              operation fails
        with a <code>KMSInvalidSignatureException</code> exception. </p>
        :param signing_algorithm: <p>The signing algorithm that was used to verify the
        signature.</p>
        """
        self.key_id = key_id
        self.signature_valid = signature_valid
        self.signing_algorithm = signing_algorithm

    def as_dict(self) -> Dict[str, Any]:
        """Converts the VerifyResponse to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        d: Dict[str, Any] = {}

        if self.key_id is not None:
            d["KeyId"] = self.key_id

        if self.signature_valid is not None:
            d["SignatureValid"] = self.signature_valid

        if self.signing_algorithm is not None:
            d["SigningAlgorithm"] = self.signing_algorithm

        return d

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "VerifyResponse":
        """Creates a VerifyResponse from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {}

        if "KeyId" in d:
            kwargs["key_id"] = d["KeyId"]

        if "SignatureValid" in d:
            kwargs["signature_valid"] = d["SignatureValid"]

        if "SigningAlgorithm" in d:
            kwargs["signing_algorithm"] = d["SigningAlgorithm"]

        return VerifyResponse(**kwargs)

    def __repr__(self) -> str:
        result = "VerifyResponse("
        if self.key_id is not None:
            result += f"key_id={repr(self.key_id)}, "

        if self.signature_valid is not None:
            result += f"signature_valid={repr(self.signature_valid)}, "

        if self.signing_algorithm is not None:
            result += f"signing_algorithm={repr(self.signing_algorithm)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, VerifyResponse):
            return False
        attributes: list[str] = ['key_id','signature_valid','signing_algorithm',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

def _tag_list_as_dict(given: list[Tag]) -> List[Any]:
    return [v.as_dict() for v in given]

def _tag_list_from_dict(given: List[Any]) -> list[Tag]:
    return [Tag.from_dict(v) for v in given]

def _multi_region_key_list_as_dict(given: list[MultiRegionKey]) -> List[Any]:
    return [v.as_dict() for v in given]

def _multi_region_key_list_from_dict(given: List[Any]) -> list[MultiRegionKey]:
    return [MultiRegionKey.from_dict(v) for v in given]

def _grant_list_as_dict(given: list[GrantListEntry]) -> List[Any]:
    return [v.as_dict() for v in given]

def _grant_list_from_dict(given: List[Any]) -> list[GrantListEntry]:
    return [GrantListEntry.from_dict(v) for v in given]

def _alias_list_as_dict(given: list[AliasListEntry]) -> List[Any]:
    return [v.as_dict() for v in given]

def _alias_list_from_dict(given: List[Any]) -> list[AliasListEntry]:
    return [AliasListEntry.from_dict(v) for v in given]

def _custom_key_stores_list_as_dict(given: list[CustomKeyStoresListEntry]) -> List[Any]:
    return [v.as_dict() for v in given]

def _custom_key_stores_list_from_dict(given: List[Any]) -> list[CustomKeyStoresListEntry]:
    return [CustomKeyStoresListEntry.from_dict(v) for v in given]

class Unit:
    pass
