# Code generated by smithy-python-codegen DO NOT EDIT.

from Wrappers import Option_None, Option_Some
from _dafny import Map, Seq
from software_amazon_cryptography_services_kms_internaldafny_types import (
    AliasListEntry_AliasListEntry as DafnyAliasListEntry,
    CancelKeyDeletionRequest_CancelKeyDeletionRequest as DafnyCancelKeyDeletionRequest,
    CancelKeyDeletionResponse_CancelKeyDeletionResponse as DafnyCancelKeyDeletionResponse,
    ConnectCustomKeyStoreRequest_ConnectCustomKeyStoreRequest as DafnyConnectCustomKeyStoreRequest,
    ConnectCustomKeyStoreResponse_ConnectCustomKeyStoreResponse as DafnyConnectCustomKeyStoreResponse,
    CreateAliasRequest_CreateAliasRequest as DafnyCreateAliasRequest,
    CreateCustomKeyStoreRequest_CreateCustomKeyStoreRequest as DafnyCreateCustomKeyStoreRequest,
    CreateCustomKeyStoreResponse_CreateCustomKeyStoreResponse as DafnyCreateCustomKeyStoreResponse,
    CreateGrantRequest_CreateGrantRequest as DafnyCreateGrantRequest,
    CreateGrantResponse_CreateGrantResponse as DafnyCreateGrantResponse,
    CreateKeyRequest_CreateKeyRequest as DafnyCreateKeyRequest,
    CreateKeyResponse_CreateKeyResponse as DafnyCreateKeyResponse,
    CustomKeyStoresListEntry_CustomKeyStoresListEntry as DafnyCustomKeyStoresListEntry,
    DecryptRequest_DecryptRequest as DafnyDecryptRequest,
    DecryptResponse_DecryptResponse as DafnyDecryptResponse,
    DeleteAliasRequest_DeleteAliasRequest as DafnyDeleteAliasRequest,
    DeleteCustomKeyStoreRequest_DeleteCustomKeyStoreRequest as DafnyDeleteCustomKeyStoreRequest,
    DeleteCustomKeyStoreResponse_DeleteCustomKeyStoreResponse as DafnyDeleteCustomKeyStoreResponse,
    DeleteImportedKeyMaterialRequest_DeleteImportedKeyMaterialRequest as DafnyDeleteImportedKeyMaterialRequest,
    DescribeCustomKeyStoresRequest_DescribeCustomKeyStoresRequest as DafnyDescribeCustomKeyStoresRequest,
    DescribeCustomKeyStoresResponse_DescribeCustomKeyStoresResponse as DafnyDescribeCustomKeyStoresResponse,
    DescribeKeyRequest_DescribeKeyRequest as DafnyDescribeKeyRequest,
    DescribeKeyResponse_DescribeKeyResponse as DafnyDescribeKeyResponse,
    DisableKeyRequest_DisableKeyRequest as DafnyDisableKeyRequest,
    DisableKeyRotationRequest_DisableKeyRotationRequest as DafnyDisableKeyRotationRequest,
    DisconnectCustomKeyStoreRequest_DisconnectCustomKeyStoreRequest as DafnyDisconnectCustomKeyStoreRequest,
    DisconnectCustomKeyStoreResponse_DisconnectCustomKeyStoreResponse as DafnyDisconnectCustomKeyStoreResponse,
    EnableKeyRequest_EnableKeyRequest as DafnyEnableKeyRequest,
    EnableKeyRotationRequest_EnableKeyRotationRequest as DafnyEnableKeyRotationRequest,
    EncryptRequest_EncryptRequest as DafnyEncryptRequest,
    EncryptResponse_EncryptResponse as DafnyEncryptResponse,
    GenerateDataKeyPairRequest_GenerateDataKeyPairRequest as DafnyGenerateDataKeyPairRequest,
    GenerateDataKeyPairResponse_GenerateDataKeyPairResponse as DafnyGenerateDataKeyPairResponse,
    GenerateDataKeyPairWithoutPlaintextRequest_GenerateDataKeyPairWithoutPlaintextRequest as DafnyGenerateDataKeyPairWithoutPlaintextRequest,
    GenerateDataKeyPairWithoutPlaintextResponse_GenerateDataKeyPairWithoutPlaintextResponse as DafnyGenerateDataKeyPairWithoutPlaintextResponse,
    GenerateDataKeyRequest_GenerateDataKeyRequest as DafnyGenerateDataKeyRequest,
    GenerateDataKeyResponse_GenerateDataKeyResponse as DafnyGenerateDataKeyResponse,
    GenerateDataKeyWithoutPlaintextRequest_GenerateDataKeyWithoutPlaintextRequest as DafnyGenerateDataKeyWithoutPlaintextRequest,
    GenerateDataKeyWithoutPlaintextResponse_GenerateDataKeyWithoutPlaintextResponse as DafnyGenerateDataKeyWithoutPlaintextResponse,
    GenerateRandomRequest_GenerateRandomRequest as DafnyGenerateRandomRequest,
    GenerateRandomResponse_GenerateRandomResponse as DafnyGenerateRandomResponse,
    GetKeyPolicyRequest_GetKeyPolicyRequest as DafnyGetKeyPolicyRequest,
    GetKeyPolicyResponse_GetKeyPolicyResponse as DafnyGetKeyPolicyResponse,
    GetKeyRotationStatusRequest_GetKeyRotationStatusRequest as DafnyGetKeyRotationStatusRequest,
    GetKeyRotationStatusResponse_GetKeyRotationStatusResponse as DafnyGetKeyRotationStatusResponse,
    GetParametersForImportRequest_GetParametersForImportRequest as DafnyGetParametersForImportRequest,
    GetParametersForImportResponse_GetParametersForImportResponse as DafnyGetParametersForImportResponse,
    GetPublicKeyRequest_GetPublicKeyRequest as DafnyGetPublicKeyRequest,
    GetPublicKeyResponse_GetPublicKeyResponse as DafnyGetPublicKeyResponse,
    GrantConstraints_GrantConstraints as DafnyGrantConstraints,
    GrantListEntry_GrantListEntry as DafnyGrantListEntry,
    ImportKeyMaterialRequest_ImportKeyMaterialRequest as DafnyImportKeyMaterialRequest,
    ImportKeyMaterialResponse_ImportKeyMaterialResponse as DafnyImportKeyMaterialResponse,
    KeyMetadata_KeyMetadata as DafnyKeyMetadata,
    ListAliasesRequest_ListAliasesRequest as DafnyListAliasesRequest,
    ListAliasesResponse_ListAliasesResponse as DafnyListAliasesResponse,
    ListGrantsRequest_ListGrantsRequest as DafnyListGrantsRequest,
    ListGrantsResponse_ListGrantsResponse as DafnyListGrantsResponse,
    ListKeyPoliciesRequest_ListKeyPoliciesRequest as DafnyListKeyPoliciesRequest,
    ListKeyPoliciesResponse_ListKeyPoliciesResponse as DafnyListKeyPoliciesResponse,
    ListResourceTagsRequest_ListResourceTagsRequest as DafnyListResourceTagsRequest,
    ListResourceTagsResponse_ListResourceTagsResponse as DafnyListResourceTagsResponse,
    MultiRegionConfiguration_MultiRegionConfiguration as DafnyMultiRegionConfiguration,
    MultiRegionKey_MultiRegionKey as DafnyMultiRegionKey,
    PutKeyPolicyRequest_PutKeyPolicyRequest as DafnyPutKeyPolicyRequest,
    ReEncryptRequest_ReEncryptRequest as DafnyReEncryptRequest,
    ReEncryptResponse_ReEncryptResponse as DafnyReEncryptResponse,
    ReplicateKeyRequest_ReplicateKeyRequest as DafnyReplicateKeyRequest,
    ReplicateKeyResponse_ReplicateKeyResponse as DafnyReplicateKeyResponse,
    RetireGrantRequest_RetireGrantRequest as DafnyRetireGrantRequest,
    RevokeGrantRequest_RevokeGrantRequest as DafnyRevokeGrantRequest,
    ScheduleKeyDeletionRequest_ScheduleKeyDeletionRequest as DafnyScheduleKeyDeletionRequest,
    ScheduleKeyDeletionResponse_ScheduleKeyDeletionResponse as DafnyScheduleKeyDeletionResponse,
    SignRequest_SignRequest as DafnySignRequest,
    SignResponse_SignResponse as DafnySignResponse,
    TagResourceRequest_TagResourceRequest as DafnyTagResourceRequest,
    Tag_Tag as DafnyTag,
    UntagResourceRequest_UntagResourceRequest as DafnyUntagResourceRequest,
    UpdateAliasRequest_UpdateAliasRequest as DafnyUpdateAliasRequest,
    UpdateCustomKeyStoreRequest_UpdateCustomKeyStoreRequest as DafnyUpdateCustomKeyStoreRequest,
    UpdateCustomKeyStoreResponse_UpdateCustomKeyStoreResponse as DafnyUpdateCustomKeyStoreResponse,
    UpdateKeyDescriptionRequest_UpdateKeyDescriptionRequest as DafnyUpdateKeyDescriptionRequest,
    UpdatePrimaryRegionRequest_UpdatePrimaryRegionRequest as DafnyUpdatePrimaryRegionRequest,
    VerifyRequest_VerifyRequest as DafnyVerifyRequest,
    VerifyResponse_VerifyResponse as DafnyVerifyResponse,
)
import module_

from .errors import CollectionOfErrors, OpaqueError, ServiceError
from .errors import (
    AlreadyExistsException,
    CloudHsmClusterInUseException,
    CloudHsmClusterInvalidConfigurationException,
    CloudHsmClusterNotActiveException,
    CloudHsmClusterNotFoundException,
    CloudHsmClusterNotRelatedException,
    CustomKeyStoreHasCMKsException,
    CustomKeyStoreInvalidStateException,
    CustomKeyStoreNameInUseException,
    CustomKeyStoreNotFoundException,
    DependencyTimeoutException,
    DisabledException,
    ExpiredImportTokenException,
    IncorrectKeyException,
    IncorrectKeyMaterialException,
    IncorrectTrustAnchorException,
    InvalidAliasNameException,
    InvalidArnException,
    InvalidCiphertextException,
    InvalidGrantIdException,
    InvalidGrantTokenException,
    InvalidImportTokenException,
    InvalidKeyUsageException,
    InvalidMarkerException,
    KMSInternalException,
    KMSInvalidSignatureException,
    KMSInvalidStateException,
    KeyUnavailableException,
    LimitExceededException,
    MalformedPolicyDocumentException,
    NotFoundException,
    TagException,
    UnsupportedOperationException,
)
from .models import (
    CancelKeyDeletionRequest,
    CancelKeyDeletionResponse,
    ConnectCustomKeyStoreRequest,
    ConnectCustomKeyStoreResponse,
    CreateAliasRequest,
    CreateCustomKeyStoreRequest,
    CreateCustomKeyStoreResponse,
    CreateGrantRequest,
    CreateGrantResponse,
    CreateKeyRequest,
    CreateKeyResponse,
    DecryptRequest,
    DecryptResponse,
    DeleteAliasRequest,
    DeleteCustomKeyStoreRequest,
    DeleteCustomKeyStoreResponse,
    DeleteImportedKeyMaterialRequest,
    DescribeCustomKeyStoresRequest,
    DescribeCustomKeyStoresResponse,
    DescribeKeyRequest,
    DescribeKeyResponse,
    DisableKeyRequest,
    DisableKeyRotationRequest,
    DisconnectCustomKeyStoreRequest,
    DisconnectCustomKeyStoreResponse,
    EnableKeyRequest,
    EnableKeyRotationRequest,
    EncryptRequest,
    EncryptResponse,
    GenerateDataKeyPairRequest,
    GenerateDataKeyPairResponse,
    GenerateDataKeyPairWithoutPlaintextRequest,
    GenerateDataKeyPairWithoutPlaintextResponse,
    GenerateDataKeyRequest,
    GenerateDataKeyResponse,
    GenerateDataKeyWithoutPlaintextRequest,
    GenerateDataKeyWithoutPlaintextResponse,
    GenerateRandomRequest,
    GenerateRandomResponse,
    GetKeyPolicyRequest,
    GetKeyPolicyResponse,
    GetKeyRotationStatusRequest,
    GetKeyRotationStatusResponse,
    GetParametersForImportRequest,
    GetParametersForImportResponse,
    GetPublicKeyRequest,
    GetPublicKeyResponse,
    GrantConstraints,
    ImportKeyMaterialRequest,
    ImportKeyMaterialResponse,
    ListAliasesRequest,
    ListAliasesResponse,
    ListGrantsRequest,
    ListGrantsResponse,
    ListKeyPoliciesRequest,
    ListKeyPoliciesResponse,
    ListResourceTagsRequest,
    ListResourceTagsResponse,
    PutKeyPolicyRequest,
    ReEncryptRequest,
    ReEncryptResponse,
    ReplicateKeyRequest,
    ReplicateKeyResponse,
    RetireGrantRequest,
    RevokeGrantRequest,
    ScheduleKeyDeletionRequest,
    ScheduleKeyDeletionResponse,
    SignRequest,
    SignResponse,
    Tag,
    TagResourceRequest,
    UntagResourceRequest,
    UpdateAliasRequest,
    UpdateCustomKeyStoreRequest,
    UpdateCustomKeyStoreResponse,
    UpdateKeyDescriptionRequest,
    UpdatePrimaryRegionRequest,
    VerifyRequest,
    VerifyResponse,
    Unit
)


import Wrappers
import asyncio
import software_amazon_cryptography_services_kms_internaldafny_types
import trent_service.smithygenerated.client as client_impl

def smithy_error_to_dafny_error(e: ServiceError):
    if isinstance(e, AlreadyExistsException):
        return software_amazon_cryptography_services_kms_internaldafny_types.Error_AlreadyExistsException(message=e.message)

    if isinstance(e, CloudHsmClusterInUseException):
        return software_amazon_cryptography_services_kms_internaldafny_types.Error_CloudHsmClusterInUseException(message=e.message)

    if isinstance(e, CloudHsmClusterInvalidConfigurationException):
        return software_amazon_cryptography_services_kms_internaldafny_types.Error_CloudHsmClusterInvalidConfigurationException(message=e.message)

    if isinstance(e, CloudHsmClusterNotActiveException):
        return software_amazon_cryptography_services_kms_internaldafny_types.Error_CloudHsmClusterNotActiveException(message=e.message)

    if isinstance(e, CloudHsmClusterNotFoundException):
        return software_amazon_cryptography_services_kms_internaldafny_types.Error_CloudHsmClusterNotFoundException(message=e.message)

    if isinstance(e, CloudHsmClusterNotRelatedException):
        return software_amazon_cryptography_services_kms_internaldafny_types.Error_CloudHsmClusterNotRelatedException(message=e.message)

    if isinstance(e, CustomKeyStoreHasCMKsException):
        return software_amazon_cryptography_services_kms_internaldafny_types.Error_CustomKeyStoreHasCMKsException(message=e.message)

    if isinstance(e, CustomKeyStoreInvalidStateException):
        return software_amazon_cryptography_services_kms_internaldafny_types.Error_CustomKeyStoreInvalidStateException(message=e.message)

    if isinstance(e, CustomKeyStoreNameInUseException):
        return software_amazon_cryptography_services_kms_internaldafny_types.Error_CustomKeyStoreNameInUseException(message=e.message)

    if isinstance(e, CustomKeyStoreNotFoundException):
        return software_amazon_cryptography_services_kms_internaldafny_types.Error_CustomKeyStoreNotFoundException(message=e.message)

    if isinstance(e, DependencyTimeoutException):
        return software_amazon_cryptography_services_kms_internaldafny_types.Error_DependencyTimeoutException(message=e.message)

    if isinstance(e, DisabledException):
        return software_amazon_cryptography_services_kms_internaldafny_types.Error_DisabledException(message=e.message)

    if isinstance(e, ExpiredImportTokenException):
        return software_amazon_cryptography_services_kms_internaldafny_types.Error_ExpiredImportTokenException(message=e.message)

    if isinstance(e, IncorrectKeyException):
        return software_amazon_cryptography_services_kms_internaldafny_types.Error_IncorrectKeyException(message=e.message)

    if isinstance(e, IncorrectKeyMaterialException):
        return software_amazon_cryptography_services_kms_internaldafny_types.Error_IncorrectKeyMaterialException(message=e.message)

    if isinstance(e, IncorrectTrustAnchorException):
        return software_amazon_cryptography_services_kms_internaldafny_types.Error_IncorrectTrustAnchorException(message=e.message)

    if isinstance(e, InvalidAliasNameException):
        return software_amazon_cryptography_services_kms_internaldafny_types.Error_InvalidAliasNameException(message=e.message)

    if isinstance(e, InvalidArnException):
        return software_amazon_cryptography_services_kms_internaldafny_types.Error_InvalidArnException(message=e.message)

    if isinstance(e, InvalidCiphertextException):
        return software_amazon_cryptography_services_kms_internaldafny_types.Error_InvalidCiphertextException(message=e.message)

    if isinstance(e, InvalidGrantIdException):
        return software_amazon_cryptography_services_kms_internaldafny_types.Error_InvalidGrantIdException(message=e.message)

    if isinstance(e, InvalidGrantTokenException):
        return software_amazon_cryptography_services_kms_internaldafny_types.Error_InvalidGrantTokenException(message=e.message)

    if isinstance(e, InvalidImportTokenException):
        return software_amazon_cryptography_services_kms_internaldafny_types.Error_InvalidImportTokenException(message=e.message)

    if isinstance(e, InvalidKeyUsageException):
        return software_amazon_cryptography_services_kms_internaldafny_types.Error_InvalidKeyUsageException(message=e.message)

    if isinstance(e, InvalidMarkerException):
        return software_amazon_cryptography_services_kms_internaldafny_types.Error_InvalidMarkerException(message=e.message)

    if isinstance(e, KeyUnavailableException):
        return software_amazon_cryptography_services_kms_internaldafny_types.Error_KeyUnavailableException(message=e.message)

    if isinstance(e, KMSInternalException):
        return software_amazon_cryptography_services_kms_internaldafny_types.Error_KMSInternalException(message=e.message)

    if isinstance(e, KMSInvalidSignatureException):
        return software_amazon_cryptography_services_kms_internaldafny_types.Error_KMSInvalidSignatureException(message=e.message)

    if isinstance(e, KMSInvalidStateException):
        return software_amazon_cryptography_services_kms_internaldafny_types.Error_KMSInvalidStateException(message=e.message)

    if isinstance(e, LimitExceededException):
        return software_amazon_cryptography_services_kms_internaldafny_types.Error_LimitExceededException(message=e.message)

    if isinstance(e, MalformedPolicyDocumentException):
        return software_amazon_cryptography_services_kms_internaldafny_types.Error_MalformedPolicyDocumentException(message=e.message)

    if isinstance(e, NotFoundException):
        return software_amazon_cryptography_services_kms_internaldafny_types.Error_NotFoundException(message=e.message)

    if isinstance(e, TagException):
        return software_amazon_cryptography_services_kms_internaldafny_types.Error_TagException(message=e.message)

    if isinstance(e, UnsupportedOperationException):
        return software_amazon_cryptography_services_kms_internaldafny_types.Error_UnsupportedOperationException(message=e.message)

    if isinstance(e, CollectionOfErrors):
        return software_amazon_cryptography_services_kms_internaldafny_types.Error_CollectionOfErrors(message=e.message, list=e.list)

    if isinstance(e, OpaqueError):
        return software_amazon_cryptography_services_kms_internaldafny_types.Error_Opaque(obj=e.obj)

class TrentServiceShim(software_amazon_cryptography_services_kms_internaldafny_types.IKMSClient):
    def __init__(self, _impl: client_impl) :
        self._impl = _impl

    def CancelKeyDeletion(self, input: DafnyCancelKeyDeletionRequest) -> DafnyCancelKeyDeletionResponse:
        unwrapped_request: CancelKeyDeletionRequest = CancelKeyDeletionRequest(key_id=input.KeyId,
        )
        try:
            wrapped_response = asyncio.run(self._impl.cancel_key_deletion(unwrapped_request))
        except ServiceError as e:
            return Wrappers.Result_Failure(smithy_error_to_dafny_error(e))

        return Wrappers.Result_Success(DafnyCancelKeyDeletionResponse(KeyId=((Option_Some(wrapped_response.key_id)) if (wrapped_response.key_id is not None) else (Option_None())),
        ))

    def ConnectCustomKeyStore(self, input: DafnyConnectCustomKeyStoreRequest) -> DafnyConnectCustomKeyStoreResponse:
        unwrapped_request: ConnectCustomKeyStoreRequest = ConnectCustomKeyStoreRequest(custom_key_store_id=input.CustomKeyStoreId,
        )
        try:
            wrapped_response = asyncio.run(self._impl.connect_custom_key_store(unwrapped_request))
        except ServiceError as e:
            return Wrappers.Result_Failure(smithy_error_to_dafny_error(e))

        return Wrappers.Result_Success(DafnyConnectCustomKeyStoreResponse())

    def CreateAlias(self, input: DafnyCreateAliasRequest) -> None:
        unwrapped_request: CreateAliasRequest = CreateAliasRequest(alias_name=input.AliasName,
        target_key_id=input.TargetKeyId,
        )
        try:
            wrapped_response = asyncio.run(self._impl.create_alias(unwrapped_request))
        except ServiceError as e:
            return Wrappers.Result_Failure(smithy_error_to_dafny_error(e))

        return Wrappers.Result_Success(None)

    def CreateCustomKeyStore(self, input: DafnyCreateCustomKeyStoreRequest) -> DafnyCreateCustomKeyStoreResponse:
        unwrapped_request: CreateCustomKeyStoreRequest = CreateCustomKeyStoreRequest(custom_key_store_name=input.CustomKeyStoreName,
        cloud_hsm_cluster_id=input.CloudHsmClusterId,
        trust_anchor_certificate=input.TrustAnchorCertificate,
        key_store_password=input.KeyStorePassword,
        )
        try:
            wrapped_response = asyncio.run(self._impl.create_custom_key_store(unwrapped_request))
        except ServiceError as e:
            return Wrappers.Result_Failure(smithy_error_to_dafny_error(e))

        return Wrappers.Result_Success(DafnyCreateCustomKeyStoreResponse(CustomKeyStoreId=((Option_Some(wrapped_response.custom_key_store_id)) if (wrapped_response.custom_key_store_id is not None) else (Option_None())),
        ))

    def CreateGrant(self, input: DafnyCreateGrantRequest) -> DafnyCreateGrantResponse:
        unwrapped_request: CreateGrantRequest = CreateGrantRequest(key_id=input.KeyId,
        grantee_principal=input.GranteePrincipal,
        retiring_principal=input.RetiringPrincipal.UnwrapOr(None),
        operations=[list_element for list_element in input.Operations],
        constraints=GrantConstraints(encryption_context_subset={key: value for (key, value) in input.Constraints.UnwrapOr(None).EncryptionContextSubset.UnwrapOr(None).items },
        encryption_context_equals={key: value for (key, value) in input.Constraints.UnwrapOr(None).EncryptionContextEquals.UnwrapOr(None).items },
        ),
        grant_tokens=[list_element for list_element in input.GrantTokens.UnwrapOr(None)],
        name=input.Name.UnwrapOr(None),
        )
        try:
            wrapped_response = asyncio.run(self._impl.create_grant(unwrapped_request))
        except ServiceError as e:
            return Wrappers.Result_Failure(smithy_error_to_dafny_error(e))

        return Wrappers.Result_Success(DafnyCreateGrantResponse(GrantToken=((Option_Some(wrapped_response.grant_token)) if (wrapped_response.grant_token is not None) else (Option_None())),
        GrantId=((Option_Some(wrapped_response.grant_id)) if (wrapped_response.grant_id is not None) else (Option_None())),
        ))

    def CreateKey(self, input: DafnyCreateKeyRequest) -> DafnyCreateKeyResponse:
        unwrapped_request: CreateKeyRequest = CreateKeyRequest(policy=input.Policy.UnwrapOr(None),
        description=input.Description.UnwrapOr(None),
        key_usage=input.KeyUsage.UnwrapOr(None),
        customer_master_key_spec=input.CustomerMasterKeySpec.UnwrapOr(None),
        key_spec=input.KeySpec.UnwrapOr(None),
        origin=input.Origin.UnwrapOr(None),
        custom_key_store_id=input.CustomKeyStoreId.UnwrapOr(None),
        bypass_policy_lockout_safety_check=input.BypassPolicyLockoutSafetyCheck.UnwrapOr(None),
        tags=[Tag(tag_key=list_element.TagKey,
        tag_value=list_element.TagValue,
        ) for list_element in input.Tags.UnwrapOr(None)],
        multi_region=input.MultiRegion.UnwrapOr(None),
        )
        try:
            wrapped_response = asyncio.run(self._impl.create_key(unwrapped_request))
        except ServiceError as e:
            return Wrappers.Result_Failure(smithy_error_to_dafny_error(e))

        return Wrappers.Result_Success(DafnyCreateKeyResponse(KeyMetadata=((Option_Some(DafnyKeyMetadata(AWSAccountId=((Option_Some(wrapped_response.key_metadata.aws_account_id)) if (wrapped_response.key_metadata.aws_account_id is not None) else (Option_None())),
        KeyId=wrapped_response.key_metadata.key_id,
        Arn=((Option_Some(wrapped_response.key_metadata.arn)) if (wrapped_response.key_metadata.arn is not None) else (Option_None())),
        CreationDate=((Option_Some(wrapped_response.key_metadata.creation_date)) if (wrapped_response.key_metadata.creation_date is not None) else (Option_None())),
        Enabled=((Option_Some(wrapped_response.key_metadata.enabled)) if (wrapped_response.key_metadata.enabled is not None) else (Option_None())),
        Description=((Option_Some(wrapped_response.key_metadata.description)) if (wrapped_response.key_metadata.description is not None) else (Option_None())),
        KeyUsage=((Option_Some(wrapped_response.key_metadata.key_usage)) if (wrapped_response.key_metadata.key_usage is not None) else (Option_None())),
        KeyState=((Option_Some(wrapped_response.key_metadata.key_state)) if (wrapped_response.key_metadata.key_state is not None) else (Option_None())),
        DeletionDate=((Option_Some(wrapped_response.key_metadata.deletion_date)) if (wrapped_response.key_metadata.deletion_date is not None) else (Option_None())),
        ValidTo=((Option_Some(wrapped_response.key_metadata.valid_to)) if (wrapped_response.key_metadata.valid_to is not None) else (Option_None())),
        Origin=((Option_Some(wrapped_response.key_metadata.origin)) if (wrapped_response.key_metadata.origin is not None) else (Option_None())),
        CustomKeyStoreId=((Option_Some(wrapped_response.key_metadata.custom_key_store_id)) if (wrapped_response.key_metadata.custom_key_store_id is not None) else (Option_None())),
        CloudHsmClusterId=((Option_Some(wrapped_response.key_metadata.cloud_hsm_cluster_id)) if (wrapped_response.key_metadata.cloud_hsm_cluster_id is not None) else (Option_None())),
        ExpirationModel=((Option_Some(wrapped_response.key_metadata.expiration_model)) if (wrapped_response.key_metadata.expiration_model is not None) else (Option_None())),
        KeyManager=((Option_Some(wrapped_response.key_metadata.key_manager)) if (wrapped_response.key_metadata.key_manager is not None) else (Option_None())),
        CustomerMasterKeySpec=((Option_Some(wrapped_response.key_metadata.customer_master_key_spec)) if (wrapped_response.key_metadata.customer_master_key_spec is not None) else (Option_None())),
        KeySpec=((Option_Some(wrapped_response.key_metadata.key_spec)) if (wrapped_response.key_metadata.key_spec is not None) else (Option_None())),
        EncryptionAlgorithms=((Option_Some(Seq([list_element for list_element in wrapped_response.key_metadata.encryption_algorithms]))) if (wrapped_response.key_metadata.encryption_algorithms is not None) else (Option_None())),
        SigningAlgorithms=((Option_Some(Seq([list_element for list_element in wrapped_response.key_metadata.signing_algorithms]))) if (wrapped_response.key_metadata.signing_algorithms is not None) else (Option_None())),
        MultiRegion=((Option_Some(wrapped_response.key_metadata.multi_region)) if (wrapped_response.key_metadata.multi_region is not None) else (Option_None())),
        MultiRegionConfiguration=((Option_Some(DafnyMultiRegionConfiguration(MultiRegionKeyType=((Option_Some(wrapped_response.key_metadata.multi_region_configuration.multi_region_key_type)) if (wrapped_response.key_metadata.multi_region_configuration.multi_region_key_type is not None) else (Option_None())),
        PrimaryKey=((Option_Some(DafnyMultiRegionKey(Arn=((Option_Some(wrapped_response.key_metadata.multi_region_configuration.primary_key.arn)) if (wrapped_response.key_metadata.multi_region_configuration.primary_key.arn is not None) else (Option_None())),
        Region=((Option_Some(wrapped_response.key_metadata.multi_region_configuration.primary_key.region)) if (wrapped_response.key_metadata.multi_region_configuration.primary_key.region is not None) else (Option_None())),
        ))) if (wrapped_response.key_metadata.multi_region_configuration.primary_key is not None) else (Option_None())),
        ReplicaKeys=((Option_Some(Seq([DafnyMultiRegionKey(Arn=((Option_Some(list_element.arn)) if (list_element.arn is not None) else (Option_None())),
        Region=((Option_Some(list_element.region)) if (list_element.region is not None) else (Option_None())),
        ) for list_element in wrapped_response.key_metadata.multi_region_configuration.replica_keys]))) if (wrapped_response.key_metadata.multi_region_configuration.replica_keys is not None) else (Option_None())),
        ))) if (wrapped_response.key_metadata.multi_region_configuration is not None) else (Option_None())),
        PendingDeletionWindowInDays=((Option_Some(wrapped_response.key_metadata.pending_deletion_window_in_days)) if (wrapped_response.key_metadata.pending_deletion_window_in_days is not None) else (Option_None())),
        ))) if (wrapped_response.key_metadata is not None) else (Option_None())),
        ))

    def Decrypt(self, input: DafnyDecryptRequest) -> DafnyDecryptResponse:
        unwrapped_request: DecryptRequest = DecryptRequest(ciphertext_blob=input.CiphertextBlob,
        encryption_context={key: value for (key, value) in input.EncryptionContext.UnwrapOr(None).items} if input.EncryptionContext.UnwrapOr(None) is not None else {},
        grant_tokens=[list_element for list_element in input.GrantTokens.UnwrapOr(None)] if input.GrantTokens.UnwrapOr(None) is not None else [],
        key_id=input.KeyId.UnwrapOr(None),
        encryption_algorithm=input.EncryptionAlgorithm.UnwrapOr(None),
        )
        try:
            wrapped_response = self._impl.decrypt(CiphertextBlob=bytes(input.CiphertextBlob),
                                                              EncryptionContext={key: value for (key, value) in input.EncryptionContext.UnwrapOr(None).items} if input.EncryptionContext.UnwrapOr(None) is not None else {},
                                                              GrantTokens=[list_element for list_element in input.GrantTokens.UnwrapOr(None)] if input.GrantTokens.UnwrapOr(None) is not None else [],
                                                              KeyId=input.KeyId.UnwrapOr(None).VerbatimString(False),
                                                              EncryptionAlgorithm=input.EncryptionAlgorithm.UnwrapOr("SYMMETRIC_DEFAULT"))
        except ServiceError as e:
            return Wrappers.Result_Failure(smithy_error_to_dafny_error(e))

        print(wrapped_response)
        return Wrappers.Result_Success(DafnyDecryptResponse(KeyId=((Option_Some(Seq(wrapped_response["KeyId"]))) if (wrapped_response["KeyId"] is not None) else (Option_None())),
        Plaintext=((Option_Some(Seq([b for b in wrapped_response["Plaintext"]]))) if (wrapped_response["Plaintext"] is not None) else (Option_None())),
        EncryptionAlgorithm=((Option_Some(wrapped_response["EncryptionAlgorithm"])) if (wrapped_response["EncryptionAlgorithm"] is not None) else (Option_None())),
        ))

    def DeleteAlias(self, input: DafnyDeleteAliasRequest) -> None:
        unwrapped_request: DeleteAliasRequest = DeleteAliasRequest(alias_name=input.AliasName,
        )
        try:
            wrapped_response = asyncio.run(self._impl.delete_alias(unwrapped_request))
        except ServiceError as e:
            return Wrappers.Result_Failure(smithy_error_to_dafny_error(e))

        return Wrappers.Result_Success(None)

    def DeleteCustomKeyStore(self, input: DafnyDeleteCustomKeyStoreRequest) -> DafnyDeleteCustomKeyStoreResponse:
        unwrapped_request: DeleteCustomKeyStoreRequest = DeleteCustomKeyStoreRequest(custom_key_store_id=input.CustomKeyStoreId,
        )
        try:
            wrapped_response = asyncio.run(self._impl.delete_custom_key_store(unwrapped_request))
        except ServiceError as e:
            return Wrappers.Result_Failure(smithy_error_to_dafny_error(e))

        return Wrappers.Result_Success(DafnyDeleteCustomKeyStoreResponse())

    def DeleteImportedKeyMaterial(self, input: DafnyDeleteImportedKeyMaterialRequest) -> None:
        unwrapped_request: DeleteImportedKeyMaterialRequest = DeleteImportedKeyMaterialRequest(key_id=input.KeyId,
        )
        try:
            wrapped_response = asyncio.run(self._impl.delete_imported_key_material(unwrapped_request))
        except ServiceError as e:
            return Wrappers.Result_Failure(smithy_error_to_dafny_error(e))

        return Wrappers.Result_Success(None)

    def DescribeCustomKeyStores(self, input: DafnyDescribeCustomKeyStoresRequest) -> DafnyDescribeCustomKeyStoresResponse:
        unwrapped_request: DescribeCustomKeyStoresRequest = DescribeCustomKeyStoresRequest(custom_key_store_id=input.CustomKeyStoreId.UnwrapOr(None),
        custom_key_store_name=input.CustomKeyStoreName.UnwrapOr(None),
        limit=input.Limit.UnwrapOr(None),
        marker=input.Marker.UnwrapOr(None),
        )
        try:
            wrapped_response = asyncio.run(self._impl.describe_custom_key_stores(unwrapped_request))
        except ServiceError as e:
            return Wrappers.Result_Failure(smithy_error_to_dafny_error(e))

        return Wrappers.Result_Success(DafnyDescribeCustomKeyStoresResponse(CustomKeyStores=((Option_Some(Seq([DafnyCustomKeyStoresListEntry(CustomKeyStoreId=((Option_Some(list_element.custom_key_store_id)) if (list_element.custom_key_store_id is not None) else (Option_None())),
        CustomKeyStoreName=((Option_Some(list_element.custom_key_store_name)) if (list_element.custom_key_store_name is not None) else (Option_None())),
        CloudHsmClusterId=((Option_Some(list_element.cloud_hsm_cluster_id)) if (list_element.cloud_hsm_cluster_id is not None) else (Option_None())),
        TrustAnchorCertificate=((Option_Some(list_element.trust_anchor_certificate)) if (list_element.trust_anchor_certificate is not None) else (Option_None())),
        ConnectionState=((Option_Some(list_element.connection_state)) if (list_element.connection_state is not None) else (Option_None())),
        ConnectionErrorCode=((Option_Some(list_element.connection_error_code)) if (list_element.connection_error_code is not None) else (Option_None())),
        CreationDate=((Option_Some(list_element.creation_date)) if (list_element.creation_date is not None) else (Option_None())),
        ) for list_element in wrapped_response.custom_key_stores]))) if (wrapped_response.custom_key_stores is not None) else (Option_None())),
        NextMarker=((Option_Some(wrapped_response.next_marker)) if (wrapped_response.next_marker is not None) else (Option_None())),
        Truncated=((Option_Some(wrapped_response.truncated)) if (wrapped_response.truncated is not None) else (Option_None())),
        ))

    def DescribeKey(self, input: DafnyDescribeKeyRequest) -> DafnyDescribeKeyResponse:
        unwrapped_request: DescribeKeyRequest = DescribeKeyRequest(key_id=input.KeyId,
        grant_tokens=[list_element for list_element in input.GrantTokens.UnwrapOr(None)],
        )
        try:
            wrapped_response = asyncio.run(self._impl.describe_key(unwrapped_request))
        except ServiceError as e:
            return Wrappers.Result_Failure(smithy_error_to_dafny_error(e))

        return Wrappers.Result_Success(DafnyDescribeKeyResponse(KeyMetadata=((Option_Some(DafnyKeyMetadata(AWSAccountId=((Option_Some(wrapped_response.key_metadata.aws_account_id)) if (wrapped_response.key_metadata.aws_account_id is not None) else (Option_None())),
        KeyId=wrapped_response.key_metadata.key_id,
        Arn=((Option_Some(wrapped_response.key_metadata.arn)) if (wrapped_response.key_metadata.arn is not None) else (Option_None())),
        CreationDate=((Option_Some(wrapped_response.key_metadata.creation_date)) if (wrapped_response.key_metadata.creation_date is not None) else (Option_None())),
        Enabled=((Option_Some(wrapped_response.key_metadata.enabled)) if (wrapped_response.key_metadata.enabled is not None) else (Option_None())),
        Description=((Option_Some(wrapped_response.key_metadata.description)) if (wrapped_response.key_metadata.description is not None) else (Option_None())),
        KeyUsage=((Option_Some(wrapped_response.key_metadata.key_usage)) if (wrapped_response.key_metadata.key_usage is not None) else (Option_None())),
        KeyState=((Option_Some(wrapped_response.key_metadata.key_state)) if (wrapped_response.key_metadata.key_state is not None) else (Option_None())),
        DeletionDate=((Option_Some(wrapped_response.key_metadata.deletion_date)) if (wrapped_response.key_metadata.deletion_date is not None) else (Option_None())),
        ValidTo=((Option_Some(wrapped_response.key_metadata.valid_to)) if (wrapped_response.key_metadata.valid_to is not None) else (Option_None())),
        Origin=((Option_Some(wrapped_response.key_metadata.origin)) if (wrapped_response.key_metadata.origin is not None) else (Option_None())),
        CustomKeyStoreId=((Option_Some(wrapped_response.key_metadata.custom_key_store_id)) if (wrapped_response.key_metadata.custom_key_store_id is not None) else (Option_None())),
        CloudHsmClusterId=((Option_Some(wrapped_response.key_metadata.cloud_hsm_cluster_id)) if (wrapped_response.key_metadata.cloud_hsm_cluster_id is not None) else (Option_None())),
        ExpirationModel=((Option_Some(wrapped_response.key_metadata.expiration_model)) if (wrapped_response.key_metadata.expiration_model is not None) else (Option_None())),
        KeyManager=((Option_Some(wrapped_response.key_metadata.key_manager)) if (wrapped_response.key_metadata.key_manager is not None) else (Option_None())),
        CustomerMasterKeySpec=((Option_Some(wrapped_response.key_metadata.customer_master_key_spec)) if (wrapped_response.key_metadata.customer_master_key_spec is not None) else (Option_None())),
        KeySpec=((Option_Some(wrapped_response.key_metadata.key_spec)) if (wrapped_response.key_metadata.key_spec is not None) else (Option_None())),
        EncryptionAlgorithms=((Option_Some(Seq([list_element for list_element in wrapped_response.key_metadata.encryption_algorithms]))) if (wrapped_response.key_metadata.encryption_algorithms is not None) else (Option_None())),
        SigningAlgorithms=((Option_Some(Seq([list_element for list_element in wrapped_response.key_metadata.signing_algorithms]))) if (wrapped_response.key_metadata.signing_algorithms is not None) else (Option_None())),
        MultiRegion=((Option_Some(wrapped_response.key_metadata.multi_region)) if (wrapped_response.key_metadata.multi_region is not None) else (Option_None())),
        MultiRegionConfiguration=((Option_Some(DafnyMultiRegionConfiguration(MultiRegionKeyType=((Option_Some(wrapped_response.key_metadata.multi_region_configuration.multi_region_key_type)) if (wrapped_response.key_metadata.multi_region_configuration.multi_region_key_type is not None) else (Option_None())),
        PrimaryKey=((Option_Some(DafnyMultiRegionKey(Arn=((Option_Some(wrapped_response.key_metadata.multi_region_configuration.primary_key.arn)) if (wrapped_response.key_metadata.multi_region_configuration.primary_key.arn is not None) else (Option_None())),
        Region=((Option_Some(wrapped_response.key_metadata.multi_region_configuration.primary_key.region)) if (wrapped_response.key_metadata.multi_region_configuration.primary_key.region is not None) else (Option_None())),
        ))) if (wrapped_response.key_metadata.multi_region_configuration.primary_key is not None) else (Option_None())),
        ReplicaKeys=((Option_Some(Seq([DafnyMultiRegionKey(Arn=((Option_Some(list_element.arn)) if (list_element.arn is not None) else (Option_None())),
        Region=((Option_Some(list_element.region)) if (list_element.region is not None) else (Option_None())),
        ) for list_element in wrapped_response.key_metadata.multi_region_configuration.replica_keys]))) if (wrapped_response.key_metadata.multi_region_configuration.replica_keys is not None) else (Option_None())),
        ))) if (wrapped_response.key_metadata.multi_region_configuration is not None) else (Option_None())),
        PendingDeletionWindowInDays=((Option_Some(wrapped_response.key_metadata.pending_deletion_window_in_days)) if (wrapped_response.key_metadata.pending_deletion_window_in_days is not None) else (Option_None())),
        ))) if (wrapped_response.key_metadata is not None) else (Option_None())),
        ))

    def DisableKey(self, input: DafnyDisableKeyRequest) -> None:
        unwrapped_request: DisableKeyRequest = DisableKeyRequest(key_id=input.KeyId,
        )
        try:
            wrapped_response = asyncio.run(self._impl.disable_key(unwrapped_request))
        except ServiceError as e:
            return Wrappers.Result_Failure(smithy_error_to_dafny_error(e))

        return Wrappers.Result_Success(None)

    def DisableKeyRotation(self, input: DafnyDisableKeyRotationRequest) -> None:
        unwrapped_request: DisableKeyRotationRequest = DisableKeyRotationRequest(key_id=input.KeyId,
        )
        try:
            wrapped_response = asyncio.run(self._impl.disable_key_rotation(unwrapped_request))
        except ServiceError as e:
            return Wrappers.Result_Failure(smithy_error_to_dafny_error(e))

        return Wrappers.Result_Success(None)

    def DisconnectCustomKeyStore(self, input: DafnyDisconnectCustomKeyStoreRequest) -> DafnyDisconnectCustomKeyStoreResponse:
        unwrapped_request: DisconnectCustomKeyStoreRequest = DisconnectCustomKeyStoreRequest(custom_key_store_id=input.CustomKeyStoreId,
        )
        try:
            wrapped_response = asyncio.run(self._impl.disconnect_custom_key_store(unwrapped_request))
        except ServiceError as e:
            return Wrappers.Result_Failure(smithy_error_to_dafny_error(e))

        return Wrappers.Result_Success(DafnyDisconnectCustomKeyStoreResponse())

    def EnableKey(self, input: DafnyEnableKeyRequest) -> None:
        unwrapped_request: EnableKeyRequest = EnableKeyRequest(key_id=input.KeyId,
        )
        try:
            wrapped_response = asyncio.run(self._impl.enable_key(unwrapped_request))
        except ServiceError as e:
            return Wrappers.Result_Failure(smithy_error_to_dafny_error(e))

        return Wrappers.Result_Success(None)

    def EnableKeyRotation(self, input: DafnyEnableKeyRotationRequest) -> None:
        unwrapped_request: EnableKeyRotationRequest = EnableKeyRotationRequest(key_id=input.KeyId,
        )
        try:
            wrapped_response = asyncio.run(self._impl.enable_key_rotation(unwrapped_request))
        except ServiceError as e:
            return Wrappers.Result_Failure(smithy_error_to_dafny_error(e))

        return Wrappers.Result_Success(None)

    def Encrypt(self, input: DafnyEncryptRequest) -> DafnyEncryptResponse:
        unwrapped_request: EncryptRequest = EncryptRequest(key_id=input.KeyId,
        plaintext=input.Plaintext,
        encryption_context={key: value for (key, value) in input.EncryptionContext.UnwrapOr(None).items },
        grant_tokens=[list_element for list_element in input.GrantTokens.UnwrapOr(None)],
        encryption_algorithm=input.EncryptionAlgorithm.UnwrapOr(None),
        )
        try:
            wrapped_response = asyncio.run(self._impl.encrypt(unwrapped_request))
        except ServiceError as e:
            return Wrappers.Result_Failure(smithy_error_to_dafny_error(e))

        return Wrappers.Result_Success(DafnyEncryptResponse(CiphertextBlob=((Option_Some(wrapped_response.ciphertext_blob)) if (wrapped_response.ciphertext_blob is not None) else (Option_None())),
        KeyId=((Option_Some(wrapped_response.key_id)) if (wrapped_response.key_id is not None) else (Option_None())),
        EncryptionAlgorithm=((Option_Some(wrapped_response.encryption_algorithm)) if (wrapped_response.encryption_algorithm is not None) else (Option_None())),
        ))

    def GenerateDataKey(self, input: DafnyGenerateDataKeyRequest) -> DafnyGenerateDataKeyResponse:
        unwrapped_request: GenerateDataKeyRequest = GenerateDataKeyRequest(key_id=input.KeyId,
        encryption_context={key: value for (key, value) in input.EncryptionContext.UnwrapOr(None).items },
        number_of_bytes=input.NumberOfBytes.UnwrapOr(None),
        key_spec=input.KeySpec.UnwrapOr(None),
        grant_tokens=[list_element for list_element in input.GrantTokens.UnwrapOr(None)],
        )
        try:
            wrapped_response = asyncio.run(self._impl.generate_data_key(unwrapped_request))
        except ServiceError as e:
            return Wrappers.Result_Failure(smithy_error_to_dafny_error(e))

        return Wrappers.Result_Success(DafnyGenerateDataKeyResponse(CiphertextBlob=((Option_Some(wrapped_response.ciphertext_blob)) if (wrapped_response.ciphertext_blob is not None) else (Option_None())),
        Plaintext=((Option_Some(wrapped_response.plaintext)) if (wrapped_response.plaintext is not None) else (Option_None())),
        KeyId=((Option_Some(wrapped_response.key_id)) if (wrapped_response.key_id is not None) else (Option_None())),
        ))

    def GenerateDataKeyPair(self, input: DafnyGenerateDataKeyPairRequest) -> DafnyGenerateDataKeyPairResponse:
        unwrapped_request: GenerateDataKeyPairRequest = GenerateDataKeyPairRequest(encryption_context={key: value for (key, value) in input.EncryptionContext.UnwrapOr(None).items },
        key_id=input.KeyId,
        key_pair_spec=input.KeyPairSpec,
        grant_tokens=[list_element for list_element in input.GrantTokens.UnwrapOr(None)],
        )
        try:
            wrapped_response = asyncio.run(self._impl.generate_data_key_pair(unwrapped_request))
        except ServiceError as e:
            return Wrappers.Result_Failure(smithy_error_to_dafny_error(e))

        return Wrappers.Result_Success(DafnyGenerateDataKeyPairResponse(PrivateKeyCiphertextBlob=((Option_Some(wrapped_response.private_key_ciphertext_blob)) if (wrapped_response.private_key_ciphertext_blob is not None) else (Option_None())),
        PrivateKeyPlaintext=((Option_Some(wrapped_response.private_key_plaintext)) if (wrapped_response.private_key_plaintext is not None) else (Option_None())),
        PublicKey=((Option_Some(wrapped_response.public_key)) if (wrapped_response.public_key is not None) else (Option_None())),
        KeyId=((Option_Some(wrapped_response.key_id)) if (wrapped_response.key_id is not None) else (Option_None())),
        KeyPairSpec=((Option_Some(wrapped_response.key_pair_spec)) if (wrapped_response.key_pair_spec is not None) else (Option_None())),
        ))

    def GenerateDataKeyPairWithoutPlaintext(self, input: DafnyGenerateDataKeyPairWithoutPlaintextRequest) -> DafnyGenerateDataKeyPairWithoutPlaintextResponse:
        unwrapped_request: GenerateDataKeyPairWithoutPlaintextRequest = GenerateDataKeyPairWithoutPlaintextRequest(encryption_context={key: value for (key, value) in input.EncryptionContext.UnwrapOr(None).items },
        key_id=input.KeyId,
        key_pair_spec=input.KeyPairSpec,
        grant_tokens=[list_element for list_element in input.GrantTokens.UnwrapOr(None)],
        )
        try:
            wrapped_response = asyncio.run(self._impl.generate_data_key_pair_without_plaintext(unwrapped_request))
        except ServiceError as e:
            return Wrappers.Result_Failure(smithy_error_to_dafny_error(e))

        return Wrappers.Result_Success(DafnyGenerateDataKeyPairWithoutPlaintextResponse(PrivateKeyCiphertextBlob=((Option_Some(wrapped_response.private_key_ciphertext_blob)) if (wrapped_response.private_key_ciphertext_blob is not None) else (Option_None())),
        PublicKey=((Option_Some(wrapped_response.public_key)) if (wrapped_response.public_key is not None) else (Option_None())),
        KeyId=((Option_Some(wrapped_response.key_id)) if (wrapped_response.key_id is not None) else (Option_None())),
        KeyPairSpec=((Option_Some(wrapped_response.key_pair_spec)) if (wrapped_response.key_pair_spec is not None) else (Option_None())),
        ))

    def GenerateDataKeyWithoutPlaintext(self, input: DafnyGenerateDataKeyWithoutPlaintextRequest) -> DafnyGenerateDataKeyWithoutPlaintextResponse:
        unwrapped_request: GenerateDataKeyWithoutPlaintextRequest = GenerateDataKeyWithoutPlaintextRequest(key_id=input.KeyId,
        encryption_context={key: value for (key, value) in input.EncryptionContext.UnwrapOr(None).items },
        key_spec=input.KeySpec.UnwrapOr(None),
        number_of_bytes=input.NumberOfBytes.UnwrapOr(None),
        grant_tokens=[list_element for list_element in input.GrantTokens.UnwrapOr(None)],
        )
        try:
            wrapped_response = asyncio.run(self._impl.generate_data_key_without_plaintext(unwrapped_request))
        except ServiceError as e:
            return Wrappers.Result_Failure(smithy_error_to_dafny_error(e))

        return Wrappers.Result_Success(DafnyGenerateDataKeyWithoutPlaintextResponse(CiphertextBlob=((Option_Some(wrapped_response.ciphertext_blob)) if (wrapped_response.ciphertext_blob is not None) else (Option_None())),
        KeyId=((Option_Some(wrapped_response.key_id)) if (wrapped_response.key_id is not None) else (Option_None())),
        ))

    def GenerateRandom(self, input: DafnyGenerateRandomRequest) -> DafnyGenerateRandomResponse:
        unwrapped_request: GenerateRandomRequest = GenerateRandomRequest(number_of_bytes=input.NumberOfBytes.UnwrapOr(None),
        custom_key_store_id=input.CustomKeyStoreId.UnwrapOr(None),
        )
        try:
            wrapped_response = asyncio.run(self._impl.generate_random(unwrapped_request))
        except ServiceError as e:
            return Wrappers.Result_Failure(smithy_error_to_dafny_error(e))

        return Wrappers.Result_Success(DafnyGenerateRandomResponse(Plaintext=((Option_Some(wrapped_response.plaintext)) if (wrapped_response.plaintext is not None) else (Option_None())),
        ))

    def GetKeyPolicy(self, input: DafnyGetKeyPolicyRequest) -> DafnyGetKeyPolicyResponse:
        unwrapped_request: GetKeyPolicyRequest = GetKeyPolicyRequest(key_id=input.KeyId,
        policy_name=input.PolicyName,
        )
        try:
            wrapped_response = asyncio.run(self._impl.get_key_policy(unwrapped_request))
        except ServiceError as e:
            return Wrappers.Result_Failure(smithy_error_to_dafny_error(e))

        return Wrappers.Result_Success(DafnyGetKeyPolicyResponse(Policy=((Option_Some(wrapped_response.policy)) if (wrapped_response.policy is not None) else (Option_None())),
        ))

    def GetKeyRotationStatus(self, input: DafnyGetKeyRotationStatusRequest) -> DafnyGetKeyRotationStatusResponse:
        unwrapped_request: GetKeyRotationStatusRequest = GetKeyRotationStatusRequest(key_id=input.KeyId,
        )
        try:
            wrapped_response = asyncio.run(self._impl.get_key_rotation_status(unwrapped_request))
        except ServiceError as e:
            return Wrappers.Result_Failure(smithy_error_to_dafny_error(e))

        return Wrappers.Result_Success(DafnyGetKeyRotationStatusResponse(KeyRotationEnabled=((Option_Some(wrapped_response.key_rotation_enabled)) if (wrapped_response.key_rotation_enabled is not None) else (Option_None())),
        ))

    def GetParametersForImport(self, input: DafnyGetParametersForImportRequest) -> DafnyGetParametersForImportResponse:
        unwrapped_request: GetParametersForImportRequest = GetParametersForImportRequest(key_id=input.KeyId,
        wrapping_algorithm=input.WrappingAlgorithm,
        wrapping_key_spec=input.WrappingKeySpec,
        )
        try:
            wrapped_response = asyncio.run(self._impl.get_parameters_for_import(unwrapped_request))
        except ServiceError as e:
            return Wrappers.Result_Failure(smithy_error_to_dafny_error(e))

        return Wrappers.Result_Success(DafnyGetParametersForImportResponse(KeyId=((Option_Some(wrapped_response.key_id)) if (wrapped_response.key_id is not None) else (Option_None())),
        ImportToken=((Option_Some(wrapped_response.import_token)) if (wrapped_response.import_token is not None) else (Option_None())),
        PublicKey=((Option_Some(wrapped_response.public_key)) if (wrapped_response.public_key is not None) else (Option_None())),
        ParametersValidTo=((Option_Some(wrapped_response.parameters_valid_to)) if (wrapped_response.parameters_valid_to is not None) else (Option_None())),
        ))

    def GetPublicKey(self, input: DafnyGetPublicKeyRequest) -> DafnyGetPublicKeyResponse:
        unwrapped_request: GetPublicKeyRequest = GetPublicKeyRequest(key_id=input.KeyId,
        grant_tokens=[list_element for list_element in input.GrantTokens.UnwrapOr(None)],
        )
        try:
            wrapped_response = asyncio.run(self._impl.get_public_key(unwrapped_request))
        except ServiceError as e:
            return Wrappers.Result_Failure(smithy_error_to_dafny_error(e))

        return Wrappers.Result_Success(DafnyGetPublicKeyResponse(KeyId=((Option_Some(wrapped_response.key_id)) if (wrapped_response.key_id is not None) else (Option_None())),
        PublicKey=((Option_Some(wrapped_response.public_key)) if (wrapped_response.public_key is not None) else (Option_None())),
        CustomerMasterKeySpec=((Option_Some(wrapped_response.customer_master_key_spec)) if (wrapped_response.customer_master_key_spec is not None) else (Option_None())),
        KeySpec=((Option_Some(wrapped_response.key_spec)) if (wrapped_response.key_spec is not None) else (Option_None())),
        KeyUsage=((Option_Some(wrapped_response.key_usage)) if (wrapped_response.key_usage is not None) else (Option_None())),
        EncryptionAlgorithms=((Option_Some(Seq([list_element for list_element in wrapped_response.encryption_algorithms]))) if (wrapped_response.encryption_algorithms is not None) else (Option_None())),
        SigningAlgorithms=((Option_Some(Seq([list_element for list_element in wrapped_response.signing_algorithms]))) if (wrapped_response.signing_algorithms is not None) else (Option_None())),
        ))

    def ImportKeyMaterial(self, input: DafnyImportKeyMaterialRequest) -> DafnyImportKeyMaterialResponse:
        unwrapped_request: ImportKeyMaterialRequest = ImportKeyMaterialRequest(key_id=input.KeyId,
        import_token=input.ImportToken,
        encrypted_key_material=input.EncryptedKeyMaterial,
        valid_to=input.ValidTo.UnwrapOr(None),
        expiration_model=input.ExpirationModel.UnwrapOr(None),
        )
        try:
            wrapped_response = asyncio.run(self._impl.import_key_material(unwrapped_request))
        except ServiceError as e:
            return Wrappers.Result_Failure(smithy_error_to_dafny_error(e))

        return Wrappers.Result_Success(DafnyImportKeyMaterialResponse())

    def ListAliases(self, input: DafnyListAliasesRequest) -> DafnyListAliasesResponse:
        unwrapped_request: ListAliasesRequest = ListAliasesRequest(key_id=input.KeyId.UnwrapOr(None),
        limit=input.Limit.UnwrapOr(None),
        marker=input.Marker.UnwrapOr(None),
        )
        try:
            wrapped_response = asyncio.run(self._impl.list_aliases(unwrapped_request))
        except ServiceError as e:
            return Wrappers.Result_Failure(smithy_error_to_dafny_error(e))

        return Wrappers.Result_Success(DafnyListAliasesResponse(Aliases=((Option_Some(Seq([DafnyAliasListEntry(AliasName=((Option_Some(list_element.alias_name)) if (list_element.alias_name is not None) else (Option_None())),
        AliasArn=((Option_Some(list_element.alias_arn)) if (list_element.alias_arn is not None) else (Option_None())),
        TargetKeyId=((Option_Some(list_element.target_key_id)) if (list_element.target_key_id is not None) else (Option_None())),
        CreationDate=((Option_Some(list_element.creation_date)) if (list_element.creation_date is not None) else (Option_None())),
        LastUpdatedDate=((Option_Some(list_element.last_updated_date)) if (list_element.last_updated_date is not None) else (Option_None())),
        ) for list_element in wrapped_response.aliases]))) if (wrapped_response.aliases is not None) else (Option_None())),
        NextMarker=((Option_Some(wrapped_response.next_marker)) if (wrapped_response.next_marker is not None) else (Option_None())),
        Truncated=((Option_Some(wrapped_response.truncated)) if (wrapped_response.truncated is not None) else (Option_None())),
        ))

    def ListGrants(self, input: DafnyListGrantsRequest) -> DafnyListGrantsResponse:
        unwrapped_request: ListGrantsRequest = ListGrantsRequest(limit=input.Limit.UnwrapOr(None),
        marker=input.Marker.UnwrapOr(None),
        key_id=input.KeyId,
        grant_id=input.GrantId.UnwrapOr(None),
        grantee_principal=input.GranteePrincipal.UnwrapOr(None),
        )
        try:
            wrapped_response = asyncio.run(self._impl.list_grants(unwrapped_request))
        except ServiceError as e:
            return Wrappers.Result_Failure(smithy_error_to_dafny_error(e))

        return Wrappers.Result_Success(DafnyListGrantsResponse(Grants=((Option_Some(Seq([DafnyGrantListEntry(KeyId=((Option_Some(list_element.key_id)) if (list_element.key_id is not None) else (Option_None())),
        GrantId=((Option_Some(list_element.grant_id)) if (list_element.grant_id is not None) else (Option_None())),
        Name=((Option_Some(list_element.name)) if (list_element.name is not None) else (Option_None())),
        CreationDate=((Option_Some(list_element.creation_date)) if (list_element.creation_date is not None) else (Option_None())),
        GranteePrincipal=((Option_Some(list_element.grantee_principal)) if (list_element.grantee_principal is not None) else (Option_None())),
        RetiringPrincipal=((Option_Some(list_element.retiring_principal)) if (list_element.retiring_principal is not None) else (Option_None())),
        IssuingAccount=((Option_Some(list_element.issuing_account)) if (list_element.issuing_account is not None) else (Option_None())),
        Operations=((Option_Some(Seq([list_element for list_element in list_element.operations]))) if (list_element.operations is not None) else (Option_None())),
        Constraints=((Option_Some(DafnyGrantConstraints(EncryptionContextSubset=((Option_Some(Map({key: value for (key, value) in list_element.constraints.encryption_context_subset.items() }))) if (list_element.constraints.encryption_context_subset is not None) else (Option_None())),
        EncryptionContextEquals=((Option_Some(Map({key: value for (key, value) in list_element.constraints.encryption_context_equals.items() }))) if (list_element.constraints.encryption_context_equals is not None) else (Option_None())),
        ))) if (list_element.constraints is not None) else (Option_None())),
        ) for list_element in wrapped_response.grants]))) if (wrapped_response.grants is not None) else (Option_None())),
        NextMarker=((Option_Some(wrapped_response.next_marker)) if (wrapped_response.next_marker is not None) else (Option_None())),
        Truncated=((Option_Some(wrapped_response.truncated)) if (wrapped_response.truncated is not None) else (Option_None())),
        ))

    def ListKeyPolicies(self, input: DafnyListKeyPoliciesRequest) -> DafnyListKeyPoliciesResponse:
        unwrapped_request: ListKeyPoliciesRequest = ListKeyPoliciesRequest(key_id=input.KeyId,
        limit=input.Limit.UnwrapOr(None),
        marker=input.Marker.UnwrapOr(None),
        )
        try:
            wrapped_response = asyncio.run(self._impl.list_key_policies(unwrapped_request))
        except ServiceError as e:
            return Wrappers.Result_Failure(smithy_error_to_dafny_error(e))

        return Wrappers.Result_Success(DafnyListKeyPoliciesResponse(PolicyNames=((Option_Some(Seq([list_element for list_element in wrapped_response.policy_names]))) if (wrapped_response.policy_names is not None) else (Option_None())),
        NextMarker=((Option_Some(wrapped_response.next_marker)) if (wrapped_response.next_marker is not None) else (Option_None())),
        Truncated=((Option_Some(wrapped_response.truncated)) if (wrapped_response.truncated is not None) else (Option_None())),
        ))

    def ListResourceTags(self, input: DafnyListResourceTagsRequest) -> DafnyListResourceTagsResponse:
        unwrapped_request: ListResourceTagsRequest = ListResourceTagsRequest(key_id=input.KeyId,
        limit=input.Limit.UnwrapOr(None),
        marker=input.Marker.UnwrapOr(None),
        )
        try:
            wrapped_response = asyncio.run(self._impl.list_resource_tags(unwrapped_request))
        except ServiceError as e:
            return Wrappers.Result_Failure(smithy_error_to_dafny_error(e))

        return Wrappers.Result_Success(DafnyListResourceTagsResponse(Tags=((Option_Some(Seq([DafnyTag(TagKey=list_element.tag_key,
        TagValue=list_element.tag_value,
        ) for list_element in wrapped_response.tags]))) if (wrapped_response.tags is not None) else (Option_None())),
        NextMarker=((Option_Some(wrapped_response.next_marker)) if (wrapped_response.next_marker is not None) else (Option_None())),
        Truncated=((Option_Some(wrapped_response.truncated)) if (wrapped_response.truncated is not None) else (Option_None())),
        ))

    def PutKeyPolicy(self, input: DafnyPutKeyPolicyRequest) -> None:
        unwrapped_request: PutKeyPolicyRequest = PutKeyPolicyRequest(key_id=input.KeyId,
        policy_name=input.PolicyName,
        policy=input.Policy,
        bypass_policy_lockout_safety_check=input.BypassPolicyLockoutSafetyCheck.UnwrapOr(None),
        )
        try:
            wrapped_response = asyncio.run(self._impl.put_key_policy(unwrapped_request))
        except ServiceError as e:
            return Wrappers.Result_Failure(smithy_error_to_dafny_error(e))

        return Wrappers.Result_Success(None)

    def ReEncrypt(self, input: DafnyReEncryptRequest) -> DafnyReEncryptResponse:
        unwrapped_request: ReEncryptRequest = ReEncryptRequest(ciphertext_blob=input.CiphertextBlob,
        source_encryption_context={key: value for (key, value) in input.SourceEncryptionContext.UnwrapOr(None).items },
        source_key_id=input.SourceKeyId.UnwrapOr(None),
        destination_key_id=input.DestinationKeyId,
        destination_encryption_context={key: value for (key, value) in input.DestinationEncryptionContext.UnwrapOr(None).items },
        source_encryption_algorithm=input.SourceEncryptionAlgorithm.UnwrapOr(None),
        destination_encryption_algorithm=input.DestinationEncryptionAlgorithm.UnwrapOr(None),
        grant_tokens=[list_element for list_element in input.GrantTokens.UnwrapOr(None)],
        )
        try:
            wrapped_response = asyncio.run(self._impl.re_encrypt(unwrapped_request))
        except ServiceError as e:
            return Wrappers.Result_Failure(smithy_error_to_dafny_error(e))

        return Wrappers.Result_Success(DafnyReEncryptResponse(CiphertextBlob=((Option_Some(wrapped_response.ciphertext_blob)) if (wrapped_response.ciphertext_blob is not None) else (Option_None())),
        SourceKeyId=((Option_Some(wrapped_response.source_key_id)) if (wrapped_response.source_key_id is not None) else (Option_None())),
        KeyId=((Option_Some(wrapped_response.key_id)) if (wrapped_response.key_id is not None) else (Option_None())),
        SourceEncryptionAlgorithm=((Option_Some(wrapped_response.source_encryption_algorithm)) if (wrapped_response.source_encryption_algorithm is not None) else (Option_None())),
        DestinationEncryptionAlgorithm=((Option_Some(wrapped_response.destination_encryption_algorithm)) if (wrapped_response.destination_encryption_algorithm is not None) else (Option_None())),
        ))

    def ReplicateKey(self, input: DafnyReplicateKeyRequest) -> DafnyReplicateKeyResponse:
        unwrapped_request: ReplicateKeyRequest = ReplicateKeyRequest(key_id=input.KeyId,
        replica_region=input.ReplicaRegion,
        policy=input.Policy.UnwrapOr(None),
        bypass_policy_lockout_safety_check=input.BypassPolicyLockoutSafetyCheck.UnwrapOr(None),
        description=input.Description.UnwrapOr(None),
        tags=[Tag(tag_key=list_element.TagKey,
        tag_value=list_element.TagValue,
        ) for list_element in input.Tags.UnwrapOr(None)],
        )
        try:
            wrapped_response = asyncio.run(self._impl.replicate_key(unwrapped_request))
        except ServiceError as e:
            return Wrappers.Result_Failure(smithy_error_to_dafny_error(e))

        return Wrappers.Result_Success(DafnyReplicateKeyResponse(ReplicaKeyMetadata=((Option_Some(DafnyKeyMetadata(AWSAccountId=((Option_Some(wrapped_response.replica_key_metadata.aws_account_id)) if (wrapped_response.replica_key_metadata.aws_account_id is not None) else (Option_None())),
        KeyId=wrapped_response.replica_key_metadata.key_id,
        Arn=((Option_Some(wrapped_response.replica_key_metadata.arn)) if (wrapped_response.replica_key_metadata.arn is not None) else (Option_None())),
        CreationDate=((Option_Some(wrapped_response.replica_key_metadata.creation_date)) if (wrapped_response.replica_key_metadata.creation_date is not None) else (Option_None())),
        Enabled=((Option_Some(wrapped_response.replica_key_metadata.enabled)) if (wrapped_response.replica_key_metadata.enabled is not None) else (Option_None())),
        Description=((Option_Some(wrapped_response.replica_key_metadata.description)) if (wrapped_response.replica_key_metadata.description is not None) else (Option_None())),
        KeyUsage=((Option_Some(wrapped_response.replica_key_metadata.key_usage)) if (wrapped_response.replica_key_metadata.key_usage is not None) else (Option_None())),
        KeyState=((Option_Some(wrapped_response.replica_key_metadata.key_state)) if (wrapped_response.replica_key_metadata.key_state is not None) else (Option_None())),
        DeletionDate=((Option_Some(wrapped_response.replica_key_metadata.deletion_date)) if (wrapped_response.replica_key_metadata.deletion_date is not None) else (Option_None())),
        ValidTo=((Option_Some(wrapped_response.replica_key_metadata.valid_to)) if (wrapped_response.replica_key_metadata.valid_to is not None) else (Option_None())),
        Origin=((Option_Some(wrapped_response.replica_key_metadata.origin)) if (wrapped_response.replica_key_metadata.origin is not None) else (Option_None())),
        CustomKeyStoreId=((Option_Some(wrapped_response.replica_key_metadata.custom_key_store_id)) if (wrapped_response.replica_key_metadata.custom_key_store_id is not None) else (Option_None())),
        CloudHsmClusterId=((Option_Some(wrapped_response.replica_key_metadata.cloud_hsm_cluster_id)) if (wrapped_response.replica_key_metadata.cloud_hsm_cluster_id is not None) else (Option_None())),
        ExpirationModel=((Option_Some(wrapped_response.replica_key_metadata.expiration_model)) if (wrapped_response.replica_key_metadata.expiration_model is not None) else (Option_None())),
        KeyManager=((Option_Some(wrapped_response.replica_key_metadata.key_manager)) if (wrapped_response.replica_key_metadata.key_manager is not None) else (Option_None())),
        CustomerMasterKeySpec=((Option_Some(wrapped_response.replica_key_metadata.customer_master_key_spec)) if (wrapped_response.replica_key_metadata.customer_master_key_spec is not None) else (Option_None())),
        KeySpec=((Option_Some(wrapped_response.replica_key_metadata.key_spec)) if (wrapped_response.replica_key_metadata.key_spec is not None) else (Option_None())),
        EncryptionAlgorithms=((Option_Some(Seq([list_element for list_element in wrapped_response.replica_key_metadata.encryption_algorithms]))) if (wrapped_response.replica_key_metadata.encryption_algorithms is not None) else (Option_None())),
        SigningAlgorithms=((Option_Some(Seq([list_element for list_element in wrapped_response.replica_key_metadata.signing_algorithms]))) if (wrapped_response.replica_key_metadata.signing_algorithms is not None) else (Option_None())),
        MultiRegion=((Option_Some(wrapped_response.replica_key_metadata.multi_region)) if (wrapped_response.replica_key_metadata.multi_region is not None) else (Option_None())),
        MultiRegionConfiguration=((Option_Some(DafnyMultiRegionConfiguration(MultiRegionKeyType=((Option_Some(wrapped_response.replica_key_metadata.multi_region_configuration.multi_region_key_type)) if (wrapped_response.replica_key_metadata.multi_region_configuration.multi_region_key_type is not None) else (Option_None())),
        PrimaryKey=((Option_Some(DafnyMultiRegionKey(Arn=((Option_Some(wrapped_response.replica_key_metadata.multi_region_configuration.primary_key.arn)) if (wrapped_response.replica_key_metadata.multi_region_configuration.primary_key.arn is not None) else (Option_None())),
        Region=((Option_Some(wrapped_response.replica_key_metadata.multi_region_configuration.primary_key.region)) if (wrapped_response.replica_key_metadata.multi_region_configuration.primary_key.region is not None) else (Option_None())),
        ))) if (wrapped_response.replica_key_metadata.multi_region_configuration.primary_key is not None) else (Option_None())),
        ReplicaKeys=((Option_Some(Seq([DafnyMultiRegionKey(Arn=((Option_Some(list_element.arn)) if (list_element.arn is not None) else (Option_None())),
        Region=((Option_Some(list_element.region)) if (list_element.region is not None) else (Option_None())),
        ) for list_element in wrapped_response.replica_key_metadata.multi_region_configuration.replica_keys]))) if (wrapped_response.replica_key_metadata.multi_region_configuration.replica_keys is not None) else (Option_None())),
        ))) if (wrapped_response.replica_key_metadata.multi_region_configuration is not None) else (Option_None())),
        PendingDeletionWindowInDays=((Option_Some(wrapped_response.replica_key_metadata.pending_deletion_window_in_days)) if (wrapped_response.replica_key_metadata.pending_deletion_window_in_days is not None) else (Option_None())),
        ))) if (wrapped_response.replica_key_metadata is not None) else (Option_None())),
        ReplicaPolicy=((Option_Some(wrapped_response.replica_policy)) if (wrapped_response.replica_policy is not None) else (Option_None())),
        ReplicaTags=((Option_Some(Seq([DafnyTag(TagKey=list_element.tag_key,
        TagValue=list_element.tag_value,
        ) for list_element in wrapped_response.replica_tags]))) if (wrapped_response.replica_tags is not None) else (Option_None())),
        ))

    def RetireGrant(self, input: DafnyRetireGrantRequest) -> None:
        unwrapped_request: RetireGrantRequest = RetireGrantRequest(grant_token=input.GrantToken.UnwrapOr(None),
        key_id=input.KeyId.UnwrapOr(None),
        grant_id=input.GrantId.UnwrapOr(None),
        )
        try:
            wrapped_response = asyncio.run(self._impl.retire_grant(unwrapped_request))
        except ServiceError as e:
            return Wrappers.Result_Failure(smithy_error_to_dafny_error(e))

        return Wrappers.Result_Success(None)

    def RevokeGrant(self, input: DafnyRevokeGrantRequest) -> None:
        unwrapped_request: RevokeGrantRequest = RevokeGrantRequest(key_id=input.KeyId,
        grant_id=input.GrantId,
        )
        try:
            wrapped_response = asyncio.run(self._impl.revoke_grant(unwrapped_request))
        except ServiceError as e:
            return Wrappers.Result_Failure(smithy_error_to_dafny_error(e))

        return Wrappers.Result_Success(None)

    def ScheduleKeyDeletion(self, input: DafnyScheduleKeyDeletionRequest) -> DafnyScheduleKeyDeletionResponse:
        unwrapped_request: ScheduleKeyDeletionRequest = ScheduleKeyDeletionRequest(key_id=input.KeyId,
        pending_window_in_days=input.PendingWindowInDays.UnwrapOr(None),
        )
        try:
            wrapped_response = asyncio.run(self._impl.schedule_key_deletion(unwrapped_request))
        except ServiceError as e:
            return Wrappers.Result_Failure(smithy_error_to_dafny_error(e))

        return Wrappers.Result_Success(DafnyScheduleKeyDeletionResponse(KeyId=((Option_Some(wrapped_response.key_id)) if (wrapped_response.key_id is not None) else (Option_None())),
        DeletionDate=((Option_Some(wrapped_response.deletion_date)) if (wrapped_response.deletion_date is not None) else (Option_None())),
        KeyState=((Option_Some(wrapped_response.key_state)) if (wrapped_response.key_state is not None) else (Option_None())),
        PendingWindowInDays=((Option_Some(wrapped_response.pending_window_in_days)) if (wrapped_response.pending_window_in_days is not None) else (Option_None())),
        ))

    def Sign(self, input: DafnySignRequest) -> DafnySignResponse:
        unwrapped_request: SignRequest = SignRequest(key_id=input.KeyId,
        message=input.Message,
        message_type=input.MessageType.UnwrapOr(None),
        grant_tokens=[list_element for list_element in input.GrantTokens.UnwrapOr(None)],
        signing_algorithm=input.SigningAlgorithm,
        )
        try:
            wrapped_response = asyncio.run(self._impl.sign(unwrapped_request))
        except ServiceError as e:
            return Wrappers.Result_Failure(smithy_error_to_dafny_error(e))

        return Wrappers.Result_Success(DafnySignResponse(KeyId=((Option_Some(wrapped_response.key_id)) if (wrapped_response.key_id is not None) else (Option_None())),
        Signature=((Option_Some(wrapped_response.signature)) if (wrapped_response.signature is not None) else (Option_None())),
        SigningAlgorithm=((Option_Some(wrapped_response.signing_algorithm)) if (wrapped_response.signing_algorithm is not None) else (Option_None())),
        ))

    def TagResource(self, input: DafnyTagResourceRequest) -> None:
        unwrapped_request: TagResourceRequest = TagResourceRequest(key_id=input.KeyId,
        tags=[Tag(tag_key=list_element.TagKey,
        tag_value=list_element.TagValue,
        ) for list_element in input.Tags],
        )
        try:
            wrapped_response = asyncio.run(self._impl.tag_resource(unwrapped_request))
        except ServiceError as e:
            return Wrappers.Result_Failure(smithy_error_to_dafny_error(e))

        return Wrappers.Result_Success(None)

    def UntagResource(self, input: DafnyUntagResourceRequest) -> None:
        unwrapped_request: UntagResourceRequest = UntagResourceRequest(key_id=input.KeyId,
        tag_keys=[list_element for list_element in input.TagKeys],
        )
        try:
            wrapped_response = asyncio.run(self._impl.untag_resource(unwrapped_request))
        except ServiceError as e:
            return Wrappers.Result_Failure(smithy_error_to_dafny_error(e))

        return Wrappers.Result_Success(None)

    def UpdateAlias(self, input: DafnyUpdateAliasRequest) -> None:
        unwrapped_request: UpdateAliasRequest = UpdateAliasRequest(alias_name=input.AliasName,
        target_key_id=input.TargetKeyId,
        )
        try:
            wrapped_response = asyncio.run(self._impl.update_alias(unwrapped_request))
        except ServiceError as e:
            return Wrappers.Result_Failure(smithy_error_to_dafny_error(e))

        return Wrappers.Result_Success(None)

    def UpdateCustomKeyStore(self, input: DafnyUpdateCustomKeyStoreRequest) -> DafnyUpdateCustomKeyStoreResponse:
        unwrapped_request: UpdateCustomKeyStoreRequest = UpdateCustomKeyStoreRequest(custom_key_store_id=input.CustomKeyStoreId,
        new_custom_key_store_name=input.NewCustomKeyStoreName.UnwrapOr(None),
        key_store_password=input.KeyStorePassword.UnwrapOr(None),
        cloud_hsm_cluster_id=input.CloudHsmClusterId.UnwrapOr(None),
        )
        try:
            wrapped_response = asyncio.run(self._impl.update_custom_key_store(unwrapped_request))
        except ServiceError as e:
            return Wrappers.Result_Failure(smithy_error_to_dafny_error(e))

        return Wrappers.Result_Success(DafnyUpdateCustomKeyStoreResponse())

    def UpdateKeyDescription(self, input: DafnyUpdateKeyDescriptionRequest) -> None:
        unwrapped_request: UpdateKeyDescriptionRequest = UpdateKeyDescriptionRequest(key_id=input.KeyId,
        description=input.Description,
        )
        try:
            wrapped_response = asyncio.run(self._impl.update_key_description(unwrapped_request))
        except ServiceError as e:
            return Wrappers.Result_Failure(smithy_error_to_dafny_error(e))

        return Wrappers.Result_Success(None)

    def UpdatePrimaryRegion(self, input: DafnyUpdatePrimaryRegionRequest) -> None:
        unwrapped_request: UpdatePrimaryRegionRequest = UpdatePrimaryRegionRequest(key_id=input.KeyId,
        primary_region=input.PrimaryRegion,
        )
        try:
            wrapped_response = asyncio.run(self._impl.update_primary_region(unwrapped_request))
        except ServiceError as e:
            return Wrappers.Result_Failure(smithy_error_to_dafny_error(e))

        return Wrappers.Result_Success(None)

    def Verify(self, input: DafnyVerifyRequest) -> DafnyVerifyResponse:
        unwrapped_request: VerifyRequest = VerifyRequest(key_id=input.KeyId,
        message=input.Message,
        message_type=input.MessageType.UnwrapOr(None),
        signature=input.Signature,
        signing_algorithm=input.SigningAlgorithm,
        grant_tokens=[list_element for list_element in input.GrantTokens.UnwrapOr(None)],
        )
        try:
            wrapped_response = asyncio.run(self._impl.verify(unwrapped_request))
        except ServiceError as e:
            return Wrappers.Result_Failure(smithy_error_to_dafny_error(e))

        return Wrappers.Result_Success(DafnyVerifyResponse(KeyId=((Option_Some(wrapped_response.key_id)) if (wrapped_response.key_id is not None) else (Option_None())),
        SignatureValid=((Option_Some(wrapped_response.signature_valid)) if (wrapped_response.signature_valid is not None) else (Option_None())),
        SigningAlgorithm=((Option_Some(wrapped_response.signing_algorithm)) if (wrapped_response.signing_algorithm is not None) else (Option_None())),
        ))
