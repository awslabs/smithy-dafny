# Code generated by smithy-python-codegen DO NOT EDIT.

from datetime import datetime
from typing import Any, Dict, List, Optional, Union


class ArchivalSummary:
    archival_date_time: Optional[datetime]
    archival_reason: Optional[str]
    archival_backup_arn: Optional[str]
    def __init__(
        self,
        *,
        archival_date_time: Optional[datetime] = None,
        archival_reason: Optional[str] = None,
        archival_backup_arn: Optional[str] = None,
    ):
        """<p>Contains details of a table archival operation.</p>

        :param archival_date_time: <p>The date and time when table archival was
        initiated by DynamoDB, in UNIX epoch time
                    format.</p>
        :param archival_reason: <p>The reason DynamoDB archived the table. Currently,
        the only possible value is:</p>

                <ul>
                    <li>

        <p>
                          <code>INACCESSIBLE_ENCRYPTION_CREDENTIALS</code> - The
        table was archived due
                            to the table's KMS key being
        inaccessible for more than seven
                            days. An On-Demand backup
        was created at the archival time.</p>
                    </li>
                 </ul>
        :param archival_backup_arn: <p>The Amazon Resource Name (ARN) of the backup the
        table was archived to, when
                    applicable in the archival reason. If
        you wish to restore this backup to the same table
                    name, you will
        need to delete the original table.</p>
        """
        self.archival_date_time = archival_date_time
        self.archival_reason = archival_reason
        self.archival_backup_arn = archival_backup_arn

    def as_dict(self) -> Dict[str, Any]:
        """Converts the ArchivalSummary to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        d: Dict[str, Any] = {}

        if self.archival_date_time is not None:
            d["ArchivalDateTime"] = self.archival_date_time

        if self.archival_reason is not None:
            d["ArchivalReason"] = self.archival_reason

        if self.archival_backup_arn is not None:
            d["ArchivalBackupArn"] = self.archival_backup_arn

        return d

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "ArchivalSummary":
        """Creates a ArchivalSummary from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {}

        if "ArchivalDateTime" in d:
            kwargs["archival_date_time"] = d["ArchivalDateTime"]

        if "ArchivalReason" in d:
            kwargs["archival_reason"] = d["ArchivalReason"]

        if "ArchivalBackupArn" in d:
            kwargs["archival_backup_arn"] = d["ArchivalBackupArn"]

        return ArchivalSummary(**kwargs)

    def __repr__(self) -> str:
        result = "ArchivalSummary("
        if self.archival_date_time is not None:
            result += f"archival_date_time={repr(self.archival_date_time)}, "

        if self.archival_reason is not None:
            result += f"archival_reason={repr(self.archival_reason)}, "

        if self.archival_backup_arn is not None:
            result += f"archival_backup_arn={repr(self.archival_backup_arn)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, ArchivalSummary):
            return False
        attributes: list[str] = ['archival_date_time','archival_reason','archival_backup_arn',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class AttributeDefinition:
    attribute_name: str
    attribute_type: str
    def __init__(
        self,
        *,
        attribute_name: str,
        attribute_type: str,
    ):
        """<p>Represents an attribute for describing the key schema for the table and

        indexes.</p>

        :param attribute_name: <p>A name for the attribute.</p>
        :param attribute_type: <p>The data type for the attribute, where:</p>

        <ul>
                    <li>
                        <p>
                            <code>S</code> -
        the attribute is of type String</p>
                    </li>
                    <li>

        <p>
                            <code>N</code> - the attribute is of type Number</p>

        </li>
                    <li>
                        <p>
                            <code>B</code> -
        the attribute is of type Binary</p>
                    </li>
                 </ul>
        """
        self.attribute_name = attribute_name
        self.attribute_type = attribute_type

    def as_dict(self) -> Dict[str, Any]:
        """Converts the AttributeDefinition to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        return {
            "AttributeName": self.attribute_name,
            "AttributeType": self.attribute_type,
        }

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "AttributeDefinition":
        """Creates a AttributeDefinition from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {
            "attribute_name": d["AttributeName"],
            "attribute_type": d["AttributeType"],
        }

        return AttributeDefinition(**kwargs)

    def __repr__(self) -> str:
        result = "AttributeDefinition("
        if self.attribute_name is not None:
            result += f"attribute_name={repr(self.attribute_name)}, "

        if self.attribute_type is not None:
            result += f"attribute_type={repr(self.attribute_type)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, AttributeDefinition):
            return False
        attributes: list[str] = ['attribute_name','attribute_type',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class AutoScalingTargetTrackingScalingPolicyConfigurationDescription:
    disable_scale_in: Optional[bool]
    scale_in_cooldown: Optional[int]
    scale_out_cooldown: Optional[int]
    target_value: float
    def __init__(
        self,
        *,
        target_value: float,
        disable_scale_in: Optional[bool] = None,
        scale_in_cooldown: Optional[int] = None,
        scale_out_cooldown: Optional[int] = None,
    ):
        """<p>Represents the properties of a target tracking scaling policy.</p>

        :param target_value: <p>The target value for the metric. The range is
        8.515920e-109 to 1.174271e+108 (Base 10)
                    or 2e-360 to 2e360 (Base
        2).</p>
        :param disable_scale_in: <p>Indicates whether scale in by the target tracking
        policy is disabled. If the value is
                    true, scale in is disabled and
        the target tracking policy won't remove capacity from the
                    scalable
        resource. Otherwise, scale in is enabled and the target tracking policy can

        remove capacity from the scalable resource. The default value is false.</p>
        :param scale_in_cooldown: <p>The amount of time, in seconds, after a scale in
        activity completes before another
                    scale in activity can start. The
        cooldown period is used to block subsequent scale in
                    requests until
        it has expired. You should scale in conservatively to protect your

        application's availability. However, if another alarm triggers a scale out
        policy during
                    the cooldown period after a scale-in, application auto
        scaling scales out your scalable
                    target immediately. </p>
        :param scale_out_cooldown: <p>The amount of time, in seconds, after a scale out
        activity completes before another
                    scale out activity can start.
        While the cooldown period is in effect, the capacity that
                    has been
        added by the previous scale out event that initiated the cooldown is calculated

        as part of the desired capacity for the next scale out. You should continuously
        (but not
                    excessively) scale out.</p>
        """
        self.target_value = target_value
        self.disable_scale_in = disable_scale_in
        self.scale_in_cooldown = scale_in_cooldown
        self.scale_out_cooldown = scale_out_cooldown

    def as_dict(self) -> Dict[str, Any]:
        """Converts the AutoScalingTargetTrackingScalingPolicyConfigurationDescription to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        d: Dict[str, Any] = {
            "TargetValue": self.target_value,
        }

        if self.disable_scale_in is not None:
            d["DisableScaleIn"] = self.disable_scale_in

        if self.scale_in_cooldown is not None:
            d["ScaleInCooldown"] = self.scale_in_cooldown

        if self.scale_out_cooldown is not None:
            d["ScaleOutCooldown"] = self.scale_out_cooldown

        return d

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "AutoScalingTargetTrackingScalingPolicyConfigurationDescription":
        """Creates a AutoScalingTargetTrackingScalingPolicyConfigurationDescription from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {
            "target_value": d["TargetValue"],
        }

        if "DisableScaleIn" in d:
            kwargs["disable_scale_in"] = d["DisableScaleIn"]

        if "ScaleInCooldown" in d:
            kwargs["scale_in_cooldown"] = d["ScaleInCooldown"]

        if "ScaleOutCooldown" in d:
            kwargs["scale_out_cooldown"] = d["ScaleOutCooldown"]

        return AutoScalingTargetTrackingScalingPolicyConfigurationDescription(**kwargs)

    def __repr__(self) -> str:
        result = "AutoScalingTargetTrackingScalingPolicyConfigurationDescription("
        if self.disable_scale_in is not None:
            result += f"disable_scale_in={repr(self.disable_scale_in)}, "

        if self.scale_in_cooldown is not None:
            result += f"scale_in_cooldown={repr(self.scale_in_cooldown)}, "

        if self.scale_out_cooldown is not None:
            result += f"scale_out_cooldown={repr(self.scale_out_cooldown)}, "

        if self.target_value is not None:
            result += f"target_value={repr(self.target_value)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, AutoScalingTargetTrackingScalingPolicyConfigurationDescription):
            return False
        attributes: list[str] = ['disable_scale_in','scale_in_cooldown','scale_out_cooldown','target_value',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class AutoScalingPolicyDescription:
    policy_name: Optional[str]
    target_tracking_scaling_policy_configuration: Optional[AutoScalingTargetTrackingScalingPolicyConfigurationDescription]
    def __init__(
        self,
        *,
        policy_name: Optional[str] = None,
        target_tracking_scaling_policy_configuration: Optional[AutoScalingTargetTrackingScalingPolicyConfigurationDescription] = None,
    ):
        """<p>Represents the properties of the scaling policy.</p>

        :param policy_name: <p>The name of the scaling policy.</p>
        :param target_tracking_scaling_policy_configuration: <p>Represents a target
        tracking scaling policy configuration.</p>
        """
        self.policy_name = policy_name
        self.target_tracking_scaling_policy_configuration = target_tracking_scaling_policy_configuration

    def as_dict(self) -> Dict[str, Any]:
        """Converts the AutoScalingPolicyDescription to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        d: Dict[str, Any] = {}

        if self.policy_name is not None:
            d["PolicyName"] = self.policy_name

        if self.target_tracking_scaling_policy_configuration is not None:
            d["TargetTrackingScalingPolicyConfiguration"] = self.target_tracking_scaling_policy_configuration.as_dict()

        return d

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "AutoScalingPolicyDescription":
        """Creates a AutoScalingPolicyDescription from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {}

        if "PolicyName" in d:
            kwargs["policy_name"] = d["PolicyName"]

        if "TargetTrackingScalingPolicyConfiguration" in d:
            kwargs["target_tracking_scaling_policy_configuration"] = AutoScalingTargetTrackingScalingPolicyConfigurationDescription.from_dict(d["TargetTrackingScalingPolicyConfiguration"])

        return AutoScalingPolicyDescription(**kwargs)

    def __repr__(self) -> str:
        result = "AutoScalingPolicyDescription("
        if self.policy_name is not None:
            result += f"policy_name={repr(self.policy_name)}, "

        if self.target_tracking_scaling_policy_configuration is not None:
            result += f"target_tracking_scaling_policy_configuration={repr(self.target_tracking_scaling_policy_configuration)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, AutoScalingPolicyDescription):
            return False
        attributes: list[str] = ['policy_name','target_tracking_scaling_policy_configuration',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class AutoScalingTargetTrackingScalingPolicyConfigurationUpdate:
    disable_scale_in: Optional[bool]
    scale_in_cooldown: Optional[int]
    scale_out_cooldown: Optional[int]
    target_value: float
    def __init__(
        self,
        *,
        target_value: float,
        disable_scale_in: Optional[bool] = None,
        scale_in_cooldown: Optional[int] = None,
        scale_out_cooldown: Optional[int] = None,
    ):
        """<p>Represents the settings of a target tracking scaling policy that will be

        modified.</p>

        :param target_value: <p>The target value for the metric. The range is
        8.515920e-109 to 1.174271e+108 (Base 10)
                    or 2e-360 to 2e360 (Base
        2).</p>
        :param disable_scale_in: <p>Indicates whether scale in by the target tracking
        policy is disabled. If the value is
                    true, scale in is disabled and
        the target tracking policy won't remove capacity from the
                    scalable
        resource. Otherwise, scale in is enabled and the target tracking policy can

        remove capacity from the scalable resource. The default value is false.</p>
        :param scale_in_cooldown: <p>The amount of time, in seconds, after a scale in
        activity completes before another
                    scale in activity can start. The
        cooldown period is used to block subsequent scale in
                    requests until
        it has expired. You should scale in conservatively to protect your

        application's availability. However, if another alarm triggers a scale out
        policy during
                    the cooldown period after a scale-in, application auto
        scaling scales out your scalable
                    target immediately. </p>
        :param scale_out_cooldown: <p>The amount of time, in seconds, after a scale out
        activity completes before another
                    scale out activity can start.
        While the cooldown period is in effect, the capacity that
                    has been
        added by the previous scale out event that initiated the cooldown is calculated

        as part of the desired capacity for the next scale out. You should continuously
        (but not
                    excessively) scale out.</p>
        """
        self.target_value = target_value
        self.disable_scale_in = disable_scale_in
        self.scale_in_cooldown = scale_in_cooldown
        self.scale_out_cooldown = scale_out_cooldown

    def as_dict(self) -> Dict[str, Any]:
        """Converts the AutoScalingTargetTrackingScalingPolicyConfigurationUpdate to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        d: Dict[str, Any] = {
            "TargetValue": self.target_value,
        }

        if self.disable_scale_in is not None:
            d["DisableScaleIn"] = self.disable_scale_in

        if self.scale_in_cooldown is not None:
            d["ScaleInCooldown"] = self.scale_in_cooldown

        if self.scale_out_cooldown is not None:
            d["ScaleOutCooldown"] = self.scale_out_cooldown

        return d

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "AutoScalingTargetTrackingScalingPolicyConfigurationUpdate":
        """Creates a AutoScalingTargetTrackingScalingPolicyConfigurationUpdate from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {
            "target_value": d["TargetValue"],
        }

        if "DisableScaleIn" in d:
            kwargs["disable_scale_in"] = d["DisableScaleIn"]

        if "ScaleInCooldown" in d:
            kwargs["scale_in_cooldown"] = d["ScaleInCooldown"]

        if "ScaleOutCooldown" in d:
            kwargs["scale_out_cooldown"] = d["ScaleOutCooldown"]

        return AutoScalingTargetTrackingScalingPolicyConfigurationUpdate(**kwargs)

    def __repr__(self) -> str:
        result = "AutoScalingTargetTrackingScalingPolicyConfigurationUpdate("
        if self.disable_scale_in is not None:
            result += f"disable_scale_in={repr(self.disable_scale_in)}, "

        if self.scale_in_cooldown is not None:
            result += f"scale_in_cooldown={repr(self.scale_in_cooldown)}, "

        if self.scale_out_cooldown is not None:
            result += f"scale_out_cooldown={repr(self.scale_out_cooldown)}, "

        if self.target_value is not None:
            result += f"target_value={repr(self.target_value)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, AutoScalingTargetTrackingScalingPolicyConfigurationUpdate):
            return False
        attributes: list[str] = ['disable_scale_in','scale_in_cooldown','scale_out_cooldown','target_value',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class AutoScalingPolicyUpdate:
    policy_name: Optional[str]
    target_tracking_scaling_policy_configuration: AutoScalingTargetTrackingScalingPolicyConfigurationUpdate
    def __init__(
        self,
        *,
        target_tracking_scaling_policy_configuration: AutoScalingTargetTrackingScalingPolicyConfigurationUpdate,
        policy_name: Optional[str] = None,
    ):
        """<p>Represents the auto scaling policy to be modified.</p>

        :param target_tracking_scaling_policy_configuration: <p>Represents a target
        tracking scaling policy configuration.</p>
        :param policy_name: <p>The name of the scaling policy.</p>
        """
        self.target_tracking_scaling_policy_configuration = target_tracking_scaling_policy_configuration
        self.policy_name = policy_name

    def as_dict(self) -> Dict[str, Any]:
        """Converts the AutoScalingPolicyUpdate to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        d: Dict[str, Any] = {
            "TargetTrackingScalingPolicyConfiguration": self.target_tracking_scaling_policy_configuration.as_dict(),
        }

        if self.policy_name is not None:
            d["PolicyName"] = self.policy_name

        return d

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "AutoScalingPolicyUpdate":
        """Creates a AutoScalingPolicyUpdate from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {
            "target_tracking_scaling_policy_configuration": AutoScalingTargetTrackingScalingPolicyConfigurationUpdate.from_dict(d["TargetTrackingScalingPolicyConfiguration"]),
        }

        if "PolicyName" in d:
            kwargs["policy_name"] = d["PolicyName"]

        return AutoScalingPolicyUpdate(**kwargs)

    def __repr__(self) -> str:
        result = "AutoScalingPolicyUpdate("
        if self.policy_name is not None:
            result += f"policy_name={repr(self.policy_name)}, "

        if self.target_tracking_scaling_policy_configuration is not None:
            result += f"target_tracking_scaling_policy_configuration={repr(self.target_tracking_scaling_policy_configuration)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, AutoScalingPolicyUpdate):
            return False
        attributes: list[str] = ['policy_name','target_tracking_scaling_policy_configuration',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class AutoScalingSettingsDescription:
    minimum_units: Optional[int]
    maximum_units: Optional[int]
    auto_scaling_disabled: Optional[bool]
    auto_scaling_role_arn: Optional[str]
    scaling_policies: Optional[list[AutoScalingPolicyDescription]]
    def __init__(
        self,
        *,
        minimum_units: Optional[int] = None,
        maximum_units: Optional[int] = None,
        auto_scaling_disabled: Optional[bool] = None,
        auto_scaling_role_arn: Optional[str] = None,
        scaling_policies: Optional[list[AutoScalingPolicyDescription]] = None,
    ):
        """<p>Represents the auto scaling settings for a global table or global secondary

        index.</p>

        :param minimum_units: <p>The minimum capacity units that a global table or
        global secondary index should be
                    scaled down to.</p>
        :param maximum_units: <p>The maximum capacity units that a global table or
        global secondary index should be
                    scaled up to.</p>
        :param auto_scaling_disabled: <p>Disabled auto scaling for this global table or
        global secondary index.</p>
        :param auto_scaling_role_arn: <p>Role ARN used for configuring the auto scaling
        policy.</p>
        :param scaling_policies: <p>Information about the scaling policies.</p>
        """
        self.minimum_units = minimum_units
        self.maximum_units = maximum_units
        self.auto_scaling_disabled = auto_scaling_disabled
        self.auto_scaling_role_arn = auto_scaling_role_arn
        self.scaling_policies = scaling_policies

    def as_dict(self) -> Dict[str, Any]:
        """Converts the AutoScalingSettingsDescription to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        d: Dict[str, Any] = {}

        if self.minimum_units is not None:
            d["MinimumUnits"] = self.minimum_units

        if self.maximum_units is not None:
            d["MaximumUnits"] = self.maximum_units

        if self.auto_scaling_disabled is not None:
            d["AutoScalingDisabled"] = self.auto_scaling_disabled

        if self.auto_scaling_role_arn is not None:
            d["AutoScalingRoleArn"] = self.auto_scaling_role_arn

        if self.scaling_policies is not None:
            d["ScalingPolicies"] = _auto_scaling_policy_description_list_as_dict(self.scaling_policies),

        return d

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "AutoScalingSettingsDescription":
        """Creates a AutoScalingSettingsDescription from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {}

        if "MinimumUnits" in d:
            kwargs["minimum_units"] = d["MinimumUnits"]

        if "MaximumUnits" in d:
            kwargs["maximum_units"] = d["MaximumUnits"]

        if "AutoScalingDisabled" in d:
            kwargs["auto_scaling_disabled"] = d["AutoScalingDisabled"]

        if "AutoScalingRoleArn" in d:
            kwargs["auto_scaling_role_arn"] = d["AutoScalingRoleArn"]

        if "ScalingPolicies" in d:
            kwargs["scaling_policies"] = _auto_scaling_policy_description_list_from_dict(d["ScalingPolicies"]),

        return AutoScalingSettingsDescription(**kwargs)

    def __repr__(self) -> str:
        result = "AutoScalingSettingsDescription("
        if self.minimum_units is not None:
            result += f"minimum_units={repr(self.minimum_units)}, "

        if self.maximum_units is not None:
            result += f"maximum_units={repr(self.maximum_units)}, "

        if self.auto_scaling_disabled is not None:
            result += f"auto_scaling_disabled={repr(self.auto_scaling_disabled)}, "

        if self.auto_scaling_role_arn is not None:
            result += f"auto_scaling_role_arn={repr(self.auto_scaling_role_arn)}, "

        if self.scaling_policies is not None:
            result += f"scaling_policies={repr(self.scaling_policies)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, AutoScalingSettingsDescription):
            return False
        attributes: list[str] = ['minimum_units','maximum_units','auto_scaling_disabled','auto_scaling_role_arn','scaling_policies',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class AutoScalingSettingsUpdate:
    minimum_units: Optional[int]
    maximum_units: Optional[int]
    auto_scaling_disabled: Optional[bool]
    auto_scaling_role_arn: Optional[str]
    scaling_policy_update: Optional[AutoScalingPolicyUpdate]
    def __init__(
        self,
        *,
        minimum_units: Optional[int] = None,
        maximum_units: Optional[int] = None,
        auto_scaling_disabled: Optional[bool] = None,
        auto_scaling_role_arn: Optional[str] = None,
        scaling_policy_update: Optional[AutoScalingPolicyUpdate] = None,
    ):
        """<p>Represents the auto scaling settings to be modified for a global table or
        global
                    secondary index.</p>

        :param minimum_units: <p>The minimum capacity units that a global table or
        global secondary index should be
                    scaled down to.</p>
        :param maximum_units: <p>The maximum capacity units that a global table or
        global secondary index should be
                    scaled up to.</p>
        :param auto_scaling_disabled: <p>Disabled auto scaling for this global table or
        global secondary index.</p>
        :param auto_scaling_role_arn: <p>Role ARN used for configuring auto scaling
        policy.</p>
        :param scaling_policy_update: <p>The scaling policy to apply for scaling target
        global table or global secondary index
                    capacity units.</p>
        """
        self.minimum_units = minimum_units
        self.maximum_units = maximum_units
        self.auto_scaling_disabled = auto_scaling_disabled
        self.auto_scaling_role_arn = auto_scaling_role_arn
        self.scaling_policy_update = scaling_policy_update

    def as_dict(self) -> Dict[str, Any]:
        """Converts the AutoScalingSettingsUpdate to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        d: Dict[str, Any] = {}

        if self.minimum_units is not None:
            d["MinimumUnits"] = self.minimum_units

        if self.maximum_units is not None:
            d["MaximumUnits"] = self.maximum_units

        if self.auto_scaling_disabled is not None:
            d["AutoScalingDisabled"] = self.auto_scaling_disabled

        if self.auto_scaling_role_arn is not None:
            d["AutoScalingRoleArn"] = self.auto_scaling_role_arn

        if self.scaling_policy_update is not None:
            d["ScalingPolicyUpdate"] = self.scaling_policy_update.as_dict()

        return d

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "AutoScalingSettingsUpdate":
        """Creates a AutoScalingSettingsUpdate from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {}

        if "MinimumUnits" in d:
            kwargs["minimum_units"] = d["MinimumUnits"]

        if "MaximumUnits" in d:
            kwargs["maximum_units"] = d["MaximumUnits"]

        if "AutoScalingDisabled" in d:
            kwargs["auto_scaling_disabled"] = d["AutoScalingDisabled"]

        if "AutoScalingRoleArn" in d:
            kwargs["auto_scaling_role_arn"] = d["AutoScalingRoleArn"]

        if "ScalingPolicyUpdate" in d:
            kwargs["scaling_policy_update"] = AutoScalingPolicyUpdate.from_dict(d["ScalingPolicyUpdate"])

        return AutoScalingSettingsUpdate(**kwargs)

    def __repr__(self) -> str:
        result = "AutoScalingSettingsUpdate("
        if self.minimum_units is not None:
            result += f"minimum_units={repr(self.minimum_units)}, "

        if self.maximum_units is not None:
            result += f"maximum_units={repr(self.maximum_units)}, "

        if self.auto_scaling_disabled is not None:
            result += f"auto_scaling_disabled={repr(self.auto_scaling_disabled)}, "

        if self.auto_scaling_role_arn is not None:
            result += f"auto_scaling_role_arn={repr(self.auto_scaling_role_arn)}, "

        if self.scaling_policy_update is not None:
            result += f"scaling_policy_update={repr(self.scaling_policy_update)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, AutoScalingSettingsUpdate):
            return False
        attributes: list[str] = ['minimum_units','maximum_units','auto_scaling_disabled','auto_scaling_role_arn','scaling_policy_update',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class BackupDetails:
    backup_arn: str
    backup_name: str
    backup_size_bytes: Optional[int]
    backup_status: str
    backup_type: str
    backup_creation_date_time: datetime
    backup_expiry_date_time: Optional[datetime]
    def __init__(
        self,
        *,
        backup_arn: str,
        backup_name: str,
        backup_status: str,
        backup_type: str,
        backup_creation_date_time: datetime,
        backup_size_bytes: Optional[int] = None,
        backup_expiry_date_time: Optional[datetime] = None,
    ):
        """<p>Contains the details of the backup created for the table.</p>

        :param backup_arn: <p>ARN associated with the backup.</p>
        :param backup_name: <p>Name of the requested backup.</p>
        :param backup_status: <p>Backup can be in one of the following states: CREATING,
        ACTIVE, DELETED. </p>
        :param backup_type: <p>BackupType:</p>
                <ul>
                    <li>

        <p>
                            <code>USER</code> - You create and manage these using
        the on-demand backup
                            feature.</p>
                    </li>

        <li>
                        <p>
                            <code>SYSTEM</code> - If you delete
        a table with point-in-time recovery enabled,
                            a
        <code>SYSTEM</code> backup is automatically created and is retained for 35

        days (at no additional cost). System backups allow you to restore the deleted

        table to the state it was in just before the point of deletion. </p>

        </li>
                    <li>
                        <p>

        <code>AWS_BACKUP</code> - On-demand backup created by you from Backup
        service.</p>
                    </li>
                 </ul>
        :param backup_creation_date_time: <p>Time at which the backup was created. This
        is the request time of the backup. </p>
        :param backup_size_bytes: <p>Size of the backup in bytes. DynamoDB updates this
        value approximately every six hours.
                 Recent changes might not be
        reflected in this value.</p>
        :param backup_expiry_date_time: <p>Time at which the automatic on-demand backup
        created by DynamoDB will
                    expire. This <code>SYSTEM</code> on-demand
        backup expires automatically 35 days after
                    its creation.</p>
        """
        self.backup_arn = backup_arn
        self.backup_name = backup_name
        self.backup_status = backup_status
        self.backup_type = backup_type
        self.backup_creation_date_time = backup_creation_date_time
        self.backup_size_bytes = backup_size_bytes
        self.backup_expiry_date_time = backup_expiry_date_time

    def as_dict(self) -> Dict[str, Any]:
        """Converts the BackupDetails to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        d: Dict[str, Any] = {
            "BackupArn": self.backup_arn,
            "BackupName": self.backup_name,
            "BackupStatus": self.backup_status,
            "BackupType": self.backup_type,
            "BackupCreationDateTime": self.backup_creation_date_time,
        }

        if self.backup_size_bytes is not None:
            d["BackupSizeBytes"] = self.backup_size_bytes

        if self.backup_expiry_date_time is not None:
            d["BackupExpiryDateTime"] = self.backup_expiry_date_time

        return d

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "BackupDetails":
        """Creates a BackupDetails from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {
            "backup_arn": d["BackupArn"],
            "backup_name": d["BackupName"],
            "backup_status": d["BackupStatus"],
            "backup_type": d["BackupType"],
            "backup_creation_date_time": d["BackupCreationDateTime"],
        }

        if "BackupSizeBytes" in d:
            kwargs["backup_size_bytes"] = d["BackupSizeBytes"]

        if "BackupExpiryDateTime" in d:
            kwargs["backup_expiry_date_time"] = d["BackupExpiryDateTime"]

        return BackupDetails(**kwargs)

    def __repr__(self) -> str:
        result = "BackupDetails("
        if self.backup_arn is not None:
            result += f"backup_arn={repr(self.backup_arn)}, "

        if self.backup_name is not None:
            result += f"backup_name={repr(self.backup_name)}, "

        if self.backup_size_bytes is not None:
            result += f"backup_size_bytes={repr(self.backup_size_bytes)}, "

        if self.backup_status is not None:
            result += f"backup_status={repr(self.backup_status)}, "

        if self.backup_type is not None:
            result += f"backup_type={repr(self.backup_type)}, "

        if self.backup_creation_date_time is not None:
            result += f"backup_creation_date_time={repr(self.backup_creation_date_time)}, "

        if self.backup_expiry_date_time is not None:
            result += f"backup_expiry_date_time={repr(self.backup_expiry_date_time)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, BackupDetails):
            return False
        attributes: list[str] = ['backup_arn','backup_name','backup_size_bytes','backup_status','backup_type','backup_creation_date_time','backup_expiry_date_time',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class KeySchemaElement:
    attribute_name: str
    key_type: str
    def __init__(
        self,
        *,
        attribute_name: str,
        key_type: str,
    ):
        """<p>Represents <i>a single element</i> of a key schema. A key schema

        specifies the attributes that make up the primary key of a table, or the key
        attributes
                    of an index.</p>
                <p>A
        <code>KeySchemaElement</code> represents exactly one attribute of the primary
        key.
                    For example, a simple primary key would be represented by one

        <code>KeySchemaElement</code> (for the partition key). A composite primary key
        would
                    require one <code>KeySchemaElement</code> for the partition
        key, and another
                        <code>KeySchemaElement</code> for the sort
        key.</p>
                <p>A <code>KeySchemaElement</code> must be a scalar, top-level
        attribute (not a nested
                    attribute). The data type must be one of
        String, Number, or Binary. The attribute cannot
                    be nested within a
        List or a Map.</p>

        :param attribute_name: <p>The name of a key attribute.</p>
        :param key_type: <p>The role that this key attribute will assume:</p>

        <ul>
                    <li>
                        <p>
                            <code>HASH</code>
        - partition key</p>
                    </li>
                    <li>
                        <p>

        <code>RANGE</code> - sort key</p>
                    </li>
                 </ul>

        <note>
                    <p>The partition key of an item is also known as its <i>hash

        attribute</i>. The term "hash attribute" derives from DynamoDB's usage of an
        internal hash function to evenly distribute data items across

        partitions, based on their partition key values.</p>
                    <p>The sort key
        of an item is also known as its <i>range attribute</i>.
                        The term
        "range attribute" derives from the way DynamoDB stores items with

        the same partition key physically close together, in sorted order by the sort
        key
                        value.</p>
                </note>
        """
        self.attribute_name = attribute_name
        self.key_type = key_type

    def as_dict(self) -> Dict[str, Any]:
        """Converts the KeySchemaElement to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        return {
            "AttributeName": self.attribute_name,
            "KeyType": self.key_type,
        }

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "KeySchemaElement":
        """Creates a KeySchemaElement from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {
            "attribute_name": d["AttributeName"],
            "key_type": d["KeyType"],
        }

        return KeySchemaElement(**kwargs)

    def __repr__(self) -> str:
        result = "KeySchemaElement("
        if self.attribute_name is not None:
            result += f"attribute_name={repr(self.attribute_name)}, "

        if self.key_type is not None:
            result += f"key_type={repr(self.key_type)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, KeySchemaElement):
            return False
        attributes: list[str] = ['attribute_name','key_type',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class ProvisionedThroughput:
    read_capacity_units: int
    write_capacity_units: int
    def __init__(
        self,
        *,
        read_capacity_units: int,
        write_capacity_units: int,
    ):
        """<p>Represents the provisioned throughput settings for a specified table or
        index. The
                    settings can be modified using the
        <code>UpdateTable</code> operation.</p>
                <p>For current minimum and
        maximum provisioned throughput values, see <a
        href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Limits.html">Service,

        Account, and Table Quotas</a> in the <i>Amazon DynamoDB Developer

        Guide</i>.</p>

        :param read_capacity_units: <p>The maximum number of strongly consistent reads
        consumed per second before DynamoDB
                    returns a
        <code>ThrottlingException</code>. For more information, see <a
        href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/WorkingWithTables.html#ProvisionedThroughput">Specifying
        Read and Write Requirements</a> in the <i>Amazon DynamoDB

        Developer Guide</i>.</p>
                <p>If read/write capacity mode is
        <code>PAY_PER_REQUEST</code> the value is set to
                    0.</p>
        :param write_capacity_units: <p>The maximum number of writes consumed per second
        before DynamoDB returns a
                        <code>ThrottlingException</code>. For
        more information, see <a
        href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/WorkingWithTables.html#ProvisionedThroughput">Specifying
        Read and Write Requirements</a> in the <i>Amazon DynamoDB

        Developer Guide</i>.</p>
                <p>If read/write capacity mode is
        <code>PAY_PER_REQUEST</code> the value is set to
                    0.</p>
        """
        self.read_capacity_units = read_capacity_units
        self.write_capacity_units = write_capacity_units

    def as_dict(self) -> Dict[str, Any]:
        """Converts the ProvisionedThroughput to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        return {
            "ReadCapacityUnits": self.read_capacity_units,
            "WriteCapacityUnits": self.write_capacity_units,
        }

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "ProvisionedThroughput":
        """Creates a ProvisionedThroughput from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {
            "read_capacity_units": d["ReadCapacityUnits"],
            "write_capacity_units": d["WriteCapacityUnits"],
        }

        return ProvisionedThroughput(**kwargs)

    def __repr__(self) -> str:
        result = "ProvisionedThroughput("
        if self.read_capacity_units is not None:
            result += f"read_capacity_units={repr(self.read_capacity_units)}, "

        if self.write_capacity_units is not None:
            result += f"write_capacity_units={repr(self.write_capacity_units)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, ProvisionedThroughput):
            return False
        attributes: list[str] = ['read_capacity_units','write_capacity_units',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class SourceTableDetails:
    table_name: str
    table_id: str
    table_arn: Optional[str]
    table_size_bytes: int
    key_schema: list[KeySchemaElement]
    table_creation_date_time: datetime
    provisioned_throughput: ProvisionedThroughput
    item_count: Optional[int]
    billing_mode: Optional[str]
    def __init__(
        self,
        *,
        table_name: str,
        table_id: str,
        key_schema: list[KeySchemaElement],
        table_creation_date_time: datetime,
        provisioned_throughput: ProvisionedThroughput,
        table_arn: Optional[str] = None,
        table_size_bytes: int = 0,
        item_count: Optional[int] = None,
        billing_mode: Optional[str] = None,
    ):
        """<p>Contains the details of the table when the backup was created. </p>

        :param table_name: <p>The name of the table for which the backup was created.
        </p>
        :param table_id: <p>Unique identifier for the table for which the backup was
        created. </p>
        :param key_schema: <p>Schema of the table. </p>
        :param table_creation_date_time: <p>Time when the source table was created. </p>
        :param provisioned_throughput: <p>Read IOPs and Write IOPS on the table when the
        backup was created.</p>
        :param table_arn: <p>ARN of the table for which backup was created. </p>
        :param table_size_bytes: <p>Size of the table in bytes. Note that this is an
        approximate value.</p>
        :param item_count: <p>Number of items in the table. Note that this is an
        approximate value. </p>
        :param billing_mode: <p>Controls how you are charged for read and write
        throughput and how you manage
                    capacity. This setting can be changed
        later.</p>
                <ul>
                    <li>
                        <p>

        <code>PROVISIONED</code> - Sets the read/write capacity mode to

        <code>PROVISIONED</code>. We recommend using <code>PROVISIONED</code> for

        predictable workloads.</p>
                    </li>
                    <li>

        <p>
                            <code>PAY_PER_REQUEST</code> - Sets the read/write
        capacity mode to
                                <code>PAY_PER_REQUEST</code>. We
        recommend using
                                <code>PAY_PER_REQUEST</code> for
        unpredictable workloads. </p>
                    </li>
                 </ul>
        """
        self.table_name = table_name
        self.table_id = table_id
        self.key_schema = key_schema
        self.table_creation_date_time = table_creation_date_time
        self.provisioned_throughput = provisioned_throughput
        self.table_arn = table_arn
        self.table_size_bytes = table_size_bytes
        self.item_count = item_count
        self.billing_mode = billing_mode

    def as_dict(self) -> Dict[str, Any]:
        """Converts the SourceTableDetails to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        d: Dict[str, Any] = {
            "TableName": self.table_name,
            "TableId": self.table_id,
            "KeySchema": _key_schema_as_dict(self.key_schema),
            "TableCreationDateTime": self.table_creation_date_time,
            "ProvisionedThroughput": self.provisioned_throughput.as_dict(),
        }

        if self.table_arn is not None:
            d["TableArn"] = self.table_arn

        if self.table_size_bytes is not None:
            d["TableSizeBytes"] = self.table_size_bytes

        if self.item_count is not None:
            d["ItemCount"] = self.item_count

        if self.billing_mode is not None:
            d["BillingMode"] = self.billing_mode

        return d

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "SourceTableDetails":
        """Creates a SourceTableDetails from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {
            "table_name": d["TableName"],
            "table_id": d["TableId"],
            "key_schema": _key_schema_from_dict(d["KeySchema"]),
            "table_creation_date_time": d["TableCreationDateTime"],
            "provisioned_throughput": ProvisionedThroughput.from_dict(d["ProvisionedThroughput"]),
        }

        if "TableArn" in d:
            kwargs["table_arn"] = d["TableArn"]

        if "TableSizeBytes" in d:
            kwargs["table_size_bytes"] = d["TableSizeBytes"]

        if "ItemCount" in d:
            kwargs["item_count"] = d["ItemCount"]

        if "BillingMode" in d:
            kwargs["billing_mode"] = d["BillingMode"]

        return SourceTableDetails(**kwargs)

    def __repr__(self) -> str:
        result = "SourceTableDetails("
        if self.table_name is not None:
            result += f"table_name={repr(self.table_name)}, "

        if self.table_id is not None:
            result += f"table_id={repr(self.table_id)}, "

        if self.table_arn is not None:
            result += f"table_arn={repr(self.table_arn)}, "

        if self.table_size_bytes is not None:
            result += f"table_size_bytes={repr(self.table_size_bytes)}, "

        if self.key_schema is not None:
            result += f"key_schema={repr(self.key_schema)}, "

        if self.table_creation_date_time is not None:
            result += f"table_creation_date_time={repr(self.table_creation_date_time)}, "

        if self.provisioned_throughput is not None:
            result += f"provisioned_throughput={repr(self.provisioned_throughput)}, "

        if self.item_count is not None:
            result += f"item_count={repr(self.item_count)}, "

        if self.billing_mode is not None:
            result += f"billing_mode={repr(self.billing_mode)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, SourceTableDetails):
            return False
        attributes: list[str] = ['table_name','table_id','table_arn','table_size_bytes','key_schema','table_creation_date_time','provisioned_throughput','item_count','billing_mode',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class Projection:
    projection_type: Optional[str]
    non_key_attributes: Optional[list[str]]
    def __init__(
        self,
        *,
        projection_type: Optional[str] = None,
        non_key_attributes: Optional[list[str]] = None,
    ):
        """<p>Represents attributes that are copied (projected) from the table into an
        index. These
                    are in addition to the primary key attributes and index
        key attributes, which are
                    automatically projected.</p>

        :param projection_type: <p>The set of attributes that are projected into the
        index:</p>
                <ul>
                    <li>
                        <p>

        <code>KEYS_ONLY</code> - Only the index and primary keys are projected into the

        index.</p>
                    </li>
                    <li>
                        <p>

        <code>INCLUDE</code> - In addition to the attributes described in

        <code>KEYS_ONLY</code>, the secondary index will include other non-key

        attributes that you specify.</p>
                    </li>
                    <li>

        <p>
                            <code>ALL</code> - All of the table attributes are
        projected into the
                            index.</p>
                    </li>

        </ul>
        :param non_key_attributes: <p>Represents the non-key attribute names which will
        be projected into the index.</p>
                <p>For local secondary indexes, the
        total count of <code>NonKeyAttributes</code> summed
                    across all of
        the local secondary indexes, must not exceed 100. If you project the same

        attribute into two different indexes, this counts as two distinct attributes
        when
                    determining the total.</p>
        """
        self.projection_type = projection_type
        self.non_key_attributes = non_key_attributes

    def as_dict(self) -> Dict[str, Any]:
        """Converts the Projection to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        d: Dict[str, Any] = {}

        if self.projection_type is not None:
            d["ProjectionType"] = self.projection_type

        if self.non_key_attributes is not None:
            d["NonKeyAttributes"] = self.non_key_attributes

        return d

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "Projection":
        """Creates a Projection from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {}

        if "ProjectionType" in d:
            kwargs["projection_type"] = d["ProjectionType"]

        if "NonKeyAttributes" in d:
            kwargs["non_key_attributes"] = d["NonKeyAttributes"]

        return Projection(**kwargs)

    def __repr__(self) -> str:
        result = "Projection("
        if self.projection_type is not None:
            result += f"projection_type={repr(self.projection_type)}, "

        if self.non_key_attributes is not None:
            result += f"non_key_attributes={repr(self.non_key_attributes)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, Projection):
            return False
        attributes: list[str] = ['projection_type','non_key_attributes',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class GlobalSecondaryIndexInfo:
    index_name: Optional[str]
    key_schema: Optional[list[KeySchemaElement]]
    projection: Optional[Projection]
    provisioned_throughput: Optional[ProvisionedThroughput]
    def __init__(
        self,
        *,
        index_name: Optional[str] = None,
        key_schema: Optional[list[KeySchemaElement]] = None,
        projection: Optional[Projection] = None,
        provisioned_throughput: Optional[ProvisionedThroughput] = None,
    ):
        """<p>Represents the properties of a global secondary index for the table when the
        backup
                    was created.</p>

        :param index_name: <p>The name of the global secondary index.</p>
        :param key_schema: <p>The complete key schema for a global secondary index,
        which consists of one or more
                    pairs of attribute names and key
        types:</p>
                <ul>
                    <li>
                        <p>

        <code>HASH</code> - partition key</p>
                    </li>
                    <li>

        <p>
                            <code>RANGE</code> - sort key</p>
                    </li>

        </ul>
                <note>
                    <p>The partition key of an item is also known
        as its <i>hash
                            attribute</i>. The term "hash attribute"
        derives from DynamoDB's usage of an internal hash function to evenly distribute
        data items across
                        partitions, based on their partition key
        values.</p>
                    <p>The sort key of an item is also known as its <i>range
        attribute</i>.
                        The term "range attribute" derives from the way
        DynamoDB stores items with
                        the same partition key physically
        close together, in sorted order by the sort key
                        value.</p>

        </note>
        :param projection: <p>Represents attributes that are copied (projected) from the
        table into the global
                    secondary index. These are in addition to the
        primary key attributes and index key
                    attributes, which are
        automatically projected. </p>
        :param provisioned_throughput: <p>Represents the provisioned throughput settings
        for the specified global secondary
                    index. </p>
        """
        self.index_name = index_name
        self.key_schema = key_schema
        self.projection = projection
        self.provisioned_throughput = provisioned_throughput

    def as_dict(self) -> Dict[str, Any]:
        """Converts the GlobalSecondaryIndexInfo to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        d: Dict[str, Any] = {}

        if self.index_name is not None:
            d["IndexName"] = self.index_name

        if self.key_schema is not None:
            d["KeySchema"] = _key_schema_as_dict(self.key_schema),

        if self.projection is not None:
            d["Projection"] = self.projection.as_dict()

        if self.provisioned_throughput is not None:
            d["ProvisionedThroughput"] = self.provisioned_throughput.as_dict()

        return d

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "GlobalSecondaryIndexInfo":
        """Creates a GlobalSecondaryIndexInfo from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {}

        if "IndexName" in d:
            kwargs["index_name"] = d["IndexName"]

        if "KeySchema" in d:
            kwargs["key_schema"] = _key_schema_from_dict(d["KeySchema"]),

        if "Projection" in d:
            kwargs["projection"] = Projection.from_dict(d["Projection"])

        if "ProvisionedThroughput" in d:
            kwargs["provisioned_throughput"] = ProvisionedThroughput.from_dict(d["ProvisionedThroughput"])

        return GlobalSecondaryIndexInfo(**kwargs)

    def __repr__(self) -> str:
        result = "GlobalSecondaryIndexInfo("
        if self.index_name is not None:
            result += f"index_name={repr(self.index_name)}, "

        if self.key_schema is not None:
            result += f"key_schema={repr(self.key_schema)}, "

        if self.projection is not None:
            result += f"projection={repr(self.projection)}, "

        if self.provisioned_throughput is not None:
            result += f"provisioned_throughput={repr(self.provisioned_throughput)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, GlobalSecondaryIndexInfo):
            return False
        attributes: list[str] = ['index_name','key_schema','projection','provisioned_throughput',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class LocalSecondaryIndexInfo:
    index_name: Optional[str]
    key_schema: Optional[list[KeySchemaElement]]
    projection: Optional[Projection]
    def __init__(
        self,
        *,
        index_name: Optional[str] = None,
        key_schema: Optional[list[KeySchemaElement]] = None,
        projection: Optional[Projection] = None,
    ):
        """<p>Represents the properties of a local secondary index for the table when the
        backup was
                    created.</p>

        :param index_name: <p>Represents the name of the local secondary index.</p>
        :param key_schema: <p>The complete key schema for a local secondary index, which
        consists of one or more
                    pairs of attribute names and key types:</p>

        <ul>
                    <li>
                        <p>
                            <code>HASH</code>
        - partition key</p>
                    </li>
                    <li>
                        <p>

        <code>RANGE</code> - sort key</p>
                    </li>
                 </ul>

        <note>
                    <p>The partition key of an item is also known as its <i>hash

        attribute</i>. The term "hash attribute" derives from DynamoDB's usage of

        an internal hash function to evenly distribute data items across partitions,
        based
                        on their partition key values.</p>
                    <p>The sort
        key of an item is also known as its <i>range attribute</i>.
                        The
        term "range attribute" derives from the way DynamoDB stores items with the same

        partition key physically close together, in sorted order by the sort key

        value.</p>
                </note>
        :param projection: <p>Represents attributes that are copied (projected) from the
        table into the global
                    secondary index. These are in addition to the
        primary key attributes and index key
                    attributes, which are
        automatically projected. </p>
        """
        self.index_name = index_name
        self.key_schema = key_schema
        self.projection = projection

    def as_dict(self) -> Dict[str, Any]:
        """Converts the LocalSecondaryIndexInfo to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        d: Dict[str, Any] = {}

        if self.index_name is not None:
            d["IndexName"] = self.index_name

        if self.key_schema is not None:
            d["KeySchema"] = _key_schema_as_dict(self.key_schema),

        if self.projection is not None:
            d["Projection"] = self.projection.as_dict()

        return d

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "LocalSecondaryIndexInfo":
        """Creates a LocalSecondaryIndexInfo from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {}

        if "IndexName" in d:
            kwargs["index_name"] = d["IndexName"]

        if "KeySchema" in d:
            kwargs["key_schema"] = _key_schema_from_dict(d["KeySchema"]),

        if "Projection" in d:
            kwargs["projection"] = Projection.from_dict(d["Projection"])

        return LocalSecondaryIndexInfo(**kwargs)

    def __repr__(self) -> str:
        result = "LocalSecondaryIndexInfo("
        if self.index_name is not None:
            result += f"index_name={repr(self.index_name)}, "

        if self.key_schema is not None:
            result += f"key_schema={repr(self.key_schema)}, "

        if self.projection is not None:
            result += f"projection={repr(self.projection)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, LocalSecondaryIndexInfo):
            return False
        attributes: list[str] = ['index_name','key_schema','projection',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class SSEDescription:
    status: Optional[str]
    sse_type: Optional[str]
    kms_master_key_arn: Optional[str]
    inaccessible_encryption_date_time: Optional[datetime]
    def __init__(
        self,
        *,
        status: Optional[str] = None,
        sse_type: Optional[str] = None,
        kms_master_key_arn: Optional[str] = None,
        inaccessible_encryption_date_time: Optional[datetime] = None,
    ):
        """<p>The description of the server-side encryption status on the specified
        table.</p>

        :param status: <p>Represents the current state of server-side encryption. The
        only supported values
                    are:</p>
                <ul>
                    <li>

        <p>
                            <code>ENABLED</code> - Server-side encryption is
        enabled.</p>
                    </li>
                    <li>
                        <p>

        <code>UPDATING</code> - Server-side encryption is being updated.</p>

        </li>
                 </ul>
        :param sse_type: <p>Server-side encryption type. The only supported value
        is:</p>
                <ul>
                    <li>
                        <p>

        <code>KMS</code> - Server-side encryption that uses Key Management Service. The

        key is stored in your account and is managed by KMS (KMS charges apply).</p>

        </li>
                 </ul>
        :param kms_master_key_arn: <p>The KMS key ARN used for the KMS

        encryption.</p>
        :param inaccessible_encryption_date_time: <p>Indicates the time, in UNIX epoch
        date format, when DynamoDB detected that
                    the table's KMS key was
        inaccessible. This attribute will automatically
                    be cleared when
        DynamoDB detects that the table's KMS key is accessible
                    again.
        DynamoDB will initiate the table archival process when table's KMS key remains
        inaccessible for more than seven days from this date.</p>
        """
        self.status = status
        self.sse_type = sse_type
        self.kms_master_key_arn = kms_master_key_arn
        self.inaccessible_encryption_date_time = inaccessible_encryption_date_time

    def as_dict(self) -> Dict[str, Any]:
        """Converts the SSEDescription to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        d: Dict[str, Any] = {}

        if self.status is not None:
            d["Status"] = self.status

        if self.sse_type is not None:
            d["SSEType"] = self.sse_type

        if self.kms_master_key_arn is not None:
            d["KMSMasterKeyArn"] = self.kms_master_key_arn

        if self.inaccessible_encryption_date_time is not None:
            d["InaccessibleEncryptionDateTime"] = self.inaccessible_encryption_date_time

        return d

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "SSEDescription":
        """Creates a SSEDescription from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {}

        if "Status" in d:
            kwargs["status"] = d["Status"]

        if "SSEType" in d:
            kwargs["sse_type"] = d["SSEType"]

        if "KMSMasterKeyArn" in d:
            kwargs["kms_master_key_arn"] = d["KMSMasterKeyArn"]

        if "InaccessibleEncryptionDateTime" in d:
            kwargs["inaccessible_encryption_date_time"] = d["InaccessibleEncryptionDateTime"]

        return SSEDescription(**kwargs)

    def __repr__(self) -> str:
        result = "SSEDescription("
        if self.status is not None:
            result += f"status={repr(self.status)}, "

        if self.sse_type is not None:
            result += f"sse_type={repr(self.sse_type)}, "

        if self.kms_master_key_arn is not None:
            result += f"kms_master_key_arn={repr(self.kms_master_key_arn)}, "

        if self.inaccessible_encryption_date_time is not None:
            result += f"inaccessible_encryption_date_time={repr(self.inaccessible_encryption_date_time)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, SSEDescription):
            return False
        attributes: list[str] = ['status','sse_type','kms_master_key_arn','inaccessible_encryption_date_time',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class StreamSpecification:
    stream_enabled: bool
    stream_view_type: Optional[str]
    def __init__(
        self,
        *,
        stream_enabled: bool,
        stream_view_type: Optional[str] = None,
    ):
        """<p>Represents the DynamoDB Streams configuration for a table in DynamoDB.</p>

        :param stream_enabled: <p>Indicates whether DynamoDB Streams is enabled (true)
        or disabled (false) on the
                    table.</p>
        :param stream_view_type: <p> When an item in the table is modified,
        <code>StreamViewType</code> determines what
                    information is written
        to the stream for this table. Valid values for

        <code>StreamViewType</code> are:</p>
                <ul>
                    <li>

        <p>
                            <code>KEYS_ONLY</code> - Only the key attributes of the
        modified item are
                            written to the stream.</p>

        </li>
                    <li>
                        <p>

        <code>NEW_IMAGE</code> - The entire item, as it appears after it was modified,

        is written to the stream.</p>
                    </li>
                    <li>

        <p>
                            <code>OLD_IMAGE</code> - The entire item, as it appeared
        before it was modified,
                            is written to the stream.</p>

        </li>
                    <li>
                        <p>

        <code>NEW_AND_OLD_IMAGES</code> - Both the new and the old item images of the

        item are written to the stream.</p>
                    </li>
                 </ul>
        """
        self.stream_enabled = stream_enabled
        self.stream_view_type = stream_view_type

    def as_dict(self) -> Dict[str, Any]:
        """Converts the StreamSpecification to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        d: Dict[str, Any] = {
            "StreamEnabled": self.stream_enabled,
        }

        if self.stream_view_type is not None:
            d["StreamViewType"] = self.stream_view_type

        return d

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "StreamSpecification":
        """Creates a StreamSpecification from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {
            "stream_enabled": d["StreamEnabled"],
        }

        if "StreamViewType" in d:
            kwargs["stream_view_type"] = d["StreamViewType"]

        return StreamSpecification(**kwargs)

    def __repr__(self) -> str:
        result = "StreamSpecification("
        if self.stream_enabled is not None:
            result += f"stream_enabled={repr(self.stream_enabled)}, "

        if self.stream_view_type is not None:
            result += f"stream_view_type={repr(self.stream_view_type)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, StreamSpecification):
            return False
        attributes: list[str] = ['stream_enabled','stream_view_type',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class TimeToLiveDescription:
    time_to_live_status: Optional[str]
    attribute_name: Optional[str]
    def __init__(
        self,
        *,
        time_to_live_status: Optional[str] = None,
        attribute_name: Optional[str] = None,
    ):
        """<p>The description of the Time to Live (TTL) status on the specified table. </p>

        :param time_to_live_status: <p> The TTL status for the table.</p>
        :param attribute_name: <p> The name of the TTL attribute for items in the
        table.</p>
        """
        self.time_to_live_status = time_to_live_status
        self.attribute_name = attribute_name

    def as_dict(self) -> Dict[str, Any]:
        """Converts the TimeToLiveDescription to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        d: Dict[str, Any] = {}

        if self.time_to_live_status is not None:
            d["TimeToLiveStatus"] = self.time_to_live_status

        if self.attribute_name is not None:
            d["AttributeName"] = self.attribute_name

        return d

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "TimeToLiveDescription":
        """Creates a TimeToLiveDescription from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {}

        if "TimeToLiveStatus" in d:
            kwargs["time_to_live_status"] = d["TimeToLiveStatus"]

        if "AttributeName" in d:
            kwargs["attribute_name"] = d["AttributeName"]

        return TimeToLiveDescription(**kwargs)

    def __repr__(self) -> str:
        result = "TimeToLiveDescription("
        if self.time_to_live_status is not None:
            result += f"time_to_live_status={repr(self.time_to_live_status)}, "

        if self.attribute_name is not None:
            result += f"attribute_name={repr(self.attribute_name)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, TimeToLiveDescription):
            return False
        attributes: list[str] = ['time_to_live_status','attribute_name',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class SourceTableFeatureDetails:
    local_secondary_indexes: Optional[list[LocalSecondaryIndexInfo]]
    global_secondary_indexes: Optional[list[GlobalSecondaryIndexInfo]]
    stream_description: Optional[StreamSpecification]
    time_to_live_description: Optional[TimeToLiveDescription]
    sse_description: Optional[SSEDescription]
    def __init__(
        self,
        *,
        local_secondary_indexes: Optional[list[LocalSecondaryIndexInfo]] = None,
        global_secondary_indexes: Optional[list[GlobalSecondaryIndexInfo]] = None,
        stream_description: Optional[StreamSpecification] = None,
        time_to_live_description: Optional[TimeToLiveDescription] = None,
        sse_description: Optional[SSEDescription] = None,
    ):
        """<p>Contains the details of the features enabled on the table when the backup was
        created.
                    For example, LSIs, GSIs, streams, TTL. </p>

        :param local_secondary_indexes: <p>Represents the LSI properties for the table
        when the backup was created. It includes
                    the IndexName, KeySchema
        and Projection for the LSIs on the table at the time of backup.
                </p>
        :param global_secondary_indexes: <p>Represents the GSI properties for the table
        when the backup was created. It includes
                    the IndexName, KeySchema,
        Projection, and ProvisionedThroughput for the GSIs on the
                    table at
        the time of backup. </p>
        :param stream_description: <p>Stream settings on the table when the backup was
        created.</p>
        :param time_to_live_description: <p>Time to Live settings on the table when the
        backup was created.</p>
        :param sse_description: <p>The description of the server-side encryption status
        on the table when the backup was
                    created.</p>
        """
        self.local_secondary_indexes = local_secondary_indexes
        self.global_secondary_indexes = global_secondary_indexes
        self.stream_description = stream_description
        self.time_to_live_description = time_to_live_description
        self.sse_description = sse_description

    def as_dict(self) -> Dict[str, Any]:
        """Converts the SourceTableFeatureDetails to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        d: Dict[str, Any] = {}

        if self.local_secondary_indexes is not None:
            d["LocalSecondaryIndexes"] = _local_secondary_indexes_as_dict(self.local_secondary_indexes),

        if self.global_secondary_indexes is not None:
            d["GlobalSecondaryIndexes"] = _global_secondary_indexes_as_dict(self.global_secondary_indexes),

        if self.stream_description is not None:
            d["StreamDescription"] = self.stream_description.as_dict()

        if self.time_to_live_description is not None:
            d["TimeToLiveDescription"] = self.time_to_live_description.as_dict()

        if self.sse_description is not None:
            d["SSEDescription"] = self.sse_description.as_dict()

        return d

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "SourceTableFeatureDetails":
        """Creates a SourceTableFeatureDetails from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {}

        if "LocalSecondaryIndexes" in d:
            kwargs["local_secondary_indexes"] = _local_secondary_indexes_from_dict(d["LocalSecondaryIndexes"]),

        if "GlobalSecondaryIndexes" in d:
            kwargs["global_secondary_indexes"] = _global_secondary_indexes_from_dict(d["GlobalSecondaryIndexes"]),

        if "StreamDescription" in d:
            kwargs["stream_description"] = StreamSpecification.from_dict(d["StreamDescription"])

        if "TimeToLiveDescription" in d:
            kwargs["time_to_live_description"] = TimeToLiveDescription.from_dict(d["TimeToLiveDescription"])

        if "SSEDescription" in d:
            kwargs["sse_description"] = SSEDescription.from_dict(d["SSEDescription"])

        return SourceTableFeatureDetails(**kwargs)

    def __repr__(self) -> str:
        result = "SourceTableFeatureDetails("
        if self.local_secondary_indexes is not None:
            result += f"local_secondary_indexes={repr(self.local_secondary_indexes)}, "

        if self.global_secondary_indexes is not None:
            result += f"global_secondary_indexes={repr(self.global_secondary_indexes)}, "

        if self.stream_description is not None:
            result += f"stream_description={repr(self.stream_description)}, "

        if self.time_to_live_description is not None:
            result += f"time_to_live_description={repr(self.time_to_live_description)}, "

        if self.sse_description is not None:
            result += f"sse_description={repr(self.sse_description)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, SourceTableFeatureDetails):
            return False
        attributes: list[str] = ['local_secondary_indexes','global_secondary_indexes','stream_description','time_to_live_description','sse_description',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class BackupDescription:
    backup_details: Optional[BackupDetails]
    source_table_details: Optional[SourceTableDetails]
    source_table_feature_details: Optional[SourceTableFeatureDetails]
    def __init__(
        self,
        *,
        backup_details: Optional[BackupDetails] = None,
        source_table_details: Optional[SourceTableDetails] = None,
        source_table_feature_details: Optional[SourceTableFeatureDetails] = None,
    ):
        """<p>Contains the description of the backup created for the table.</p>

        :param backup_details: <p>Contains the details of the backup created for the
        table. </p>
        :param source_table_details: <p>Contains the details of the table when the
        backup was created. </p>
        :param source_table_feature_details: <p>Contains the details of the features
        enabled on the table when the backup was created.
                    For example, LSIs,
        GSIs, streams, TTL.</p>
        """
        self.backup_details = backup_details
        self.source_table_details = source_table_details
        self.source_table_feature_details = source_table_feature_details

    def as_dict(self) -> Dict[str, Any]:
        """Converts the BackupDescription to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        d: Dict[str, Any] = {}

        if self.backup_details is not None:
            d["BackupDetails"] = self.backup_details.as_dict()

        if self.source_table_details is not None:
            d["SourceTableDetails"] = self.source_table_details.as_dict()

        if self.source_table_feature_details is not None:
            d["SourceTableFeatureDetails"] = self.source_table_feature_details.as_dict()

        return d

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "BackupDescription":
        """Creates a BackupDescription from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {}

        if "BackupDetails" in d:
            kwargs["backup_details"] = BackupDetails.from_dict(d["BackupDetails"])

        if "SourceTableDetails" in d:
            kwargs["source_table_details"] = SourceTableDetails.from_dict(d["SourceTableDetails"])

        if "SourceTableFeatureDetails" in d:
            kwargs["source_table_feature_details"] = SourceTableFeatureDetails.from_dict(d["SourceTableFeatureDetails"])

        return BackupDescription(**kwargs)

    def __repr__(self) -> str:
        result = "BackupDescription("
        if self.backup_details is not None:
            result += f"backup_details={repr(self.backup_details)}, "

        if self.source_table_details is not None:
            result += f"source_table_details={repr(self.source_table_details)}, "

        if self.source_table_feature_details is not None:
            result += f"source_table_feature_details={repr(self.source_table_feature_details)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, BackupDescription):
            return False
        attributes: list[str] = ['backup_details','source_table_details','source_table_feature_details',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class BackupSummary:
    table_name: Optional[str]
    table_id: Optional[str]
    table_arn: Optional[str]
    backup_arn: Optional[str]
    backup_name: Optional[str]
    backup_creation_date_time: Optional[datetime]
    backup_expiry_date_time: Optional[datetime]
    backup_status: Optional[str]
    backup_type: Optional[str]
    backup_size_bytes: Optional[int]
    def __init__(
        self,
        *,
        table_name: Optional[str] = None,
        table_id: Optional[str] = None,
        table_arn: Optional[str] = None,
        backup_arn: Optional[str] = None,
        backup_name: Optional[str] = None,
        backup_creation_date_time: Optional[datetime] = None,
        backup_expiry_date_time: Optional[datetime] = None,
        backup_status: Optional[str] = None,
        backup_type: Optional[str] = None,
        backup_size_bytes: Optional[int] = None,
    ):
        """<p>Contains details for the backup.</p>

        :param table_name: <p>Name of the table.</p>
        :param table_id: <p>Unique identifier for the table.</p>
        :param table_arn: <p>ARN associated with the table.</p>
        :param backup_arn: <p>ARN associated with the backup.</p>
        :param backup_name: <p>Name of the specified backup.</p>
        :param backup_creation_date_time: <p>Time at which the backup was created.</p>
        :param backup_expiry_date_time: <p>Time at which the automatic on-demand backup
        created by DynamoDB will
                    expire. This <code>SYSTEM</code> on-demand
        backup expires automatically 35 days after
                    its creation.</p>
        :param backup_status: <p>Backup can be in one of the following states: CREATING,
        ACTIVE, DELETED.</p>
        :param backup_type: <p>BackupType:</p>
                <ul>
                    <li>

        <p>
                            <code>USER</code> - You create and manage these using
        the on-demand backup
                            feature.</p>
                    </li>

        <li>
                        <p>
                            <code>SYSTEM</code> - If you delete
        a table with point-in-time recovery enabled,
                            a
        <code>SYSTEM</code> backup is automatically created and is retained for 35

        days (at no additional cost). System backups allow you to restore the deleted

        table to the state it was in just before the point of deletion. </p>

        </li>
                    <li>
                        <p>

        <code>AWS_BACKUP</code> - On-demand backup created by you from Backup
        service.</p>
                    </li>
                 </ul>
        :param backup_size_bytes: <p>Size of the backup in bytes.</p>
        """
        self.table_name = table_name
        self.table_id = table_id
        self.table_arn = table_arn
        self.backup_arn = backup_arn
        self.backup_name = backup_name
        self.backup_creation_date_time = backup_creation_date_time
        self.backup_expiry_date_time = backup_expiry_date_time
        self.backup_status = backup_status
        self.backup_type = backup_type
        self.backup_size_bytes = backup_size_bytes

    def as_dict(self) -> Dict[str, Any]:
        """Converts the BackupSummary to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        d: Dict[str, Any] = {}

        if self.table_name is not None:
            d["TableName"] = self.table_name

        if self.table_id is not None:
            d["TableId"] = self.table_id

        if self.table_arn is not None:
            d["TableArn"] = self.table_arn

        if self.backup_arn is not None:
            d["BackupArn"] = self.backup_arn

        if self.backup_name is not None:
            d["BackupName"] = self.backup_name

        if self.backup_creation_date_time is not None:
            d["BackupCreationDateTime"] = self.backup_creation_date_time

        if self.backup_expiry_date_time is not None:
            d["BackupExpiryDateTime"] = self.backup_expiry_date_time

        if self.backup_status is not None:
            d["BackupStatus"] = self.backup_status

        if self.backup_type is not None:
            d["BackupType"] = self.backup_type

        if self.backup_size_bytes is not None:
            d["BackupSizeBytes"] = self.backup_size_bytes

        return d

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "BackupSummary":
        """Creates a BackupSummary from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {}

        if "TableName" in d:
            kwargs["table_name"] = d["TableName"]

        if "TableId" in d:
            kwargs["table_id"] = d["TableId"]

        if "TableArn" in d:
            kwargs["table_arn"] = d["TableArn"]

        if "BackupArn" in d:
            kwargs["backup_arn"] = d["BackupArn"]

        if "BackupName" in d:
            kwargs["backup_name"] = d["BackupName"]

        if "BackupCreationDateTime" in d:
            kwargs["backup_creation_date_time"] = d["BackupCreationDateTime"]

        if "BackupExpiryDateTime" in d:
            kwargs["backup_expiry_date_time"] = d["BackupExpiryDateTime"]

        if "BackupStatus" in d:
            kwargs["backup_status"] = d["BackupStatus"]

        if "BackupType" in d:
            kwargs["backup_type"] = d["BackupType"]

        if "BackupSizeBytes" in d:
            kwargs["backup_size_bytes"] = d["BackupSizeBytes"]

        return BackupSummary(**kwargs)

    def __repr__(self) -> str:
        result = "BackupSummary("
        if self.table_name is not None:
            result += f"table_name={repr(self.table_name)}, "

        if self.table_id is not None:
            result += f"table_id={repr(self.table_id)}, "

        if self.table_arn is not None:
            result += f"table_arn={repr(self.table_arn)}, "

        if self.backup_arn is not None:
            result += f"backup_arn={repr(self.backup_arn)}, "

        if self.backup_name is not None:
            result += f"backup_name={repr(self.backup_name)}, "

        if self.backup_creation_date_time is not None:
            result += f"backup_creation_date_time={repr(self.backup_creation_date_time)}, "

        if self.backup_expiry_date_time is not None:
            result += f"backup_expiry_date_time={repr(self.backup_expiry_date_time)}, "

        if self.backup_status is not None:
            result += f"backup_status={repr(self.backup_status)}, "

        if self.backup_type is not None:
            result += f"backup_type={repr(self.backup_type)}, "

        if self.backup_size_bytes is not None:
            result += f"backup_size_bytes={repr(self.backup_size_bytes)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, BackupSummary):
            return False
        attributes: list[str] = ['table_name','table_id','table_arn','backup_arn','backup_name','backup_creation_date_time','backup_expiry_date_time','backup_status','backup_type','backup_size_bytes',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class Capacity:
    read_capacity_units: Optional[float]
    write_capacity_units: Optional[float]
    capacity_units: Optional[float]
    def __init__(
        self,
        *,
        read_capacity_units: Optional[float] = None,
        write_capacity_units: Optional[float] = None,
        capacity_units: Optional[float] = None,
    ):
        """<p>Represents the amount of provisioned throughput capacity consumed on a table
        or an
                    index.</p>

        :param read_capacity_units: <p>The total number of read capacity units consumed
        on a table or an index.</p>
        :param write_capacity_units: <p>The total number of write capacity units
        consumed on a table or an index.</p>
        :param capacity_units: <p>The total number of capacity units consumed on a table
        or an index.</p>
        """
        self.read_capacity_units = read_capacity_units
        self.write_capacity_units = write_capacity_units
        self.capacity_units = capacity_units

    def as_dict(self) -> Dict[str, Any]:
        """Converts the Capacity to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        d: Dict[str, Any] = {}

        if self.read_capacity_units is not None:
            d["ReadCapacityUnits"] = self.read_capacity_units

        if self.write_capacity_units is not None:
            d["WriteCapacityUnits"] = self.write_capacity_units

        if self.capacity_units is not None:
            d["CapacityUnits"] = self.capacity_units

        return d

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "Capacity":
        """Creates a Capacity from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {}

        if "ReadCapacityUnits" in d:
            kwargs["read_capacity_units"] = d["ReadCapacityUnits"]

        if "WriteCapacityUnits" in d:
            kwargs["write_capacity_units"] = d["WriteCapacityUnits"]

        if "CapacityUnits" in d:
            kwargs["capacity_units"] = d["CapacityUnits"]

        return Capacity(**kwargs)

    def __repr__(self) -> str:
        result = "Capacity("
        if self.read_capacity_units is not None:
            result += f"read_capacity_units={repr(self.read_capacity_units)}, "

        if self.write_capacity_units is not None:
            result += f"write_capacity_units={repr(self.write_capacity_units)}, "

        if self.capacity_units is not None:
            result += f"capacity_units={repr(self.capacity_units)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, Capacity):
            return False
        attributes: list[str] = ['read_capacity_units','write_capacity_units','capacity_units',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class ConsumedCapacity:
    table_name: Optional[str]
    capacity_units: Optional[float]
    read_capacity_units: Optional[float]
    write_capacity_units: Optional[float]
    table: Optional[Capacity]
    local_secondary_indexes: Optional[dict[str, Capacity]]
    global_secondary_indexes: Optional[dict[str, Capacity]]
    def __init__(
        self,
        *,
        table_name: Optional[str] = None,
        capacity_units: Optional[float] = None,
        read_capacity_units: Optional[float] = None,
        write_capacity_units: Optional[float] = None,
        table: Optional[Capacity] = None,
        local_secondary_indexes: Optional[dict[str, Capacity]] = None,
        global_secondary_indexes: Optional[dict[str, Capacity]] = None,
    ):
        """<p>The capacity units consumed by an operation. The data returned includes the
        total
                    provisioned throughput consumed, along with statistics for the
        table and any indexes
                    involved in the operation.
        <code>ConsumedCapacity</code> is only returned if the request
                    asked
        for it. For more information, see <a
        href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/ProvisionedThroughputIntro.html">Provisioned
        Throughput</a> in the <i>Amazon DynamoDB Developer

        Guide</i>.</p>

        :param table_name: <p>The name of the table that was affected by the
        operation.</p>
        :param capacity_units: <p>The total number of capacity units consumed by the
        operation.</p>
        :param read_capacity_units: <p>The total number of read capacity units consumed
        by the operation.</p>
        :param write_capacity_units: <p>The total number of write capacity units
        consumed by the operation.</p>
        :param table: <p>The amount of throughput consumed on the table affected by the
        operation.</p>
        :param local_secondary_indexes: <p>The amount of throughput consumed on each
        local index affected by the
                    operation.</p>
        :param global_secondary_indexes: <p>The amount of throughput consumed on each
        global index affected by the
                    operation.</p>
        """
        self.table_name = table_name
        self.capacity_units = capacity_units
        self.read_capacity_units = read_capacity_units
        self.write_capacity_units = write_capacity_units
        self.table = table
        self.local_secondary_indexes = local_secondary_indexes
        self.global_secondary_indexes = global_secondary_indexes

    def as_dict(self) -> Dict[str, Any]:
        """Converts the ConsumedCapacity to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        d: Dict[str, Any] = {}

        if self.table_name is not None:
            d["TableName"] = self.table_name

        if self.capacity_units is not None:
            d["CapacityUnits"] = self.capacity_units

        if self.read_capacity_units is not None:
            d["ReadCapacityUnits"] = self.read_capacity_units

        if self.write_capacity_units is not None:
            d["WriteCapacityUnits"] = self.write_capacity_units

        if self.table is not None:
            d["Table"] = self.table.as_dict()

        if self.local_secondary_indexes is not None:
            d["LocalSecondaryIndexes"] = _secondary_indexes_capacity_map_as_dict(self.local_secondary_indexes),

        if self.global_secondary_indexes is not None:
            d["GlobalSecondaryIndexes"] = _secondary_indexes_capacity_map_as_dict(self.global_secondary_indexes),

        return d

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "ConsumedCapacity":
        """Creates a ConsumedCapacity from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {}

        if "TableName" in d:
            kwargs["table_name"] = d["TableName"]

        if "CapacityUnits" in d:
            kwargs["capacity_units"] = d["CapacityUnits"]

        if "ReadCapacityUnits" in d:
            kwargs["read_capacity_units"] = d["ReadCapacityUnits"]

        if "WriteCapacityUnits" in d:
            kwargs["write_capacity_units"] = d["WriteCapacityUnits"]

        if "Table" in d:
            kwargs["table"] = Capacity.from_dict(d["Table"])

        if "LocalSecondaryIndexes" in d:
            kwargs["local_secondary_indexes"] = _secondary_indexes_capacity_map_from_dict(d["LocalSecondaryIndexes"]),

        if "GlobalSecondaryIndexes" in d:
            kwargs["global_secondary_indexes"] = _secondary_indexes_capacity_map_from_dict(d["GlobalSecondaryIndexes"]),

        return ConsumedCapacity(**kwargs)

    def __repr__(self) -> str:
        result = "ConsumedCapacity("
        if self.table_name is not None:
            result += f"table_name={repr(self.table_name)}, "

        if self.capacity_units is not None:
            result += f"capacity_units={repr(self.capacity_units)}, "

        if self.read_capacity_units is not None:
            result += f"read_capacity_units={repr(self.read_capacity_units)}, "

        if self.write_capacity_units is not None:
            result += f"write_capacity_units={repr(self.write_capacity_units)}, "

        if self.table is not None:
            result += f"table={repr(self.table)}, "

        if self.local_secondary_indexes is not None:
            result += f"local_secondary_indexes={repr(self.local_secondary_indexes)}, "

        if self.global_secondary_indexes is not None:
            result += f"global_secondary_indexes={repr(self.global_secondary_indexes)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, ConsumedCapacity):
            return False
        attributes: list[str] = ['table_name','capacity_units','read_capacity_units','write_capacity_units','table','local_secondary_indexes','global_secondary_indexes',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class BatchStatementError:
    code: Optional[str]
    message: Optional[str]
    def __init__(
        self,
        *,
        code: Optional[str] = None,
        message: Optional[str] = None,
    ):
        """<p> An error associated with a statement in a PartiQL batch that was run. </p>

        :param code: <p> The error code associated with the failed PartiQL batch
        statement. </p>
        :param message: <p> The error message associated with the PartiQL batch
        response. </p>
        """
        self.code = code
        self.message = message

    def as_dict(self) -> Dict[str, Any]:
        """Converts the BatchStatementError to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        d: Dict[str, Any] = {}

        if self.code is not None:
            d["Code"] = self.code

        if self.message is not None:
            d["Message"] = self.message

        return d

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "BatchStatementError":
        """Creates a BatchStatementError from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {}

        if "Code" in d:
            kwargs["code"] = d["Code"]

        if "Message" in d:
            kwargs["message"] = d["Message"]

        return BatchStatementError(**kwargs)

    def __repr__(self) -> str:
        result = "BatchStatementError("
        if self.code is not None:
            result += f"code={repr(self.code)}, "

        if self.message is not None:
            result += f"message={repr(self.message)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, BatchStatementError):
            return False
        attributes: list[str] = ['code','message',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class BillingModeSummary:
    billing_mode: Optional[str]
    last_update_to_pay_per_request_date_time: Optional[datetime]
    def __init__(
        self,
        *,
        billing_mode: Optional[str] = None,
        last_update_to_pay_per_request_date_time: Optional[datetime] = None,
    ):
        """<p>Contains the details for the read/write capacity mode.</p>

        :param billing_mode: <p>Controls how you are charged for read and write
        throughput and how you manage
                    capacity. This setting can be changed
        later.</p>
                <ul>
                    <li>
                        <p>

        <code>PROVISIONED</code> - Sets the read/write capacity mode to

        <code>PROVISIONED</code>. We recommend using <code>PROVISIONED</code> for

        predictable workloads.</p>
                    </li>
                    <li>

        <p>
                            <code>PAY_PER_REQUEST</code> - Sets the read/write
        capacity mode to
                                <code>PAY_PER_REQUEST</code>. We
        recommend using
                                <code>PAY_PER_REQUEST</code> for
        unpredictable workloads. </p>
                    </li>
                 </ul>
        :param last_update_to_pay_per_request_date_time: <p>Represents the time when
        <code>PAY_PER_REQUEST</code> was last set as the read/write
                    capacity
        mode.</p>
        """
        self.billing_mode = billing_mode
        self.last_update_to_pay_per_request_date_time = last_update_to_pay_per_request_date_time

    def as_dict(self) -> Dict[str, Any]:
        """Converts the BillingModeSummary to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        d: Dict[str, Any] = {}

        if self.billing_mode is not None:
            d["BillingMode"] = self.billing_mode

        if self.last_update_to_pay_per_request_date_time is not None:
            d["LastUpdateToPayPerRequestDateTime"] = self.last_update_to_pay_per_request_date_time

        return d

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "BillingModeSummary":
        """Creates a BillingModeSummary from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {}

        if "BillingMode" in d:
            kwargs["billing_mode"] = d["BillingMode"]

        if "LastUpdateToPayPerRequestDateTime" in d:
            kwargs["last_update_to_pay_per_request_date_time"] = d["LastUpdateToPayPerRequestDateTime"]

        return BillingModeSummary(**kwargs)

    def __repr__(self) -> str:
        result = "BillingModeSummary("
        if self.billing_mode is not None:
            result += f"billing_mode={repr(self.billing_mode)}, "

        if self.last_update_to_pay_per_request_date_time is not None:
            result += f"last_update_to_pay_per_request_date_time={repr(self.last_update_to_pay_per_request_date_time)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, BillingModeSummary):
            return False
        attributes: list[str] = ['billing_mode','last_update_to_pay_per_request_date_time',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class PointInTimeRecoveryDescription:
    point_in_time_recovery_status: Optional[str]
    earliest_restorable_date_time: Optional[datetime]
    latest_restorable_date_time: Optional[datetime]
    def __init__(
        self,
        *,
        point_in_time_recovery_status: Optional[str] = None,
        earliest_restorable_date_time: Optional[datetime] = None,
        latest_restorable_date_time: Optional[datetime] = None,
    ):
        """<p>The description of the point in time settings applied to the table.</p>

        :param point_in_time_recovery_status: <p>The current state of point in time
        recovery:</p>
                <ul>
                    <li>
                        <p>

        <code>ENABLED</code> - Point in time recovery is enabled.</p>
                    </li>

        <li>
                        <p>
                            <code>DISABLED</code> - Point in
        time recovery is disabled.</p>
                    </li>
                 </ul>
        :param earliest_restorable_date_time: <p>Specifies the earliest point in time
        you can restore your table to. You can restore
                    your table to any
        point in time during the last 35 days. </p>
        :param latest_restorable_date_time: <p>

        <code>LatestRestorableDateTime</code> is typically 5 minutes before the current
        time.
                </p>
        """
        self.point_in_time_recovery_status = point_in_time_recovery_status
        self.earliest_restorable_date_time = earliest_restorable_date_time
        self.latest_restorable_date_time = latest_restorable_date_time

    def as_dict(self) -> Dict[str, Any]:
        """Converts the PointInTimeRecoveryDescription to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        d: Dict[str, Any] = {}

        if self.point_in_time_recovery_status is not None:
            d["PointInTimeRecoveryStatus"] = self.point_in_time_recovery_status

        if self.earliest_restorable_date_time is not None:
            d["EarliestRestorableDateTime"] = self.earliest_restorable_date_time

        if self.latest_restorable_date_time is not None:
            d["LatestRestorableDateTime"] = self.latest_restorable_date_time

        return d

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "PointInTimeRecoveryDescription":
        """Creates a PointInTimeRecoveryDescription from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {}

        if "PointInTimeRecoveryStatus" in d:
            kwargs["point_in_time_recovery_status"] = d["PointInTimeRecoveryStatus"]

        if "EarliestRestorableDateTime" in d:
            kwargs["earliest_restorable_date_time"] = d["EarliestRestorableDateTime"]

        if "LatestRestorableDateTime" in d:
            kwargs["latest_restorable_date_time"] = d["LatestRestorableDateTime"]

        return PointInTimeRecoveryDescription(**kwargs)

    def __repr__(self) -> str:
        result = "PointInTimeRecoveryDescription("
        if self.point_in_time_recovery_status is not None:
            result += f"point_in_time_recovery_status={repr(self.point_in_time_recovery_status)}, "

        if self.earliest_restorable_date_time is not None:
            result += f"earliest_restorable_date_time={repr(self.earliest_restorable_date_time)}, "

        if self.latest_restorable_date_time is not None:
            result += f"latest_restorable_date_time={repr(self.latest_restorable_date_time)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, PointInTimeRecoveryDescription):
            return False
        attributes: list[str] = ['point_in_time_recovery_status','earliest_restorable_date_time','latest_restorable_date_time',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class ContinuousBackupsDescription:
    continuous_backups_status: str
    point_in_time_recovery_description: Optional[PointInTimeRecoveryDescription]
    def __init__(
        self,
        *,
        continuous_backups_status: str,
        point_in_time_recovery_description: Optional[PointInTimeRecoveryDescription] = None,
    ):
        """<p>Represents the continuous backups and point in time recovery settings on the

        table.</p>

        :param continuous_backups_status: <p>

        <code>ContinuousBackupsStatus</code> can be one of the following states:
        ENABLED,
                    DISABLED</p>
        :param point_in_time_recovery_description: <p>The description of the point in
        time recovery settings applied to the table.</p>
        """
        self.continuous_backups_status = continuous_backups_status
        self.point_in_time_recovery_description = point_in_time_recovery_description

    def as_dict(self) -> Dict[str, Any]:
        """Converts the ContinuousBackupsDescription to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        d: Dict[str, Any] = {
            "ContinuousBackupsStatus": self.continuous_backups_status,
        }

        if self.point_in_time_recovery_description is not None:
            d["PointInTimeRecoveryDescription"] = self.point_in_time_recovery_description.as_dict()

        return d

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "ContinuousBackupsDescription":
        """Creates a ContinuousBackupsDescription from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {
            "continuous_backups_status": d["ContinuousBackupsStatus"],
        }

        if "PointInTimeRecoveryDescription" in d:
            kwargs["point_in_time_recovery_description"] = PointInTimeRecoveryDescription.from_dict(d["PointInTimeRecoveryDescription"])

        return ContinuousBackupsDescription(**kwargs)

    def __repr__(self) -> str:
        result = "ContinuousBackupsDescription("
        if self.continuous_backups_status is not None:
            result += f"continuous_backups_status={repr(self.continuous_backups_status)}, "

        if self.point_in_time_recovery_description is not None:
            result += f"point_in_time_recovery_description={repr(self.point_in_time_recovery_description)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, ContinuousBackupsDescription):
            return False
        attributes: list[str] = ['continuous_backups_status','point_in_time_recovery_description',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class ContributorInsightsSummary:
    table_name: Optional[str]
    index_name: Optional[str]
    contributor_insights_status: Optional[str]
    def __init__(
        self,
        *,
        table_name: Optional[str] = None,
        index_name: Optional[str] = None,
        contributor_insights_status: Optional[str] = None,
    ):
        """<p>Represents a Contributor Insights summary entry.</p>

        :param table_name: <p>Name of the table associated with the summary.</p>
        :param index_name: <p>Name of the index associated with the summary, if any.</p>
        :param contributor_insights_status: <p>Describes the current status for
        contributor insights for the given table and index,
                    if
        applicable.</p>
        """
        self.table_name = table_name
        self.index_name = index_name
        self.contributor_insights_status = contributor_insights_status

    def as_dict(self) -> Dict[str, Any]:
        """Converts the ContributorInsightsSummary to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        d: Dict[str, Any] = {}

        if self.table_name is not None:
            d["TableName"] = self.table_name

        if self.index_name is not None:
            d["IndexName"] = self.index_name

        if self.contributor_insights_status is not None:
            d["ContributorInsightsStatus"] = self.contributor_insights_status

        return d

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "ContributorInsightsSummary":
        """Creates a ContributorInsightsSummary from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {}

        if "TableName" in d:
            kwargs["table_name"] = d["TableName"]

        if "IndexName" in d:
            kwargs["index_name"] = d["IndexName"]

        if "ContributorInsightsStatus" in d:
            kwargs["contributor_insights_status"] = d["ContributorInsightsStatus"]

        return ContributorInsightsSummary(**kwargs)

    def __repr__(self) -> str:
        result = "ContributorInsightsSummary("
        if self.table_name is not None:
            result += f"table_name={repr(self.table_name)}, "

        if self.index_name is not None:
            result += f"index_name={repr(self.index_name)}, "

        if self.contributor_insights_status is not None:
            result += f"contributor_insights_status={repr(self.contributor_insights_status)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, ContributorInsightsSummary):
            return False
        attributes: list[str] = ['table_name','index_name','contributor_insights_status',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class CreateBackupInput:
    table_name: str
    backup_name: str
    def __init__(
        self,
        *,
        table_name: str,
        backup_name: str,
    ):
        """
        :param table_name: <p>The name of the table.</p>
        :param backup_name: <p>Specified name for the backup.</p>
        """
        self.table_name = table_name
        self.backup_name = backup_name

    def as_dict(self) -> Dict[str, Any]:
        """Converts the CreateBackupInput to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        return {
            "TableName": self.table_name,
            "BackupName": self.backup_name,
        }

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "CreateBackupInput":
        """Creates a CreateBackupInput from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {
            "table_name": d["TableName"],
            "backup_name": d["BackupName"],
        }

        return CreateBackupInput(**kwargs)

    def __repr__(self) -> str:
        result = "CreateBackupInput("
        if self.table_name is not None:
            result += f"table_name={repr(self.table_name)}, "

        if self.backup_name is not None:
            result += f"backup_name={repr(self.backup_name)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, CreateBackupInput):
            return False
        attributes: list[str] = ['table_name','backup_name',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class CreateBackupOutput:
    backup_details: Optional[BackupDetails]
    def __init__(
        self,
        *,
        backup_details: Optional[BackupDetails] = None,
    ):
        """
        :param backup_details: <p>Contains the details of the backup created for the
        table.</p>
        """
        self.backup_details = backup_details

    def as_dict(self) -> Dict[str, Any]:
        """Converts the CreateBackupOutput to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        d: Dict[str, Any] = {}

        if self.backup_details is not None:
            d["BackupDetails"] = self.backup_details.as_dict()

        return d

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "CreateBackupOutput":
        """Creates a CreateBackupOutput from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {}

        if "BackupDetails" in d:
            kwargs["backup_details"] = BackupDetails.from_dict(d["BackupDetails"])

        return CreateBackupOutput(**kwargs)

    def __repr__(self) -> str:
        result = "CreateBackupOutput("
        if self.backup_details is not None:
            result += f"backup_details={repr(self.backup_details)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, CreateBackupOutput):
            return False
        attributes: list[str] = ['backup_details',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class CreateGlobalSecondaryIndexAction:
    index_name: str
    key_schema: list[KeySchemaElement]
    projection: Projection
    provisioned_throughput: Optional[ProvisionedThroughput]
    def __init__(
        self,
        *,
        index_name: str,
        key_schema: list[KeySchemaElement],
        projection: Projection,
        provisioned_throughput: Optional[ProvisionedThroughput] = None,
    ):
        """<p>Represents a new global secondary index to be added to an existing table.</p>

        :param index_name: <p>The name of the global secondary index to be created.</p>
        :param key_schema: <p>The key schema for the global secondary index.</p>
        :param projection: <p>Represents attributes that are copied (projected) from the
        table into an index. These
                    are in addition to the primary key
        attributes and index key attributes, which are
                    automatically
        projected.</p>
        :param provisioned_throughput: <p>Represents the provisioned throughput settings
        for the specified global secondary
                    index.</p>
                <p>For current
        minimum and maximum provisioned throughput values, see <a
        href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Limits.html">Service,

        Account, and Table Quotas</a> in the <i>Amazon DynamoDB Developer

        Guide</i>.</p>
        """
        self.index_name = index_name
        self.key_schema = key_schema
        self.projection = projection
        self.provisioned_throughput = provisioned_throughput

    def as_dict(self) -> Dict[str, Any]:
        """Converts the CreateGlobalSecondaryIndexAction to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        d: Dict[str, Any] = {
            "IndexName": self.index_name,
            "KeySchema": _key_schema_as_dict(self.key_schema),
            "Projection": self.projection.as_dict(),
        }

        if self.provisioned_throughput is not None:
            d["ProvisionedThroughput"] = self.provisioned_throughput.as_dict()

        return d

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "CreateGlobalSecondaryIndexAction":
        """Creates a CreateGlobalSecondaryIndexAction from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {
            "index_name": d["IndexName"],
            "key_schema": _key_schema_from_dict(d["KeySchema"]),
            "projection": Projection.from_dict(d["Projection"]),
        }

        if "ProvisionedThroughput" in d:
            kwargs["provisioned_throughput"] = ProvisionedThroughput.from_dict(d["ProvisionedThroughput"])

        return CreateGlobalSecondaryIndexAction(**kwargs)

    def __repr__(self) -> str:
        result = "CreateGlobalSecondaryIndexAction("
        if self.index_name is not None:
            result += f"index_name={repr(self.index_name)}, "

        if self.key_schema is not None:
            result += f"key_schema={repr(self.key_schema)}, "

        if self.projection is not None:
            result += f"projection={repr(self.projection)}, "

        if self.provisioned_throughput is not None:
            result += f"provisioned_throughput={repr(self.provisioned_throughput)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, CreateGlobalSecondaryIndexAction):
            return False
        attributes: list[str] = ['index_name','key_schema','projection','provisioned_throughput',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class Replica:
    region_name: Optional[str]
    def __init__(
        self,
        *,
        region_name: Optional[str] = None,
    ):
        """<p>Represents the properties of a replica.</p>

        :param region_name: <p>The Region where the replica needs to be created.</p>
        """
        self.region_name = region_name

    def as_dict(self) -> Dict[str, Any]:
        """Converts the Replica to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        d: Dict[str, Any] = {}

        if self.region_name is not None:
            d["RegionName"] = self.region_name

        return d

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "Replica":
        """Creates a Replica from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {}

        if "RegionName" in d:
            kwargs["region_name"] = d["RegionName"]

        return Replica(**kwargs)

    def __repr__(self) -> str:
        result = "Replica("
        if self.region_name is not None:
            result += f"region_name={repr(self.region_name)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, Replica):
            return False
        attributes: list[str] = ['region_name',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class CreateGlobalTableInput:
    global_table_name: str
    replication_group: list[Replica]
    def __init__(
        self,
        *,
        global_table_name: str,
        replication_group: list[Replica],
    ):
        """
        :param global_table_name: <p>The global table name.</p>
        :param replication_group: <p>The Regions where the global table needs to be
        created.</p>
        """
        self.global_table_name = global_table_name
        self.replication_group = replication_group

    def as_dict(self) -> Dict[str, Any]:
        """Converts the CreateGlobalTableInput to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        return {
            "GlobalTableName": self.global_table_name,
            "ReplicationGroup": _replica_list_as_dict(self.replication_group),
        }

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "CreateGlobalTableInput":
        """Creates a CreateGlobalTableInput from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {
            "global_table_name": d["GlobalTableName"],
            "replication_group": _replica_list_from_dict(d["ReplicationGroup"]),
        }

        return CreateGlobalTableInput(**kwargs)

    def __repr__(self) -> str:
        result = "CreateGlobalTableInput("
        if self.global_table_name is not None:
            result += f"global_table_name={repr(self.global_table_name)}, "

        if self.replication_group is not None:
            result += f"replication_group={repr(self.replication_group)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, CreateGlobalTableInput):
            return False
        attributes: list[str] = ['global_table_name','replication_group',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class ProvisionedThroughputOverride:
    read_capacity_units: Optional[int]
    def __init__(
        self,
        *,
        read_capacity_units: Optional[int] = None,
    ):
        """<p>Replica-specific provisioned throughput settings. If not specified, uses the
        source
                    table's provisioned throughput settings.</p>

        :param read_capacity_units: <p>Replica-specific read capacity units. If not
        specified, uses the source table's read
                    capacity settings.</p>
        """
        self.read_capacity_units = read_capacity_units

    def as_dict(self) -> Dict[str, Any]:
        """Converts the ProvisionedThroughputOverride to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        d: Dict[str, Any] = {}

        if self.read_capacity_units is not None:
            d["ReadCapacityUnits"] = self.read_capacity_units

        return d

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "ProvisionedThroughputOverride":
        """Creates a ProvisionedThroughputOverride from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {}

        if "ReadCapacityUnits" in d:
            kwargs["read_capacity_units"] = d["ReadCapacityUnits"]

        return ProvisionedThroughputOverride(**kwargs)

    def __repr__(self) -> str:
        result = "ProvisionedThroughputOverride("
        if self.read_capacity_units is not None:
            result += f"read_capacity_units={repr(self.read_capacity_units)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, ProvisionedThroughputOverride):
            return False
        attributes: list[str] = ['read_capacity_units',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class ReplicaGlobalSecondaryIndexDescription:
    index_name: Optional[str]
    provisioned_throughput_override: Optional[ProvisionedThroughputOverride]
    def __init__(
        self,
        *,
        index_name: Optional[str] = None,
        provisioned_throughput_override: Optional[ProvisionedThroughputOverride] = None,
    ):
        """<p>Represents the properties of a replica global secondary index.</p>

        :param index_name: <p>The name of the global secondary index.</p>
        :param provisioned_throughput_override: <p>If not described, uses the source
        table GSI's read capacity settings.</p>
        """
        self.index_name = index_name
        self.provisioned_throughput_override = provisioned_throughput_override

    def as_dict(self) -> Dict[str, Any]:
        """Converts the ReplicaGlobalSecondaryIndexDescription to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        d: Dict[str, Any] = {}

        if self.index_name is not None:
            d["IndexName"] = self.index_name

        if self.provisioned_throughput_override is not None:
            d["ProvisionedThroughputOverride"] = self.provisioned_throughput_override.as_dict()

        return d

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "ReplicaGlobalSecondaryIndexDescription":
        """Creates a ReplicaGlobalSecondaryIndexDescription from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {}

        if "IndexName" in d:
            kwargs["index_name"] = d["IndexName"]

        if "ProvisionedThroughputOverride" in d:
            kwargs["provisioned_throughput_override"] = ProvisionedThroughputOverride.from_dict(d["ProvisionedThroughputOverride"])

        return ReplicaGlobalSecondaryIndexDescription(**kwargs)

    def __repr__(self) -> str:
        result = "ReplicaGlobalSecondaryIndexDescription("
        if self.index_name is not None:
            result += f"index_name={repr(self.index_name)}, "

        if self.provisioned_throughput_override is not None:
            result += f"provisioned_throughput_override={repr(self.provisioned_throughput_override)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, ReplicaGlobalSecondaryIndexDescription):
            return False
        attributes: list[str] = ['index_name','provisioned_throughput_override',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class TableClassSummary:
    table_class: Optional[str]
    last_update_date_time: Optional[datetime]
    def __init__(
        self,
        *,
        table_class: Optional[str] = None,
        last_update_date_time: Optional[datetime] = None,
    ):
        """<p>Contains details of the table class.</p>

        :param table_class: <p>The table class of the specified table. Valid values are
        <code>STANDARD</code> and

        <code>STANDARD_INFREQUENT_ACCESS</code>.</p>
        :param last_update_date_time: <p>The date and time at which the table class was
        last updated.</p>
        """
        self.table_class = table_class
        self.last_update_date_time = last_update_date_time

    def as_dict(self) -> Dict[str, Any]:
        """Converts the TableClassSummary to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        d: Dict[str, Any] = {}

        if self.table_class is not None:
            d["TableClass"] = self.table_class

        if self.last_update_date_time is not None:
            d["LastUpdateDateTime"] = self.last_update_date_time

        return d

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "TableClassSummary":
        """Creates a TableClassSummary from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {}

        if "TableClass" in d:
            kwargs["table_class"] = d["TableClass"]

        if "LastUpdateDateTime" in d:
            kwargs["last_update_date_time"] = d["LastUpdateDateTime"]

        return TableClassSummary(**kwargs)

    def __repr__(self) -> str:
        result = "TableClassSummary("
        if self.table_class is not None:
            result += f"table_class={repr(self.table_class)}, "

        if self.last_update_date_time is not None:
            result += f"last_update_date_time={repr(self.last_update_date_time)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, TableClassSummary):
            return False
        attributes: list[str] = ['table_class','last_update_date_time',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class ReplicaDescription:
    region_name: Optional[str]
    replica_status: Optional[str]
    replica_status_description: Optional[str]
    replica_status_percent_progress: Optional[str]
    kms_master_key_id: Optional[str]
    provisioned_throughput_override: Optional[ProvisionedThroughputOverride]
    global_secondary_indexes: Optional[list[ReplicaGlobalSecondaryIndexDescription]]
    replica_inaccessible_date_time: Optional[datetime]
    replica_table_class_summary: Optional[TableClassSummary]
    def __init__(
        self,
        *,
        region_name: Optional[str] = None,
        replica_status: Optional[str] = None,
        replica_status_description: Optional[str] = None,
        replica_status_percent_progress: Optional[str] = None,
        kms_master_key_id: Optional[str] = None,
        provisioned_throughput_override: Optional[ProvisionedThroughputOverride] = None,
        global_secondary_indexes: Optional[list[ReplicaGlobalSecondaryIndexDescription]] = None,
        replica_inaccessible_date_time: Optional[datetime] = None,
        replica_table_class_summary: Optional[TableClassSummary] = None,
    ):
        """<p>Contains the details of the replica.</p>

        :param region_name: <p>The name of the Region.</p>
        :param replica_status: <p>The current state of the replica:</p>
                <ul>

        <li>
                        <p>
                            <code>CREATING</code> - The replica
        is being created.</p>
                    </li>
                    <li>
                        <p>

        <code>UPDATING</code> - The replica is being updated.</p>
                    </li>

        <li>
                        <p>
                            <code>DELETING</code> - The replica
        is being deleted.</p>
                    </li>
                    <li>
                        <p>

        <code>ACTIVE</code> - The replica is ready for use.</p>
                    </li>

        <li>
                        <p>
                            <code>REGION_DISABLED</code> - The
        replica is inaccessible because the Amazon Web Services Region has been
        disabled.</p>
                        <note>
                            <p>If the Amazon Web
        Services Region remains inaccessible for more than 20

        hours, DynamoDB will remove this replica from the replication

        group. The replica will not be deleted and replication will stop from and to

        this region.</p>
                        </note>
                    </li>
                    <li>

        <p>
                          <code>INACCESSIBLE_ENCRYPTION_CREDENTIALS </code> - The
        KMS key
                            used to encrypt the table is inaccessible.</p>

        <note>
                            <p>If the KMS key remains inaccessible for more than
        20 hours,
                                    DynamoDB will remove this replica from the
        replication group.
                                The replica will not be deleted and
        replication will stop from and to this
                                region.</p>

        </note>
                    </li>
                 </ul>
        :param replica_status_description: <p>Detailed information about the replica
        status.</p>
        :param replica_status_percent_progress: <p>Specifies the progress of a Create,
        Update, or Delete action on the replica as a
                    percentage.</p>
        :param kms_master_key_id: <p>The KMS key of the replica that will be used for

        KMS encryption.</p>
        :param provisioned_throughput_override: <p>Replica-specific provisioned
        throughput. If not described, uses the source table's
                    provisioned
        throughput settings.</p>
        :param global_secondary_indexes: <p>Replica-specific global secondary index
        settings.</p>
        :param replica_inaccessible_date_time: <p>The time at which the replica was
        first detected as inaccessible. To determine cause
                    of
        inaccessibility check the <code>ReplicaStatus</code> property.</p>
        :param replica_table_class_summary: <p>Contains details of the table class.</p>
        """
        self.region_name = region_name
        self.replica_status = replica_status
        self.replica_status_description = replica_status_description
        self.replica_status_percent_progress = replica_status_percent_progress
        self.kms_master_key_id = kms_master_key_id
        self.provisioned_throughput_override = provisioned_throughput_override
        self.global_secondary_indexes = global_secondary_indexes
        self.replica_inaccessible_date_time = replica_inaccessible_date_time
        self.replica_table_class_summary = replica_table_class_summary

    def as_dict(self) -> Dict[str, Any]:
        """Converts the ReplicaDescription to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        d: Dict[str, Any] = {}

        if self.region_name is not None:
            d["RegionName"] = self.region_name

        if self.replica_status is not None:
            d["ReplicaStatus"] = self.replica_status

        if self.replica_status_description is not None:
            d["ReplicaStatusDescription"] = self.replica_status_description

        if self.replica_status_percent_progress is not None:
            d["ReplicaStatusPercentProgress"] = self.replica_status_percent_progress

        if self.kms_master_key_id is not None:
            d["KMSMasterKeyId"] = self.kms_master_key_id

        if self.provisioned_throughput_override is not None:
            d["ProvisionedThroughputOverride"] = self.provisioned_throughput_override.as_dict()

        if self.global_secondary_indexes is not None:
            d["GlobalSecondaryIndexes"] = _replica_global_secondary_index_description_list_as_dict(self.global_secondary_indexes),

        if self.replica_inaccessible_date_time is not None:
            d["ReplicaInaccessibleDateTime"] = self.replica_inaccessible_date_time

        if self.replica_table_class_summary is not None:
            d["ReplicaTableClassSummary"] = self.replica_table_class_summary.as_dict()

        return d

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "ReplicaDescription":
        """Creates a ReplicaDescription from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {}

        if "RegionName" in d:
            kwargs["region_name"] = d["RegionName"]

        if "ReplicaStatus" in d:
            kwargs["replica_status"] = d["ReplicaStatus"]

        if "ReplicaStatusDescription" in d:
            kwargs["replica_status_description"] = d["ReplicaStatusDescription"]

        if "ReplicaStatusPercentProgress" in d:
            kwargs["replica_status_percent_progress"] = d["ReplicaStatusPercentProgress"]

        if "KMSMasterKeyId" in d:
            kwargs["kms_master_key_id"] = d["KMSMasterKeyId"]

        if "ProvisionedThroughputOverride" in d:
            kwargs["provisioned_throughput_override"] = ProvisionedThroughputOverride.from_dict(d["ProvisionedThroughputOverride"])

        if "GlobalSecondaryIndexes" in d:
            kwargs["global_secondary_indexes"] = _replica_global_secondary_index_description_list_from_dict(d["GlobalSecondaryIndexes"]),

        if "ReplicaInaccessibleDateTime" in d:
            kwargs["replica_inaccessible_date_time"] = d["ReplicaInaccessibleDateTime"]

        if "ReplicaTableClassSummary" in d:
            kwargs["replica_table_class_summary"] = TableClassSummary.from_dict(d["ReplicaTableClassSummary"])

        return ReplicaDescription(**kwargs)

    def __repr__(self) -> str:
        result = "ReplicaDescription("
        if self.region_name is not None:
            result += f"region_name={repr(self.region_name)}, "

        if self.replica_status is not None:
            result += f"replica_status={repr(self.replica_status)}, "

        if self.replica_status_description is not None:
            result += f"replica_status_description={repr(self.replica_status_description)}, "

        if self.replica_status_percent_progress is not None:
            result += f"replica_status_percent_progress={repr(self.replica_status_percent_progress)}, "

        if self.kms_master_key_id is not None:
            result += f"kms_master_key_id={repr(self.kms_master_key_id)}, "

        if self.provisioned_throughput_override is not None:
            result += f"provisioned_throughput_override={repr(self.provisioned_throughput_override)}, "

        if self.global_secondary_indexes is not None:
            result += f"global_secondary_indexes={repr(self.global_secondary_indexes)}, "

        if self.replica_inaccessible_date_time is not None:
            result += f"replica_inaccessible_date_time={repr(self.replica_inaccessible_date_time)}, "

        if self.replica_table_class_summary is not None:
            result += f"replica_table_class_summary={repr(self.replica_table_class_summary)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, ReplicaDescription):
            return False
        attributes: list[str] = ['region_name','replica_status','replica_status_description','replica_status_percent_progress','kms_master_key_id','provisioned_throughput_override','global_secondary_indexes','replica_inaccessible_date_time','replica_table_class_summary',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class GlobalTableDescription:
    replication_group: Optional[list[ReplicaDescription]]
    global_table_arn: Optional[str]
    creation_date_time: Optional[datetime]
    global_table_status: Optional[str]
    global_table_name: Optional[str]
    def __init__(
        self,
        *,
        replication_group: Optional[list[ReplicaDescription]] = None,
        global_table_arn: Optional[str] = None,
        creation_date_time: Optional[datetime] = None,
        global_table_status: Optional[str] = None,
        global_table_name: Optional[str] = None,
    ):
        """<p>Contains details about the global table.</p>

        :param replication_group: <p>The Regions where the global table has
        replicas.</p>
        :param global_table_arn: <p>The unique identifier of the global table.</p>
        :param creation_date_time: <p>The creation time of the global table.</p>
        :param global_table_status: <p>The current state of the global table:</p>

        <ul>
                    <li>
                        <p>

        <code>CREATING</code> - The global table is being created.</p>

        </li>
                    <li>
                        <p>

        <code>UPDATING</code> - The global table is being updated.</p>

        </li>
                    <li>
                        <p>

        <code>DELETING</code> - The global table is being deleted.</p>

        </li>
                    <li>
                        <p>

        <code>ACTIVE</code> - The global table is ready for use.</p>
                    </li>

        </ul>
        :param global_table_name: <p>The global table name.</p>
        """
        self.replication_group = replication_group
        self.global_table_arn = global_table_arn
        self.creation_date_time = creation_date_time
        self.global_table_status = global_table_status
        self.global_table_name = global_table_name

    def as_dict(self) -> Dict[str, Any]:
        """Converts the GlobalTableDescription to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        d: Dict[str, Any] = {}

        if self.replication_group is not None:
            d["ReplicationGroup"] = _replica_description_list_as_dict(self.replication_group),

        if self.global_table_arn is not None:
            d["GlobalTableArn"] = self.global_table_arn

        if self.creation_date_time is not None:
            d["CreationDateTime"] = self.creation_date_time

        if self.global_table_status is not None:
            d["GlobalTableStatus"] = self.global_table_status

        if self.global_table_name is not None:
            d["GlobalTableName"] = self.global_table_name

        return d

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "GlobalTableDescription":
        """Creates a GlobalTableDescription from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {}

        if "ReplicationGroup" in d:
            kwargs["replication_group"] = _replica_description_list_from_dict(d["ReplicationGroup"]),

        if "GlobalTableArn" in d:
            kwargs["global_table_arn"] = d["GlobalTableArn"]

        if "CreationDateTime" in d:
            kwargs["creation_date_time"] = d["CreationDateTime"]

        if "GlobalTableStatus" in d:
            kwargs["global_table_status"] = d["GlobalTableStatus"]

        if "GlobalTableName" in d:
            kwargs["global_table_name"] = d["GlobalTableName"]

        return GlobalTableDescription(**kwargs)

    def __repr__(self) -> str:
        result = "GlobalTableDescription("
        if self.replication_group is not None:
            result += f"replication_group={repr(self.replication_group)}, "

        if self.global_table_arn is not None:
            result += f"global_table_arn={repr(self.global_table_arn)}, "

        if self.creation_date_time is not None:
            result += f"creation_date_time={repr(self.creation_date_time)}, "

        if self.global_table_status is not None:
            result += f"global_table_status={repr(self.global_table_status)}, "

        if self.global_table_name is not None:
            result += f"global_table_name={repr(self.global_table_name)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, GlobalTableDescription):
            return False
        attributes: list[str] = ['replication_group','global_table_arn','creation_date_time','global_table_status','global_table_name',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class CreateGlobalTableOutput:
    global_table_description: Optional[GlobalTableDescription]
    def __init__(
        self,
        *,
        global_table_description: Optional[GlobalTableDescription] = None,
    ):
        """
        :param global_table_description: <p>Contains the details of the global
        table.</p>
        """
        self.global_table_description = global_table_description

    def as_dict(self) -> Dict[str, Any]:
        """Converts the CreateGlobalTableOutput to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        d: Dict[str, Any] = {}

        if self.global_table_description is not None:
            d["GlobalTableDescription"] = self.global_table_description.as_dict()

        return d

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "CreateGlobalTableOutput":
        """Creates a CreateGlobalTableOutput from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {}

        if "GlobalTableDescription" in d:
            kwargs["global_table_description"] = GlobalTableDescription.from_dict(d["GlobalTableDescription"])

        return CreateGlobalTableOutput(**kwargs)

    def __repr__(self) -> str:
        result = "CreateGlobalTableOutput("
        if self.global_table_description is not None:
            result += f"global_table_description={repr(self.global_table_description)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, CreateGlobalTableOutput):
            return False
        attributes: list[str] = ['global_table_description',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class CreateReplicaAction:
    region_name: str
    def __init__(
        self,
        *,
        region_name: str,
    ):
        """<p>Represents a replica to be added.</p>

        :param region_name: <p>The Region of the replica to be added.</p>
        """
        self.region_name = region_name

    def as_dict(self) -> Dict[str, Any]:
        """Converts the CreateReplicaAction to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        return {
            "RegionName": self.region_name,
        }

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "CreateReplicaAction":
        """Creates a CreateReplicaAction from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {
            "region_name": d["RegionName"],
        }

        return CreateReplicaAction(**kwargs)

    def __repr__(self) -> str:
        result = "CreateReplicaAction("
        if self.region_name is not None:
            result += f"region_name={repr(self.region_name)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, CreateReplicaAction):
            return False
        attributes: list[str] = ['region_name',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class ReplicaGlobalSecondaryIndex:
    index_name: str
    provisioned_throughput_override: Optional[ProvisionedThroughputOverride]
    def __init__(
        self,
        *,
        index_name: str,
        provisioned_throughput_override: Optional[ProvisionedThroughputOverride] = None,
    ):
        """<p>Represents the properties of a replica global secondary index.</p>

        :param index_name: <p>The name of the global secondary index.</p>
        :param provisioned_throughput_override: <p>Replica table GSI-specific
        provisioned throughput. If not specified, uses the source
                    table
        GSI's read capacity settings.</p>
        """
        self.index_name = index_name
        self.provisioned_throughput_override = provisioned_throughput_override

    def as_dict(self) -> Dict[str, Any]:
        """Converts the ReplicaGlobalSecondaryIndex to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        d: Dict[str, Any] = {
            "IndexName": self.index_name,
        }

        if self.provisioned_throughput_override is not None:
            d["ProvisionedThroughputOverride"] = self.provisioned_throughput_override.as_dict()

        return d

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "ReplicaGlobalSecondaryIndex":
        """Creates a ReplicaGlobalSecondaryIndex from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {
            "index_name": d["IndexName"],
        }

        if "ProvisionedThroughputOverride" in d:
            kwargs["provisioned_throughput_override"] = ProvisionedThroughputOverride.from_dict(d["ProvisionedThroughputOverride"])

        return ReplicaGlobalSecondaryIndex(**kwargs)

    def __repr__(self) -> str:
        result = "ReplicaGlobalSecondaryIndex("
        if self.index_name is not None:
            result += f"index_name={repr(self.index_name)}, "

        if self.provisioned_throughput_override is not None:
            result += f"provisioned_throughput_override={repr(self.provisioned_throughput_override)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, ReplicaGlobalSecondaryIndex):
            return False
        attributes: list[str] = ['index_name','provisioned_throughput_override',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class CreateReplicationGroupMemberAction:
    region_name: str
    kms_master_key_id: Optional[str]
    provisioned_throughput_override: Optional[ProvisionedThroughputOverride]
    global_secondary_indexes: Optional[list[ReplicaGlobalSecondaryIndex]]
    table_class_override: Optional[str]
    def __init__(
        self,
        *,
        region_name: str,
        kms_master_key_id: Optional[str] = None,
        provisioned_throughput_override: Optional[ProvisionedThroughputOverride] = None,
        global_secondary_indexes: Optional[list[ReplicaGlobalSecondaryIndex]] = None,
        table_class_override: Optional[str] = None,
    ):
        """<p>Represents a replica to be created.</p>

        :param region_name: <p>The Region where the new replica will be created.</p>
        :param kms_master_key_id: <p>The KMS key that should be used for KMS encryption
        in
                    the new replica. To specify a key, use its key ID, Amazon
        Resource Name (ARN), alias
                    name, or alias ARN. Note that you should
        only provide this parameter if the key is
                    different from the default
        DynamoDB KMS key
                    <code>alias/aws/dynamodb</code>.</p>
        :param provisioned_throughput_override: <p>Replica-specific provisioned
        throughput. If not specified, uses the source table's
                    provisioned
        throughput settings.</p>
        :param global_secondary_indexes: <p>Replica-specific global secondary index
        settings.</p>
        :param table_class_override: <p>Replica-specific table class. If not specified,
        uses the source table's
                    table class.</p>
        """
        self.region_name = region_name
        self.kms_master_key_id = kms_master_key_id
        self.provisioned_throughput_override = provisioned_throughput_override
        self.global_secondary_indexes = global_secondary_indexes
        self.table_class_override = table_class_override

    def as_dict(self) -> Dict[str, Any]:
        """Converts the CreateReplicationGroupMemberAction to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        d: Dict[str, Any] = {
            "RegionName": self.region_name,
        }

        if self.kms_master_key_id is not None:
            d["KMSMasterKeyId"] = self.kms_master_key_id

        if self.provisioned_throughput_override is not None:
            d["ProvisionedThroughputOverride"] = self.provisioned_throughput_override.as_dict()

        if self.global_secondary_indexes is not None:
            d["GlobalSecondaryIndexes"] = _replica_global_secondary_index_list_as_dict(self.global_secondary_indexes),

        if self.table_class_override is not None:
            d["TableClassOverride"] = self.table_class_override

        return d

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "CreateReplicationGroupMemberAction":
        """Creates a CreateReplicationGroupMemberAction from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {
            "region_name": d["RegionName"],
        }

        if "KMSMasterKeyId" in d:
            kwargs["kms_master_key_id"] = d["KMSMasterKeyId"]

        if "ProvisionedThroughputOverride" in d:
            kwargs["provisioned_throughput_override"] = ProvisionedThroughputOverride.from_dict(d["ProvisionedThroughputOverride"])

        if "GlobalSecondaryIndexes" in d:
            kwargs["global_secondary_indexes"] = _replica_global_secondary_index_list_from_dict(d["GlobalSecondaryIndexes"]),

        if "TableClassOverride" in d:
            kwargs["table_class_override"] = d["TableClassOverride"]

        return CreateReplicationGroupMemberAction(**kwargs)

    def __repr__(self) -> str:
        result = "CreateReplicationGroupMemberAction("
        if self.region_name is not None:
            result += f"region_name={repr(self.region_name)}, "

        if self.kms_master_key_id is not None:
            result += f"kms_master_key_id={repr(self.kms_master_key_id)}, "

        if self.provisioned_throughput_override is not None:
            result += f"provisioned_throughput_override={repr(self.provisioned_throughput_override)}, "

        if self.global_secondary_indexes is not None:
            result += f"global_secondary_indexes={repr(self.global_secondary_indexes)}, "

        if self.table_class_override is not None:
            result += f"table_class_override={repr(self.table_class_override)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, CreateReplicationGroupMemberAction):
            return False
        attributes: list[str] = ['region_name','kms_master_key_id','provisioned_throughput_override','global_secondary_indexes','table_class_override',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class GlobalSecondaryIndex:
    index_name: str
    key_schema: list[KeySchemaElement]
    projection: Projection
    provisioned_throughput: Optional[ProvisionedThroughput]
    def __init__(
        self,
        *,
        index_name: str,
        key_schema: list[KeySchemaElement],
        projection: Projection,
        provisioned_throughput: Optional[ProvisionedThroughput] = None,
    ):
        """<p>Represents the properties of a global secondary index.</p>

        :param index_name: <p>The name of the global secondary index. The name must be
        unique among all other
                    indexes on this table.</p>
        :param key_schema: <p>The complete key schema for a global secondary index,
        which consists of one or more
                    pairs of attribute names and key
        types:</p>
                <ul>
                    <li>
                        <p>

        <code>HASH</code> - partition key</p>
                    </li>
                    <li>

        <p>
                            <code>RANGE</code> - sort key</p>
                    </li>

        </ul>
                <note>
                    <p>The partition key of an item is also known
        as its <i>hash
                            attribute</i>. The term "hash attribute"
        derives from DynamoDB's usage of
                        an internal hash function to
        evenly distribute data items across partitions, based
                        on their
        partition key values.</p>
                    <p>The sort key of an item is also known
        as its <i>range attribute</i>.
                        The term "range attribute"
        derives from the way DynamoDB stores items with the same

        partition key physically close together, in sorted order by the sort key

        value.</p>
                </note>
        :param projection: <p>Represents attributes that are copied (projected) from the
        table into the global
                    secondary index. These are in addition to the
        primary key attributes and index key
                    attributes, which are
        automatically projected. </p>
        :param provisioned_throughput: <p>Represents the provisioned throughput settings
        for the specified global secondary
                    index.</p>
                <p>For current
        minimum and maximum provisioned throughput values, see <a
        href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Limits.html">Service,

        Account, and Table Quotas</a> in the <i>Amazon DynamoDB Developer

        Guide</i>.</p>
        """
        self.index_name = index_name
        self.key_schema = key_schema
        self.projection = projection
        self.provisioned_throughput = provisioned_throughput

    def as_dict(self) -> Dict[str, Any]:
        """Converts the GlobalSecondaryIndex to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        d: Dict[str, Any] = {
            "IndexName": self.index_name,
            "KeySchema": _key_schema_as_dict(self.key_schema),
            "Projection": self.projection.as_dict(),
        }

        if self.provisioned_throughput is not None:
            d["ProvisionedThroughput"] = self.provisioned_throughput.as_dict()

        return d

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "GlobalSecondaryIndex":
        """Creates a GlobalSecondaryIndex from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {
            "index_name": d["IndexName"],
            "key_schema": _key_schema_from_dict(d["KeySchema"]),
            "projection": Projection.from_dict(d["Projection"]),
        }

        if "ProvisionedThroughput" in d:
            kwargs["provisioned_throughput"] = ProvisionedThroughput.from_dict(d["ProvisionedThroughput"])

        return GlobalSecondaryIndex(**kwargs)

    def __repr__(self) -> str:
        result = "GlobalSecondaryIndex("
        if self.index_name is not None:
            result += f"index_name={repr(self.index_name)}, "

        if self.key_schema is not None:
            result += f"key_schema={repr(self.key_schema)}, "

        if self.projection is not None:
            result += f"projection={repr(self.projection)}, "

        if self.provisioned_throughput is not None:
            result += f"provisioned_throughput={repr(self.provisioned_throughput)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, GlobalSecondaryIndex):
            return False
        attributes: list[str] = ['index_name','key_schema','projection','provisioned_throughput',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class LocalSecondaryIndex:
    index_name: str
    key_schema: list[KeySchemaElement]
    projection: Projection
    def __init__(
        self,
        *,
        index_name: str,
        key_schema: list[KeySchemaElement],
        projection: Projection,
    ):
        """<p>Represents the properties of a local secondary index.</p>

        :param index_name: <p>The name of the local secondary index. The name must be
        unique among all other indexes
                    on this table.</p>
        :param key_schema: <p>The complete key schema for the local secondary index,
        consisting of one or more pairs
                    of attribute names and key
        types:</p>
                <ul>
                    <li>
                        <p>

        <code>HASH</code> - partition key</p>
                    </li>
                    <li>

        <p>
                            <code>RANGE</code> - sort key</p>
                    </li>

        </ul>
                <note>
                    <p>The partition key of an item is also known
        as its <i>hash
                            attribute</i>. The term "hash attribute"
        derives from DynamoDB's usage of
                        an internal hash function to
        evenly distribute data items across partitions, based
                        on their
        partition key values.</p>
                    <p>The sort key of an item is also known
        as its <i>range attribute</i>.
                        The term "range attribute"
        derives from the way DynamoDB stores items with the same

        partition key physically close together, in sorted order by the sort key

        value.</p>
                </note>
        :param projection: <p>Represents attributes that are copied (projected) from the
        table into the local
                    secondary index. These are in addition to the
        primary key attributes and index key
                    attributes, which are
        automatically projected. </p>
        """
        self.index_name = index_name
        self.key_schema = key_schema
        self.projection = projection

    def as_dict(self) -> Dict[str, Any]:
        """Converts the LocalSecondaryIndex to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        return {
            "IndexName": self.index_name,
            "KeySchema": _key_schema_as_dict(self.key_schema),
            "Projection": self.projection.as_dict(),
        }

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "LocalSecondaryIndex":
        """Creates a LocalSecondaryIndex from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {
            "index_name": d["IndexName"],
            "key_schema": _key_schema_from_dict(d["KeySchema"]),
            "projection": Projection.from_dict(d["Projection"]),
        }

        return LocalSecondaryIndex(**kwargs)

    def __repr__(self) -> str:
        result = "LocalSecondaryIndex("
        if self.index_name is not None:
            result += f"index_name={repr(self.index_name)}, "

        if self.key_schema is not None:
            result += f"key_schema={repr(self.key_schema)}, "

        if self.projection is not None:
            result += f"projection={repr(self.projection)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, LocalSecondaryIndex):
            return False
        attributes: list[str] = ['index_name','key_schema','projection',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class SSESpecification:
    enabled: Optional[bool]
    sse_type: Optional[str]
    kms_master_key_id: Optional[str]
    def __init__(
        self,
        *,
        enabled: Optional[bool] = None,
        sse_type: Optional[str] = None,
        kms_master_key_id: Optional[str] = None,
    ):
        """<p>Represents the settings used to enable server-side encryption.</p>

        :param enabled: <p>Indicates whether server-side encryption is done using an
        Amazon Web Services managed
                    key or an Amazon Web Services owned key.
        If enabled (true), server-side encryption type
                    is set to
        <code>KMS</code> and an Amazon Web Services managed key is used (KMS charges
        apply). If disabled (false) or not specified, server-side
                    encryption
        is set to Amazon Web Services owned key.</p>
        :param sse_type: <p>Server-side encryption type. The only supported value
        is:</p>
                <ul>
                    <li>
                        <p>

        <code>KMS</code> - Server-side encryption that uses Key Management Service. The

        key is stored in your account and is managed by KMS (KMS charges apply).</p>

        </li>
                 </ul>
        :param kms_master_key_id: <p>The KMS key that should be used for the KMS
        encryption.
                    To specify a key, use its key ID, Amazon Resource Name
        (ARN), alias name, or alias ARN.
                    Note that you should only provide
        this parameter if the key is different from the
                    default DynamoDB key
        <code>alias/aws/dynamodb</code>.</p>
        """
        self.enabled = enabled
        self.sse_type = sse_type
        self.kms_master_key_id = kms_master_key_id

    def as_dict(self) -> Dict[str, Any]:
        """Converts the SSESpecification to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        d: Dict[str, Any] = {}

        if self.enabled is not None:
            d["Enabled"] = self.enabled

        if self.sse_type is not None:
            d["SSEType"] = self.sse_type

        if self.kms_master_key_id is not None:
            d["KMSMasterKeyId"] = self.kms_master_key_id

        return d

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "SSESpecification":
        """Creates a SSESpecification from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {}

        if "Enabled" in d:
            kwargs["enabled"] = d["Enabled"]

        if "SSEType" in d:
            kwargs["sse_type"] = d["SSEType"]

        if "KMSMasterKeyId" in d:
            kwargs["kms_master_key_id"] = d["KMSMasterKeyId"]

        return SSESpecification(**kwargs)

    def __repr__(self) -> str:
        result = "SSESpecification("
        if self.enabled is not None:
            result += f"enabled={repr(self.enabled)}, "

        if self.sse_type is not None:
            result += f"sse_type={repr(self.sse_type)}, "

        if self.kms_master_key_id is not None:
            result += f"kms_master_key_id={repr(self.kms_master_key_id)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, SSESpecification):
            return False
        attributes: list[str] = ['enabled','sse_type','kms_master_key_id',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class Tag:
    key: str
    value: str
    def __init__(
        self,
        *,
        key: str,
        value: str,
    ):
        """<p>Describes a tag. A tag is a key-value pair. You can add up to 50 tags to a
        single
                    DynamoDB table. </p>
                <p>Amazon Web Services-assigned
        tag names and values are automatically assigned the

        <code>aws:</code> prefix, which the user cannot assign. Amazon Web
        Services-assigned
                    tag names do not count towards the tag limit of
        50. User-assigned tag names have the
                    prefix <code>user:</code> in
        the Cost Allocation Report. You cannot backdate the
                    application of a
        tag.</p>
                <p>For an overview on tagging DynamoDB resources, see <a
        href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Tagging.html">Tagging

        for DynamoDB</a> in the <i>Amazon DynamoDB Developer

        Guide</i>.</p>

        :param key: <p>The key of the tag. Tag keys are case sensitive. Each DynamoDB
        table can
                    only have up to one tag with the same key. If you try to
        add an existing tag (same key),
                    the existing tag value will be
        updated to the new value.</p>
        :param value: <p>The value of the tag. Tag values are case-sensitive and can be
        null.</p>
        """
        self.key = key
        self.value = value

    def as_dict(self) -> Dict[str, Any]:
        """Converts the Tag to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        return {
            "Key": self.key,
            "Value": self.value,
        }

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "Tag":
        """Creates a Tag from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {
            "key": d["Key"],
            "value": d["Value"],
        }

        return Tag(**kwargs)

    def __repr__(self) -> str:
        result = "Tag("
        if self.key is not None:
            result += f"key={repr(self.key)}, "

        if self.value is not None:
            result += f"value={repr(self.value)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, Tag):
            return False
        attributes: list[str] = ['key','value',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class CreateTableInput:
    attribute_definitions: list[AttributeDefinition]
    table_name: str
    key_schema: list[KeySchemaElement]
    local_secondary_indexes: Optional[list[LocalSecondaryIndex]]
    global_secondary_indexes: Optional[list[GlobalSecondaryIndex]]
    billing_mode: Optional[str]
    provisioned_throughput: Optional[ProvisionedThroughput]
    stream_specification: Optional[StreamSpecification]
    sse_specification: Optional[SSESpecification]
    tags: Optional[list[Tag]]
    table_class: Optional[str]
    def __init__(
        self,
        *,
        attribute_definitions: list[AttributeDefinition],
        table_name: str,
        key_schema: list[KeySchemaElement],
        local_secondary_indexes: Optional[list[LocalSecondaryIndex]] = None,
        global_secondary_indexes: Optional[list[GlobalSecondaryIndex]] = None,
        billing_mode: Optional[str] = None,
        provisioned_throughput: Optional[ProvisionedThroughput] = None,
        stream_specification: Optional[StreamSpecification] = None,
        sse_specification: Optional[SSESpecification] = None,
        tags: Optional[list[Tag]] = None,
        table_class: Optional[str] = None,
    ):
        """<p>Represents the input of a <code>CreateTable</code> operation.</p>

        :param attribute_definitions: <p>An array of attributes that describe the key
        schema for the table and indexes.</p>
        :param table_name: <p>The name of the table to create.</p>
        :param key_schema: <p>Specifies the attributes that make up the primary key for
        a table or an index. The
                    attributes in <code>KeySchema</code> must
        also be defined in the
                        <code>AttributeDefinitions</code> array.
        For more information, see <a
        href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/DataModel.html">Data

        Model</a> in the <i>Amazon DynamoDB Developer Guide</i>.</p>
                <p>Each
        <code>KeySchemaElement</code> in the array is composed of:</p>
                <ul>

        <li>
                        <p>
                            <code>AttributeName</code> - The
        name of this key attribute.</p>
                    </li>
                    <li>

        <p>
                            <code>KeyType</code> - The role that the key attribute
        will assume:</p>
                        <ul>
                          <li>

        <p>
                                    <code>HASH</code> - partition key</p>

        </li>
                          <li>
                                <p>

        <code>RANGE</code> - sort key</p>
                            </li>

        </ul>
                    </li>
                 </ul>
                <note>
                    <p>The
        partition key of an item is also known as its <i>hash

        attribute</i>. The term "hash attribute" derives from the DynamoDB usage

        of an internal hash function to evenly distribute data items across partitions,

        based on their partition key values.</p>
                    <p>The sort key of an item
        is also known as its <i>range attribute</i>.
                        The term "range
        attribute" derives from the way DynamoDB stores items with the same

        partition key physically close together, in sorted order by the sort key

        value.</p>
                </note>

                <p>For a simple primary key (partition key),
        you must provide exactly one element with a
                        <code>KeyType</code>
        of <code>HASH</code>.</p>
                <p>For a composite primary key (partition key
        and sort key), you must provide exactly two
                    elements, in this order:
        The first element must have a <code>KeyType</code> of

        <code>HASH</code>, and the second element must have a <code>KeyType</code> of

        <code>RANGE</code>.</p>
                <p>For more information, see <a
        href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/WorkingWithTables.html#WorkingWithTables.primary.key">Working
        with Tables</a> in the <i>Amazon DynamoDB Developer

        Guide</i>.</p>
        :param local_secondary_indexes: <p>One or more local secondary indexes (the
        maximum is 5) to be created on the table.
                    Each index is scoped to a
        given partition key value. There is a 10 GB size limit per
                    partition
        key value; otherwise, the size of a local secondary index is

        unconstrained.</p>
                <p>Each local secondary index in the array includes
        the following:</p>
                <ul>
                    <li>
                        <p>

        <code>IndexName</code> - The name of the local secondary index. Must be unique

        only for this table.</p>
                        <p></p>
                    </li>

        <li>
                        <p>
                            <code>KeySchema</code> - Specifies
        the key schema for the local secondary index.
                            The key schema
        must begin with the same partition key as the table.</p>
                    </li>

        <li>
                        <p>
                            <code>Projection</code> - Specifies
        attributes that are copied (projected) from
                            the table into
        the index. These are in addition to the primary key attributes

        and index key attributes, which are automatically projected. Each attribute

        specification is composed of:</p>
                        <ul>
                          <li>

        <p>
                                    <code>ProjectionType</code> - One of the
        following:</p>
                                <ul>
                                <li>

        <p>
                                            <code>KEYS_ONLY</code> - Only the index
        and primary keys are
                                            projected into the
        index.</p>
                                    </li>
                                <li>

        <p>
                                            <code>INCLUDE</code> - Only the
        specified table attributes are
                                            projected
        into the index. The list of projected attributes is in

        <code>NonKeyAttributes</code>.</p>
                                    </li>

        <li>
                                        <p>

        <code>ALL</code> - All of the table attributes are projected

        into the index.</p>
                                    </li>

        </ul>
                            </li>
                          <li>

        <p>
                                    <code>NonKeyAttributes</code> - A list of one or
        more non-key attribute
                                    names that are projected into
        the secondary index. The total count of
                                    attributes
        provided in <code>NonKeyAttributes</code>, summed across all

        of the secondary indexes, must not exceed 100. If you project the same

        attribute into two different indexes, this counts as two distinct

        attributes when determining the total.</p>
                            </li>

        </ul>
                    </li>
                 </ul>
        :param global_secondary_indexes: <p>One or more global secondary indexes (the
        maximum is 20) to be created on the table.
                    Each global secondary
        index in the array includes the following:</p>
                <ul>
                    <li>

        <p>
                            <code>IndexName</code> - The name of the global
        secondary index. Must be unique
                            only for this table.</p>

        <p></p>
                    </li>
                    <li>
                        <p>

        <code>KeySchema</code> - Specifies the key schema for the global secondary

        index.</p>
                    </li>
                    <li>
                        <p>

        <code>Projection</code> - Specifies attributes that are copied (projected) from

        the table into the index. These are in addition to the primary key attributes

        and index key attributes, which are automatically projected. Each attribute

        specification is composed of:</p>
                        <ul>
                          <li>

        <p>
                                    <code>ProjectionType</code> - One of the
        following:</p>
                                <ul>
                                <li>

        <p>
                                            <code>KEYS_ONLY</code> - Only the index
        and primary keys are
                                            projected into the
        index.</p>
                                    </li>
                                <li>

        <p>
                                            <code>INCLUDE</code> - Only the
        specified table attributes are
                                            projected
        into the index. The list of projected attributes is in

        <code>NonKeyAttributes</code>.</p>
                                    </li>

        <li>
                                        <p>

        <code>ALL</code> - All of the table attributes are projected

        into the index.</p>
                                    </li>

        </ul>
                            </li>
                          <li>

        <p>
                                    <code>NonKeyAttributes</code> - A list of one or
        more non-key attribute
                                    names that are projected into
        the secondary index. The total count of
                                    attributes
        provided in <code>NonKeyAttributes</code>, summed across all

        of the secondary indexes, must not exceed 100. If you project the same

        attribute into two different indexes, this counts as two distinct

        attributes when determining the total.</p>
                            </li>

        </ul>
                    </li>
                    <li>
                        <p>

        <code>ProvisionedThroughput</code> - The provisioned throughput settings for
        the
                            global secondary index, consisting of read and write
        capacity units.</p>
                    </li>
                 </ul>
        :param billing_mode: <p>Controls how you are charged for read and write
        throughput and how you manage
                    capacity. This setting can be changed
        later.</p>
                <ul>
                    <li>
                        <p>

        <code>PROVISIONED</code> - We recommend using <code>PROVISIONED</code> for

        predictable workloads. <code>PROVISIONED</code> sets the billing mode to <a
        href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/HowItWorks.ReadWriteCapacityMode.html#HowItWorks.ProvisionedThroughput.Manual">Provisioned
        Mode</a>.</p>
                    </li>
                    <li>
                        <p>

        <code>PAY_PER_REQUEST</code> - We recommend using <code>PAY_PER_REQUEST</code>

        for unpredictable workloads. <code>PAY_PER_REQUEST</code> sets the billing mode

        to <a
        href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/HowItWorks.ReadWriteCapacityMode.html#HowItWorks.OnDemand">On-Demand
        Mode</a>. </p>
                    </li>
                 </ul>
        :param provisioned_throughput: <p>Represents the provisioned throughput settings
        for a specified table or index. The
                    settings can be modified using
        the <code>UpdateTable</code> operation.</p>
                <p> If you set BillingMode
        as <code>PROVISIONED</code>, you must specify this property.
                    If you
        set BillingMode as <code>PAY_PER_REQUEST</code>, you cannot specify this

        property.</p>
                <p>For current minimum and maximum provisioned throughput
        values, see <a
        href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Limits.html">Service,

        Account, and Table Quotas</a> in the <i>Amazon DynamoDB Developer

        Guide</i>.</p>
        :param stream_specification: <p>The settings for DynamoDB Streams on the table.
        These settings consist of:</p>
                <ul>
                    <li>

        <p>
                            <code>StreamEnabled</code> - Indicates whether DynamoDB
        Streams is to be enabled
                            (true) or disabled (false).</p>

        </li>
                    <li>
                        <p>

        <code>StreamViewType</code> - When an item in the table is modified,

        <code>StreamViewType</code> determines what information is written to the

        table's stream. Valid values for <code>StreamViewType</code> are:</p>

        <ul>
                          <li>
                                <p>

        <code>KEYS_ONLY</code> - Only the key attributes of the modified item

        are written to the stream.</p>
                            </li>
                          <li>

        <p>
                                    <code>NEW_IMAGE</code> - The entire item, as it
        appears after it was
                                    modified, is written to the
        stream.</p>
                            </li>
                          <li>

        <p>
                                    <code>OLD_IMAGE</code> - The entire item, as it
        appeared before it was
                                    modified, is written to the
        stream.</p>
                            </li>
                          <li>

        <p>
                                    <code>NEW_AND_OLD_IMAGES</code> - Both the new
        and the old item images
                                    of the item are written to
        the stream.</p>
                            </li>
                       </ul>

        </li>
                 </ul>
        :param sse_specification: <p>Represents the settings used to enable server-side
        encryption.</p>
        :param tags: <p>A list of key-value pairs to label the table. For more
        information, see <a
        href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Tagging.html">Tagging

        for DynamoDB</a>.</p>
        :param table_class: <p>The table class of the new table. Valid values are
        <code>STANDARD</code> and

        <code>STANDARD_INFREQUENT_ACCESS</code>.</p>
        """
        self.attribute_definitions = attribute_definitions
        self.table_name = table_name
        self.key_schema = key_schema
        self.local_secondary_indexes = local_secondary_indexes
        self.global_secondary_indexes = global_secondary_indexes
        self.billing_mode = billing_mode
        self.provisioned_throughput = provisioned_throughput
        self.stream_specification = stream_specification
        self.sse_specification = sse_specification
        self.tags = tags
        self.table_class = table_class

    def as_dict(self) -> Dict[str, Any]:
        """Converts the CreateTableInput to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        d: Dict[str, Any] = {
            "AttributeDefinitions": _attribute_definitions_as_dict(self.attribute_definitions),
            "TableName": self.table_name,
            "KeySchema": _key_schema_as_dict(self.key_schema),
        }

        if self.local_secondary_indexes is not None:
            d["LocalSecondaryIndexes"] = _local_secondary_index_list_as_dict(self.local_secondary_indexes),

        if self.global_secondary_indexes is not None:
            d["GlobalSecondaryIndexes"] = _global_secondary_index_list_as_dict(self.global_secondary_indexes),

        if self.billing_mode is not None:
            d["BillingMode"] = self.billing_mode

        if self.provisioned_throughput is not None:
            d["ProvisionedThroughput"] = self.provisioned_throughput.as_dict()

        if self.stream_specification is not None:
            d["StreamSpecification"] = self.stream_specification.as_dict()

        if self.sse_specification is not None:
            d["SSESpecification"] = self.sse_specification.as_dict()

        if self.tags is not None:
            d["Tags"] = _tag_list_as_dict(self.tags),

        if self.table_class is not None:
            d["TableClass"] = self.table_class

        return d

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "CreateTableInput":
        """Creates a CreateTableInput from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {
            "attribute_definitions": _attribute_definitions_from_dict(d["AttributeDefinitions"]),
            "table_name": d["TableName"],
            "key_schema": _key_schema_from_dict(d["KeySchema"]),
        }

        if "LocalSecondaryIndexes" in d:
            kwargs["local_secondary_indexes"] = _local_secondary_index_list_from_dict(d["LocalSecondaryIndexes"]),

        if "GlobalSecondaryIndexes" in d:
            kwargs["global_secondary_indexes"] = _global_secondary_index_list_from_dict(d["GlobalSecondaryIndexes"]),

        if "BillingMode" in d:
            kwargs["billing_mode"] = d["BillingMode"]

        if "ProvisionedThroughput" in d:
            kwargs["provisioned_throughput"] = ProvisionedThroughput.from_dict(d["ProvisionedThroughput"])

        if "StreamSpecification" in d:
            kwargs["stream_specification"] = StreamSpecification.from_dict(d["StreamSpecification"])

        if "SSESpecification" in d:
            kwargs["sse_specification"] = SSESpecification.from_dict(d["SSESpecification"])

        if "Tags" in d:
            kwargs["tags"] = _tag_list_from_dict(d["Tags"]),

        if "TableClass" in d:
            kwargs["table_class"] = d["TableClass"]

        return CreateTableInput(**kwargs)

    def __repr__(self) -> str:
        result = "CreateTableInput("
        if self.attribute_definitions is not None:
            result += f"attribute_definitions={repr(self.attribute_definitions)}, "

        if self.table_name is not None:
            result += f"table_name={repr(self.table_name)}, "

        if self.key_schema is not None:
            result += f"key_schema={repr(self.key_schema)}, "

        if self.local_secondary_indexes is not None:
            result += f"local_secondary_indexes={repr(self.local_secondary_indexes)}, "

        if self.global_secondary_indexes is not None:
            result += f"global_secondary_indexes={repr(self.global_secondary_indexes)}, "

        if self.billing_mode is not None:
            result += f"billing_mode={repr(self.billing_mode)}, "

        if self.provisioned_throughput is not None:
            result += f"provisioned_throughput={repr(self.provisioned_throughput)}, "

        if self.stream_specification is not None:
            result += f"stream_specification={repr(self.stream_specification)}, "

        if self.sse_specification is not None:
            result += f"sse_specification={repr(self.sse_specification)}, "

        if self.tags is not None:
            result += f"tags={repr(self.tags)}, "

        if self.table_class is not None:
            result += f"table_class={repr(self.table_class)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, CreateTableInput):
            return False
        attributes: list[str] = ['attribute_definitions','table_name','key_schema','local_secondary_indexes','global_secondary_indexes','billing_mode','provisioned_throughput','stream_specification','sse_specification','tags','table_class',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class ProvisionedThroughputDescription:
    last_increase_date_time: Optional[datetime]
    last_decrease_date_time: Optional[datetime]
    number_of_decreases_today: Optional[int]
    read_capacity_units: Optional[int]
    write_capacity_units: Optional[int]
    def __init__(
        self,
        *,
        last_increase_date_time: Optional[datetime] = None,
        last_decrease_date_time: Optional[datetime] = None,
        number_of_decreases_today: Optional[int] = None,
        read_capacity_units: Optional[int] = None,
        write_capacity_units: Optional[int] = None,
    ):
        """<p>Represents the provisioned throughput settings for the table, consisting of
        read and
                    write capacity units, along with data about increases and
        decreases.</p>

        :param last_increase_date_time: <p>The date and time of the last provisioned
        throughput increase for this table.</p>
        :param last_decrease_date_time: <p>The date and time of the last provisioned
        throughput decrease for this table.</p>
        :param number_of_decreases_today: <p>The number of provisioned throughput
        decreases for this table during this UTC calendar
                    day. For current
        maximums on provisioned throughput decreases, see <a
        href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Limits.html">Service,

        Account, and Table Quotas</a> in the <i>Amazon DynamoDB Developer

        Guide</i>.</p>
        :param read_capacity_units: <p>The maximum number of strongly consistent reads
        consumed per second before DynamoDB
                    returns a
        <code>ThrottlingException</code>. Eventually consistent reads require less

        effort than strongly consistent reads, so a setting of 50
        <code>ReadCapacityUnits</code>
                    per second provides 100 eventually
        consistent <code>ReadCapacityUnits</code> per
                    second.</p>
        :param write_capacity_units: <p>The maximum number of writes consumed per second
        before DynamoDB returns a
                        <code>ThrottlingException</code>.</p>
        """
        self.last_increase_date_time = last_increase_date_time
        self.last_decrease_date_time = last_decrease_date_time
        self.number_of_decreases_today = number_of_decreases_today
        self.read_capacity_units = read_capacity_units
        self.write_capacity_units = write_capacity_units

    def as_dict(self) -> Dict[str, Any]:
        """Converts the ProvisionedThroughputDescription to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        d: Dict[str, Any] = {}

        if self.last_increase_date_time is not None:
            d["LastIncreaseDateTime"] = self.last_increase_date_time

        if self.last_decrease_date_time is not None:
            d["LastDecreaseDateTime"] = self.last_decrease_date_time

        if self.number_of_decreases_today is not None:
            d["NumberOfDecreasesToday"] = self.number_of_decreases_today

        if self.read_capacity_units is not None:
            d["ReadCapacityUnits"] = self.read_capacity_units

        if self.write_capacity_units is not None:
            d["WriteCapacityUnits"] = self.write_capacity_units

        return d

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "ProvisionedThroughputDescription":
        """Creates a ProvisionedThroughputDescription from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {}

        if "LastIncreaseDateTime" in d:
            kwargs["last_increase_date_time"] = d["LastIncreaseDateTime"]

        if "LastDecreaseDateTime" in d:
            kwargs["last_decrease_date_time"] = d["LastDecreaseDateTime"]

        if "NumberOfDecreasesToday" in d:
            kwargs["number_of_decreases_today"] = d["NumberOfDecreasesToday"]

        if "ReadCapacityUnits" in d:
            kwargs["read_capacity_units"] = d["ReadCapacityUnits"]

        if "WriteCapacityUnits" in d:
            kwargs["write_capacity_units"] = d["WriteCapacityUnits"]

        return ProvisionedThroughputDescription(**kwargs)

    def __repr__(self) -> str:
        result = "ProvisionedThroughputDescription("
        if self.last_increase_date_time is not None:
            result += f"last_increase_date_time={repr(self.last_increase_date_time)}, "

        if self.last_decrease_date_time is not None:
            result += f"last_decrease_date_time={repr(self.last_decrease_date_time)}, "

        if self.number_of_decreases_today is not None:
            result += f"number_of_decreases_today={repr(self.number_of_decreases_today)}, "

        if self.read_capacity_units is not None:
            result += f"read_capacity_units={repr(self.read_capacity_units)}, "

        if self.write_capacity_units is not None:
            result += f"write_capacity_units={repr(self.write_capacity_units)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, ProvisionedThroughputDescription):
            return False
        attributes: list[str] = ['last_increase_date_time','last_decrease_date_time','number_of_decreases_today','read_capacity_units','write_capacity_units',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class GlobalSecondaryIndexDescription:
    index_name: Optional[str]
    key_schema: Optional[list[KeySchemaElement]]
    projection: Optional[Projection]
    index_status: Optional[str]
    backfilling: Optional[bool]
    provisioned_throughput: Optional[ProvisionedThroughputDescription]
    index_size_bytes: int
    item_count: int
    index_arn: Optional[str]
    def __init__(
        self,
        *,
        index_name: Optional[str] = None,
        key_schema: Optional[list[KeySchemaElement]] = None,
        projection: Optional[Projection] = None,
        index_status: Optional[str] = None,
        backfilling: Optional[bool] = None,
        provisioned_throughput: Optional[ProvisionedThroughputDescription] = None,
        index_size_bytes: int = 0,
        item_count: int = 0,
        index_arn: Optional[str] = None,
    ):
        """<p>Represents the properties of a global secondary index.</p>

        :param index_name: <p>The name of the global secondary index.</p>
        :param key_schema: <p>The complete key schema for a global secondary index,
        which consists of one or more
                    pairs of attribute names and key
        types:</p>
                <ul>
                    <li>
                        <p>

        <code>HASH</code> - partition key</p>
                    </li>
                    <li>

        <p>
                            <code>RANGE</code> - sort key</p>
                    </li>

        </ul>
                <note>
                    <p>The partition key of an item is also known
        as its <i>hash
                            attribute</i>. The term "hash attribute"
        derives from DynamoDB's usage of an internal hash function to evenly distribute
        data items across
                        partitions, based on their partition key
        values.</p>
                    <p>The sort key of an item is also known as its <i>range
        attribute</i>.
                        The term "range attribute" derives from the way
        DynamoDB stores items with
                        the same partition key physically
        close together, in sorted order by the sort key
                        value.</p>

        </note>
        :param projection: <p>Represents attributes that are copied (projected) from the
        table into the global
                    secondary index. These are in addition to the
        primary key attributes and index key
                    attributes, which are
        automatically projected. </p>
        :param index_status: <p>The current state of the global secondary index:</p>

        <ul>
                    <li>
                        <p>

        <code>CREATING</code> - The index is being created.</p>
                    </li>

        <li>
                        <p>
                            <code>UPDATING</code> - The index
        is being updated.</p>
                    </li>
                    <li>
                        <p>

        <code>DELETING</code> - The index is being deleted.</p>
                    </li>

        <li>
                        <p>
                            <code>ACTIVE</code> - The index is
        ready for use.</p>
                    </li>
                 </ul>
        :param backfilling: <p>Indicates whether the index is currently backfilling.
        <i>Backfilling</i>
                    is the process of reading items from the table
        and determining whether they can be added
                    to the index. (Not all
        items will qualify: For example, a partition key cannot have any

        duplicate values.) If an item can be added to the index, DynamoDB will do so.
        After all
                    items have been processed, the backfilling operation is
        complete and
                        <code>Backfilling</code> is false.</p>

        <p>You can delete an index that is being created during the
        <code>Backfilling</code>
                    phase when <code>IndexStatus</code> is set
        to CREATING and <code>Backfilling</code> is
                    true. You can't delete
        the index that is being created when <code>IndexStatus</code> is
                    set
        to CREATING and <code>Backfilling</code> is false. </p>
                <note>

        <p>For indexes that were created during a <code>CreateTable</code> operation,
        the
                            <code>Backfilling</code> attribute does not appear in
        the
                            <code>DescribeTable</code> output.</p>
                </note>
        :param provisioned_throughput: <p>Represents the provisioned throughput settings
        for the specified global secondary
                    index.</p>
                <p>For current
        minimum and maximum provisioned throughput values, see <a
        href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Limits.html">Service,

        Account, and Table Quotas</a> in the <i>Amazon DynamoDB Developer

        Guide</i>.</p>
        :param index_size_bytes: <p>The total size of the specified index, in bytes.
        DynamoDB updates this value
                    approximately every six hours. Recent
        changes might not be reflected in this
                    value.</p>
        :param item_count: <p>The number of items in the specified index. DynamoDB
        updates this value approximately
                    every six hours. Recent changes
        might not be reflected in this value.</p>
        :param index_arn: <p>The Amazon Resource Name (ARN) that uniquely identifies the
        index.</p>
        """
        self.index_name = index_name
        self.key_schema = key_schema
        self.projection = projection
        self.index_status = index_status
        self.backfilling = backfilling
        self.provisioned_throughput = provisioned_throughput
        self.index_size_bytes = index_size_bytes
        self.item_count = item_count
        self.index_arn = index_arn

    def as_dict(self) -> Dict[str, Any]:
        """Converts the GlobalSecondaryIndexDescription to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        d: Dict[str, Any] = {}

        if self.index_name is not None:
            d["IndexName"] = self.index_name

        if self.key_schema is not None:
            d["KeySchema"] = _key_schema_as_dict(self.key_schema),

        if self.projection is not None:
            d["Projection"] = self.projection.as_dict()

        if self.index_status is not None:
            d["IndexStatus"] = self.index_status

        if self.backfilling is not None:
            d["Backfilling"] = self.backfilling

        if self.provisioned_throughput is not None:
            d["ProvisionedThroughput"] = self.provisioned_throughput.as_dict()

        if self.index_size_bytes is not None:
            d["IndexSizeBytes"] = self.index_size_bytes

        if self.item_count is not None:
            d["ItemCount"] = self.item_count

        if self.index_arn is not None:
            d["IndexArn"] = self.index_arn

        return d

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "GlobalSecondaryIndexDescription":
        """Creates a GlobalSecondaryIndexDescription from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {}

        if "IndexName" in d:
            kwargs["index_name"] = d["IndexName"]

        if "KeySchema" in d:
            kwargs["key_schema"] = _key_schema_from_dict(d["KeySchema"]),

        if "Projection" in d:
            kwargs["projection"] = Projection.from_dict(d["Projection"])

        if "IndexStatus" in d:
            kwargs["index_status"] = d["IndexStatus"]

        if "Backfilling" in d:
            kwargs["backfilling"] = d["Backfilling"]

        if "ProvisionedThroughput" in d:
            kwargs["provisioned_throughput"] = ProvisionedThroughputDescription.from_dict(d["ProvisionedThroughput"])

        if "IndexSizeBytes" in d:
            kwargs["index_size_bytes"] = d["IndexSizeBytes"]

        if "ItemCount" in d:
            kwargs["item_count"] = d["ItemCount"]

        if "IndexArn" in d:
            kwargs["index_arn"] = d["IndexArn"]

        return GlobalSecondaryIndexDescription(**kwargs)

    def __repr__(self) -> str:
        result = "GlobalSecondaryIndexDescription("
        if self.index_name is not None:
            result += f"index_name={repr(self.index_name)}, "

        if self.key_schema is not None:
            result += f"key_schema={repr(self.key_schema)}, "

        if self.projection is not None:
            result += f"projection={repr(self.projection)}, "

        if self.index_status is not None:
            result += f"index_status={repr(self.index_status)}, "

        if self.backfilling is not None:
            result += f"backfilling={repr(self.backfilling)}, "

        if self.provisioned_throughput is not None:
            result += f"provisioned_throughput={repr(self.provisioned_throughput)}, "

        if self.index_size_bytes is not None:
            result += f"index_size_bytes={repr(self.index_size_bytes)}, "

        if self.item_count is not None:
            result += f"item_count={repr(self.item_count)}, "

        if self.index_arn is not None:
            result += f"index_arn={repr(self.index_arn)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, GlobalSecondaryIndexDescription):
            return False
        attributes: list[str] = ['index_name','key_schema','projection','index_status','backfilling','provisioned_throughput','index_size_bytes','item_count','index_arn',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class LocalSecondaryIndexDescription:
    index_name: Optional[str]
    key_schema: Optional[list[KeySchemaElement]]
    projection: Optional[Projection]
    index_size_bytes: int
    item_count: int
    index_arn: Optional[str]
    def __init__(
        self,
        *,
        index_name: Optional[str] = None,
        key_schema: Optional[list[KeySchemaElement]] = None,
        projection: Optional[Projection] = None,
        index_size_bytes: int = 0,
        item_count: int = 0,
        index_arn: Optional[str] = None,
    ):
        """<p>Represents the properties of a local secondary index.</p>

        :param index_name: <p>Represents the name of the local secondary index.</p>
        :param key_schema: <p>The complete key schema for the local secondary index,
        consisting of one or more pairs
                    of attribute names and key
        types:</p>
                <ul>
                    <li>
                        <p>

        <code>HASH</code> - partition key</p>
                    </li>
                    <li>

        <p>
                            <code>RANGE</code> - sort key</p>
                    </li>

        </ul>
                <note>
                    <p>The partition key of an item is also known
        as its <i>hash
                            attribute</i>. The term "hash attribute"
        derives from DynamoDB's usage of
                        an internal hash function to
        evenly distribute data items across partitions, based
                        on their
        partition key values.</p>
                    <p>The sort key of an item is also known
        as its <i>range attribute</i>.
                        The term "range attribute"
        derives from the way DynamoDB stores items with the same

        partition key physically close together, in sorted order by the sort key

        value.</p>
                </note>
        :param projection: <p>Represents attributes that are copied (projected) from the
        table into the global
                    secondary index. These are in addition to the
        primary key attributes and index key
                    attributes, which are
        automatically projected. </p>
        :param index_size_bytes: <p>The total size of the specified index, in bytes.
        DynamoDB updates this value
                    approximately every six hours. Recent
        changes might not be reflected in this
                    value.</p>
        :param item_count: <p>The number of items in the specified index. DynamoDB
        updates this value
                    approximately every six hours. Recent changes
        might not be reflected in this
                    value.</p>
        :param index_arn: <p>The Amazon Resource Name (ARN) that uniquely identifies the
        index.</p>
        """
        self.index_name = index_name
        self.key_schema = key_schema
        self.projection = projection
        self.index_size_bytes = index_size_bytes
        self.item_count = item_count
        self.index_arn = index_arn

    def as_dict(self) -> Dict[str, Any]:
        """Converts the LocalSecondaryIndexDescription to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        d: Dict[str, Any] = {}

        if self.index_name is not None:
            d["IndexName"] = self.index_name

        if self.key_schema is not None:
            d["KeySchema"] = _key_schema_as_dict(self.key_schema),

        if self.projection is not None:
            d["Projection"] = self.projection.as_dict()

        if self.index_size_bytes is not None:
            d["IndexSizeBytes"] = self.index_size_bytes

        if self.item_count is not None:
            d["ItemCount"] = self.item_count

        if self.index_arn is not None:
            d["IndexArn"] = self.index_arn

        return d

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "LocalSecondaryIndexDescription":
        """Creates a LocalSecondaryIndexDescription from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {}

        if "IndexName" in d:
            kwargs["index_name"] = d["IndexName"]

        if "KeySchema" in d:
            kwargs["key_schema"] = _key_schema_from_dict(d["KeySchema"]),

        if "Projection" in d:
            kwargs["projection"] = Projection.from_dict(d["Projection"])

        if "IndexSizeBytes" in d:
            kwargs["index_size_bytes"] = d["IndexSizeBytes"]

        if "ItemCount" in d:
            kwargs["item_count"] = d["ItemCount"]

        if "IndexArn" in d:
            kwargs["index_arn"] = d["IndexArn"]

        return LocalSecondaryIndexDescription(**kwargs)

    def __repr__(self) -> str:
        result = "LocalSecondaryIndexDescription("
        if self.index_name is not None:
            result += f"index_name={repr(self.index_name)}, "

        if self.key_schema is not None:
            result += f"key_schema={repr(self.key_schema)}, "

        if self.projection is not None:
            result += f"projection={repr(self.projection)}, "

        if self.index_size_bytes is not None:
            result += f"index_size_bytes={repr(self.index_size_bytes)}, "

        if self.item_count is not None:
            result += f"item_count={repr(self.item_count)}, "

        if self.index_arn is not None:
            result += f"index_arn={repr(self.index_arn)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, LocalSecondaryIndexDescription):
            return False
        attributes: list[str] = ['index_name','key_schema','projection','index_size_bytes','item_count','index_arn',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class RestoreSummary:
    source_backup_arn: Optional[str]
    source_table_arn: Optional[str]
    restore_date_time: datetime
    restore_in_progress: bool
    def __init__(
        self,
        *,
        restore_date_time: datetime,
        restore_in_progress: bool,
        source_backup_arn: Optional[str] = None,
        source_table_arn: Optional[str] = None,
    ):
        """<p>Contains details for the restore.</p>

        :param restore_date_time: <p>Point in time or source backup time.</p>
        :param restore_in_progress: <p>Indicates if a restore is in progress or not.</p>
        :param source_backup_arn: <p>The Amazon Resource Name (ARN) of the backup from
        which the table was restored.</p>
        :param source_table_arn: <p>The ARN of the source table of the backup that is
        being restored.</p>
        """
        self.restore_date_time = restore_date_time
        self.restore_in_progress = restore_in_progress
        self.source_backup_arn = source_backup_arn
        self.source_table_arn = source_table_arn

    def as_dict(self) -> Dict[str, Any]:
        """Converts the RestoreSummary to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        d: Dict[str, Any] = {
            "RestoreDateTime": self.restore_date_time,
            "RestoreInProgress": self.restore_in_progress,
        }

        if self.source_backup_arn is not None:
            d["SourceBackupArn"] = self.source_backup_arn

        if self.source_table_arn is not None:
            d["SourceTableArn"] = self.source_table_arn

        return d

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "RestoreSummary":
        """Creates a RestoreSummary from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {
            "restore_date_time": d["RestoreDateTime"],
            "restore_in_progress": d["RestoreInProgress"],
        }

        if "SourceBackupArn" in d:
            kwargs["source_backup_arn"] = d["SourceBackupArn"]

        if "SourceTableArn" in d:
            kwargs["source_table_arn"] = d["SourceTableArn"]

        return RestoreSummary(**kwargs)

    def __repr__(self) -> str:
        result = "RestoreSummary("
        if self.source_backup_arn is not None:
            result += f"source_backup_arn={repr(self.source_backup_arn)}, "

        if self.source_table_arn is not None:
            result += f"source_table_arn={repr(self.source_table_arn)}, "

        if self.restore_date_time is not None:
            result += f"restore_date_time={repr(self.restore_date_time)}, "

        if self.restore_in_progress is not None:
            result += f"restore_in_progress={repr(self.restore_in_progress)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, RestoreSummary):
            return False
        attributes: list[str] = ['source_backup_arn','source_table_arn','restore_date_time','restore_in_progress',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class TableDescription:
    attribute_definitions: Optional[list[AttributeDefinition]]
    table_name: Optional[str]
    key_schema: Optional[list[KeySchemaElement]]
    table_status: Optional[str]
    creation_date_time: Optional[datetime]
    provisioned_throughput: Optional[ProvisionedThroughputDescription]
    table_size_bytes: int
    item_count: int
    table_arn: Optional[str]
    table_id: Optional[str]
    billing_mode_summary: Optional[BillingModeSummary]
    local_secondary_indexes: Optional[list[LocalSecondaryIndexDescription]]
    global_secondary_indexes: Optional[list[GlobalSecondaryIndexDescription]]
    stream_specification: Optional[StreamSpecification]
    latest_stream_label: Optional[str]
    latest_stream_arn: Optional[str]
    global_table_version: Optional[str]
    replicas: Optional[list[ReplicaDescription]]
    restore_summary: Optional[RestoreSummary]
    sse_description: Optional[SSEDescription]
    archival_summary: Optional[ArchivalSummary]
    table_class_summary: Optional[TableClassSummary]
    def __init__(
        self,
        *,
        attribute_definitions: Optional[list[AttributeDefinition]] = None,
        table_name: Optional[str] = None,
        key_schema: Optional[list[KeySchemaElement]] = None,
        table_status: Optional[str] = None,
        creation_date_time: Optional[datetime] = None,
        provisioned_throughput: Optional[ProvisionedThroughputDescription] = None,
        table_size_bytes: int = 0,
        item_count: int = 0,
        table_arn: Optional[str] = None,
        table_id: Optional[str] = None,
        billing_mode_summary: Optional[BillingModeSummary] = None,
        local_secondary_indexes: Optional[list[LocalSecondaryIndexDescription]] = None,
        global_secondary_indexes: Optional[list[GlobalSecondaryIndexDescription]] = None,
        stream_specification: Optional[StreamSpecification] = None,
        latest_stream_label: Optional[str] = None,
        latest_stream_arn: Optional[str] = None,
        global_table_version: Optional[str] = None,
        replicas: Optional[list[ReplicaDescription]] = None,
        restore_summary: Optional[RestoreSummary] = None,
        sse_description: Optional[SSEDescription] = None,
        archival_summary: Optional[ArchivalSummary] = None,
        table_class_summary: Optional[TableClassSummary] = None,
    ):
        """<p>Represents the properties of a table.</p>

        :param attribute_definitions: <p>An array of <code>AttributeDefinition</code>
        objects. Each of these objects describes
                    one attribute in the table
        and index key schema.</p>
                <p>Each <code>AttributeDefinition</code>
        object in this array is composed of:</p>
                <ul>
                    <li>

        <p>
                            <code>AttributeName</code> - The name of the
        attribute.</p>
                    </li>
                    <li>
                        <p>

        <code>AttributeType</code> - The data type for the attribute.</p>

        </li>
                 </ul>
        :param table_name: <p>The name of the table.</p>
        :param key_schema: <p>The primary key structure for the table. Each
        <code>KeySchemaElement</code> consists
                    of:</p>
                <ul>

        <li>
                        <p>
                            <code>AttributeName</code> - The
        name of the attribute.</p>
                    </li>
                    <li>

        <p>
                            <code>KeyType</code> - The role of the attribute:</p>

        <ul>
                          <li>
                                <p>

        <code>HASH</code> - partition key</p>
                            </li>

        <li>
                                <p>
                                    <code>RANGE</code>
        - sort key</p>
                            </li>
                       </ul>

        <note>
                            <p>The partition key of an item is also known as its
        <i>hash
                                    attribute</i>. The term "hash attribute"
        derives from DynamoDB's
                                usage of an internal hash
        function to evenly distribute data items across

        partitions, based on their partition key values.</p>
                            <p>The
        sort key of an item is also known as its <i>range

        attribute</i>. The term "range attribute" derives from the way

        DynamoDB stores items with the same partition key physically close together,

        in sorted order by the sort key value.</p>
                        </note>

        </li>
                 </ul>
                <p>For more information about primary keys, see <a
        href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/DataModel.html#DataModelPrimaryKey">Primary
        Key</a> in the <i>Amazon DynamoDB Developer
                    Guide</i>.</p>
        :param table_status: <p>The current state of the table:</p>
                <ul>

        <li>
                        <p>
                            <code>CREATING</code> - The table
        is being created.</p>
                    </li>
                    <li>
                        <p>

        <code>UPDATING</code> - The table is being updated.</p>
                    </li>

        <li>
                        <p>
                            <code>DELETING</code> - The table
        is being deleted.</p>
                    </li>
                    <li>
                        <p>

        <code>ACTIVE</code> - The table is ready for use.</p>
                    </li>

        <li>
                        <p>

        <code>INACCESSIBLE_ENCRYPTION_CREDENTIALS</code> - The KMS key

        used to encrypt the table in inaccessible. Table operations may fail due to

        failure to use the KMS key. DynamoDB will initiate the
                            table
        archival process when a table's KMS key remains
                            inaccessible
        for more than seven days. </p>
                    </li>
                    <li>

        <p>
                            <code>ARCHIVING</code> - The table is being archived.
        Operations are not allowed
                            until archival is complete. </p>

        </li>
                    <li>
                        <p>

        <code>ARCHIVED</code> - The table has been archived. See the ArchivalReason for

        more information. </p>
                    </li>
                 </ul>
        :param creation_date_time: <p>The date and time when the table was created, in
        <a href="http://www.epochconverter.com/">UNIX epoch time</a> format.</p>
        :param provisioned_throughput: <p>The provisioned throughput settings for the
        table, consisting of read and write
                    capacity units, along with data
        about increases and decreases.</p>
        :param table_size_bytes: <p>The total size of the specified table, in bytes.
        DynamoDB updates this value
                    approximately every six hours. Recent
        changes might not be reflected in this
                    value.</p>
        :param item_count: <p>The number of items in the specified table. DynamoDB
        updates this value approximately
                    every six hours. Recent changes
        might not be reflected in this value.</p>
        :param table_arn: <p>The Amazon Resource Name (ARN) that uniquely identifies the
        table.</p>
        :param table_id: <p>Unique identifier for the table for which the backup was
        created. </p>
        :param billing_mode_summary: <p>Contains the details for the read/write capacity
        mode.</p>
        :param local_secondary_indexes: <p>Represents one or more local secondary
        indexes on the table. Each index is scoped to a
                    given partition key
        value. Tables with one or more local secondary indexes are subject

        to an item collection size limit, where the amount of data within a given item

        collection cannot exceed 10 GB. Each element is composed of:</p>
                <ul>

        <li>
                        <p>
                            <code>IndexName</code> - The name
        of the local secondary index.</p>
                    </li>
                    <li>

        <p>
                            <code>KeySchema</code> - Specifies the complete index
        key schema. The attribute
                            names in the key schema must be
        between 1 and 255 characters (inclusive). The
                            key schema
        must begin with the same partition key as the table.</p>
                    </li>

        <li>
                        <p>
                            <code>Projection</code> - Specifies
        attributes that are copied (projected) from
                            the table into
        the index. These are in addition to the primary key attributes

        and index key attributes, which are automatically projected. Each attribute

        specification is composed of:</p>
                        <ul>
                          <li>

        <p>
                                    <code>ProjectionType</code> - One of the
        following:</p>
                                <ul>
                                <li>

        <p>
                                            <code>KEYS_ONLY</code> - Only the index
        and primary keys are
                                            projected into the
        index.</p>
                                    </li>
                                <li>

        <p>
                                            <code>INCLUDE</code> - Only the
        specified table attributes are
                                            projected
        into the index. The list of projected attributes is in

        <code>NonKeyAttributes</code>.</p>
                                    </li>

        <li>
                                        <p>

        <code>ALL</code> - All of the table attributes are projected

        into the index.</p>
                                    </li>

        </ul>
                            </li>
                          <li>

        <p>
                                    <code>NonKeyAttributes</code> - A list of one or
        more non-key attribute
                                    names that are projected into
        the secondary index. The total count of
                                    attributes
        provided in <code>NonKeyAttributes</code>, summed across all

        of the secondary indexes, must not exceed 100. If you project the same

        attribute into two different indexes, this counts as two distinct

        attributes when determining the total.</p>
                            </li>

        </ul>
                    </li>
                    <li>
                        <p>

        <code>IndexSizeBytes</code> - Represents the total size of the index, in bytes.

        DynamoDB updates this value approximately every six hours. Recent changes might

        not be reflected in this value.</p>
                    </li>
                    <li>

        <p>
                            <code>ItemCount</code> - Represents the number of items
        in the index. DynamoDB
                            updates this value approximately
        every six hours. Recent changes might not be
                            reflected in
        this value.</p>
                    </li>
                 </ul>
                <p>If the table is in
        the <code>DELETING</code> state, no information about indexes will

        be returned.</p>
        :param global_secondary_indexes: <p>The global secondary indexes, if any, on the
        table. Each index is scoped to a given
                    partition key value. Each
        element is composed of:</p>
                <ul>
                    <li>
                        <p>

        <code>Backfilling</code> - If true, then the index is currently in the

        backfilling phase. Backfilling occurs only when a new global secondary index is

        added to the table. It is the process by which DynamoDB populates the new index

        with data from the table. (This attribute does not appear for indexes that were

        created during a <code>CreateTable</code> operation.) </p>
                        <p>
        You can delete an index that is being created during the

        <code>Backfilling</code> phase when <code>IndexStatus</code> is set to

        CREATING and <code>Backfilling</code> is true. You can't delete the index that

        is being created when <code>IndexStatus</code> is set to CREATING and

        <code>Backfilling</code> is false. (This attribute does not appear for

        indexes that were created during a <code>CreateTable</code> operation.)</p>

        </li>
                    <li>
                        <p>

        <code>IndexName</code> - The name of the global secondary index.</p>

        </li>
                    <li>
                        <p>

        <code>IndexSizeBytes</code> - The total size of the global secondary index, in

        bytes. DynamoDB updates this value approximately every six hours. Recent
        changes
                            might not be reflected in this value. </p>

        </li>
                    <li>
                        <p>

        <code>IndexStatus</code> - The current status of the global secondary

        index:</p>
                        <ul>
                          <li>

        <p>
                                    <code>CREATING</code> - The index is being
        created.</p>
                            </li>
                          <li>

        <p>
                                    <code>UPDATING</code> - The index is being
        updated.</p>
                            </li>
                          <li>

        <p>
                                    <code>DELETING</code> - The index is being
        deleted.</p>
                            </li>
                          <li>

        <p>
                                    <code>ACTIVE</code> - The index is ready for
        use.</p>
                            </li>
                       </ul>
                    </li>

        <li>
                        <p>
                            <code>ItemCount</code> - The number
        of items in the global secondary index.
                            DynamoDB updates
        this value approximately every six hours. Recent changes might

        not be reflected in this value. </p>
                    </li>
                    <li>

        <p>
                            <code>KeySchema</code> - Specifies the complete index
        key schema. The attribute
                            names in the key schema must be
        between 1 and 255 characters (inclusive). The
                            key schema
        must begin with the same partition key as the table.</p>
                    </li>

        <li>
                        <p>
                            <code>Projection</code> - Specifies
        attributes that are copied (projected) from
                            the table into
        the index. These are in addition to the primary key attributes

        and index key attributes, which are automatically projected. Each attribute

        specification is composed of:</p>
                        <ul>
                          <li>

        <p>
                                    <code>ProjectionType</code> - One of the
        following:</p>
                                <ul>
                                <li>

        <p>
                                            <code>KEYS_ONLY</code> - Only the index
        and primary keys are
                                            projected into the
        index.</p>
                                    </li>
                                <li>

        <p>
                                            <code>INCLUDE</code> - In addition to
        the attributes described
                                            in
        <code>KEYS_ONLY</code>, the secondary index will include

        other non-key attributes that you specify.</p>

        </li>
                                <li>
                                        <p>

        <code>ALL</code> - All of the table attributes are projected

        into the index.</p>
                                    </li>

        </ul>
                            </li>
                          <li>

        <p>
                                    <code>NonKeyAttributes</code> - A list of one or
        more non-key attribute
                                    names that are projected into
        the secondary index. The total count of
                                    attributes
        provided in <code>NonKeyAttributes</code>, summed across all

        of the secondary indexes, must not exceed 100. If you project the same

        attribute into two different indexes, this counts as two distinct

        attributes when determining the total.</p>
                            </li>

        </ul>
                    </li>
                    <li>
                        <p>

        <code>ProvisionedThroughput</code> - The provisioned throughput settings for
        the
                            global secondary index, consisting of read and write
        capacity units, along with
                            data about increases and
        decreases. </p>
                    </li>
                 </ul>
                <p>If the table is in
        the <code>DELETING</code> state, no information about indexes will

        be returned.</p>
        :param stream_specification: <p>The current DynamoDB Streams configuration for
        the table.</p>
        :param latest_stream_label: <p>A timestamp, in ISO 8601 format, for this
        stream.</p>

                <p>Note that <code>LatestStreamLabel</code> is not a unique
        identifier for the stream,
                    because it is possible that a stream from
        another table might have the same timestamp.
                    However, the
        combination of the following three elements is guaranteed to be

        unique:</p>
                <ul>
                    <li>
                        <p>Amazon Web Services
        customer ID</p>
                    </li>
                    <li>
                        <p>Table
        name</p>
                    </li>
                    <li>
                        <p>

        <code>StreamLabel</code>
                       </p>
                    </li>
                 </ul>
        :param latest_stream_arn: <p>The Amazon Resource Name (ARN) that uniquely
        identifies the latest stream for this
                    table.</p>
        :param global_table_version: <p>Represents the version of <a
        href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/GlobalTables.html">global
        tables</a>
                    in use, if the table is replicated across Amazon Web
        Services Regions.</p>
        :param replicas: <p>Represents replicas of the table.</p>
        :param restore_summary: <p>Contains details for the restore.</p>
        :param sse_description: <p>The description of the server-side encryption status
        on the specified table.</p>
        :param archival_summary: <p>Contains information about the table archive.</p>
        :param table_class_summary: <p>Contains details of the table class.</p>
        """
        self.attribute_definitions = attribute_definitions
        self.table_name = table_name
        self.key_schema = key_schema
        self.table_status = table_status
        self.creation_date_time = creation_date_time
        self.provisioned_throughput = provisioned_throughput
        self.table_size_bytes = table_size_bytes
        self.item_count = item_count
        self.table_arn = table_arn
        self.table_id = table_id
        self.billing_mode_summary = billing_mode_summary
        self.local_secondary_indexes = local_secondary_indexes
        self.global_secondary_indexes = global_secondary_indexes
        self.stream_specification = stream_specification
        self.latest_stream_label = latest_stream_label
        self.latest_stream_arn = latest_stream_arn
        self.global_table_version = global_table_version
        self.replicas = replicas
        self.restore_summary = restore_summary
        self.sse_description = sse_description
        self.archival_summary = archival_summary
        self.table_class_summary = table_class_summary

    def as_dict(self) -> Dict[str, Any]:
        """Converts the TableDescription to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        d: Dict[str, Any] = {}

        if self.attribute_definitions is not None:
            d["AttributeDefinitions"] = _attribute_definitions_as_dict(self.attribute_definitions),

        if self.table_name is not None:
            d["TableName"] = self.table_name

        if self.key_schema is not None:
            d["KeySchema"] = _key_schema_as_dict(self.key_schema),

        if self.table_status is not None:
            d["TableStatus"] = self.table_status

        if self.creation_date_time is not None:
            d["CreationDateTime"] = self.creation_date_time

        if self.provisioned_throughput is not None:
            d["ProvisionedThroughput"] = self.provisioned_throughput.as_dict()

        if self.table_size_bytes is not None:
            d["TableSizeBytes"] = self.table_size_bytes

        if self.item_count is not None:
            d["ItemCount"] = self.item_count

        if self.table_arn is not None:
            d["TableArn"] = self.table_arn

        if self.table_id is not None:
            d["TableId"] = self.table_id

        if self.billing_mode_summary is not None:
            d["BillingModeSummary"] = self.billing_mode_summary.as_dict()

        if self.local_secondary_indexes is not None:
            d["LocalSecondaryIndexes"] = _local_secondary_index_description_list_as_dict(self.local_secondary_indexes),

        if self.global_secondary_indexes is not None:
            d["GlobalSecondaryIndexes"] = _global_secondary_index_description_list_as_dict(self.global_secondary_indexes),

        if self.stream_specification is not None:
            d["StreamSpecification"] = self.stream_specification.as_dict()

        if self.latest_stream_label is not None:
            d["LatestStreamLabel"] = self.latest_stream_label

        if self.latest_stream_arn is not None:
            d["LatestStreamArn"] = self.latest_stream_arn

        if self.global_table_version is not None:
            d["GlobalTableVersion"] = self.global_table_version

        if self.replicas is not None:
            d["Replicas"] = _replica_description_list_as_dict(self.replicas),

        if self.restore_summary is not None:
            d["RestoreSummary"] = self.restore_summary.as_dict()

        if self.sse_description is not None:
            d["SSEDescription"] = self.sse_description.as_dict()

        if self.archival_summary is not None:
            d["ArchivalSummary"] = self.archival_summary.as_dict()

        if self.table_class_summary is not None:
            d["TableClassSummary"] = self.table_class_summary.as_dict()

        return d

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "TableDescription":
        """Creates a TableDescription from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {}

        if "AttributeDefinitions" in d:
            kwargs["attribute_definitions"] = _attribute_definitions_from_dict(d["AttributeDefinitions"]),

        if "TableName" in d:
            kwargs["table_name"] = d["TableName"]

        if "KeySchema" in d:
            kwargs["key_schema"] = _key_schema_from_dict(d["KeySchema"]),

        if "TableStatus" in d:
            kwargs["table_status"] = d["TableStatus"]

        if "CreationDateTime" in d:
            kwargs["creation_date_time"] = d["CreationDateTime"]

        if "ProvisionedThroughput" in d:
            kwargs["provisioned_throughput"] = ProvisionedThroughputDescription.from_dict(d["ProvisionedThroughput"])

        if "TableSizeBytes" in d:
            kwargs["table_size_bytes"] = d["TableSizeBytes"]

        if "ItemCount" in d:
            kwargs["item_count"] = d["ItemCount"]

        if "TableArn" in d:
            kwargs["table_arn"] = d["TableArn"]

        if "TableId" in d:
            kwargs["table_id"] = d["TableId"]

        if "BillingModeSummary" in d:
            kwargs["billing_mode_summary"] = BillingModeSummary.from_dict(d["BillingModeSummary"])

        if "LocalSecondaryIndexes" in d:
            kwargs["local_secondary_indexes"] = _local_secondary_index_description_list_from_dict(d["LocalSecondaryIndexes"]),

        if "GlobalSecondaryIndexes" in d:
            kwargs["global_secondary_indexes"] = _global_secondary_index_description_list_from_dict(d["GlobalSecondaryIndexes"]),

        if "StreamSpecification" in d:
            kwargs["stream_specification"] = StreamSpecification.from_dict(d["StreamSpecification"])

        if "LatestStreamLabel" in d:
            kwargs["latest_stream_label"] = d["LatestStreamLabel"]

        if "LatestStreamArn" in d:
            kwargs["latest_stream_arn"] = d["LatestStreamArn"]

        if "GlobalTableVersion" in d:
            kwargs["global_table_version"] = d["GlobalTableVersion"]

        if "Replicas" in d:
            kwargs["replicas"] = _replica_description_list_from_dict(d["Replicas"]),

        if "RestoreSummary" in d:
            kwargs["restore_summary"] = RestoreSummary.from_dict(d["RestoreSummary"])

        if "SSEDescription" in d:
            kwargs["sse_description"] = SSEDescription.from_dict(d["SSEDescription"])

        if "ArchivalSummary" in d:
            kwargs["archival_summary"] = ArchivalSummary.from_dict(d["ArchivalSummary"])

        if "TableClassSummary" in d:
            kwargs["table_class_summary"] = TableClassSummary.from_dict(d["TableClassSummary"])

        return TableDescription(**kwargs)

    def __repr__(self) -> str:
        result = "TableDescription("
        if self.attribute_definitions is not None:
            result += f"attribute_definitions={repr(self.attribute_definitions)}, "

        if self.table_name is not None:
            result += f"table_name={repr(self.table_name)}, "

        if self.key_schema is not None:
            result += f"key_schema={repr(self.key_schema)}, "

        if self.table_status is not None:
            result += f"table_status={repr(self.table_status)}, "

        if self.creation_date_time is not None:
            result += f"creation_date_time={repr(self.creation_date_time)}, "

        if self.provisioned_throughput is not None:
            result += f"provisioned_throughput={repr(self.provisioned_throughput)}, "

        if self.table_size_bytes is not None:
            result += f"table_size_bytes={repr(self.table_size_bytes)}, "

        if self.item_count is not None:
            result += f"item_count={repr(self.item_count)}, "

        if self.table_arn is not None:
            result += f"table_arn={repr(self.table_arn)}, "

        if self.table_id is not None:
            result += f"table_id={repr(self.table_id)}, "

        if self.billing_mode_summary is not None:
            result += f"billing_mode_summary={repr(self.billing_mode_summary)}, "

        if self.local_secondary_indexes is not None:
            result += f"local_secondary_indexes={repr(self.local_secondary_indexes)}, "

        if self.global_secondary_indexes is not None:
            result += f"global_secondary_indexes={repr(self.global_secondary_indexes)}, "

        if self.stream_specification is not None:
            result += f"stream_specification={repr(self.stream_specification)}, "

        if self.latest_stream_label is not None:
            result += f"latest_stream_label={repr(self.latest_stream_label)}, "

        if self.latest_stream_arn is not None:
            result += f"latest_stream_arn={repr(self.latest_stream_arn)}, "

        if self.global_table_version is not None:
            result += f"global_table_version={repr(self.global_table_version)}, "

        if self.replicas is not None:
            result += f"replicas={repr(self.replicas)}, "

        if self.restore_summary is not None:
            result += f"restore_summary={repr(self.restore_summary)}, "

        if self.sse_description is not None:
            result += f"sse_description={repr(self.sse_description)}, "

        if self.archival_summary is not None:
            result += f"archival_summary={repr(self.archival_summary)}, "

        if self.table_class_summary is not None:
            result += f"table_class_summary={repr(self.table_class_summary)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, TableDescription):
            return False
        attributes: list[str] = ['attribute_definitions','table_name','key_schema','table_status','creation_date_time','provisioned_throughput','table_size_bytes','item_count','table_arn','table_id','billing_mode_summary','local_secondary_indexes','global_secondary_indexes','stream_specification','latest_stream_label','latest_stream_arn','global_table_version','replicas','restore_summary','sse_description','archival_summary','table_class_summary',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class CreateTableOutput:
    table_description: Optional[TableDescription]
    def __init__(
        self,
        *,
        table_description: Optional[TableDescription] = None,
    ):
        """<p>Represents the output of a <code>CreateTable</code> operation.</p>

        :param table_description: <p>Represents the properties of the table.</p>
        """
        self.table_description = table_description

    def as_dict(self) -> Dict[str, Any]:
        """Converts the CreateTableOutput to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        d: Dict[str, Any] = {}

        if self.table_description is not None:
            d["TableDescription"] = self.table_description.as_dict()

        return d

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "CreateTableOutput":
        """Creates a CreateTableOutput from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {}

        if "TableDescription" in d:
            kwargs["table_description"] = TableDescription.from_dict(d["TableDescription"])

        return CreateTableOutput(**kwargs)

    def __repr__(self) -> str:
        result = "CreateTableOutput("
        if self.table_description is not None:
            result += f"table_description={repr(self.table_description)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, CreateTableOutput):
            return False
        attributes: list[str] = ['table_description',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class CsvOptions:
    delimiter: Optional[str]
    header_list: Optional[list[str]]
    def __init__(
        self,
        *,
        delimiter: Optional[str] = None,
        header_list: Optional[list[str]] = None,
    ):
        """<p>
                    Processing options for the CSV file being imported.

        </p>

        :param delimiter: <p>
                    The delimiter used for separating items in the
        CSV file being imported.
                    </p>
        :param header_list: <p> List of the headers used to specify a common header for
        all source CSV files being
                    imported. If this field is specified then
        the first line of each CSV file is treated as
                    data instead of the
        header. If this field is not specified the the first line of each

        CSV file is treated as the header.
                    </p>
        """
        self.delimiter = delimiter
        self.header_list = header_list

    def as_dict(self) -> Dict[str, Any]:
        """Converts the CsvOptions to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        d: Dict[str, Any] = {}

        if self.delimiter is not None:
            d["Delimiter"] = self.delimiter

        if self.header_list is not None:
            d["HeaderList"] = self.header_list

        return d

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "CsvOptions":
        """Creates a CsvOptions from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {}

        if "Delimiter" in d:
            kwargs["delimiter"] = d["Delimiter"]

        if "HeaderList" in d:
            kwargs["header_list"] = d["HeaderList"]

        return CsvOptions(**kwargs)

    def __repr__(self) -> str:
        result = "CsvOptions("
        if self.delimiter is not None:
            result += f"delimiter={repr(self.delimiter)}, "

        if self.header_list is not None:
            result += f"header_list={repr(self.header_list)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, CsvOptions):
            return False
        attributes: list[str] = ['delimiter','header_list',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class DeleteBackupInput:
    backup_arn: str
    def __init__(
        self,
        *,
        backup_arn: str,
    ):
        """
        :param backup_arn: <p>The ARN associated with the backup.</p>
        """
        self.backup_arn = backup_arn

    def as_dict(self) -> Dict[str, Any]:
        """Converts the DeleteBackupInput to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        return {
            "BackupArn": self.backup_arn,
        }

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "DeleteBackupInput":
        """Creates a DeleteBackupInput from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {
            "backup_arn": d["BackupArn"],
        }

        return DeleteBackupInput(**kwargs)

    def __repr__(self) -> str:
        result = "DeleteBackupInput("
        if self.backup_arn is not None:
            result += f"backup_arn={repr(self.backup_arn)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, DeleteBackupInput):
            return False
        attributes: list[str] = ['backup_arn',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class DeleteBackupOutput:
    backup_description: Optional[BackupDescription]
    def __init__(
        self,
        *,
        backup_description: Optional[BackupDescription] = None,
    ):
        """
        :param backup_description: <p>Contains the description of the backup created for
        the table.</p>
        """
        self.backup_description = backup_description

    def as_dict(self) -> Dict[str, Any]:
        """Converts the DeleteBackupOutput to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        d: Dict[str, Any] = {}

        if self.backup_description is not None:
            d["BackupDescription"] = self.backup_description.as_dict()

        return d

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "DeleteBackupOutput":
        """Creates a DeleteBackupOutput from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {}

        if "BackupDescription" in d:
            kwargs["backup_description"] = BackupDescription.from_dict(d["BackupDescription"])

        return DeleteBackupOutput(**kwargs)

    def __repr__(self) -> str:
        result = "DeleteBackupOutput("
        if self.backup_description is not None:
            result += f"backup_description={repr(self.backup_description)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, DeleteBackupOutput):
            return False
        attributes: list[str] = ['backup_description',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class DeleteGlobalSecondaryIndexAction:
    index_name: str
    def __init__(
        self,
        *,
        index_name: str,
    ):
        """<p>Represents a global secondary index to be deleted from an existing table.</p>

        :param index_name: <p>The name of the global secondary index to be deleted.</p>
        """
        self.index_name = index_name

    def as_dict(self) -> Dict[str, Any]:
        """Converts the DeleteGlobalSecondaryIndexAction to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        return {
            "IndexName": self.index_name,
        }

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "DeleteGlobalSecondaryIndexAction":
        """Creates a DeleteGlobalSecondaryIndexAction from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {
            "index_name": d["IndexName"],
        }

        return DeleteGlobalSecondaryIndexAction(**kwargs)

    def __repr__(self) -> str:
        result = "DeleteGlobalSecondaryIndexAction("
        if self.index_name is not None:
            result += f"index_name={repr(self.index_name)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, DeleteGlobalSecondaryIndexAction):
            return False
        attributes: list[str] = ['index_name',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class DeleteReplicaAction:
    region_name: str
    def __init__(
        self,
        *,
        region_name: str,
    ):
        """<p>Represents a replica to be removed.</p>

        :param region_name: <p>The Region of the replica to be removed.</p>
        """
        self.region_name = region_name

    def as_dict(self) -> Dict[str, Any]:
        """Converts the DeleteReplicaAction to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        return {
            "RegionName": self.region_name,
        }

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "DeleteReplicaAction":
        """Creates a DeleteReplicaAction from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {
            "region_name": d["RegionName"],
        }

        return DeleteReplicaAction(**kwargs)

    def __repr__(self) -> str:
        result = "DeleteReplicaAction("
        if self.region_name is not None:
            result += f"region_name={repr(self.region_name)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, DeleteReplicaAction):
            return False
        attributes: list[str] = ['region_name',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class DeleteReplicationGroupMemberAction:
    region_name: str
    def __init__(
        self,
        *,
        region_name: str,
    ):
        """<p>Represents a replica to be deleted.</p>

        :param region_name: <p>The Region where the replica exists.</p>
        """
        self.region_name = region_name

    def as_dict(self) -> Dict[str, Any]:
        """Converts the DeleteReplicationGroupMemberAction to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        return {
            "RegionName": self.region_name,
        }

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "DeleteReplicationGroupMemberAction":
        """Creates a DeleteReplicationGroupMemberAction from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {
            "region_name": d["RegionName"],
        }

        return DeleteReplicationGroupMemberAction(**kwargs)

    def __repr__(self) -> str:
        result = "DeleteReplicationGroupMemberAction("
        if self.region_name is not None:
            result += f"region_name={repr(self.region_name)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, DeleteReplicationGroupMemberAction):
            return False
        attributes: list[str] = ['region_name',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class DeleteTableInput:
    table_name: str
    def __init__(
        self,
        *,
        table_name: str,
    ):
        """<p>Represents the input of a <code>DeleteTable</code> operation.</p>

        :param table_name: <p>The name of the table to delete.</p>
        """
        self.table_name = table_name

    def as_dict(self) -> Dict[str, Any]:
        """Converts the DeleteTableInput to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        return {
            "TableName": self.table_name,
        }

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "DeleteTableInput":
        """Creates a DeleteTableInput from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {
            "table_name": d["TableName"],
        }

        return DeleteTableInput(**kwargs)

    def __repr__(self) -> str:
        result = "DeleteTableInput("
        if self.table_name is not None:
            result += f"table_name={repr(self.table_name)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, DeleteTableInput):
            return False
        attributes: list[str] = ['table_name',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class DeleteTableOutput:
    table_description: Optional[TableDescription]
    def __init__(
        self,
        *,
        table_description: Optional[TableDescription] = None,
    ):
        """<p>Represents the output of a <code>DeleteTable</code> operation.</p>

        :param table_description: <p>Represents the properties of a table.</p>
        """
        self.table_description = table_description

    def as_dict(self) -> Dict[str, Any]:
        """Converts the DeleteTableOutput to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        d: Dict[str, Any] = {}

        if self.table_description is not None:
            d["TableDescription"] = self.table_description.as_dict()

        return d

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "DeleteTableOutput":
        """Creates a DeleteTableOutput from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {}

        if "TableDescription" in d:
            kwargs["table_description"] = TableDescription.from_dict(d["TableDescription"])

        return DeleteTableOutput(**kwargs)

    def __repr__(self) -> str:
        result = "DeleteTableOutput("
        if self.table_description is not None:
            result += f"table_description={repr(self.table_description)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, DeleteTableOutput):
            return False
        attributes: list[str] = ['table_description',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class DescribeBackupInput:
    backup_arn: str
    def __init__(
        self,
        *,
        backup_arn: str,
    ):
        """
        :param backup_arn: <p>The Amazon Resource Name (ARN) associated with the
        backup.</p>
        """
        self.backup_arn = backup_arn

    def as_dict(self) -> Dict[str, Any]:
        """Converts the DescribeBackupInput to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        return {
            "BackupArn": self.backup_arn,
        }

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "DescribeBackupInput":
        """Creates a DescribeBackupInput from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {
            "backup_arn": d["BackupArn"],
        }

        return DescribeBackupInput(**kwargs)

    def __repr__(self) -> str:
        result = "DescribeBackupInput("
        if self.backup_arn is not None:
            result += f"backup_arn={repr(self.backup_arn)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, DescribeBackupInput):
            return False
        attributes: list[str] = ['backup_arn',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class DescribeBackupOutput:
    backup_description: Optional[BackupDescription]
    def __init__(
        self,
        *,
        backup_description: Optional[BackupDescription] = None,
    ):
        """
        :param backup_description: <p>Contains the description of the backup created for
        the table.</p>
        """
        self.backup_description = backup_description

    def as_dict(self) -> Dict[str, Any]:
        """Converts the DescribeBackupOutput to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        d: Dict[str, Any] = {}

        if self.backup_description is not None:
            d["BackupDescription"] = self.backup_description.as_dict()

        return d

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "DescribeBackupOutput":
        """Creates a DescribeBackupOutput from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {}

        if "BackupDescription" in d:
            kwargs["backup_description"] = BackupDescription.from_dict(d["BackupDescription"])

        return DescribeBackupOutput(**kwargs)

    def __repr__(self) -> str:
        result = "DescribeBackupOutput("
        if self.backup_description is not None:
            result += f"backup_description={repr(self.backup_description)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, DescribeBackupOutput):
            return False
        attributes: list[str] = ['backup_description',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class DescribeContinuousBackupsInput:
    table_name: str
    def __init__(
        self,
        *,
        table_name: str,
    ):
        """
        :param table_name: <p>Name of the table for which the customer wants to check
        the continuous backups and
                    point in time recovery settings.</p>
        """
        self.table_name = table_name

    def as_dict(self) -> Dict[str, Any]:
        """Converts the DescribeContinuousBackupsInput to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        return {
            "TableName": self.table_name,
        }

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "DescribeContinuousBackupsInput":
        """Creates a DescribeContinuousBackupsInput from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {
            "table_name": d["TableName"],
        }

        return DescribeContinuousBackupsInput(**kwargs)

    def __repr__(self) -> str:
        result = "DescribeContinuousBackupsInput("
        if self.table_name is not None:
            result += f"table_name={repr(self.table_name)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, DescribeContinuousBackupsInput):
            return False
        attributes: list[str] = ['table_name',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class DescribeContinuousBackupsOutput:
    continuous_backups_description: Optional[ContinuousBackupsDescription]
    def __init__(
        self,
        *,
        continuous_backups_description: Optional[ContinuousBackupsDescription] = None,
    ):
        """
        :param continuous_backups_description: <p>Represents the continuous backups and
        point in time recovery settings on the
                    table.</p>
        """
        self.continuous_backups_description = continuous_backups_description

    def as_dict(self) -> Dict[str, Any]:
        """Converts the DescribeContinuousBackupsOutput to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        d: Dict[str, Any] = {}

        if self.continuous_backups_description is not None:
            d["ContinuousBackupsDescription"] = self.continuous_backups_description.as_dict()

        return d

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "DescribeContinuousBackupsOutput":
        """Creates a DescribeContinuousBackupsOutput from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {}

        if "ContinuousBackupsDescription" in d:
            kwargs["continuous_backups_description"] = ContinuousBackupsDescription.from_dict(d["ContinuousBackupsDescription"])

        return DescribeContinuousBackupsOutput(**kwargs)

    def __repr__(self) -> str:
        result = "DescribeContinuousBackupsOutput("
        if self.continuous_backups_description is not None:
            result += f"continuous_backups_description={repr(self.continuous_backups_description)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, DescribeContinuousBackupsOutput):
            return False
        attributes: list[str] = ['continuous_backups_description',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class DescribeContributorInsightsInput:
    table_name: str
    index_name: Optional[str]
    def __init__(
        self,
        *,
        table_name: str,
        index_name: Optional[str] = None,
    ):
        """
        :param table_name: <p>The name of the table to describe.</p>
        :param index_name: <p>The name of the global secondary index to describe, if
        applicable.</p>
        """
        self.table_name = table_name
        self.index_name = index_name

    def as_dict(self) -> Dict[str, Any]:
        """Converts the DescribeContributorInsightsInput to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        d: Dict[str, Any] = {
            "TableName": self.table_name,
        }

        if self.index_name is not None:
            d["IndexName"] = self.index_name

        return d

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "DescribeContributorInsightsInput":
        """Creates a DescribeContributorInsightsInput from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {
            "table_name": d["TableName"],
        }

        if "IndexName" in d:
            kwargs["index_name"] = d["IndexName"]

        return DescribeContributorInsightsInput(**kwargs)

    def __repr__(self) -> str:
        result = "DescribeContributorInsightsInput("
        if self.table_name is not None:
            result += f"table_name={repr(self.table_name)}, "

        if self.index_name is not None:
            result += f"index_name={repr(self.index_name)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, DescribeContributorInsightsInput):
            return False
        attributes: list[str] = ['table_name','index_name',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class FailureException:
    exception_name: Optional[str]
    exception_description: Optional[str]
    def __init__(
        self,
        *,
        exception_name: Optional[str] = None,
        exception_description: Optional[str] = None,
    ):
        """<p>Represents a failure a contributor insights operation.</p>

        :param exception_name: <p>Exception name.</p>
        :param exception_description: <p>Description of the failure.</p>
        """
        self.exception_name = exception_name
        self.exception_description = exception_description

    def as_dict(self) -> Dict[str, Any]:
        """Converts the FailureException to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        d: Dict[str, Any] = {}

        if self.exception_name is not None:
            d["ExceptionName"] = self.exception_name

        if self.exception_description is not None:
            d["ExceptionDescription"] = self.exception_description

        return d

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "FailureException":
        """Creates a FailureException from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {}

        if "ExceptionName" in d:
            kwargs["exception_name"] = d["ExceptionName"]

        if "ExceptionDescription" in d:
            kwargs["exception_description"] = d["ExceptionDescription"]

        return FailureException(**kwargs)

    def __repr__(self) -> str:
        result = "FailureException("
        if self.exception_name is not None:
            result += f"exception_name={repr(self.exception_name)}, "

        if self.exception_description is not None:
            result += f"exception_description={repr(self.exception_description)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, FailureException):
            return False
        attributes: list[str] = ['exception_name','exception_description',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class DescribeContributorInsightsOutput:
    table_name: Optional[str]
    index_name: Optional[str]
    contributor_insights_rule_list: Optional[list[str]]
    contributor_insights_status: Optional[str]
    last_update_date_time: Optional[datetime]
    failure_exception: Optional[FailureException]
    def __init__(
        self,
        *,
        table_name: Optional[str] = None,
        index_name: Optional[str] = None,
        contributor_insights_rule_list: Optional[list[str]] = None,
        contributor_insights_status: Optional[str] = None,
        last_update_date_time: Optional[datetime] = None,
        failure_exception: Optional[FailureException] = None,
    ):
        """
        :param table_name: <p>The name of the table being described.</p>
        :param index_name: <p>The name of the global secondary index being
        described.</p>
        :param contributor_insights_rule_list: <p>List of names of the associated
        contributor insights rules.</p>
        :param contributor_insights_status: <p>Current status of contributor
        insights.</p>
        :param last_update_date_time: <p>Timestamp of the last time the status was
        changed.</p>
        :param failure_exception: <p>Returns information about the last failure that was
        encountered.</p>
                <p>The most common exceptions for a FAILED status
        are:</p>
                <ul>
                    <li>
                        <p>LimitExceededException
        - Per-account Amazon CloudWatch Contributor Insights
                            rule
        limit reached. Please disable Contributor Insights for other tables/indexes

        OR disable Contributor Insights rules before retrying.</p>
                    </li>

        <li>
                        <p>AccessDeniedException - Amazon CloudWatch Contributor
        Insights rules cannot be
                            modified due to insufficient
        permissions.</p>
                    </li>
                    <li>

        <p>AccessDeniedException - Failed to create service-linked role for Contributor

        Insights due to insufficient permissions.</p>
                    </li>

        <li>
                        <p>InternalServerError - Failed to create Amazon CloudWatch
        Contributor Insights
                            rules. Please retry request.</p>

        </li>
                 </ul>
        """
        self.table_name = table_name
        self.index_name = index_name
        self.contributor_insights_rule_list = contributor_insights_rule_list
        self.contributor_insights_status = contributor_insights_status
        self.last_update_date_time = last_update_date_time
        self.failure_exception = failure_exception

    def as_dict(self) -> Dict[str, Any]:
        """Converts the DescribeContributorInsightsOutput to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        d: Dict[str, Any] = {}

        if self.table_name is not None:
            d["TableName"] = self.table_name

        if self.index_name is not None:
            d["IndexName"] = self.index_name

        if self.contributor_insights_rule_list is not None:
            d["ContributorInsightsRuleList"] = self.contributor_insights_rule_list

        if self.contributor_insights_status is not None:
            d["ContributorInsightsStatus"] = self.contributor_insights_status

        if self.last_update_date_time is not None:
            d["LastUpdateDateTime"] = self.last_update_date_time

        if self.failure_exception is not None:
            d["FailureException"] = self.failure_exception.as_dict()

        return d

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "DescribeContributorInsightsOutput":
        """Creates a DescribeContributorInsightsOutput from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {}

        if "TableName" in d:
            kwargs["table_name"] = d["TableName"]

        if "IndexName" in d:
            kwargs["index_name"] = d["IndexName"]

        if "ContributorInsightsRuleList" in d:
            kwargs["contributor_insights_rule_list"] = d["ContributorInsightsRuleList"]

        if "ContributorInsightsStatus" in d:
            kwargs["contributor_insights_status"] = d["ContributorInsightsStatus"]

        if "LastUpdateDateTime" in d:
            kwargs["last_update_date_time"] = d["LastUpdateDateTime"]

        if "FailureException" in d:
            kwargs["failure_exception"] = FailureException.from_dict(d["FailureException"])

        return DescribeContributorInsightsOutput(**kwargs)

    def __repr__(self) -> str:
        result = "DescribeContributorInsightsOutput("
        if self.table_name is not None:
            result += f"table_name={repr(self.table_name)}, "

        if self.index_name is not None:
            result += f"index_name={repr(self.index_name)}, "

        if self.contributor_insights_rule_list is not None:
            result += f"contributor_insights_rule_list={repr(self.contributor_insights_rule_list)}, "

        if self.contributor_insights_status is not None:
            result += f"contributor_insights_status={repr(self.contributor_insights_status)}, "

        if self.last_update_date_time is not None:
            result += f"last_update_date_time={repr(self.last_update_date_time)}, "

        if self.failure_exception is not None:
            result += f"failure_exception={repr(self.failure_exception)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, DescribeContributorInsightsOutput):
            return False
        attributes: list[str] = ['table_name','index_name','contributor_insights_rule_list','contributor_insights_status','last_update_date_time','failure_exception',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class DescribeEndpointsRequest:
    def as_dict(self) -> Dict[str, Any]:
        """Converts the DescribeEndpointsRequest to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        return {}

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "DescribeEndpointsRequest":
        """Creates a DescribeEndpointsRequest from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        return DescribeEndpointsRequest()

    def __repr__(self) -> str:
        result = "DescribeEndpointsRequest("

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        return isinstance(other, DescribeEndpointsRequest)

class Endpoint:
    address: str
    cache_period_in_minutes: int
    def __init__(
        self,
        *,
        address: str,
        cache_period_in_minutes: int = 0,
    ):
        """<p>An endpoint information details.</p>

        :param address: <p>IP address of the endpoint.</p>
        :param cache_period_in_minutes: <p>Endpoint cache time to live (TTL) value.</p>
        """
        self.address = address
        self.cache_period_in_minutes = cache_period_in_minutes

    def as_dict(self) -> Dict[str, Any]:
        """Converts the Endpoint to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        d: Dict[str, Any] = {
            "Address": self.address,
        }

        if self.cache_period_in_minutes is not None:
            d["CachePeriodInMinutes"] = self.cache_period_in_minutes

        return d

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "Endpoint":
        """Creates a Endpoint from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {
            "address": d["Address"],
        }

        if "CachePeriodInMinutes" in d:
            kwargs["cache_period_in_minutes"] = d["CachePeriodInMinutes"]

        return Endpoint(**kwargs)

    def __repr__(self) -> str:
        result = "Endpoint("
        if self.address is not None:
            result += f"address={repr(self.address)}, "

        if self.cache_period_in_minutes is not None:
            result += f"cache_period_in_minutes={repr(self.cache_period_in_minutes)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, Endpoint):
            return False
        attributes: list[str] = ['address','cache_period_in_minutes',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class DescribeEndpointsResponse:
    endpoints: list[Endpoint]
    def __init__(
        self,
        *,
        endpoints: list[Endpoint],
    ):
        """
        :param endpoints: <p>List of endpoints.</p>
        """
        self.endpoints = endpoints

    def as_dict(self) -> Dict[str, Any]:
        """Converts the DescribeEndpointsResponse to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        return {
            "Endpoints": _endpoints_as_dict(self.endpoints),
        }

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "DescribeEndpointsResponse":
        """Creates a DescribeEndpointsResponse from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {
            "endpoints": _endpoints_from_dict(d["Endpoints"]),
        }

        return DescribeEndpointsResponse(**kwargs)

    def __repr__(self) -> str:
        result = "DescribeEndpointsResponse("
        if self.endpoints is not None:
            result += f"endpoints={repr(self.endpoints)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, DescribeEndpointsResponse):
            return False
        attributes: list[str] = ['endpoints',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class DescribeExportInput:
    export_arn: str
    def __init__(
        self,
        *,
        export_arn: str,
    ):
        """
        :param export_arn: <p>The Amazon Resource Name (ARN) associated with the
        export.</p>
        """
        self.export_arn = export_arn

    def as_dict(self) -> Dict[str, Any]:
        """Converts the DescribeExportInput to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        return {
            "ExportArn": self.export_arn,
        }

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "DescribeExportInput":
        """Creates a DescribeExportInput from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {
            "export_arn": d["ExportArn"],
        }

        return DescribeExportInput(**kwargs)

    def __repr__(self) -> str:
        result = "DescribeExportInput("
        if self.export_arn is not None:
            result += f"export_arn={repr(self.export_arn)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, DescribeExportInput):
            return False
        attributes: list[str] = ['export_arn',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class ExportDescription:
    export_arn: Optional[str]
    export_status: Optional[str]
    start_time: Optional[datetime]
    end_time: Optional[datetime]
    export_manifest: Optional[str]
    table_arn: Optional[str]
    table_id: Optional[str]
    export_time: Optional[datetime]
    client_token: Optional[str]
    s3_bucket: Optional[str]
    s3_bucket_owner: Optional[str]
    s3_prefix: Optional[str]
    s3_sse_algorithm: Optional[str]
    s3_sse_kms_key_id: Optional[str]
    failure_code: Optional[str]
    failure_message: Optional[str]
    export_format: Optional[str]
    billed_size_bytes: Optional[int]
    item_count: Optional[int]
    def __init__(
        self,
        *,
        export_arn: Optional[str] = None,
        export_status: Optional[str] = None,
        start_time: Optional[datetime] = None,
        end_time: Optional[datetime] = None,
        export_manifest: Optional[str] = None,
        table_arn: Optional[str] = None,
        table_id: Optional[str] = None,
        export_time: Optional[datetime] = None,
        client_token: Optional[str] = None,
        s3_bucket: Optional[str] = None,
        s3_bucket_owner: Optional[str] = None,
        s3_prefix: Optional[str] = None,
        s3_sse_algorithm: Optional[str] = None,
        s3_sse_kms_key_id: Optional[str] = None,
        failure_code: Optional[str] = None,
        failure_message: Optional[str] = None,
        export_format: Optional[str] = None,
        billed_size_bytes: Optional[int] = None,
        item_count: Optional[int] = None,
    ):
        """<p>Represents the properties of the exported table.</p>

        :param export_arn: <p>The Amazon Resource Name (ARN) of the table export.</p>
        :param export_status: <p>Export can be in one of the following states:
        IN_PROGRESS, COMPLETED, or
                    FAILED.</p>
        :param start_time: <p>The time at which the export task began.</p>
        :param end_time: <p>The time at which the export task completed.</p>
        :param export_manifest: <p>The name of the manifest file for the export
        task.</p>
        :param table_arn: <p>The Amazon Resource Name (ARN) of the table that was
        exported.</p>
        :param table_id: <p>Unique ID of the table that was exported.</p>
        :param export_time: <p>Point in time from which table data was exported.</p>
        :param client_token: <p>The client token that was provided for the export task.
        A client token makes calls to

        <code>ExportTableToPointInTimeInput</code> idempotent, meaning that multiple

        identical calls have the same effect as one single call.</p>
        :param s3_bucket: <p>The name of the Amazon S3 bucket containing the export.</p>
        :param s3_bucket_owner: <p>The ID of the Amazon Web Services account that owns
        the bucket containing the
                    export.</p>
        :param s3_prefix: <p>The Amazon S3 bucket prefix used as the file name and path
        of the exported
                    snapshot.</p>
        :param s3_sse_algorithm: <p>Type of encryption used on the bucket where export
        data is stored. Valid values for
                        <code>S3SseAlgorithm</code>
        are:</p>
                <ul>
                    <li>
                        <p>

        <code>AES256</code> - server-side encryption with Amazon S3 managed

        keys</p>
                    </li>
                    <li>
                        <p>

        <code>KMS</code> - server-side encryption with KMS managed

        keys</p>
                    </li>
                 </ul>
        :param s3_sse_kms_key_id: <p>The ID of the KMS managed key used to encrypt the
        S3 bucket where
                    export data is stored (if applicable).</p>
        :param failure_code: <p>Status code for the result of the failed export.</p>
        :param failure_message: <p>Export failure reason description.</p>
        :param export_format: <p>The format of the exported data. Valid values for
        <code>ExportFormat</code> are
                        <code>DYNAMODB_JSON</code> or
        <code>ION</code>.</p>
        :param billed_size_bytes: <p>The billable size of the table export.</p>
        :param item_count: <p>The number of items exported.</p>
        """
        self.export_arn = export_arn
        self.export_status = export_status
        self.start_time = start_time
        self.end_time = end_time
        self.export_manifest = export_manifest
        self.table_arn = table_arn
        self.table_id = table_id
        self.export_time = export_time
        self.client_token = client_token
        self.s3_bucket = s3_bucket
        self.s3_bucket_owner = s3_bucket_owner
        self.s3_prefix = s3_prefix
        self.s3_sse_algorithm = s3_sse_algorithm
        self.s3_sse_kms_key_id = s3_sse_kms_key_id
        self.failure_code = failure_code
        self.failure_message = failure_message
        self.export_format = export_format
        self.billed_size_bytes = billed_size_bytes
        self.item_count = item_count

    def as_dict(self) -> Dict[str, Any]:
        """Converts the ExportDescription to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        d: Dict[str, Any] = {}

        if self.export_arn is not None:
            d["ExportArn"] = self.export_arn

        if self.export_status is not None:
            d["ExportStatus"] = self.export_status

        if self.start_time is not None:
            d["StartTime"] = self.start_time

        if self.end_time is not None:
            d["EndTime"] = self.end_time

        if self.export_manifest is not None:
            d["ExportManifest"] = self.export_manifest

        if self.table_arn is not None:
            d["TableArn"] = self.table_arn

        if self.table_id is not None:
            d["TableId"] = self.table_id

        if self.export_time is not None:
            d["ExportTime"] = self.export_time

        if self.client_token is not None:
            d["ClientToken"] = self.client_token

        if self.s3_bucket is not None:
            d["S3Bucket"] = self.s3_bucket

        if self.s3_bucket_owner is not None:
            d["S3BucketOwner"] = self.s3_bucket_owner

        if self.s3_prefix is not None:
            d["S3Prefix"] = self.s3_prefix

        if self.s3_sse_algorithm is not None:
            d["S3SseAlgorithm"] = self.s3_sse_algorithm

        if self.s3_sse_kms_key_id is not None:
            d["S3SseKmsKeyId"] = self.s3_sse_kms_key_id

        if self.failure_code is not None:
            d["FailureCode"] = self.failure_code

        if self.failure_message is not None:
            d["FailureMessage"] = self.failure_message

        if self.export_format is not None:
            d["ExportFormat"] = self.export_format

        if self.billed_size_bytes is not None:
            d["BilledSizeBytes"] = self.billed_size_bytes

        if self.item_count is not None:
            d["ItemCount"] = self.item_count

        return d

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "ExportDescription":
        """Creates a ExportDescription from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {}

        if "ExportArn" in d:
            kwargs["export_arn"] = d["ExportArn"]

        if "ExportStatus" in d:
            kwargs["export_status"] = d["ExportStatus"]

        if "StartTime" in d:
            kwargs["start_time"] = d["StartTime"]

        if "EndTime" in d:
            kwargs["end_time"] = d["EndTime"]

        if "ExportManifest" in d:
            kwargs["export_manifest"] = d["ExportManifest"]

        if "TableArn" in d:
            kwargs["table_arn"] = d["TableArn"]

        if "TableId" in d:
            kwargs["table_id"] = d["TableId"]

        if "ExportTime" in d:
            kwargs["export_time"] = d["ExportTime"]

        if "ClientToken" in d:
            kwargs["client_token"] = d["ClientToken"]

        if "S3Bucket" in d:
            kwargs["s3_bucket"] = d["S3Bucket"]

        if "S3BucketOwner" in d:
            kwargs["s3_bucket_owner"] = d["S3BucketOwner"]

        if "S3Prefix" in d:
            kwargs["s3_prefix"] = d["S3Prefix"]

        if "S3SseAlgorithm" in d:
            kwargs["s3_sse_algorithm"] = d["S3SseAlgorithm"]

        if "S3SseKmsKeyId" in d:
            kwargs["s3_sse_kms_key_id"] = d["S3SseKmsKeyId"]

        if "FailureCode" in d:
            kwargs["failure_code"] = d["FailureCode"]

        if "FailureMessage" in d:
            kwargs["failure_message"] = d["FailureMessage"]

        if "ExportFormat" in d:
            kwargs["export_format"] = d["ExportFormat"]

        if "BilledSizeBytes" in d:
            kwargs["billed_size_bytes"] = d["BilledSizeBytes"]

        if "ItemCount" in d:
            kwargs["item_count"] = d["ItemCount"]

        return ExportDescription(**kwargs)

    def __repr__(self) -> str:
        result = "ExportDescription("
        if self.export_arn is not None:
            result += f"export_arn={repr(self.export_arn)}, "

        if self.export_status is not None:
            result += f"export_status={repr(self.export_status)}, "

        if self.start_time is not None:
            result += f"start_time={repr(self.start_time)}, "

        if self.end_time is not None:
            result += f"end_time={repr(self.end_time)}, "

        if self.export_manifest is not None:
            result += f"export_manifest={repr(self.export_manifest)}, "

        if self.table_arn is not None:
            result += f"table_arn={repr(self.table_arn)}, "

        if self.table_id is not None:
            result += f"table_id={repr(self.table_id)}, "

        if self.export_time is not None:
            result += f"export_time={repr(self.export_time)}, "

        if self.client_token is not None:
            result += f"client_token={repr(self.client_token)}, "

        if self.s3_bucket is not None:
            result += f"s3_bucket={repr(self.s3_bucket)}, "

        if self.s3_bucket_owner is not None:
            result += f"s3_bucket_owner={repr(self.s3_bucket_owner)}, "

        if self.s3_prefix is not None:
            result += f"s3_prefix={repr(self.s3_prefix)}, "

        if self.s3_sse_algorithm is not None:
            result += f"s3_sse_algorithm={repr(self.s3_sse_algorithm)}, "

        if self.s3_sse_kms_key_id is not None:
            result += f"s3_sse_kms_key_id={repr(self.s3_sse_kms_key_id)}, "

        if self.failure_code is not None:
            result += f"failure_code={repr(self.failure_code)}, "

        if self.failure_message is not None:
            result += f"failure_message={repr(self.failure_message)}, "

        if self.export_format is not None:
            result += f"export_format={repr(self.export_format)}, "

        if self.billed_size_bytes is not None:
            result += f"billed_size_bytes={repr(self.billed_size_bytes)}, "

        if self.item_count is not None:
            result += f"item_count={repr(self.item_count)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, ExportDescription):
            return False
        attributes: list[str] = ['export_arn','export_status','start_time','end_time','export_manifest','table_arn','table_id','export_time','client_token','s3_bucket','s3_bucket_owner','s3_prefix','s3_sse_algorithm','s3_sse_kms_key_id','failure_code','failure_message','export_format','billed_size_bytes','item_count',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class DescribeExportOutput:
    export_description: Optional[ExportDescription]
    def __init__(
        self,
        *,
        export_description: Optional[ExportDescription] = None,
    ):
        """
        :param export_description: <p>Represents the properties of the export.</p>
        """
        self.export_description = export_description

    def as_dict(self) -> Dict[str, Any]:
        """Converts the DescribeExportOutput to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        d: Dict[str, Any] = {}

        if self.export_description is not None:
            d["ExportDescription"] = self.export_description.as_dict()

        return d

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "DescribeExportOutput":
        """Creates a DescribeExportOutput from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {}

        if "ExportDescription" in d:
            kwargs["export_description"] = ExportDescription.from_dict(d["ExportDescription"])

        return DescribeExportOutput(**kwargs)

    def __repr__(self) -> str:
        result = "DescribeExportOutput("
        if self.export_description is not None:
            result += f"export_description={repr(self.export_description)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, DescribeExportOutput):
            return False
        attributes: list[str] = ['export_description',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class DescribeGlobalTableInput:
    global_table_name: str
    def __init__(
        self,
        *,
        global_table_name: str,
    ):
        """
        :param global_table_name: <p>The name of the global table.</p>
        """
        self.global_table_name = global_table_name

    def as_dict(self) -> Dict[str, Any]:
        """Converts the DescribeGlobalTableInput to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        return {
            "GlobalTableName": self.global_table_name,
        }

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "DescribeGlobalTableInput":
        """Creates a DescribeGlobalTableInput from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {
            "global_table_name": d["GlobalTableName"],
        }

        return DescribeGlobalTableInput(**kwargs)

    def __repr__(self) -> str:
        result = "DescribeGlobalTableInput("
        if self.global_table_name is not None:
            result += f"global_table_name={repr(self.global_table_name)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, DescribeGlobalTableInput):
            return False
        attributes: list[str] = ['global_table_name',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class DescribeGlobalTableOutput:
    global_table_description: Optional[GlobalTableDescription]
    def __init__(
        self,
        *,
        global_table_description: Optional[GlobalTableDescription] = None,
    ):
        """
        :param global_table_description: <p>Contains the details of the global
        table.</p>
        """
        self.global_table_description = global_table_description

    def as_dict(self) -> Dict[str, Any]:
        """Converts the DescribeGlobalTableOutput to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        d: Dict[str, Any] = {}

        if self.global_table_description is not None:
            d["GlobalTableDescription"] = self.global_table_description.as_dict()

        return d

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "DescribeGlobalTableOutput":
        """Creates a DescribeGlobalTableOutput from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {}

        if "GlobalTableDescription" in d:
            kwargs["global_table_description"] = GlobalTableDescription.from_dict(d["GlobalTableDescription"])

        return DescribeGlobalTableOutput(**kwargs)

    def __repr__(self) -> str:
        result = "DescribeGlobalTableOutput("
        if self.global_table_description is not None:
            result += f"global_table_description={repr(self.global_table_description)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, DescribeGlobalTableOutput):
            return False
        attributes: list[str] = ['global_table_description',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class DescribeGlobalTableSettingsInput:
    global_table_name: str
    def __init__(
        self,
        *,
        global_table_name: str,
    ):
        """
        :param global_table_name: <p>The name of the global table to describe.</p>
        """
        self.global_table_name = global_table_name

    def as_dict(self) -> Dict[str, Any]:
        """Converts the DescribeGlobalTableSettingsInput to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        return {
            "GlobalTableName": self.global_table_name,
        }

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "DescribeGlobalTableSettingsInput":
        """Creates a DescribeGlobalTableSettingsInput from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {
            "global_table_name": d["GlobalTableName"],
        }

        return DescribeGlobalTableSettingsInput(**kwargs)

    def __repr__(self) -> str:
        result = "DescribeGlobalTableSettingsInput("
        if self.global_table_name is not None:
            result += f"global_table_name={repr(self.global_table_name)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, DescribeGlobalTableSettingsInput):
            return False
        attributes: list[str] = ['global_table_name',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class ReplicaGlobalSecondaryIndexSettingsDescription:
    index_name: str
    index_status: Optional[str]
    provisioned_read_capacity_units: Optional[int]
    provisioned_read_capacity_auto_scaling_settings: Optional[AutoScalingSettingsDescription]
    provisioned_write_capacity_units: Optional[int]
    provisioned_write_capacity_auto_scaling_settings: Optional[AutoScalingSettingsDescription]
    def __init__(
        self,
        *,
        index_name: str,
        index_status: Optional[str] = None,
        provisioned_read_capacity_units: Optional[int] = None,
        provisioned_read_capacity_auto_scaling_settings: Optional[AutoScalingSettingsDescription] = None,
        provisioned_write_capacity_units: Optional[int] = None,
        provisioned_write_capacity_auto_scaling_settings: Optional[AutoScalingSettingsDescription] = None,
    ):
        """<p>Represents the properties of a global secondary index.</p>

        :param index_name: <p>The name of the global secondary index. The name must be
        unique among all other
                    indexes on this table.</p>
        :param index_status: <p> The current status of the global secondary index:</p>

        <ul>
                    <li>
                        <p>

        <code>CREATING</code> - The global secondary index is being created.</p>

        </li>
                    <li>
                        <p>

        <code>UPDATING</code> - The global secondary index is being updated.</p>

        </li>
                    <li>
                        <p>

        <code>DELETING</code> - The global secondary index is being deleted.</p>

        </li>
                    <li>
                        <p>

        <code>ACTIVE</code> - The global secondary index is ready for use.</p>

        </li>
                 </ul>
        :param provisioned_read_capacity_units: <p>The maximum number of strongly
        consistent reads consumed per second before DynamoDB
                    returns a
        <code>ThrottlingException</code>.</p>
        :param provisioned_read_capacity_auto_scaling_settings: <p>Auto scaling settings
        for a global secondary index replica's read capacity
                    units.</p>
        :param provisioned_write_capacity_units: <p>The maximum number of writes
        consumed per second before DynamoDB returns a

        <code>ThrottlingException</code>.</p>
        :param provisioned_write_capacity_auto_scaling_settings: <p>Auto scaling
        settings for a global secondary index replica's write capacity

        units.</p>
        """
        self.index_name = index_name
        self.index_status = index_status
        self.provisioned_read_capacity_units = provisioned_read_capacity_units
        self.provisioned_read_capacity_auto_scaling_settings = provisioned_read_capacity_auto_scaling_settings
        self.provisioned_write_capacity_units = provisioned_write_capacity_units
        self.provisioned_write_capacity_auto_scaling_settings = provisioned_write_capacity_auto_scaling_settings

    def as_dict(self) -> Dict[str, Any]:
        """Converts the ReplicaGlobalSecondaryIndexSettingsDescription to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        d: Dict[str, Any] = {
            "IndexName": self.index_name,
        }

        if self.index_status is not None:
            d["IndexStatus"] = self.index_status

        if self.provisioned_read_capacity_units is not None:
            d["ProvisionedReadCapacityUnits"] = self.provisioned_read_capacity_units

        if self.provisioned_read_capacity_auto_scaling_settings is not None:
            d["ProvisionedReadCapacityAutoScalingSettings"] = self.provisioned_read_capacity_auto_scaling_settings.as_dict()

        if self.provisioned_write_capacity_units is not None:
            d["ProvisionedWriteCapacityUnits"] = self.provisioned_write_capacity_units

        if self.provisioned_write_capacity_auto_scaling_settings is not None:
            d["ProvisionedWriteCapacityAutoScalingSettings"] = self.provisioned_write_capacity_auto_scaling_settings.as_dict()

        return d

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "ReplicaGlobalSecondaryIndexSettingsDescription":
        """Creates a ReplicaGlobalSecondaryIndexSettingsDescription from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {
            "index_name": d["IndexName"],
        }

        if "IndexStatus" in d:
            kwargs["index_status"] = d["IndexStatus"]

        if "ProvisionedReadCapacityUnits" in d:
            kwargs["provisioned_read_capacity_units"] = d["ProvisionedReadCapacityUnits"]

        if "ProvisionedReadCapacityAutoScalingSettings" in d:
            kwargs["provisioned_read_capacity_auto_scaling_settings"] = AutoScalingSettingsDescription.from_dict(d["ProvisionedReadCapacityAutoScalingSettings"])

        if "ProvisionedWriteCapacityUnits" in d:
            kwargs["provisioned_write_capacity_units"] = d["ProvisionedWriteCapacityUnits"]

        if "ProvisionedWriteCapacityAutoScalingSettings" in d:
            kwargs["provisioned_write_capacity_auto_scaling_settings"] = AutoScalingSettingsDescription.from_dict(d["ProvisionedWriteCapacityAutoScalingSettings"])

        return ReplicaGlobalSecondaryIndexSettingsDescription(**kwargs)

    def __repr__(self) -> str:
        result = "ReplicaGlobalSecondaryIndexSettingsDescription("
        if self.index_name is not None:
            result += f"index_name={repr(self.index_name)}, "

        if self.index_status is not None:
            result += f"index_status={repr(self.index_status)}, "

        if self.provisioned_read_capacity_units is not None:
            result += f"provisioned_read_capacity_units={repr(self.provisioned_read_capacity_units)}, "

        if self.provisioned_read_capacity_auto_scaling_settings is not None:
            result += f"provisioned_read_capacity_auto_scaling_settings={repr(self.provisioned_read_capacity_auto_scaling_settings)}, "

        if self.provisioned_write_capacity_units is not None:
            result += f"provisioned_write_capacity_units={repr(self.provisioned_write_capacity_units)}, "

        if self.provisioned_write_capacity_auto_scaling_settings is not None:
            result += f"provisioned_write_capacity_auto_scaling_settings={repr(self.provisioned_write_capacity_auto_scaling_settings)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, ReplicaGlobalSecondaryIndexSettingsDescription):
            return False
        attributes: list[str] = ['index_name','index_status','provisioned_read_capacity_units','provisioned_read_capacity_auto_scaling_settings','provisioned_write_capacity_units','provisioned_write_capacity_auto_scaling_settings',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class ReplicaSettingsDescription:
    region_name: str
    replica_status: Optional[str]
    replica_billing_mode_summary: Optional[BillingModeSummary]
    replica_provisioned_read_capacity_units: Optional[int]
    replica_provisioned_read_capacity_auto_scaling_settings: Optional[AutoScalingSettingsDescription]
    replica_provisioned_write_capacity_units: Optional[int]
    replica_provisioned_write_capacity_auto_scaling_settings: Optional[AutoScalingSettingsDescription]
    replica_global_secondary_index_settings: Optional[list[ReplicaGlobalSecondaryIndexSettingsDescription]]
    replica_table_class_summary: Optional[TableClassSummary]
    def __init__(
        self,
        *,
        region_name: str,
        replica_status: Optional[str] = None,
        replica_billing_mode_summary: Optional[BillingModeSummary] = None,
        replica_provisioned_read_capacity_units: Optional[int] = None,
        replica_provisioned_read_capacity_auto_scaling_settings: Optional[AutoScalingSettingsDescription] = None,
        replica_provisioned_write_capacity_units: Optional[int] = None,
        replica_provisioned_write_capacity_auto_scaling_settings: Optional[AutoScalingSettingsDescription] = None,
        replica_global_secondary_index_settings: Optional[list[ReplicaGlobalSecondaryIndexSettingsDescription]] = None,
        replica_table_class_summary: Optional[TableClassSummary] = None,
    ):
        """<p>Represents the properties of a replica.</p>

        :param region_name: <p>The Region name of the replica.</p>
        :param replica_status: <p>The current state of the Region:</p>
                <ul>

        <li>
                        <p>
                            <code>CREATING</code> - The Region
        is being created.</p>
                    </li>
                    <li>
                        <p>

        <code>UPDATING</code> - The Region is being updated.</p>
                    </li>

        <li>
                        <p>
                            <code>DELETING</code> - The Region
        is being deleted.</p>
                    </li>
                    <li>
                        <p>

        <code>ACTIVE</code> - The Region is ready for use.</p>
                    </li>

        </ul>
        :param replica_billing_mode_summary: <p>The read/write capacity mode of the
        replica.</p>
        :param replica_provisioned_read_capacity_units: <p>The maximum number of
        strongly consistent reads consumed per second before DynamoDB

        returns a <code>ThrottlingException</code>. For more information, see <a
        href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/WorkingWithTables.html#ProvisionedThroughput">Specifying
        Read and Write Requirements</a> in the <i>Amazon DynamoDB

        Developer Guide</i>. </p>
        :param replica_provisioned_read_capacity_auto_scaling_settings: <p>Auto scaling
        settings for a global table replica's read capacity units.</p>
        :param replica_provisioned_write_capacity_units: <p>The maximum number of writes
        consumed per second before DynamoDB returns a

        <code>ThrottlingException</code>. For more information, see <a
        href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/WorkingWithTables.html#ProvisionedThroughput">Specifying
        Read and Write Requirements</a> in the <i>Amazon DynamoDB

        Developer Guide</i>.</p>
        :param replica_provisioned_write_capacity_auto_scaling_settings: <p>Auto scaling
        settings for a global table replica's write capacity units.</p>
        :param replica_global_secondary_index_settings: <p>Replica global secondary
        index settings for the global table.</p>
        :param replica_table_class_summary: <p>Contains details of the table class.</p>
        """
        self.region_name = region_name
        self.replica_status = replica_status
        self.replica_billing_mode_summary = replica_billing_mode_summary
        self.replica_provisioned_read_capacity_units = replica_provisioned_read_capacity_units
        self.replica_provisioned_read_capacity_auto_scaling_settings = replica_provisioned_read_capacity_auto_scaling_settings
        self.replica_provisioned_write_capacity_units = replica_provisioned_write_capacity_units
        self.replica_provisioned_write_capacity_auto_scaling_settings = replica_provisioned_write_capacity_auto_scaling_settings
        self.replica_global_secondary_index_settings = replica_global_secondary_index_settings
        self.replica_table_class_summary = replica_table_class_summary

    def as_dict(self) -> Dict[str, Any]:
        """Converts the ReplicaSettingsDescription to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        d: Dict[str, Any] = {
            "RegionName": self.region_name,
        }

        if self.replica_status is not None:
            d["ReplicaStatus"] = self.replica_status

        if self.replica_billing_mode_summary is not None:
            d["ReplicaBillingModeSummary"] = self.replica_billing_mode_summary.as_dict()

        if self.replica_provisioned_read_capacity_units is not None:
            d["ReplicaProvisionedReadCapacityUnits"] = self.replica_provisioned_read_capacity_units

        if self.replica_provisioned_read_capacity_auto_scaling_settings is not None:
            d["ReplicaProvisionedReadCapacityAutoScalingSettings"] = self.replica_provisioned_read_capacity_auto_scaling_settings.as_dict()

        if self.replica_provisioned_write_capacity_units is not None:
            d["ReplicaProvisionedWriteCapacityUnits"] = self.replica_provisioned_write_capacity_units

        if self.replica_provisioned_write_capacity_auto_scaling_settings is not None:
            d["ReplicaProvisionedWriteCapacityAutoScalingSettings"] = self.replica_provisioned_write_capacity_auto_scaling_settings.as_dict()

        if self.replica_global_secondary_index_settings is not None:
            d["ReplicaGlobalSecondaryIndexSettings"] = _replica_global_secondary_index_settings_description_list_as_dict(self.replica_global_secondary_index_settings),

        if self.replica_table_class_summary is not None:
            d["ReplicaTableClassSummary"] = self.replica_table_class_summary.as_dict()

        return d

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "ReplicaSettingsDescription":
        """Creates a ReplicaSettingsDescription from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {
            "region_name": d["RegionName"],
        }

        if "ReplicaStatus" in d:
            kwargs["replica_status"] = d["ReplicaStatus"]

        if "ReplicaBillingModeSummary" in d:
            kwargs["replica_billing_mode_summary"] = BillingModeSummary.from_dict(d["ReplicaBillingModeSummary"])

        if "ReplicaProvisionedReadCapacityUnits" in d:
            kwargs["replica_provisioned_read_capacity_units"] = d["ReplicaProvisionedReadCapacityUnits"]

        if "ReplicaProvisionedReadCapacityAutoScalingSettings" in d:
            kwargs["replica_provisioned_read_capacity_auto_scaling_settings"] = AutoScalingSettingsDescription.from_dict(d["ReplicaProvisionedReadCapacityAutoScalingSettings"])

        if "ReplicaProvisionedWriteCapacityUnits" in d:
            kwargs["replica_provisioned_write_capacity_units"] = d["ReplicaProvisionedWriteCapacityUnits"]

        if "ReplicaProvisionedWriteCapacityAutoScalingSettings" in d:
            kwargs["replica_provisioned_write_capacity_auto_scaling_settings"] = AutoScalingSettingsDescription.from_dict(d["ReplicaProvisionedWriteCapacityAutoScalingSettings"])

        if "ReplicaGlobalSecondaryIndexSettings" in d:
            kwargs["replica_global_secondary_index_settings"] = _replica_global_secondary_index_settings_description_list_from_dict(d["ReplicaGlobalSecondaryIndexSettings"]),

        if "ReplicaTableClassSummary" in d:
            kwargs["replica_table_class_summary"] = TableClassSummary.from_dict(d["ReplicaTableClassSummary"])

        return ReplicaSettingsDescription(**kwargs)

    def __repr__(self) -> str:
        result = "ReplicaSettingsDescription("
        if self.region_name is not None:
            result += f"region_name={repr(self.region_name)}, "

        if self.replica_status is not None:
            result += f"replica_status={repr(self.replica_status)}, "

        if self.replica_billing_mode_summary is not None:
            result += f"replica_billing_mode_summary={repr(self.replica_billing_mode_summary)}, "

        if self.replica_provisioned_read_capacity_units is not None:
            result += f"replica_provisioned_read_capacity_units={repr(self.replica_provisioned_read_capacity_units)}, "

        if self.replica_provisioned_read_capacity_auto_scaling_settings is not None:
            result += f"replica_provisioned_read_capacity_auto_scaling_settings={repr(self.replica_provisioned_read_capacity_auto_scaling_settings)}, "

        if self.replica_provisioned_write_capacity_units is not None:
            result += f"replica_provisioned_write_capacity_units={repr(self.replica_provisioned_write_capacity_units)}, "

        if self.replica_provisioned_write_capacity_auto_scaling_settings is not None:
            result += f"replica_provisioned_write_capacity_auto_scaling_settings={repr(self.replica_provisioned_write_capacity_auto_scaling_settings)}, "

        if self.replica_global_secondary_index_settings is not None:
            result += f"replica_global_secondary_index_settings={repr(self.replica_global_secondary_index_settings)}, "

        if self.replica_table_class_summary is not None:
            result += f"replica_table_class_summary={repr(self.replica_table_class_summary)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, ReplicaSettingsDescription):
            return False
        attributes: list[str] = ['region_name','replica_status','replica_billing_mode_summary','replica_provisioned_read_capacity_units','replica_provisioned_read_capacity_auto_scaling_settings','replica_provisioned_write_capacity_units','replica_provisioned_write_capacity_auto_scaling_settings','replica_global_secondary_index_settings','replica_table_class_summary',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class DescribeGlobalTableSettingsOutput:
    global_table_name: Optional[str]
    replica_settings: Optional[list[ReplicaSettingsDescription]]
    def __init__(
        self,
        *,
        global_table_name: Optional[str] = None,
        replica_settings: Optional[list[ReplicaSettingsDescription]] = None,
    ):
        """
        :param global_table_name: <p>The name of the global table.</p>
        :param replica_settings: <p>The Region-specific settings for the global
        table.</p>
        """
        self.global_table_name = global_table_name
        self.replica_settings = replica_settings

    def as_dict(self) -> Dict[str, Any]:
        """Converts the DescribeGlobalTableSettingsOutput to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        d: Dict[str, Any] = {}

        if self.global_table_name is not None:
            d["GlobalTableName"] = self.global_table_name

        if self.replica_settings is not None:
            d["ReplicaSettings"] = _replica_settings_description_list_as_dict(self.replica_settings),

        return d

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "DescribeGlobalTableSettingsOutput":
        """Creates a DescribeGlobalTableSettingsOutput from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {}

        if "GlobalTableName" in d:
            kwargs["global_table_name"] = d["GlobalTableName"]

        if "ReplicaSettings" in d:
            kwargs["replica_settings"] = _replica_settings_description_list_from_dict(d["ReplicaSettings"]),

        return DescribeGlobalTableSettingsOutput(**kwargs)

    def __repr__(self) -> str:
        result = "DescribeGlobalTableSettingsOutput("
        if self.global_table_name is not None:
            result += f"global_table_name={repr(self.global_table_name)}, "

        if self.replica_settings is not None:
            result += f"replica_settings={repr(self.replica_settings)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, DescribeGlobalTableSettingsOutput):
            return False
        attributes: list[str] = ['global_table_name','replica_settings',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class DescribeImportInput:
    import_arn: str
    def __init__(
        self,
        *,
        import_arn: str,
    ):
        """
        :param import_arn: <p>
                        The Amazon Resource Name (ARN) associated
        with the table you're importing to.
                    </p>
        """
        self.import_arn = import_arn

    def as_dict(self) -> Dict[str, Any]:
        """Converts the DescribeImportInput to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        return {
            "ImportArn": self.import_arn,
        }

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "DescribeImportInput":
        """Creates a DescribeImportInput from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {
            "import_arn": d["ImportArn"],
        }

        return DescribeImportInput(**kwargs)

    def __repr__(self) -> str:
        result = "DescribeImportInput("
        if self.import_arn is not None:
            result += f"import_arn={repr(self.import_arn)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, DescribeImportInput):
            return False
        attributes: list[str] = ['import_arn',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class InputFormatOptions:
    csv: Optional[CsvOptions]
    def __init__(
        self,
        *,
        csv: Optional[CsvOptions] = None,
    ):
        """<p>
                    The format options for the data that was imported into the
        target table. There is one value, CsvOption.</p>

        :param csv: <p>
                    The options for imported source files in CSV format.
        The values are Delimiter and HeaderList.
                    </p>
        """
        self.csv = csv

    def as_dict(self) -> Dict[str, Any]:
        """Converts the InputFormatOptions to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        d: Dict[str, Any] = {}

        if self.csv is not None:
            d["Csv"] = self.csv.as_dict()

        return d

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "InputFormatOptions":
        """Creates a InputFormatOptions from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {}

        if "Csv" in d:
            kwargs["csv"] = CsvOptions.from_dict(d["Csv"])

        return InputFormatOptions(**kwargs)

    def __repr__(self) -> str:
        result = "InputFormatOptions("
        if self.csv is not None:
            result += f"csv={repr(self.csv)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, InputFormatOptions):
            return False
        attributes: list[str] = ['csv',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class S3BucketSource:
    s3_bucket_owner: Optional[str]
    s3_bucket: str
    s3_key_prefix: Optional[str]
    def __init__(
        self,
        *,
        s3_bucket: str,
        s3_bucket_owner: Optional[str] = None,
        s3_key_prefix: Optional[str] = None,
    ):
        """<p>
                    The S3 bucket that is being imported from.
                    </p>

        :param s3_bucket: <p>
                    The S3 bucket that is being imported from.

        </p>
        :param s3_bucket_owner: <p>
                    The account number of the S3 bucket that
        is being imported from.
                    If the bucket is owned by the requester
        this is optional.
                    </p>
        :param s3_key_prefix: <p>
                    The key prefix shared by all S3 Objects
        that are being imported.
                    </p>
        """
        self.s3_bucket = s3_bucket
        self.s3_bucket_owner = s3_bucket_owner
        self.s3_key_prefix = s3_key_prefix

    def as_dict(self) -> Dict[str, Any]:
        """Converts the S3BucketSource to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        d: Dict[str, Any] = {
            "S3Bucket": self.s3_bucket,
        }

        if self.s3_bucket_owner is not None:
            d["S3BucketOwner"] = self.s3_bucket_owner

        if self.s3_key_prefix is not None:
            d["S3KeyPrefix"] = self.s3_key_prefix

        return d

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "S3BucketSource":
        """Creates a S3BucketSource from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {
            "s3_bucket": d["S3Bucket"],
        }

        if "S3BucketOwner" in d:
            kwargs["s3_bucket_owner"] = d["S3BucketOwner"]

        if "S3KeyPrefix" in d:
            kwargs["s3_key_prefix"] = d["S3KeyPrefix"]

        return S3BucketSource(**kwargs)

    def __repr__(self) -> str:
        result = "S3BucketSource("
        if self.s3_bucket_owner is not None:
            result += f"s3_bucket_owner={repr(self.s3_bucket_owner)}, "

        if self.s3_bucket is not None:
            result += f"s3_bucket={repr(self.s3_bucket)}, "

        if self.s3_key_prefix is not None:
            result += f"s3_key_prefix={repr(self.s3_key_prefix)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, S3BucketSource):
            return False
        attributes: list[str] = ['s3_bucket_owner','s3_bucket','s3_key_prefix',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class TableCreationParameters:
    table_name: str
    attribute_definitions: list[AttributeDefinition]
    key_schema: list[KeySchemaElement]
    billing_mode: Optional[str]
    provisioned_throughput: Optional[ProvisionedThroughput]
    sse_specification: Optional[SSESpecification]
    global_secondary_indexes: Optional[list[GlobalSecondaryIndex]]
    def __init__(
        self,
        *,
        table_name: str,
        attribute_definitions: list[AttributeDefinition],
        key_schema: list[KeySchemaElement],
        billing_mode: Optional[str] = None,
        provisioned_throughput: Optional[ProvisionedThroughput] = None,
        sse_specification: Optional[SSESpecification] = None,
        global_secondary_indexes: Optional[list[GlobalSecondaryIndex]] = None,
    ):
        """<p> The parameters for the table created as part of the import operation.

        </p>

        :param table_name: <p>
                    The name of the table created as part of the
        import operation.
                    </p>
        :param attribute_definitions: <p>
                    The attributes of the table
        created as part of the import operation.
                    </p>
        :param key_schema: <p>
                    The primary key and option sort key of the
        table created as part of the import operation.
                    </p>
        :param billing_mode: <p>
                    The billing mode for provisioning the table
        created as part of the import operation.
                    </p>
        :param provisioned_throughput: <p>Represents the provisioned throughput settings
        for a specified table or index. The
                    settings can be modified using
        the <code>UpdateTable</code> operation.</p>
                <p>For current minimum and
        maximum provisioned throughput values, see <a
        href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Limits.html">Service,

        Account, and Table Quotas</a> in the <i>Amazon DynamoDB Developer

        Guide</i>.</p>
        :param sse_specification: <p>Represents the settings used to enable server-side
        encryption.</p>
        :param global_secondary_indexes: <p>
                    The Global Secondary Indexes
        (GSI) of the table to be created as part of the import operation.

        </p>
        """
        self.table_name = table_name
        self.attribute_definitions = attribute_definitions
        self.key_schema = key_schema
        self.billing_mode = billing_mode
        self.provisioned_throughput = provisioned_throughput
        self.sse_specification = sse_specification
        self.global_secondary_indexes = global_secondary_indexes

    def as_dict(self) -> Dict[str, Any]:
        """Converts the TableCreationParameters to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        d: Dict[str, Any] = {
            "TableName": self.table_name,
            "AttributeDefinitions": _attribute_definitions_as_dict(self.attribute_definitions),
            "KeySchema": _key_schema_as_dict(self.key_schema),
        }

        if self.billing_mode is not None:
            d["BillingMode"] = self.billing_mode

        if self.provisioned_throughput is not None:
            d["ProvisionedThroughput"] = self.provisioned_throughput.as_dict()

        if self.sse_specification is not None:
            d["SSESpecification"] = self.sse_specification.as_dict()

        if self.global_secondary_indexes is not None:
            d["GlobalSecondaryIndexes"] = _global_secondary_index_list_as_dict(self.global_secondary_indexes),

        return d

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "TableCreationParameters":
        """Creates a TableCreationParameters from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {
            "table_name": d["TableName"],
            "attribute_definitions": _attribute_definitions_from_dict(d["AttributeDefinitions"]),
            "key_schema": _key_schema_from_dict(d["KeySchema"]),
        }

        if "BillingMode" in d:
            kwargs["billing_mode"] = d["BillingMode"]

        if "ProvisionedThroughput" in d:
            kwargs["provisioned_throughput"] = ProvisionedThroughput.from_dict(d["ProvisionedThroughput"])

        if "SSESpecification" in d:
            kwargs["sse_specification"] = SSESpecification.from_dict(d["SSESpecification"])

        if "GlobalSecondaryIndexes" in d:
            kwargs["global_secondary_indexes"] = _global_secondary_index_list_from_dict(d["GlobalSecondaryIndexes"]),

        return TableCreationParameters(**kwargs)

    def __repr__(self) -> str:
        result = "TableCreationParameters("
        if self.table_name is not None:
            result += f"table_name={repr(self.table_name)}, "

        if self.attribute_definitions is not None:
            result += f"attribute_definitions={repr(self.attribute_definitions)}, "

        if self.key_schema is not None:
            result += f"key_schema={repr(self.key_schema)}, "

        if self.billing_mode is not None:
            result += f"billing_mode={repr(self.billing_mode)}, "

        if self.provisioned_throughput is not None:
            result += f"provisioned_throughput={repr(self.provisioned_throughput)}, "

        if self.sse_specification is not None:
            result += f"sse_specification={repr(self.sse_specification)}, "

        if self.global_secondary_indexes is not None:
            result += f"global_secondary_indexes={repr(self.global_secondary_indexes)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, TableCreationParameters):
            return False
        attributes: list[str] = ['table_name','attribute_definitions','key_schema','billing_mode','provisioned_throughput','sse_specification','global_secondary_indexes',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class ImportTableDescription:
    import_arn: Optional[str]
    import_status: Optional[str]
    table_arn: Optional[str]
    table_id: Optional[str]
    client_token: Optional[str]
    s3_bucket_source: Optional[S3BucketSource]
    error_count: int
    cloud_watch_log_group_arn: Optional[str]
    input_format: Optional[str]
    input_format_options: Optional[InputFormatOptions]
    input_compression_type: Optional[str]
    table_creation_parameters: Optional[TableCreationParameters]
    start_time: Optional[datetime]
    end_time: Optional[datetime]
    processed_size_bytes: int
    processed_item_count: int
    imported_item_count: int
    failure_code: Optional[str]
    failure_message: Optional[str]
    def __init__(
        self,
        *,
        import_arn: Optional[str] = None,
        import_status: Optional[str] = None,
        table_arn: Optional[str] = None,
        table_id: Optional[str] = None,
        client_token: Optional[str] = None,
        s3_bucket_source: Optional[S3BucketSource] = None,
        error_count: int = 0,
        cloud_watch_log_group_arn: Optional[str] = None,
        input_format: Optional[str] = None,
        input_format_options: Optional[InputFormatOptions] = None,
        input_compression_type: Optional[str] = None,
        table_creation_parameters: Optional[TableCreationParameters] = None,
        start_time: Optional[datetime] = None,
        end_time: Optional[datetime] = None,
        processed_size_bytes: int = 0,
        processed_item_count: int = 0,
        imported_item_count: int = 0,
        failure_code: Optional[str] = None,
        failure_message: Optional[str] = None,
    ):
        """<p>
                    Represents the properties of the table being imported into.

        </p>

        :param import_arn: <p>
                    The Amazon Resource Number (ARN)
        corresponding to the import request.
                    </p>
        :param import_status: <p>
                    The status of the import.
                    </p>
        :param table_arn: <p>
                    The Amazon Resource Number (ARN) of the table
        being imported into.
                    </p>
        :param table_id: <p>
                    The table id corresponding to the table created
        by import table process.

                    </p>
        :param client_token: <p>
                    The client token that was provided for the
        import task. Reusing the client token
                    on retry makes a call to
        <code>ImportTable</code> idempotent.
                    </p>
        :param s3_bucket_source: <p>
                    Values for the S3 bucket the source
        file is imported from. Includes bucket name (required),
                    key prefix
        (optional) and bucket account owner ID (optional).
                    </p>
        :param error_count: <p>
                    The number of errors occurred on importing
        the source file into the target table.
                    </p>
        :param cloud_watch_log_group_arn: <p>
                    The Amazon Resource Number
        (ARN) of the Cloudwatch Log Group associated with the target table.

        </p>
        :param input_format: <p>
                    The format of the source data going into
        the target table.
                    </p>
        :param input_format_options: <p> The format options for the data that was
        imported into the target table. There is one value, CsvOption.
                    </p>
        :param input_compression_type: <p>
                    The compression options for the
        data that has been imported into the target table. The values are

        NONE, GZIP, or ZSTD.
                    </p>
        :param table_creation_parameters: <p>
                    The parameters for the new
        table that is being imported into.
                    </p>
        :param start_time: <p>
                    The time when this import task started.

        </p>
        :param end_time: <p>
                    The time at which the creation of the table
        associated with this import task completed.
                    </p>
        :param processed_size_bytes: <p>
                    The total size of data processed
        from the source file, in Bytes.
                    </p>
        :param processed_item_count: <p>
                    The total number of items processed
        from the source file.
                    </p>
        :param imported_item_count: <p>
                    The number of items successfully
        imported into the new table.
                    </p>
        :param failure_code: <p>
                    The error code corresponding to the failure
        that the import job ran into during execution.
                    </p>
        :param failure_message: <p>
                    The error message corresponding to the
        failure that the import job ran into during execution.
                    </p>
        """
        self.import_arn = import_arn
        self.import_status = import_status
        self.table_arn = table_arn
        self.table_id = table_id
        self.client_token = client_token
        self.s3_bucket_source = s3_bucket_source
        self.error_count = error_count
        self.cloud_watch_log_group_arn = cloud_watch_log_group_arn
        self.input_format = input_format
        self.input_format_options = input_format_options
        self.input_compression_type = input_compression_type
        self.table_creation_parameters = table_creation_parameters
        self.start_time = start_time
        self.end_time = end_time
        self.processed_size_bytes = processed_size_bytes
        self.processed_item_count = processed_item_count
        self.imported_item_count = imported_item_count
        self.failure_code = failure_code
        self.failure_message = failure_message

    def as_dict(self) -> Dict[str, Any]:
        """Converts the ImportTableDescription to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        d: Dict[str, Any] = {}

        if self.import_arn is not None:
            d["ImportArn"] = self.import_arn

        if self.import_status is not None:
            d["ImportStatus"] = self.import_status

        if self.table_arn is not None:
            d["TableArn"] = self.table_arn

        if self.table_id is not None:
            d["TableId"] = self.table_id

        if self.client_token is not None:
            d["ClientToken"] = self.client_token

        if self.s3_bucket_source is not None:
            d["S3BucketSource"] = self.s3_bucket_source.as_dict()

        if self.error_count is not None:
            d["ErrorCount"] = self.error_count

        if self.cloud_watch_log_group_arn is not None:
            d["CloudWatchLogGroupArn"] = self.cloud_watch_log_group_arn

        if self.input_format is not None:
            d["InputFormat"] = self.input_format

        if self.input_format_options is not None:
            d["InputFormatOptions"] = self.input_format_options.as_dict()

        if self.input_compression_type is not None:
            d["InputCompressionType"] = self.input_compression_type

        if self.table_creation_parameters is not None:
            d["TableCreationParameters"] = self.table_creation_parameters.as_dict()

        if self.start_time is not None:
            d["StartTime"] = self.start_time

        if self.end_time is not None:
            d["EndTime"] = self.end_time

        if self.processed_size_bytes is not None:
            d["ProcessedSizeBytes"] = self.processed_size_bytes

        if self.processed_item_count is not None:
            d["ProcessedItemCount"] = self.processed_item_count

        if self.imported_item_count is not None:
            d["ImportedItemCount"] = self.imported_item_count

        if self.failure_code is not None:
            d["FailureCode"] = self.failure_code

        if self.failure_message is not None:
            d["FailureMessage"] = self.failure_message

        return d

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "ImportTableDescription":
        """Creates a ImportTableDescription from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {}

        if "ImportArn" in d:
            kwargs["import_arn"] = d["ImportArn"]

        if "ImportStatus" in d:
            kwargs["import_status"] = d["ImportStatus"]

        if "TableArn" in d:
            kwargs["table_arn"] = d["TableArn"]

        if "TableId" in d:
            kwargs["table_id"] = d["TableId"]

        if "ClientToken" in d:
            kwargs["client_token"] = d["ClientToken"]

        if "S3BucketSource" in d:
            kwargs["s3_bucket_source"] = S3BucketSource.from_dict(d["S3BucketSource"])

        if "ErrorCount" in d:
            kwargs["error_count"] = d["ErrorCount"]

        if "CloudWatchLogGroupArn" in d:
            kwargs["cloud_watch_log_group_arn"] = d["CloudWatchLogGroupArn"]

        if "InputFormat" in d:
            kwargs["input_format"] = d["InputFormat"]

        if "InputFormatOptions" in d:
            kwargs["input_format_options"] = InputFormatOptions.from_dict(d["InputFormatOptions"])

        if "InputCompressionType" in d:
            kwargs["input_compression_type"] = d["InputCompressionType"]

        if "TableCreationParameters" in d:
            kwargs["table_creation_parameters"] = TableCreationParameters.from_dict(d["TableCreationParameters"])

        if "StartTime" in d:
            kwargs["start_time"] = d["StartTime"]

        if "EndTime" in d:
            kwargs["end_time"] = d["EndTime"]

        if "ProcessedSizeBytes" in d:
            kwargs["processed_size_bytes"] = d["ProcessedSizeBytes"]

        if "ProcessedItemCount" in d:
            kwargs["processed_item_count"] = d["ProcessedItemCount"]

        if "ImportedItemCount" in d:
            kwargs["imported_item_count"] = d["ImportedItemCount"]

        if "FailureCode" in d:
            kwargs["failure_code"] = d["FailureCode"]

        if "FailureMessage" in d:
            kwargs["failure_message"] = d["FailureMessage"]

        return ImportTableDescription(**kwargs)

    def __repr__(self) -> str:
        result = "ImportTableDescription("
        if self.import_arn is not None:
            result += f"import_arn={repr(self.import_arn)}, "

        if self.import_status is not None:
            result += f"import_status={repr(self.import_status)}, "

        if self.table_arn is not None:
            result += f"table_arn={repr(self.table_arn)}, "

        if self.table_id is not None:
            result += f"table_id={repr(self.table_id)}, "

        if self.client_token is not None:
            result += f"client_token={repr(self.client_token)}, "

        if self.s3_bucket_source is not None:
            result += f"s3_bucket_source={repr(self.s3_bucket_source)}, "

        if self.error_count is not None:
            result += f"error_count={repr(self.error_count)}, "

        if self.cloud_watch_log_group_arn is not None:
            result += f"cloud_watch_log_group_arn={repr(self.cloud_watch_log_group_arn)}, "

        if self.input_format is not None:
            result += f"input_format={repr(self.input_format)}, "

        if self.input_format_options is not None:
            result += f"input_format_options={repr(self.input_format_options)}, "

        if self.input_compression_type is not None:
            result += f"input_compression_type={repr(self.input_compression_type)}, "

        if self.table_creation_parameters is not None:
            result += f"table_creation_parameters={repr(self.table_creation_parameters)}, "

        if self.start_time is not None:
            result += f"start_time={repr(self.start_time)}, "

        if self.end_time is not None:
            result += f"end_time={repr(self.end_time)}, "

        if self.processed_size_bytes is not None:
            result += f"processed_size_bytes={repr(self.processed_size_bytes)}, "

        if self.processed_item_count is not None:
            result += f"processed_item_count={repr(self.processed_item_count)}, "

        if self.imported_item_count is not None:
            result += f"imported_item_count={repr(self.imported_item_count)}, "

        if self.failure_code is not None:
            result += f"failure_code={repr(self.failure_code)}, "

        if self.failure_message is not None:
            result += f"failure_message={repr(self.failure_message)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, ImportTableDescription):
            return False
        attributes: list[str] = ['import_arn','import_status','table_arn','table_id','client_token','s3_bucket_source','error_count','cloud_watch_log_group_arn','input_format','input_format_options','input_compression_type','table_creation_parameters','start_time','end_time','processed_size_bytes','processed_item_count','imported_item_count','failure_code','failure_message',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class DescribeImportOutput:
    import_table_description: ImportTableDescription
    def __init__(
        self,
        *,
        import_table_description: ImportTableDescription,
    ):
        """
        :param import_table_description: <p>
                        Represents the properties
        of the table created for the import, and parameters of
                        the
        import. The import parameters include import status, how many items were
        processed,
                        and how many errors were encountered.

        </p>
        """
        self.import_table_description = import_table_description

    def as_dict(self) -> Dict[str, Any]:
        """Converts the DescribeImportOutput to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        return {
            "ImportTableDescription": self.import_table_description.as_dict(),
        }

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "DescribeImportOutput":
        """Creates a DescribeImportOutput from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {
            "import_table_description": ImportTableDescription.from_dict(d["ImportTableDescription"]),
        }

        return DescribeImportOutput(**kwargs)

    def __repr__(self) -> str:
        result = "DescribeImportOutput("
        if self.import_table_description is not None:
            result += f"import_table_description={repr(self.import_table_description)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, DescribeImportOutput):
            return False
        attributes: list[str] = ['import_table_description',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class DescribeKinesisStreamingDestinationInput:
    table_name: str
    def __init__(
        self,
        *,
        table_name: str,
    ):
        """
        :param table_name: <p>The name of the table being described.</p>
        """
        self.table_name = table_name

    def as_dict(self) -> Dict[str, Any]:
        """Converts the DescribeKinesisStreamingDestinationInput to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        return {
            "TableName": self.table_name,
        }

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "DescribeKinesisStreamingDestinationInput":
        """Creates a DescribeKinesisStreamingDestinationInput from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {
            "table_name": d["TableName"],
        }

        return DescribeKinesisStreamingDestinationInput(**kwargs)

    def __repr__(self) -> str:
        result = "DescribeKinesisStreamingDestinationInput("
        if self.table_name is not None:
            result += f"table_name={repr(self.table_name)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, DescribeKinesisStreamingDestinationInput):
            return False
        attributes: list[str] = ['table_name',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class KinesisDataStreamDestination:
    stream_arn: Optional[str]
    destination_status: Optional[str]
    destination_status_description: Optional[str]
    def __init__(
        self,
        *,
        stream_arn: Optional[str] = None,
        destination_status: Optional[str] = None,
        destination_status_description: Optional[str] = None,
    ):
        """<p>Describes a Kinesis data stream destination.</p>

        :param stream_arn: <p>The ARN for a specific Kinesis data stream.</p>
        :param destination_status: <p>The current status of replication.</p>
        :param destination_status_description: <p>The human-readable string that
        corresponds to the replica status.</p>
        """
        self.stream_arn = stream_arn
        self.destination_status = destination_status
        self.destination_status_description = destination_status_description

    def as_dict(self) -> Dict[str, Any]:
        """Converts the KinesisDataStreamDestination to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        d: Dict[str, Any] = {}

        if self.stream_arn is not None:
            d["StreamArn"] = self.stream_arn

        if self.destination_status is not None:
            d["DestinationStatus"] = self.destination_status

        if self.destination_status_description is not None:
            d["DestinationStatusDescription"] = self.destination_status_description

        return d

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "KinesisDataStreamDestination":
        """Creates a KinesisDataStreamDestination from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {}

        if "StreamArn" in d:
            kwargs["stream_arn"] = d["StreamArn"]

        if "DestinationStatus" in d:
            kwargs["destination_status"] = d["DestinationStatus"]

        if "DestinationStatusDescription" in d:
            kwargs["destination_status_description"] = d["DestinationStatusDescription"]

        return KinesisDataStreamDestination(**kwargs)

    def __repr__(self) -> str:
        result = "KinesisDataStreamDestination("
        if self.stream_arn is not None:
            result += f"stream_arn={repr(self.stream_arn)}, "

        if self.destination_status is not None:
            result += f"destination_status={repr(self.destination_status)}, "

        if self.destination_status_description is not None:
            result += f"destination_status_description={repr(self.destination_status_description)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, KinesisDataStreamDestination):
            return False
        attributes: list[str] = ['stream_arn','destination_status','destination_status_description',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class DescribeKinesisStreamingDestinationOutput:
    table_name: Optional[str]
    kinesis_data_stream_destinations: Optional[list[KinesisDataStreamDestination]]
    def __init__(
        self,
        *,
        table_name: Optional[str] = None,
        kinesis_data_stream_destinations: Optional[list[KinesisDataStreamDestination]] = None,
    ):
        """
        :param table_name: <p>The name of the table being described.</p>
        :param kinesis_data_stream_destinations: <p>The list of replica structures for
        the table being described.</p>
        """
        self.table_name = table_name
        self.kinesis_data_stream_destinations = kinesis_data_stream_destinations

    def as_dict(self) -> Dict[str, Any]:
        """Converts the DescribeKinesisStreamingDestinationOutput to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        d: Dict[str, Any] = {}

        if self.table_name is not None:
            d["TableName"] = self.table_name

        if self.kinesis_data_stream_destinations is not None:
            d["KinesisDataStreamDestinations"] = _kinesis_data_stream_destinations_as_dict(self.kinesis_data_stream_destinations),

        return d

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "DescribeKinesisStreamingDestinationOutput":
        """Creates a DescribeKinesisStreamingDestinationOutput from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {}

        if "TableName" in d:
            kwargs["table_name"] = d["TableName"]

        if "KinesisDataStreamDestinations" in d:
            kwargs["kinesis_data_stream_destinations"] = _kinesis_data_stream_destinations_from_dict(d["KinesisDataStreamDestinations"]),

        return DescribeKinesisStreamingDestinationOutput(**kwargs)

    def __repr__(self) -> str:
        result = "DescribeKinesisStreamingDestinationOutput("
        if self.table_name is not None:
            result += f"table_name={repr(self.table_name)}, "

        if self.kinesis_data_stream_destinations is not None:
            result += f"kinesis_data_stream_destinations={repr(self.kinesis_data_stream_destinations)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, DescribeKinesisStreamingDestinationOutput):
            return False
        attributes: list[str] = ['table_name','kinesis_data_stream_destinations',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class DescribeLimitsInput:
    """<p>Represents the input of a <code>DescribeLimits</code> operation. Has no

    content.</p>
    """
    def as_dict(self) -> Dict[str, Any]:
        """Converts the DescribeLimitsInput to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        return {}

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "DescribeLimitsInput":
        """Creates a DescribeLimitsInput from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        return DescribeLimitsInput()

    def __repr__(self) -> str:
        result = "DescribeLimitsInput("

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        return isinstance(other, DescribeLimitsInput)

class DescribeLimitsOutput:
    account_max_read_capacity_units: Optional[int]
    account_max_write_capacity_units: Optional[int]
    table_max_read_capacity_units: Optional[int]
    table_max_write_capacity_units: Optional[int]
    def __init__(
        self,
        *,
        account_max_read_capacity_units: Optional[int] = None,
        account_max_write_capacity_units: Optional[int] = None,
        table_max_read_capacity_units: Optional[int] = None,
        table_max_write_capacity_units: Optional[int] = None,
    ):
        """<p>Represents the output of a <code>DescribeLimits</code> operation.</p>

        :param account_max_read_capacity_units: <p>The maximum total read capacity units
        that your account allows you to provision across
                    all of your tables
        in this Region.</p>
        :param account_max_write_capacity_units: <p>The maximum total write capacity
        units that your account allows you to provision
                    across all of your
        tables in this Region.</p>
        :param table_max_read_capacity_units: <p>The maximum read capacity units that
        your account allows you to provision for a new
                    table that you are
        creating in this Region, including the read capacity units

        provisioned for its global secondary indexes (GSIs).</p>
        :param table_max_write_capacity_units: <p>The maximum write capacity units that
        your account allows you to provision for a new
                    table that you are
        creating in this Region, including the write capacity units

        provisioned for its global secondary indexes (GSIs).</p>
        """
        self.account_max_read_capacity_units = account_max_read_capacity_units
        self.account_max_write_capacity_units = account_max_write_capacity_units
        self.table_max_read_capacity_units = table_max_read_capacity_units
        self.table_max_write_capacity_units = table_max_write_capacity_units

    def as_dict(self) -> Dict[str, Any]:
        """Converts the DescribeLimitsOutput to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        d: Dict[str, Any] = {}

        if self.account_max_read_capacity_units is not None:
            d["AccountMaxReadCapacityUnits"] = self.account_max_read_capacity_units

        if self.account_max_write_capacity_units is not None:
            d["AccountMaxWriteCapacityUnits"] = self.account_max_write_capacity_units

        if self.table_max_read_capacity_units is not None:
            d["TableMaxReadCapacityUnits"] = self.table_max_read_capacity_units

        if self.table_max_write_capacity_units is not None:
            d["TableMaxWriteCapacityUnits"] = self.table_max_write_capacity_units

        return d

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "DescribeLimitsOutput":
        """Creates a DescribeLimitsOutput from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {}

        if "AccountMaxReadCapacityUnits" in d:
            kwargs["account_max_read_capacity_units"] = d["AccountMaxReadCapacityUnits"]

        if "AccountMaxWriteCapacityUnits" in d:
            kwargs["account_max_write_capacity_units"] = d["AccountMaxWriteCapacityUnits"]

        if "TableMaxReadCapacityUnits" in d:
            kwargs["table_max_read_capacity_units"] = d["TableMaxReadCapacityUnits"]

        if "TableMaxWriteCapacityUnits" in d:
            kwargs["table_max_write_capacity_units"] = d["TableMaxWriteCapacityUnits"]

        return DescribeLimitsOutput(**kwargs)

    def __repr__(self) -> str:
        result = "DescribeLimitsOutput("
        if self.account_max_read_capacity_units is not None:
            result += f"account_max_read_capacity_units={repr(self.account_max_read_capacity_units)}, "

        if self.account_max_write_capacity_units is not None:
            result += f"account_max_write_capacity_units={repr(self.account_max_write_capacity_units)}, "

        if self.table_max_read_capacity_units is not None:
            result += f"table_max_read_capacity_units={repr(self.table_max_read_capacity_units)}, "

        if self.table_max_write_capacity_units is not None:
            result += f"table_max_write_capacity_units={repr(self.table_max_write_capacity_units)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, DescribeLimitsOutput):
            return False
        attributes: list[str] = ['account_max_read_capacity_units','account_max_write_capacity_units','table_max_read_capacity_units','table_max_write_capacity_units',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class DescribeTableInput:
    table_name: str
    def __init__(
        self,
        *,
        table_name: str,
    ):
        """<p>Represents the input of a <code>DescribeTable</code> operation.</p>

        :param table_name: <p>The name of the table to describe.</p>
        """
        self.table_name = table_name

    def as_dict(self) -> Dict[str, Any]:
        """Converts the DescribeTableInput to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        return {
            "TableName": self.table_name,
        }

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "DescribeTableInput":
        """Creates a DescribeTableInput from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {
            "table_name": d["TableName"],
        }

        return DescribeTableInput(**kwargs)

    def __repr__(self) -> str:
        result = "DescribeTableInput("
        if self.table_name is not None:
            result += f"table_name={repr(self.table_name)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, DescribeTableInput):
            return False
        attributes: list[str] = ['table_name',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class DescribeTableOutput:
    table: Optional[TableDescription]
    def __init__(
        self,
        *,
        table: Optional[TableDescription] = None,
    ):
        """<p>Represents the output of a <code>DescribeTable</code> operation.</p>

        :param table: <p>The properties of the table.</p>
        """
        self.table = table

    def as_dict(self) -> Dict[str, Any]:
        """Converts the DescribeTableOutput to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        d: Dict[str, Any] = {}

        if self.table is not None:
            d["Table"] = self.table.as_dict()

        return d

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "DescribeTableOutput":
        """Creates a DescribeTableOutput from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {}

        if "Table" in d:
            kwargs["table"] = TableDescription.from_dict(d["Table"])

        return DescribeTableOutput(**kwargs)

    def __repr__(self) -> str:
        result = "DescribeTableOutput("
        if self.table is not None:
            result += f"table={repr(self.table)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, DescribeTableOutput):
            return False
        attributes: list[str] = ['table',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class DescribeTableReplicaAutoScalingInput:
    table_name: str
    def __init__(
        self,
        *,
        table_name: str,
    ):
        """
        :param table_name: <p>The name of the table.</p>
        """
        self.table_name = table_name

    def as_dict(self) -> Dict[str, Any]:
        """Converts the DescribeTableReplicaAutoScalingInput to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        return {
            "TableName": self.table_name,
        }

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "DescribeTableReplicaAutoScalingInput":
        """Creates a DescribeTableReplicaAutoScalingInput from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {
            "table_name": d["TableName"],
        }

        return DescribeTableReplicaAutoScalingInput(**kwargs)

    def __repr__(self) -> str:
        result = "DescribeTableReplicaAutoScalingInput("
        if self.table_name is not None:
            result += f"table_name={repr(self.table_name)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, DescribeTableReplicaAutoScalingInput):
            return False
        attributes: list[str] = ['table_name',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class ReplicaGlobalSecondaryIndexAutoScalingDescription:
    index_name: Optional[str]
    index_status: Optional[str]
    provisioned_read_capacity_auto_scaling_settings: Optional[AutoScalingSettingsDescription]
    provisioned_write_capacity_auto_scaling_settings: Optional[AutoScalingSettingsDescription]
    def __init__(
        self,
        *,
        index_name: Optional[str] = None,
        index_status: Optional[str] = None,
        provisioned_read_capacity_auto_scaling_settings: Optional[AutoScalingSettingsDescription] = None,
        provisioned_write_capacity_auto_scaling_settings: Optional[AutoScalingSettingsDescription] = None,
    ):
        """<p>Represents the auto scaling configuration for a replica global secondary
        index.</p>

        :param index_name: <p>The name of the global secondary index.</p>
        :param index_status: <p>The current state of the replica global secondary
        index:</p>
                <ul>
                    <li>
                        <p>

        <code>CREATING</code> - The index is being created.</p>
                    </li>

        <li>
                        <p>
                            <code>UPDATING</code> - The index
        is being updated.</p>
                    </li>
                    <li>
                        <p>

        <code>DELETING</code> - The index is being deleted.</p>
                    </li>

        <li>
                        <p>
                            <code>ACTIVE</code> - The index is
        ready for use.</p>
                    </li>
                 </ul>
        :param provisioned_read_capacity_auto_scaling_settings: <p>Represents the auto
        scaling settings for a global table or global secondary
                    index.</p>
        :param provisioned_write_capacity_auto_scaling_settings: <p>Represents the auto
        scaling settings for a global table or global secondary
                    index.</p>
        """
        self.index_name = index_name
        self.index_status = index_status
        self.provisioned_read_capacity_auto_scaling_settings = provisioned_read_capacity_auto_scaling_settings
        self.provisioned_write_capacity_auto_scaling_settings = provisioned_write_capacity_auto_scaling_settings

    def as_dict(self) -> Dict[str, Any]:
        """Converts the ReplicaGlobalSecondaryIndexAutoScalingDescription to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        d: Dict[str, Any] = {}

        if self.index_name is not None:
            d["IndexName"] = self.index_name

        if self.index_status is not None:
            d["IndexStatus"] = self.index_status

        if self.provisioned_read_capacity_auto_scaling_settings is not None:
            d["ProvisionedReadCapacityAutoScalingSettings"] = self.provisioned_read_capacity_auto_scaling_settings.as_dict()

        if self.provisioned_write_capacity_auto_scaling_settings is not None:
            d["ProvisionedWriteCapacityAutoScalingSettings"] = self.provisioned_write_capacity_auto_scaling_settings.as_dict()

        return d

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "ReplicaGlobalSecondaryIndexAutoScalingDescription":
        """Creates a ReplicaGlobalSecondaryIndexAutoScalingDescription from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {}

        if "IndexName" in d:
            kwargs["index_name"] = d["IndexName"]

        if "IndexStatus" in d:
            kwargs["index_status"] = d["IndexStatus"]

        if "ProvisionedReadCapacityAutoScalingSettings" in d:
            kwargs["provisioned_read_capacity_auto_scaling_settings"] = AutoScalingSettingsDescription.from_dict(d["ProvisionedReadCapacityAutoScalingSettings"])

        if "ProvisionedWriteCapacityAutoScalingSettings" in d:
            kwargs["provisioned_write_capacity_auto_scaling_settings"] = AutoScalingSettingsDescription.from_dict(d["ProvisionedWriteCapacityAutoScalingSettings"])

        return ReplicaGlobalSecondaryIndexAutoScalingDescription(**kwargs)

    def __repr__(self) -> str:
        result = "ReplicaGlobalSecondaryIndexAutoScalingDescription("
        if self.index_name is not None:
            result += f"index_name={repr(self.index_name)}, "

        if self.index_status is not None:
            result += f"index_status={repr(self.index_status)}, "

        if self.provisioned_read_capacity_auto_scaling_settings is not None:
            result += f"provisioned_read_capacity_auto_scaling_settings={repr(self.provisioned_read_capacity_auto_scaling_settings)}, "

        if self.provisioned_write_capacity_auto_scaling_settings is not None:
            result += f"provisioned_write_capacity_auto_scaling_settings={repr(self.provisioned_write_capacity_auto_scaling_settings)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, ReplicaGlobalSecondaryIndexAutoScalingDescription):
            return False
        attributes: list[str] = ['index_name','index_status','provisioned_read_capacity_auto_scaling_settings','provisioned_write_capacity_auto_scaling_settings',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class ReplicaAutoScalingDescription:
    region_name: Optional[str]
    global_secondary_indexes: Optional[list[ReplicaGlobalSecondaryIndexAutoScalingDescription]]
    replica_provisioned_read_capacity_auto_scaling_settings: Optional[AutoScalingSettingsDescription]
    replica_provisioned_write_capacity_auto_scaling_settings: Optional[AutoScalingSettingsDescription]
    replica_status: Optional[str]
    def __init__(
        self,
        *,
        region_name: Optional[str] = None,
        global_secondary_indexes: Optional[list[ReplicaGlobalSecondaryIndexAutoScalingDescription]] = None,
        replica_provisioned_read_capacity_auto_scaling_settings: Optional[AutoScalingSettingsDescription] = None,
        replica_provisioned_write_capacity_auto_scaling_settings: Optional[AutoScalingSettingsDescription] = None,
        replica_status: Optional[str] = None,
    ):
        """<p>Represents the auto scaling settings of the replica.</p>

        :param region_name: <p>The Region where the replica exists.</p>
        :param global_secondary_indexes: <p>Replica-specific global secondary index auto
        scaling settings.</p>
        :param replica_provisioned_read_capacity_auto_scaling_settings: <p>Represents
        the auto scaling settings for a global table or global secondary

        index.</p>
        :param replica_provisioned_write_capacity_auto_scaling_settings: <p>Represents
        the auto scaling settings for a global table or global secondary

        index.</p>
        :param replica_status: <p>The current state of the replica:</p>
                <ul>

        <li>
                        <p>
                            <code>CREATING</code> - The replica
        is being created.</p>
                    </li>
                    <li>
                        <p>

        <code>UPDATING</code> - The replica is being updated.</p>
                    </li>

        <li>
                        <p>
                            <code>DELETING</code> - The replica
        is being deleted.</p>
                    </li>
                    <li>
                        <p>

        <code>ACTIVE</code> - The replica is ready for use.</p>
                    </li>

        </ul>
        """
        self.region_name = region_name
        self.global_secondary_indexes = global_secondary_indexes
        self.replica_provisioned_read_capacity_auto_scaling_settings = replica_provisioned_read_capacity_auto_scaling_settings
        self.replica_provisioned_write_capacity_auto_scaling_settings = replica_provisioned_write_capacity_auto_scaling_settings
        self.replica_status = replica_status

    def as_dict(self) -> Dict[str, Any]:
        """Converts the ReplicaAutoScalingDescription to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        d: Dict[str, Any] = {}

        if self.region_name is not None:
            d["RegionName"] = self.region_name

        if self.global_secondary_indexes is not None:
            d["GlobalSecondaryIndexes"] = _replica_global_secondary_index_auto_scaling_description_list_as_dict(self.global_secondary_indexes),

        if self.replica_provisioned_read_capacity_auto_scaling_settings is not None:
            d["ReplicaProvisionedReadCapacityAutoScalingSettings"] = self.replica_provisioned_read_capacity_auto_scaling_settings.as_dict()

        if self.replica_provisioned_write_capacity_auto_scaling_settings is not None:
            d["ReplicaProvisionedWriteCapacityAutoScalingSettings"] = self.replica_provisioned_write_capacity_auto_scaling_settings.as_dict()

        if self.replica_status is not None:
            d["ReplicaStatus"] = self.replica_status

        return d

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "ReplicaAutoScalingDescription":
        """Creates a ReplicaAutoScalingDescription from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {}

        if "RegionName" in d:
            kwargs["region_name"] = d["RegionName"]

        if "GlobalSecondaryIndexes" in d:
            kwargs["global_secondary_indexes"] = _replica_global_secondary_index_auto_scaling_description_list_from_dict(d["GlobalSecondaryIndexes"]),

        if "ReplicaProvisionedReadCapacityAutoScalingSettings" in d:
            kwargs["replica_provisioned_read_capacity_auto_scaling_settings"] = AutoScalingSettingsDescription.from_dict(d["ReplicaProvisionedReadCapacityAutoScalingSettings"])

        if "ReplicaProvisionedWriteCapacityAutoScalingSettings" in d:
            kwargs["replica_provisioned_write_capacity_auto_scaling_settings"] = AutoScalingSettingsDescription.from_dict(d["ReplicaProvisionedWriteCapacityAutoScalingSettings"])

        if "ReplicaStatus" in d:
            kwargs["replica_status"] = d["ReplicaStatus"]

        return ReplicaAutoScalingDescription(**kwargs)

    def __repr__(self) -> str:
        result = "ReplicaAutoScalingDescription("
        if self.region_name is not None:
            result += f"region_name={repr(self.region_name)}, "

        if self.global_secondary_indexes is not None:
            result += f"global_secondary_indexes={repr(self.global_secondary_indexes)}, "

        if self.replica_provisioned_read_capacity_auto_scaling_settings is not None:
            result += f"replica_provisioned_read_capacity_auto_scaling_settings={repr(self.replica_provisioned_read_capacity_auto_scaling_settings)}, "

        if self.replica_provisioned_write_capacity_auto_scaling_settings is not None:
            result += f"replica_provisioned_write_capacity_auto_scaling_settings={repr(self.replica_provisioned_write_capacity_auto_scaling_settings)}, "

        if self.replica_status is not None:
            result += f"replica_status={repr(self.replica_status)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, ReplicaAutoScalingDescription):
            return False
        attributes: list[str] = ['region_name','global_secondary_indexes','replica_provisioned_read_capacity_auto_scaling_settings','replica_provisioned_write_capacity_auto_scaling_settings','replica_status',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class TableAutoScalingDescription:
    table_name: Optional[str]
    table_status: Optional[str]
    replicas: Optional[list[ReplicaAutoScalingDescription]]
    def __init__(
        self,
        *,
        table_name: Optional[str] = None,
        table_status: Optional[str] = None,
        replicas: Optional[list[ReplicaAutoScalingDescription]] = None,
    ):
        """<p>Represents the auto scaling configuration for a global table.</p>

        :param table_name: <p>The name of the table.</p>
        :param table_status: <p>The current state of the table:</p>
                <ul>

        <li>
                        <p>
                            <code>CREATING</code> - The table
        is being created.</p>
                    </li>
                    <li>
                        <p>

        <code>UPDATING</code> - The table is being updated.</p>
                    </li>

        <li>
                        <p>
                            <code>DELETING</code> - The table
        is being deleted.</p>
                    </li>
                    <li>
                        <p>

        <code>ACTIVE</code> - The table is ready for use.</p>
                    </li>

        </ul>
        :param replicas: <p>Represents replicas of the global table.</p>
        """
        self.table_name = table_name
        self.table_status = table_status
        self.replicas = replicas

    def as_dict(self) -> Dict[str, Any]:
        """Converts the TableAutoScalingDescription to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        d: Dict[str, Any] = {}

        if self.table_name is not None:
            d["TableName"] = self.table_name

        if self.table_status is not None:
            d["TableStatus"] = self.table_status

        if self.replicas is not None:
            d["Replicas"] = _replica_auto_scaling_description_list_as_dict(self.replicas),

        return d

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "TableAutoScalingDescription":
        """Creates a TableAutoScalingDescription from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {}

        if "TableName" in d:
            kwargs["table_name"] = d["TableName"]

        if "TableStatus" in d:
            kwargs["table_status"] = d["TableStatus"]

        if "Replicas" in d:
            kwargs["replicas"] = _replica_auto_scaling_description_list_from_dict(d["Replicas"]),

        return TableAutoScalingDescription(**kwargs)

    def __repr__(self) -> str:
        result = "TableAutoScalingDescription("
        if self.table_name is not None:
            result += f"table_name={repr(self.table_name)}, "

        if self.table_status is not None:
            result += f"table_status={repr(self.table_status)}, "

        if self.replicas is not None:
            result += f"replicas={repr(self.replicas)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, TableAutoScalingDescription):
            return False
        attributes: list[str] = ['table_name','table_status','replicas',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class DescribeTableReplicaAutoScalingOutput:
    table_auto_scaling_description: Optional[TableAutoScalingDescription]
    def __init__(
        self,
        *,
        table_auto_scaling_description: Optional[TableAutoScalingDescription] = None,
    ):
        """
        :param table_auto_scaling_description: <p>Represents the auto scaling properties
        of the table.</p>
        """
        self.table_auto_scaling_description = table_auto_scaling_description

    def as_dict(self) -> Dict[str, Any]:
        """Converts the DescribeTableReplicaAutoScalingOutput to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        d: Dict[str, Any] = {}

        if self.table_auto_scaling_description is not None:
            d["TableAutoScalingDescription"] = self.table_auto_scaling_description.as_dict()

        return d

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "DescribeTableReplicaAutoScalingOutput":
        """Creates a DescribeTableReplicaAutoScalingOutput from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {}

        if "TableAutoScalingDescription" in d:
            kwargs["table_auto_scaling_description"] = TableAutoScalingDescription.from_dict(d["TableAutoScalingDescription"])

        return DescribeTableReplicaAutoScalingOutput(**kwargs)

    def __repr__(self) -> str:
        result = "DescribeTableReplicaAutoScalingOutput("
        if self.table_auto_scaling_description is not None:
            result += f"table_auto_scaling_description={repr(self.table_auto_scaling_description)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, DescribeTableReplicaAutoScalingOutput):
            return False
        attributes: list[str] = ['table_auto_scaling_description',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class DescribeTimeToLiveInput:
    table_name: str
    def __init__(
        self,
        *,
        table_name: str,
    ):
        """
        :param table_name: <p>The name of the table to be described.</p>
        """
        self.table_name = table_name

    def as_dict(self) -> Dict[str, Any]:
        """Converts the DescribeTimeToLiveInput to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        return {
            "TableName": self.table_name,
        }

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "DescribeTimeToLiveInput":
        """Creates a DescribeTimeToLiveInput from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {
            "table_name": d["TableName"],
        }

        return DescribeTimeToLiveInput(**kwargs)

    def __repr__(self) -> str:
        result = "DescribeTimeToLiveInput("
        if self.table_name is not None:
            result += f"table_name={repr(self.table_name)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, DescribeTimeToLiveInput):
            return False
        attributes: list[str] = ['table_name',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class DescribeTimeToLiveOutput:
    time_to_live_description: Optional[TimeToLiveDescription]
    def __init__(
        self,
        *,
        time_to_live_description: Optional[TimeToLiveDescription] = None,
    ):
        """
        :param time_to_live_description: <p></p>
        """
        self.time_to_live_description = time_to_live_description

    def as_dict(self) -> Dict[str, Any]:
        """Converts the DescribeTimeToLiveOutput to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        d: Dict[str, Any] = {}

        if self.time_to_live_description is not None:
            d["TimeToLiveDescription"] = self.time_to_live_description.as_dict()

        return d

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "DescribeTimeToLiveOutput":
        """Creates a DescribeTimeToLiveOutput from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {}

        if "TimeToLiveDescription" in d:
            kwargs["time_to_live_description"] = TimeToLiveDescription.from_dict(d["TimeToLiveDescription"])

        return DescribeTimeToLiveOutput(**kwargs)

    def __repr__(self) -> str:
        result = "DescribeTimeToLiveOutput("
        if self.time_to_live_description is not None:
            result += f"time_to_live_description={repr(self.time_to_live_description)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, DescribeTimeToLiveOutput):
            return False
        attributes: list[str] = ['time_to_live_description',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class DisableKinesisStreamingDestinationInput:
    table_name: str
    stream_arn: str
    def __init__(
        self,
        *,
        table_name: str,
        stream_arn: str,
    ):
        """
        :param table_name: <p>The name of the DynamoDB table.</p>
        :param stream_arn: <p>The ARN for a Kinesis data stream.</p>
        """
        self.table_name = table_name
        self.stream_arn = stream_arn

    def as_dict(self) -> Dict[str, Any]:
        """Converts the DisableKinesisStreamingDestinationInput to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        return {
            "TableName": self.table_name,
            "StreamArn": self.stream_arn,
        }

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "DisableKinesisStreamingDestinationInput":
        """Creates a DisableKinesisStreamingDestinationInput from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {
            "table_name": d["TableName"],
            "stream_arn": d["StreamArn"],
        }

        return DisableKinesisStreamingDestinationInput(**kwargs)

    def __repr__(self) -> str:
        result = "DisableKinesisStreamingDestinationInput("
        if self.table_name is not None:
            result += f"table_name={repr(self.table_name)}, "

        if self.stream_arn is not None:
            result += f"stream_arn={repr(self.stream_arn)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, DisableKinesisStreamingDestinationInput):
            return False
        attributes: list[str] = ['table_name','stream_arn',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class DisableKinesisStreamingDestinationOutput:
    table_name: Optional[str]
    stream_arn: Optional[str]
    destination_status: Optional[str]
    def __init__(
        self,
        *,
        table_name: Optional[str] = None,
        stream_arn: Optional[str] = None,
        destination_status: Optional[str] = None,
    ):
        """
        :param table_name: <p>The name of the table being modified.</p>
        :param stream_arn: <p>The ARN for the specific Kinesis data stream.</p>
        :param destination_status: <p>The current status of the replication.</p>
        """
        self.table_name = table_name
        self.stream_arn = stream_arn
        self.destination_status = destination_status

    def as_dict(self) -> Dict[str, Any]:
        """Converts the DisableKinesisStreamingDestinationOutput to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        d: Dict[str, Any] = {}

        if self.table_name is not None:
            d["TableName"] = self.table_name

        if self.stream_arn is not None:
            d["StreamArn"] = self.stream_arn

        if self.destination_status is not None:
            d["DestinationStatus"] = self.destination_status

        return d

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "DisableKinesisStreamingDestinationOutput":
        """Creates a DisableKinesisStreamingDestinationOutput from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {}

        if "TableName" in d:
            kwargs["table_name"] = d["TableName"]

        if "StreamArn" in d:
            kwargs["stream_arn"] = d["StreamArn"]

        if "DestinationStatus" in d:
            kwargs["destination_status"] = d["DestinationStatus"]

        return DisableKinesisStreamingDestinationOutput(**kwargs)

    def __repr__(self) -> str:
        result = "DisableKinesisStreamingDestinationOutput("
        if self.table_name is not None:
            result += f"table_name={repr(self.table_name)}, "

        if self.stream_arn is not None:
            result += f"stream_arn={repr(self.stream_arn)}, "

        if self.destination_status is not None:
            result += f"destination_status={repr(self.destination_status)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, DisableKinesisStreamingDestinationOutput):
            return False
        attributes: list[str] = ['table_name','stream_arn','destination_status',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class EnableKinesisStreamingDestinationInput:
    table_name: str
    stream_arn: str
    def __init__(
        self,
        *,
        table_name: str,
        stream_arn: str,
    ):
        """
        :param table_name: <p>The name of the DynamoDB table.</p>
        :param stream_arn: <p>The ARN for a Kinesis data stream.</p>
        """
        self.table_name = table_name
        self.stream_arn = stream_arn

    def as_dict(self) -> Dict[str, Any]:
        """Converts the EnableKinesisStreamingDestinationInput to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        return {
            "TableName": self.table_name,
            "StreamArn": self.stream_arn,
        }

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "EnableKinesisStreamingDestinationInput":
        """Creates a EnableKinesisStreamingDestinationInput from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {
            "table_name": d["TableName"],
            "stream_arn": d["StreamArn"],
        }

        return EnableKinesisStreamingDestinationInput(**kwargs)

    def __repr__(self) -> str:
        result = "EnableKinesisStreamingDestinationInput("
        if self.table_name is not None:
            result += f"table_name={repr(self.table_name)}, "

        if self.stream_arn is not None:
            result += f"stream_arn={repr(self.stream_arn)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, EnableKinesisStreamingDestinationInput):
            return False
        attributes: list[str] = ['table_name','stream_arn',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class EnableKinesisStreamingDestinationOutput:
    table_name: Optional[str]
    stream_arn: Optional[str]
    destination_status: Optional[str]
    def __init__(
        self,
        *,
        table_name: Optional[str] = None,
        stream_arn: Optional[str] = None,
        destination_status: Optional[str] = None,
    ):
        """
        :param table_name: <p>The name of the table being modified.</p>
        :param stream_arn: <p>The ARN for the specific Kinesis data stream.</p>
        :param destination_status: <p>The current status of the replication.</p>
        """
        self.table_name = table_name
        self.stream_arn = stream_arn
        self.destination_status = destination_status

    def as_dict(self) -> Dict[str, Any]:
        """Converts the EnableKinesisStreamingDestinationOutput to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        d: Dict[str, Any] = {}

        if self.table_name is not None:
            d["TableName"] = self.table_name

        if self.stream_arn is not None:
            d["StreamArn"] = self.stream_arn

        if self.destination_status is not None:
            d["DestinationStatus"] = self.destination_status

        return d

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "EnableKinesisStreamingDestinationOutput":
        """Creates a EnableKinesisStreamingDestinationOutput from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {}

        if "TableName" in d:
            kwargs["table_name"] = d["TableName"]

        if "StreamArn" in d:
            kwargs["stream_arn"] = d["StreamArn"]

        if "DestinationStatus" in d:
            kwargs["destination_status"] = d["DestinationStatus"]

        return EnableKinesisStreamingDestinationOutput(**kwargs)

    def __repr__(self) -> str:
        result = "EnableKinesisStreamingDestinationOutput("
        if self.table_name is not None:
            result += f"table_name={repr(self.table_name)}, "

        if self.stream_arn is not None:
            result += f"stream_arn={repr(self.stream_arn)}, "

        if self.destination_status is not None:
            result += f"destination_status={repr(self.destination_status)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, EnableKinesisStreamingDestinationOutput):
            return False
        attributes: list[str] = ['table_name','stream_arn','destination_status',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class ExportTableToPointInTimeInput:
    table_arn: str
    export_time: Optional[datetime]
    client_token: Optional[str]
    s3_bucket: str
    s3_bucket_owner: Optional[str]
    s3_prefix: Optional[str]
    s3_sse_algorithm: Optional[str]
    s3_sse_kms_key_id: Optional[str]
    export_format: Optional[str]
    def __init__(
        self,
        *,
        table_arn: str,
        s3_bucket: str,
        export_time: Optional[datetime] = None,
        client_token: Optional[str] = None,
        s3_bucket_owner: Optional[str] = None,
        s3_prefix: Optional[str] = None,
        s3_sse_algorithm: Optional[str] = None,
        s3_sse_kms_key_id: Optional[str] = None,
        export_format: Optional[str] = None,
    ):
        """
        :param table_arn: <p>The Amazon Resource Name (ARN) associated with the table to
        export.</p>
        :param s3_bucket: <p>The name of the Amazon S3 bucket to export the snapshot
        to.</p>
        :param export_time: <p>Time in the past from which to export table data, counted
        in seconds from the start of
                    the Unix epoch. The table export will
        be a snapshot of the table's state at this point
                    in time.</p>
        :param client_token: <p>Providing a <code>ClientToken</code> makes the call to

        <code>ExportTableToPointInTimeInput</code> idempotent, meaning that multiple

        identical calls have the same effect as one single call.</p>
                <p>A client
        token is valid for 8 hours after the first request that uses it is completed.

        After 8 hours, any request with the same client token is treated as a new
        request. Do
                    not resubmit the same request with the same client token
        for more than 8 hours, or the
                    result might not be idempotent.</p>

        <p>If you submit a request with the same client token but a change in other
        parameters
                    within the 8-hour idempotency window, DynamoDB returns
        an
                    <code>ImportConflictException</code>.</p>
        :param s3_bucket_owner: <p>The ID of the Amazon Web Services account that owns
        the bucket the export will be
                    stored in.</p>
        :param s3_prefix: <p>The Amazon S3 bucket prefix to use as the file name and
        path of the exported
                    snapshot.</p>
        :param s3_sse_algorithm: <p>Type of encryption used on the bucket where export
        data will be stored. Valid values
                    for <code>S3SseAlgorithm</code>
        are:</p>
                <ul>
                    <li>
                        <p>

        <code>AES256</code> - server-side encryption with Amazon S3 managed

        keys</p>
                    </li>
                    <li>
                        <p>

        <code>KMS</code> - server-side encryption with KMS managed

        keys</p>
                    </li>
                 </ul>
        :param s3_sse_kms_key_id: <p>The ID of the KMS managed key used to encrypt the
        S3 bucket where
                    export data will be stored (if applicable).</p>
        :param export_format: <p>The format for the exported data. Valid values for
        <code>ExportFormat</code> are
                        <code>DYNAMODB_JSON</code> or
        <code>ION</code>.</p>
        """
        self.table_arn = table_arn
        self.s3_bucket = s3_bucket
        self.export_time = export_time
        self.client_token = client_token
        self.s3_bucket_owner = s3_bucket_owner
        self.s3_prefix = s3_prefix
        self.s3_sse_algorithm = s3_sse_algorithm
        self.s3_sse_kms_key_id = s3_sse_kms_key_id
        self.export_format = export_format

    def as_dict(self) -> Dict[str, Any]:
        """Converts the ExportTableToPointInTimeInput to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        d: Dict[str, Any] = {
            "TableArn": self.table_arn,
            "S3Bucket": self.s3_bucket,
        }

        if self.export_time is not None:
            d["ExportTime"] = self.export_time

        if self.client_token is not None:
            d["ClientToken"] = self.client_token

        if self.s3_bucket_owner is not None:
            d["S3BucketOwner"] = self.s3_bucket_owner

        if self.s3_prefix is not None:
            d["S3Prefix"] = self.s3_prefix

        if self.s3_sse_algorithm is not None:
            d["S3SseAlgorithm"] = self.s3_sse_algorithm

        if self.s3_sse_kms_key_id is not None:
            d["S3SseKmsKeyId"] = self.s3_sse_kms_key_id

        if self.export_format is not None:
            d["ExportFormat"] = self.export_format

        return d

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "ExportTableToPointInTimeInput":
        """Creates a ExportTableToPointInTimeInput from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {
            "table_arn": d["TableArn"],
            "s3_bucket": d["S3Bucket"],
        }

        if "ExportTime" in d:
            kwargs["export_time"] = d["ExportTime"]

        if "ClientToken" in d:
            kwargs["client_token"] = d["ClientToken"]

        if "S3BucketOwner" in d:
            kwargs["s3_bucket_owner"] = d["S3BucketOwner"]

        if "S3Prefix" in d:
            kwargs["s3_prefix"] = d["S3Prefix"]

        if "S3SseAlgorithm" in d:
            kwargs["s3_sse_algorithm"] = d["S3SseAlgorithm"]

        if "S3SseKmsKeyId" in d:
            kwargs["s3_sse_kms_key_id"] = d["S3SseKmsKeyId"]

        if "ExportFormat" in d:
            kwargs["export_format"] = d["ExportFormat"]

        return ExportTableToPointInTimeInput(**kwargs)

    def __repr__(self) -> str:
        result = "ExportTableToPointInTimeInput("
        if self.table_arn is not None:
            result += f"table_arn={repr(self.table_arn)}, "

        if self.export_time is not None:
            result += f"export_time={repr(self.export_time)}, "

        if self.client_token is not None:
            result += f"client_token={repr(self.client_token)}, "

        if self.s3_bucket is not None:
            result += f"s3_bucket={repr(self.s3_bucket)}, "

        if self.s3_bucket_owner is not None:
            result += f"s3_bucket_owner={repr(self.s3_bucket_owner)}, "

        if self.s3_prefix is not None:
            result += f"s3_prefix={repr(self.s3_prefix)}, "

        if self.s3_sse_algorithm is not None:
            result += f"s3_sse_algorithm={repr(self.s3_sse_algorithm)}, "

        if self.s3_sse_kms_key_id is not None:
            result += f"s3_sse_kms_key_id={repr(self.s3_sse_kms_key_id)}, "

        if self.export_format is not None:
            result += f"export_format={repr(self.export_format)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, ExportTableToPointInTimeInput):
            return False
        attributes: list[str] = ['table_arn','export_time','client_token','s3_bucket','s3_bucket_owner','s3_prefix','s3_sse_algorithm','s3_sse_kms_key_id','export_format',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class ExportTableToPointInTimeOutput:
    export_description: Optional[ExportDescription]
    def __init__(
        self,
        *,
        export_description: Optional[ExportDescription] = None,
    ):
        """
        :param export_description: <p>Contains a description of the table export.</p>
        """
        self.export_description = export_description

    def as_dict(self) -> Dict[str, Any]:
        """Converts the ExportTableToPointInTimeOutput to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        d: Dict[str, Any] = {}

        if self.export_description is not None:
            d["ExportDescription"] = self.export_description.as_dict()

        return d

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "ExportTableToPointInTimeOutput":
        """Creates a ExportTableToPointInTimeOutput from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {}

        if "ExportDescription" in d:
            kwargs["export_description"] = ExportDescription.from_dict(d["ExportDescription"])

        return ExportTableToPointInTimeOutput(**kwargs)

    def __repr__(self) -> str:
        result = "ExportTableToPointInTimeOutput("
        if self.export_description is not None:
            result += f"export_description={repr(self.export_description)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, ExportTableToPointInTimeOutput):
            return False
        attributes: list[str] = ['export_description',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class ImportTableInput:
    client_token: Optional[str]
    s3_bucket_source: S3BucketSource
    input_format: str
    input_format_options: Optional[InputFormatOptions]
    input_compression_type: Optional[str]
    table_creation_parameters: TableCreationParameters
    def __init__(
        self,
        *,
        s3_bucket_source: S3BucketSource,
        input_format: str,
        table_creation_parameters: TableCreationParameters,
        client_token: Optional[str] = None,
        input_format_options: Optional[InputFormatOptions] = None,
        input_compression_type: Optional[str] = None,
    ):
        """
        :param s3_bucket_source: <p>
                        The S3 bucket that provides the
        source for the import.
                        </p>
        :param input_format: <p> The format of the source data. Valid values for
        <code>ImportFormat</code> are
                        <code>CSV</code>,
        <code>DYNAMODB_JSON</code> or <code>ION</code>.
                    </p>
        :param table_creation_parameters: <p>Parameters for the table to import the data
        into.
                    </p>
        :param client_token: <p>Providing a <code>ClientToken</code> makes the call to

        <code>ImportTableInput</code> idempotent, meaning that multiple

        identical calls have the same effect as one single call.</p>

        <p>A client token is valid for 8 hours after the first request that uses it is
        completed.
                            After 8 hours, any request with the same client
        token is treated as a new request. Do
                            not resubmit the same
        request with the same client token for more than 8 hours, or the

        result might not be idempotent.</p>
                        <p>If you submit a request
        with the same client token but a change in other parameters

        within the 8-hour idempotency window, DynamoDB returns an

        <code>IdempotentParameterMismatch</code> exception.</p>
        :param input_format_options: <p>
                        Additional properties that
        specify how the input is formatted,
                        </p>
        :param input_compression_type: <p>
                        Type of compression to be
        used on the input coming from the imported table.
                        </p>
        """
        self.s3_bucket_source = s3_bucket_source
        self.input_format = input_format
        self.table_creation_parameters = table_creation_parameters
        self.client_token = client_token
        self.input_format_options = input_format_options
        self.input_compression_type = input_compression_type

    def as_dict(self) -> Dict[str, Any]:
        """Converts the ImportTableInput to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        d: Dict[str, Any] = {
            "S3BucketSource": self.s3_bucket_source.as_dict(),
            "InputFormat": self.input_format,
            "TableCreationParameters": self.table_creation_parameters.as_dict(),
        }

        if self.client_token is not None:
            d["ClientToken"] = self.client_token

        if self.input_format_options is not None:
            d["InputFormatOptions"] = self.input_format_options.as_dict()

        if self.input_compression_type is not None:
            d["InputCompressionType"] = self.input_compression_type

        return d

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "ImportTableInput":
        """Creates a ImportTableInput from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {
            "s3_bucket_source": S3BucketSource.from_dict(d["S3BucketSource"]),
            "input_format": d["InputFormat"],
            "table_creation_parameters": TableCreationParameters.from_dict(d["TableCreationParameters"]),
        }

        if "ClientToken" in d:
            kwargs["client_token"] = d["ClientToken"]

        if "InputFormatOptions" in d:
            kwargs["input_format_options"] = InputFormatOptions.from_dict(d["InputFormatOptions"])

        if "InputCompressionType" in d:
            kwargs["input_compression_type"] = d["InputCompressionType"]

        return ImportTableInput(**kwargs)

    def __repr__(self) -> str:
        result = "ImportTableInput("
        if self.client_token is not None:
            result += f"client_token={repr(self.client_token)}, "

        if self.s3_bucket_source is not None:
            result += f"s3_bucket_source={repr(self.s3_bucket_source)}, "

        if self.input_format is not None:
            result += f"input_format={repr(self.input_format)}, "

        if self.input_format_options is not None:
            result += f"input_format_options={repr(self.input_format_options)}, "

        if self.input_compression_type is not None:
            result += f"input_compression_type={repr(self.input_compression_type)}, "

        if self.table_creation_parameters is not None:
            result += f"table_creation_parameters={repr(self.table_creation_parameters)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, ImportTableInput):
            return False
        attributes: list[str] = ['client_token','s3_bucket_source','input_format','input_format_options','input_compression_type','table_creation_parameters',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class ImportTableOutput:
    import_table_description: ImportTableDescription
    def __init__(
        self,
        *,
        import_table_description: ImportTableDescription,
    ):
        """
        :param import_table_description: <p>
                        Represents the properties
        of the table created for the import, and parameters of
                        the
        import. The import parameters include import status, how many items were
        processed,
                        and how many errors were encountered.

        </p>
        """
        self.import_table_description = import_table_description

    def as_dict(self) -> Dict[str, Any]:
        """Converts the ImportTableOutput to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        return {
            "ImportTableDescription": self.import_table_description.as_dict(),
        }

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "ImportTableOutput":
        """Creates a ImportTableOutput from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {
            "import_table_description": ImportTableDescription.from_dict(d["ImportTableDescription"]),
        }

        return ImportTableOutput(**kwargs)

    def __repr__(self) -> str:
        result = "ImportTableOutput("
        if self.import_table_description is not None:
            result += f"import_table_description={repr(self.import_table_description)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, ImportTableOutput):
            return False
        attributes: list[str] = ['import_table_description',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class ListBackupsInput:
    table_name: Optional[str]
    limit: Optional[int]
    time_range_lower_bound: Optional[datetime]
    time_range_upper_bound: Optional[datetime]
    exclusive_start_backup_arn: Optional[str]
    backup_type: Optional[str]
    def __init__(
        self,
        *,
        table_name: Optional[str] = None,
        limit: Optional[int] = None,
        time_range_lower_bound: Optional[datetime] = None,
        time_range_upper_bound: Optional[datetime] = None,
        exclusive_start_backup_arn: Optional[str] = None,
        backup_type: Optional[str] = None,
    ):
        """
        :param table_name: <p>The backups from the table specified by
        <code>TableName</code> are listed. </p>
        :param limit: <p>Maximum number of backups to return at once.</p>
        :param time_range_lower_bound: <p>Only backups created after this time are
        listed. <code>TimeRangeLowerBound</code> is
                    inclusive.</p>
        :param time_range_upper_bound: <p>Only backups created before this time are
        listed. <code>TimeRangeUpperBound</code> is
                    exclusive. </p>
        :param exclusive_start_backup_arn: <p>

        <code>LastEvaluatedBackupArn</code> is the Amazon Resource Name (ARN) of the
        backup last
                    evaluated when the current page of results was returned,
        inclusive of the current page
                    of results. This value may be
        specified as the <code>ExclusiveStartBackupArn</code> of a
                    new
        <code>ListBackups</code> operation in order to fetch the next page of results.

        </p>
        :param backup_type: <p>The backups from the table specified by
        <code>BackupType</code> are listed.</p>
                <p>Where <code>BackupType</code>
        can be:</p>
                <ul>
                    <li>
                        <p>

        <code>USER</code> - On-demand backup created by you. (The default setting if no
        other backup types are specified.)</p>
                    </li>
                    <li>

        <p>
                            <code>SYSTEM</code> - On-demand backup automatically
        created by DynamoDB.</p>
                    </li>
                    <li>
                        <p>

        <code>ALL</code> - All types of on-demand backups (USER and SYSTEM).</p>

        </li>
                 </ul>
        """
        self.table_name = table_name
        self.limit = limit
        self.time_range_lower_bound = time_range_lower_bound
        self.time_range_upper_bound = time_range_upper_bound
        self.exclusive_start_backup_arn = exclusive_start_backup_arn
        self.backup_type = backup_type

    def as_dict(self) -> Dict[str, Any]:
        """Converts the ListBackupsInput to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        d: Dict[str, Any] = {}

        if self.table_name is not None:
            d["TableName"] = self.table_name

        if self.limit is not None:
            d["Limit"] = self.limit

        if self.time_range_lower_bound is not None:
            d["TimeRangeLowerBound"] = self.time_range_lower_bound

        if self.time_range_upper_bound is not None:
            d["TimeRangeUpperBound"] = self.time_range_upper_bound

        if self.exclusive_start_backup_arn is not None:
            d["ExclusiveStartBackupArn"] = self.exclusive_start_backup_arn

        if self.backup_type is not None:
            d["BackupType"] = self.backup_type

        return d

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "ListBackupsInput":
        """Creates a ListBackupsInput from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {}

        if "TableName" in d:
            kwargs["table_name"] = d["TableName"]

        if "Limit" in d:
            kwargs["limit"] = d["Limit"]

        if "TimeRangeLowerBound" in d:
            kwargs["time_range_lower_bound"] = d["TimeRangeLowerBound"]

        if "TimeRangeUpperBound" in d:
            kwargs["time_range_upper_bound"] = d["TimeRangeUpperBound"]

        if "ExclusiveStartBackupArn" in d:
            kwargs["exclusive_start_backup_arn"] = d["ExclusiveStartBackupArn"]

        if "BackupType" in d:
            kwargs["backup_type"] = d["BackupType"]

        return ListBackupsInput(**kwargs)

    def __repr__(self) -> str:
        result = "ListBackupsInput("
        if self.table_name is not None:
            result += f"table_name={repr(self.table_name)}, "

        if self.limit is not None:
            result += f"limit={repr(self.limit)}, "

        if self.time_range_lower_bound is not None:
            result += f"time_range_lower_bound={repr(self.time_range_lower_bound)}, "

        if self.time_range_upper_bound is not None:
            result += f"time_range_upper_bound={repr(self.time_range_upper_bound)}, "

        if self.exclusive_start_backup_arn is not None:
            result += f"exclusive_start_backup_arn={repr(self.exclusive_start_backup_arn)}, "

        if self.backup_type is not None:
            result += f"backup_type={repr(self.backup_type)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, ListBackupsInput):
            return False
        attributes: list[str] = ['table_name','limit','time_range_lower_bound','time_range_upper_bound','exclusive_start_backup_arn','backup_type',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class ListBackupsOutput:
    backup_summaries: Optional[list[BackupSummary]]
    last_evaluated_backup_arn: Optional[str]
    def __init__(
        self,
        *,
        backup_summaries: Optional[list[BackupSummary]] = None,
        last_evaluated_backup_arn: Optional[str] = None,
    ):
        """
        :param backup_summaries: <p>List of <code>BackupSummary</code> objects.</p>
        :param last_evaluated_backup_arn: <p> The ARN of the backup last evaluated when
        the current page of results was returned,
                    inclusive of the current
        page of results. This value may be specified as the

        <code>ExclusiveStartBackupArn</code> of a new <code>ListBackups</code> operation
        in
                    order to fetch the next page of results. </p>
                <p> If
        <code>LastEvaluatedBackupArn</code> is empty, then the last page of results has

        been processed and there are no more results to be retrieved. </p>
                <p>
        If <code>LastEvaluatedBackupArn</code> is not empty, this may or may not
        indicate
                    that there is more data to be returned. All results are
        guaranteed to have been returned
                    if and only if no value for
        <code>LastEvaluatedBackupArn</code> is returned. </p>
        """
        self.backup_summaries = backup_summaries
        self.last_evaluated_backup_arn = last_evaluated_backup_arn

    def as_dict(self) -> Dict[str, Any]:
        """Converts the ListBackupsOutput to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        d: Dict[str, Any] = {}

        if self.backup_summaries is not None:
            d["BackupSummaries"] = _backup_summaries_as_dict(self.backup_summaries),

        if self.last_evaluated_backup_arn is not None:
            d["LastEvaluatedBackupArn"] = self.last_evaluated_backup_arn

        return d

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "ListBackupsOutput":
        """Creates a ListBackupsOutput from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {}

        if "BackupSummaries" in d:
            kwargs["backup_summaries"] = _backup_summaries_from_dict(d["BackupSummaries"]),

        if "LastEvaluatedBackupArn" in d:
            kwargs["last_evaluated_backup_arn"] = d["LastEvaluatedBackupArn"]

        return ListBackupsOutput(**kwargs)

    def __repr__(self) -> str:
        result = "ListBackupsOutput("
        if self.backup_summaries is not None:
            result += f"backup_summaries={repr(self.backup_summaries)}, "

        if self.last_evaluated_backup_arn is not None:
            result += f"last_evaluated_backup_arn={repr(self.last_evaluated_backup_arn)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, ListBackupsOutput):
            return False
        attributes: list[str] = ['backup_summaries','last_evaluated_backup_arn',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class ListContributorInsightsInput:
    table_name: Optional[str]
    next_token: Optional[str]
    max_results: int
    def __init__(
        self,
        *,
        table_name: Optional[str] = None,
        next_token: Optional[str] = None,
        max_results: int = 0,
    ):
        """
        :param table_name: <p>The name of the table.</p>
        :param next_token: <p>A token to for the desired page, if there is one.</p>
        :param max_results: <p>Maximum number of results to return per page.</p>
        """
        self.table_name = table_name
        self.next_token = next_token
        self.max_results = max_results

    def as_dict(self) -> Dict[str, Any]:
        """Converts the ListContributorInsightsInput to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        d: Dict[str, Any] = {}

        if self.table_name is not None:
            d["TableName"] = self.table_name

        if self.next_token is not None:
            d["NextToken"] = self.next_token

        if self.max_results is not None:
            d["MaxResults"] = self.max_results

        return d

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "ListContributorInsightsInput":
        """Creates a ListContributorInsightsInput from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {}

        if "TableName" in d:
            kwargs["table_name"] = d["TableName"]

        if "NextToken" in d:
            kwargs["next_token"] = d["NextToken"]

        if "MaxResults" in d:
            kwargs["max_results"] = d["MaxResults"]

        return ListContributorInsightsInput(**kwargs)

    def __repr__(self) -> str:
        result = "ListContributorInsightsInput("
        if self.table_name is not None:
            result += f"table_name={repr(self.table_name)}, "

        if self.next_token is not None:
            result += f"next_token={repr(self.next_token)}, "

        if self.max_results is not None:
            result += f"max_results={repr(self.max_results)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, ListContributorInsightsInput):
            return False
        attributes: list[str] = ['table_name','next_token','max_results',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class ListContributorInsightsOutput:
    contributor_insights_summaries: Optional[list[ContributorInsightsSummary]]
    next_token: Optional[str]
    def __init__(
        self,
        *,
        contributor_insights_summaries: Optional[list[ContributorInsightsSummary]] = None,
        next_token: Optional[str] = None,
    ):
        """
        :param contributor_insights_summaries: <p>A list of
        ContributorInsightsSummary.</p>
        :param next_token: <p>A token to go to the next page if there is one.</p>
        """
        self.contributor_insights_summaries = contributor_insights_summaries
        self.next_token = next_token

    def as_dict(self) -> Dict[str, Any]:
        """Converts the ListContributorInsightsOutput to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        d: Dict[str, Any] = {}

        if self.contributor_insights_summaries is not None:
            d["ContributorInsightsSummaries"] = _contributor_insights_summaries_as_dict(self.contributor_insights_summaries),

        if self.next_token is not None:
            d["NextToken"] = self.next_token

        return d

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "ListContributorInsightsOutput":
        """Creates a ListContributorInsightsOutput from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {}

        if "ContributorInsightsSummaries" in d:
            kwargs["contributor_insights_summaries"] = _contributor_insights_summaries_from_dict(d["ContributorInsightsSummaries"]),

        if "NextToken" in d:
            kwargs["next_token"] = d["NextToken"]

        return ListContributorInsightsOutput(**kwargs)

    def __repr__(self) -> str:
        result = "ListContributorInsightsOutput("
        if self.contributor_insights_summaries is not None:
            result += f"contributor_insights_summaries={repr(self.contributor_insights_summaries)}, "

        if self.next_token is not None:
            result += f"next_token={repr(self.next_token)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, ListContributorInsightsOutput):
            return False
        attributes: list[str] = ['contributor_insights_summaries','next_token',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class ListExportsInput:
    table_arn: Optional[str]
    max_results: Optional[int]
    next_token: Optional[str]
    def __init__(
        self,
        *,
        table_arn: Optional[str] = None,
        max_results: Optional[int] = None,
        next_token: Optional[str] = None,
    ):
        """
        :param table_arn: <p>The Amazon Resource Name (ARN) associated with the exported
        table.</p>
        :param max_results: <p>Maximum number of results to return per page.</p>
        :param next_token: <p>An optional string that, if supplied, must be copied from
        the output of a previous
                    call to <code>ListExports</code>. When
        provided in this manner, the API fetches the next
                    page of
        results.</p>
        """
        self.table_arn = table_arn
        self.max_results = max_results
        self.next_token = next_token

    def as_dict(self) -> Dict[str, Any]:
        """Converts the ListExportsInput to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        d: Dict[str, Any] = {}

        if self.table_arn is not None:
            d["TableArn"] = self.table_arn

        if self.max_results is not None:
            d["MaxResults"] = self.max_results

        if self.next_token is not None:
            d["NextToken"] = self.next_token

        return d

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "ListExportsInput":
        """Creates a ListExportsInput from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {}

        if "TableArn" in d:
            kwargs["table_arn"] = d["TableArn"]

        if "MaxResults" in d:
            kwargs["max_results"] = d["MaxResults"]

        if "NextToken" in d:
            kwargs["next_token"] = d["NextToken"]

        return ListExportsInput(**kwargs)

    def __repr__(self) -> str:
        result = "ListExportsInput("
        if self.table_arn is not None:
            result += f"table_arn={repr(self.table_arn)}, "

        if self.max_results is not None:
            result += f"max_results={repr(self.max_results)}, "

        if self.next_token is not None:
            result += f"next_token={repr(self.next_token)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, ListExportsInput):
            return False
        attributes: list[str] = ['table_arn','max_results','next_token',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class ExportSummary:
    export_arn: Optional[str]
    export_status: Optional[str]
    def __init__(
        self,
        *,
        export_arn: Optional[str] = None,
        export_status: Optional[str] = None,
    ):
        """<p>Summary information about an export task.</p>

        :param export_arn: <p>The Amazon Resource Name (ARN) of the export.</p>
        :param export_status: <p>Export can be in one of the following states:
        IN_PROGRESS, COMPLETED, or
                    FAILED.</p>
        """
        self.export_arn = export_arn
        self.export_status = export_status

    def as_dict(self) -> Dict[str, Any]:
        """Converts the ExportSummary to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        d: Dict[str, Any] = {}

        if self.export_arn is not None:
            d["ExportArn"] = self.export_arn

        if self.export_status is not None:
            d["ExportStatus"] = self.export_status

        return d

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "ExportSummary":
        """Creates a ExportSummary from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {}

        if "ExportArn" in d:
            kwargs["export_arn"] = d["ExportArn"]

        if "ExportStatus" in d:
            kwargs["export_status"] = d["ExportStatus"]

        return ExportSummary(**kwargs)

    def __repr__(self) -> str:
        result = "ExportSummary("
        if self.export_arn is not None:
            result += f"export_arn={repr(self.export_arn)}, "

        if self.export_status is not None:
            result += f"export_status={repr(self.export_status)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, ExportSummary):
            return False
        attributes: list[str] = ['export_arn','export_status',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class ListExportsOutput:
    export_summaries: Optional[list[ExportSummary]]
    next_token: Optional[str]
    def __init__(
        self,
        *,
        export_summaries: Optional[list[ExportSummary]] = None,
        next_token: Optional[str] = None,
    ):
        """
        :param export_summaries: <p>A list of <code>ExportSummary</code> objects.</p>
        :param next_token: <p>If this value is returned, there are additional results to
        be displayed. To retrieve
                    them, call <code>ListExports</code> again,
        with <code>NextToken</code> set to this
                    value.</p>
        """
        self.export_summaries = export_summaries
        self.next_token = next_token

    def as_dict(self) -> Dict[str, Any]:
        """Converts the ListExportsOutput to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        d: Dict[str, Any] = {}

        if self.export_summaries is not None:
            d["ExportSummaries"] = _export_summaries_as_dict(self.export_summaries),

        if self.next_token is not None:
            d["NextToken"] = self.next_token

        return d

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "ListExportsOutput":
        """Creates a ListExportsOutput from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {}

        if "ExportSummaries" in d:
            kwargs["export_summaries"] = _export_summaries_from_dict(d["ExportSummaries"]),

        if "NextToken" in d:
            kwargs["next_token"] = d["NextToken"]

        return ListExportsOutput(**kwargs)

    def __repr__(self) -> str:
        result = "ListExportsOutput("
        if self.export_summaries is not None:
            result += f"export_summaries={repr(self.export_summaries)}, "

        if self.next_token is not None:
            result += f"next_token={repr(self.next_token)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, ListExportsOutput):
            return False
        attributes: list[str] = ['export_summaries','next_token',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class ListGlobalTablesInput:
    exclusive_start_global_table_name: Optional[str]
    limit: Optional[int]
    region_name: Optional[str]
    def __init__(
        self,
        *,
        exclusive_start_global_table_name: Optional[str] = None,
        limit: Optional[int] = None,
        region_name: Optional[str] = None,
    ):
        """
        :param exclusive_start_global_table_name: <p>The first global table name that
        this operation will evaluate.</p>
        :param limit: <p>The maximum number of table names to return, if the parameter
        is not specified
                    DynamoDB defaults to 100.</p>
                <p>If the
        number of global tables DynamoDB finds reaches this limit, it stops the

        operation and returns the table names collected up to that point, with a table
        name in
                    the <code>LastEvaluatedGlobalTableName</code> to apply in a
        subsequent operation to the

        <code>ExclusiveStartGlobalTableName</code> parameter.</p>
        :param region_name: <p>Lists the global tables in a specific Region.</p>
        """
        self.exclusive_start_global_table_name = exclusive_start_global_table_name
        self.limit = limit
        self.region_name = region_name

    def as_dict(self) -> Dict[str, Any]:
        """Converts the ListGlobalTablesInput to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        d: Dict[str, Any] = {}

        if self.exclusive_start_global_table_name is not None:
            d["ExclusiveStartGlobalTableName"] = self.exclusive_start_global_table_name

        if self.limit is not None:
            d["Limit"] = self.limit

        if self.region_name is not None:
            d["RegionName"] = self.region_name

        return d

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "ListGlobalTablesInput":
        """Creates a ListGlobalTablesInput from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {}

        if "ExclusiveStartGlobalTableName" in d:
            kwargs["exclusive_start_global_table_name"] = d["ExclusiveStartGlobalTableName"]

        if "Limit" in d:
            kwargs["limit"] = d["Limit"]

        if "RegionName" in d:
            kwargs["region_name"] = d["RegionName"]

        return ListGlobalTablesInput(**kwargs)

    def __repr__(self) -> str:
        result = "ListGlobalTablesInput("
        if self.exclusive_start_global_table_name is not None:
            result += f"exclusive_start_global_table_name={repr(self.exclusive_start_global_table_name)}, "

        if self.limit is not None:
            result += f"limit={repr(self.limit)}, "

        if self.region_name is not None:
            result += f"region_name={repr(self.region_name)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, ListGlobalTablesInput):
            return False
        attributes: list[str] = ['exclusive_start_global_table_name','limit','region_name',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class GlobalTable:
    global_table_name: Optional[str]
    replication_group: Optional[list[Replica]]
    def __init__(
        self,
        *,
        global_table_name: Optional[str] = None,
        replication_group: Optional[list[Replica]] = None,
    ):
        """<p>Represents the properties of a global table.</p>

        :param global_table_name: <p>The global table name.</p>
        :param replication_group: <p>The Regions where the global table has
        replicas.</p>
        """
        self.global_table_name = global_table_name
        self.replication_group = replication_group

    def as_dict(self) -> Dict[str, Any]:
        """Converts the GlobalTable to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        d: Dict[str, Any] = {}

        if self.global_table_name is not None:
            d["GlobalTableName"] = self.global_table_name

        if self.replication_group is not None:
            d["ReplicationGroup"] = _replica_list_as_dict(self.replication_group),

        return d

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "GlobalTable":
        """Creates a GlobalTable from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {}

        if "GlobalTableName" in d:
            kwargs["global_table_name"] = d["GlobalTableName"]

        if "ReplicationGroup" in d:
            kwargs["replication_group"] = _replica_list_from_dict(d["ReplicationGroup"]),

        return GlobalTable(**kwargs)

    def __repr__(self) -> str:
        result = "GlobalTable("
        if self.global_table_name is not None:
            result += f"global_table_name={repr(self.global_table_name)}, "

        if self.replication_group is not None:
            result += f"replication_group={repr(self.replication_group)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, GlobalTable):
            return False
        attributes: list[str] = ['global_table_name','replication_group',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class ListGlobalTablesOutput:
    global_tables: Optional[list[GlobalTable]]
    last_evaluated_global_table_name: Optional[str]
    def __init__(
        self,
        *,
        global_tables: Optional[list[GlobalTable]] = None,
        last_evaluated_global_table_name: Optional[str] = None,
    ):
        """
        :param global_tables: <p>List of global table names.</p>
        :param last_evaluated_global_table_name: <p>Last evaluated global table
        name.</p>
        """
        self.global_tables = global_tables
        self.last_evaluated_global_table_name = last_evaluated_global_table_name

    def as_dict(self) -> Dict[str, Any]:
        """Converts the ListGlobalTablesOutput to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        d: Dict[str, Any] = {}

        if self.global_tables is not None:
            d["GlobalTables"] = _global_table_list_as_dict(self.global_tables),

        if self.last_evaluated_global_table_name is not None:
            d["LastEvaluatedGlobalTableName"] = self.last_evaluated_global_table_name

        return d

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "ListGlobalTablesOutput":
        """Creates a ListGlobalTablesOutput from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {}

        if "GlobalTables" in d:
            kwargs["global_tables"] = _global_table_list_from_dict(d["GlobalTables"]),

        if "LastEvaluatedGlobalTableName" in d:
            kwargs["last_evaluated_global_table_name"] = d["LastEvaluatedGlobalTableName"]

        return ListGlobalTablesOutput(**kwargs)

    def __repr__(self) -> str:
        result = "ListGlobalTablesOutput("
        if self.global_tables is not None:
            result += f"global_tables={repr(self.global_tables)}, "

        if self.last_evaluated_global_table_name is not None:
            result += f"last_evaluated_global_table_name={repr(self.last_evaluated_global_table_name)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, ListGlobalTablesOutput):
            return False
        attributes: list[str] = ['global_tables','last_evaluated_global_table_name',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class ListImportsInput:
    table_arn: Optional[str]
    page_size: Optional[int]
    next_token: Optional[str]
    def __init__(
        self,
        *,
        table_arn: Optional[str] = None,
        page_size: Optional[int] = None,
        next_token: Optional[str] = None,
    ):
        """
        :param table_arn: <p>
                        The Amazon Resource Name (ARN) associated
        with the table that was imported to.
                        </p>
        :param page_size: <p>
                        The number of <code>ImportSummary
        </code>objects returned in a single page.
                        </p>
        :param next_token: <p>
                        An optional string that, if supplied,
        must be copied from the output of a previous
                        call to
        <code>ListImports</code>. When provided in this manner, the API fetches the
        next
                        page of results.
                        </p>
        """
        self.table_arn = table_arn
        self.page_size = page_size
        self.next_token = next_token

    def as_dict(self) -> Dict[str, Any]:
        """Converts the ListImportsInput to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        d: Dict[str, Any] = {}

        if self.table_arn is not None:
            d["TableArn"] = self.table_arn

        if self.page_size is not None:
            d["PageSize"] = self.page_size

        if self.next_token is not None:
            d["NextToken"] = self.next_token

        return d

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "ListImportsInput":
        """Creates a ListImportsInput from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {}

        if "TableArn" in d:
            kwargs["table_arn"] = d["TableArn"]

        if "PageSize" in d:
            kwargs["page_size"] = d["PageSize"]

        if "NextToken" in d:
            kwargs["next_token"] = d["NextToken"]

        return ListImportsInput(**kwargs)

    def __repr__(self) -> str:
        result = "ListImportsInput("
        if self.table_arn is not None:
            result += f"table_arn={repr(self.table_arn)}, "

        if self.page_size is not None:
            result += f"page_size={repr(self.page_size)}, "

        if self.next_token is not None:
            result += f"next_token={repr(self.next_token)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, ListImportsInput):
            return False
        attributes: list[str] = ['table_arn','page_size','next_token',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class ImportSummary:
    import_arn: Optional[str]
    import_status: Optional[str]
    table_arn: Optional[str]
    s3_bucket_source: Optional[S3BucketSource]
    cloud_watch_log_group_arn: Optional[str]
    input_format: Optional[str]
    start_time: Optional[datetime]
    end_time: Optional[datetime]
    def __init__(
        self,
        *,
        import_arn: Optional[str] = None,
        import_status: Optional[str] = None,
        table_arn: Optional[str] = None,
        s3_bucket_source: Optional[S3BucketSource] = None,
        cloud_watch_log_group_arn: Optional[str] = None,
        input_format: Optional[str] = None,
        start_time: Optional[datetime] = None,
        end_time: Optional[datetime] = None,
    ):
        """<p>
                    Summary information about the source file for the import.

        </p>

        :param import_arn: <p>
                    The Amazon Resource Number (ARN)
        corresponding to the import request.
                    </p>
        :param import_status: <p>
                    The status of the import operation.

        </p>
        :param table_arn: <p>
                    The Amazon Resource Number (ARN) of the table
        being imported into.
                    </p>
        :param s3_bucket_source: <p>
                    The path and S3 bucket of the source
        file that is being imported. This includes the S3Bucket (required),

        S3KeyPrefix (optional) and S3BucketOwner (optional if the bucket is owned by the
        requester).
                    </p>
        :param cloud_watch_log_group_arn: <p>
                    The Amazon Resource Number
        (ARN) of the Cloudwatch Log Group associated with this import task.

        </p>
        :param input_format: <p>
                    The format of the source data. Valid values
        are <code>CSV</code>,
                    <code>DYNAMODB_JSON</code> or
        <code>ION</code>.</p>
        :param start_time: <p>
                    The time at which this import task began.

        </p>
        :param end_time: <p>
                    The time at which this import task ended. (Does
        this include the successful complete creation of
                    the table it was
        imported to?)
                    </p>
        """
        self.import_arn = import_arn
        self.import_status = import_status
        self.table_arn = table_arn
        self.s3_bucket_source = s3_bucket_source
        self.cloud_watch_log_group_arn = cloud_watch_log_group_arn
        self.input_format = input_format
        self.start_time = start_time
        self.end_time = end_time

    def as_dict(self) -> Dict[str, Any]:
        """Converts the ImportSummary to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        d: Dict[str, Any] = {}

        if self.import_arn is not None:
            d["ImportArn"] = self.import_arn

        if self.import_status is not None:
            d["ImportStatus"] = self.import_status

        if self.table_arn is not None:
            d["TableArn"] = self.table_arn

        if self.s3_bucket_source is not None:
            d["S3BucketSource"] = self.s3_bucket_source.as_dict()

        if self.cloud_watch_log_group_arn is not None:
            d["CloudWatchLogGroupArn"] = self.cloud_watch_log_group_arn

        if self.input_format is not None:
            d["InputFormat"] = self.input_format

        if self.start_time is not None:
            d["StartTime"] = self.start_time

        if self.end_time is not None:
            d["EndTime"] = self.end_time

        return d

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "ImportSummary":
        """Creates a ImportSummary from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {}

        if "ImportArn" in d:
            kwargs["import_arn"] = d["ImportArn"]

        if "ImportStatus" in d:
            kwargs["import_status"] = d["ImportStatus"]

        if "TableArn" in d:
            kwargs["table_arn"] = d["TableArn"]

        if "S3BucketSource" in d:
            kwargs["s3_bucket_source"] = S3BucketSource.from_dict(d["S3BucketSource"])

        if "CloudWatchLogGroupArn" in d:
            kwargs["cloud_watch_log_group_arn"] = d["CloudWatchLogGroupArn"]

        if "InputFormat" in d:
            kwargs["input_format"] = d["InputFormat"]

        if "StartTime" in d:
            kwargs["start_time"] = d["StartTime"]

        if "EndTime" in d:
            kwargs["end_time"] = d["EndTime"]

        return ImportSummary(**kwargs)

    def __repr__(self) -> str:
        result = "ImportSummary("
        if self.import_arn is not None:
            result += f"import_arn={repr(self.import_arn)}, "

        if self.import_status is not None:
            result += f"import_status={repr(self.import_status)}, "

        if self.table_arn is not None:
            result += f"table_arn={repr(self.table_arn)}, "

        if self.s3_bucket_source is not None:
            result += f"s3_bucket_source={repr(self.s3_bucket_source)}, "

        if self.cloud_watch_log_group_arn is not None:
            result += f"cloud_watch_log_group_arn={repr(self.cloud_watch_log_group_arn)}, "

        if self.input_format is not None:
            result += f"input_format={repr(self.input_format)}, "

        if self.start_time is not None:
            result += f"start_time={repr(self.start_time)}, "

        if self.end_time is not None:
            result += f"end_time={repr(self.end_time)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, ImportSummary):
            return False
        attributes: list[str] = ['import_arn','import_status','table_arn','s3_bucket_source','cloud_watch_log_group_arn','input_format','start_time','end_time',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class ListImportsOutput:
    import_summary_list: Optional[list[ImportSummary]]
    next_token: Optional[str]
    def __init__(
        self,
        *,
        import_summary_list: Optional[list[ImportSummary]] = None,
        next_token: Optional[str] = None,
    ):
        """
        :param import_summary_list: <p>
                        A list of
        <code>ImportSummary</code> objects.
                        </p>
        :param next_token: <p>
                        If this value is returned, there are
        additional results to be displayed. To retrieve
                        them, call
        <code>ListImports</code> again, with <code>NextToken</code> set to this

        value.
                        </p>
        """
        self.import_summary_list = import_summary_list
        self.next_token = next_token

    def as_dict(self) -> Dict[str, Any]:
        """Converts the ListImportsOutput to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        d: Dict[str, Any] = {}

        if self.import_summary_list is not None:
            d["ImportSummaryList"] = _import_summary_list_as_dict(self.import_summary_list),

        if self.next_token is not None:
            d["NextToken"] = self.next_token

        return d

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "ListImportsOutput":
        """Creates a ListImportsOutput from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {}

        if "ImportSummaryList" in d:
            kwargs["import_summary_list"] = _import_summary_list_from_dict(d["ImportSummaryList"]),

        if "NextToken" in d:
            kwargs["next_token"] = d["NextToken"]

        return ListImportsOutput(**kwargs)

    def __repr__(self) -> str:
        result = "ListImportsOutput("
        if self.import_summary_list is not None:
            result += f"import_summary_list={repr(self.import_summary_list)}, "

        if self.next_token is not None:
            result += f"next_token={repr(self.next_token)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, ListImportsOutput):
            return False
        attributes: list[str] = ['import_summary_list','next_token',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class ListTablesInput:
    exclusive_start_table_name: Optional[str]
    limit: Optional[int]
    def __init__(
        self,
        *,
        exclusive_start_table_name: Optional[str] = None,
        limit: Optional[int] = None,
    ):
        """<p>Represents the input of a <code>ListTables</code> operation.</p>

        :param exclusive_start_table_name: <p>The first table name that this operation
        will evaluate. Use the value that was
                    returned for
        <code>LastEvaluatedTableName</code> in a previous operation, so that you

        can obtain the next page of results.</p>
        :param limit: <p>A maximum number of table names to return. If this parameter is
        not specified, the
                    limit is 100.</p>
        """
        self.exclusive_start_table_name = exclusive_start_table_name
        self.limit = limit

    def as_dict(self) -> Dict[str, Any]:
        """Converts the ListTablesInput to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        d: Dict[str, Any] = {}

        if self.exclusive_start_table_name is not None:
            d["ExclusiveStartTableName"] = self.exclusive_start_table_name

        if self.limit is not None:
            d["Limit"] = self.limit

        return d

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "ListTablesInput":
        """Creates a ListTablesInput from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {}

        if "ExclusiveStartTableName" in d:
            kwargs["exclusive_start_table_name"] = d["ExclusiveStartTableName"]

        if "Limit" in d:
            kwargs["limit"] = d["Limit"]

        return ListTablesInput(**kwargs)

    def __repr__(self) -> str:
        result = "ListTablesInput("
        if self.exclusive_start_table_name is not None:
            result += f"exclusive_start_table_name={repr(self.exclusive_start_table_name)}, "

        if self.limit is not None:
            result += f"limit={repr(self.limit)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, ListTablesInput):
            return False
        attributes: list[str] = ['exclusive_start_table_name','limit',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class ListTablesOutput:
    table_names: Optional[list[str]]
    last_evaluated_table_name: Optional[str]
    def __init__(
        self,
        *,
        table_names: Optional[list[str]] = None,
        last_evaluated_table_name: Optional[str] = None,
    ):
        """<p>Represents the output of a <code>ListTables</code> operation.</p>

        :param table_names: <p>The names of the tables associated with the current
        account at the current endpoint.
                    The maximum size of this array is
        100.</p>
                <p>If <code>LastEvaluatedTableName</code> also appears in the
        output, you can use this
                    value as the
        <code>ExclusiveStartTableName</code> parameter in a subsequent

        <code>ListTables</code> request and obtain the next page of results.</p>
        :param last_evaluated_table_name: <p>The name of the last table in the current
        page of results. Use this value as the

        <code>ExclusiveStartTableName</code> in a new request to obtain the next page
        of
                    results, until all the table names are returned.</p>

        <p>If you do not receive a <code>LastEvaluatedTableName</code> value in the
        response,
                    this means that there are no more table names to be
        retrieved.</p>
        """
        self.table_names = table_names
        self.last_evaluated_table_name = last_evaluated_table_name

    def as_dict(self) -> Dict[str, Any]:
        """Converts the ListTablesOutput to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        d: Dict[str, Any] = {}

        if self.table_names is not None:
            d["TableNames"] = self.table_names

        if self.last_evaluated_table_name is not None:
            d["LastEvaluatedTableName"] = self.last_evaluated_table_name

        return d

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "ListTablesOutput":
        """Creates a ListTablesOutput from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {}

        if "TableNames" in d:
            kwargs["table_names"] = d["TableNames"]

        if "LastEvaluatedTableName" in d:
            kwargs["last_evaluated_table_name"] = d["LastEvaluatedTableName"]

        return ListTablesOutput(**kwargs)

    def __repr__(self) -> str:
        result = "ListTablesOutput("
        if self.table_names is not None:
            result += f"table_names={repr(self.table_names)}, "

        if self.last_evaluated_table_name is not None:
            result += f"last_evaluated_table_name={repr(self.last_evaluated_table_name)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, ListTablesOutput):
            return False
        attributes: list[str] = ['table_names','last_evaluated_table_name',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class ListTagsOfResourceInput:
    resource_arn: str
    next_token: Optional[str]
    def __init__(
        self,
        *,
        resource_arn: str,
        next_token: Optional[str] = None,
    ):
        """
        :param resource_arn: <p>The Amazon DynamoDB resource with tags to be listed.
        This value is an Amazon Resource
                    Name (ARN).</p>
        :param next_token: <p>An optional string that, if supplied, must be copied from
        the output of a previous
                    call to ListTagOfResource. When provided in
        this manner, this API fetches the next page
                    of results.</p>
        """
        self.resource_arn = resource_arn
        self.next_token = next_token

    def as_dict(self) -> Dict[str, Any]:
        """Converts the ListTagsOfResourceInput to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        d: Dict[str, Any] = {
            "ResourceArn": self.resource_arn,
        }

        if self.next_token is not None:
            d["NextToken"] = self.next_token

        return d

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "ListTagsOfResourceInput":
        """Creates a ListTagsOfResourceInput from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {
            "resource_arn": d["ResourceArn"],
        }

        if "NextToken" in d:
            kwargs["next_token"] = d["NextToken"]

        return ListTagsOfResourceInput(**kwargs)

    def __repr__(self) -> str:
        result = "ListTagsOfResourceInput("
        if self.resource_arn is not None:
            result += f"resource_arn={repr(self.resource_arn)}, "

        if self.next_token is not None:
            result += f"next_token={repr(self.next_token)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, ListTagsOfResourceInput):
            return False
        attributes: list[str] = ['resource_arn','next_token',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class ListTagsOfResourceOutput:
    tags: Optional[list[Tag]]
    next_token: Optional[str]
    def __init__(
        self,
        *,
        tags: Optional[list[Tag]] = None,
        next_token: Optional[str] = None,
    ):
        """
        :param tags: <p>The tags currently associated with the Amazon DynamoDB
        resource.</p>
        :param next_token: <p>If this value is returned, there are additional results to
        be displayed. To retrieve
                    them, call ListTagsOfResource again, with
        NextToken set to this value.</p>
        """
        self.tags = tags
        self.next_token = next_token

    def as_dict(self) -> Dict[str, Any]:
        """Converts the ListTagsOfResourceOutput to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        d: Dict[str, Any] = {}

        if self.tags is not None:
            d["Tags"] = _tag_list_as_dict(self.tags),

        if self.next_token is not None:
            d["NextToken"] = self.next_token

        return d

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "ListTagsOfResourceOutput":
        """Creates a ListTagsOfResourceOutput from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {}

        if "Tags" in d:
            kwargs["tags"] = _tag_list_from_dict(d["Tags"]),

        if "NextToken" in d:
            kwargs["next_token"] = d["NextToken"]

        return ListTagsOfResourceOutput(**kwargs)

    def __repr__(self) -> str:
        result = "ListTagsOfResourceOutput("
        if self.tags is not None:
            result += f"tags={repr(self.tags)}, "

        if self.next_token is not None:
            result += f"next_token={repr(self.next_token)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, ListTagsOfResourceOutput):
            return False
        attributes: list[str] = ['tags','next_token',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class RestoreTableFromBackupInput:
    target_table_name: str
    backup_arn: str
    billing_mode_override: Optional[str]
    global_secondary_index_override: Optional[list[GlobalSecondaryIndex]]
    local_secondary_index_override: Optional[list[LocalSecondaryIndex]]
    provisioned_throughput_override: Optional[ProvisionedThroughput]
    sse_specification_override: Optional[SSESpecification]
    def __init__(
        self,
        *,
        target_table_name: str,
        backup_arn: str,
        billing_mode_override: Optional[str] = None,
        global_secondary_index_override: Optional[list[GlobalSecondaryIndex]] = None,
        local_secondary_index_override: Optional[list[LocalSecondaryIndex]] = None,
        provisioned_throughput_override: Optional[ProvisionedThroughput] = None,
        sse_specification_override: Optional[SSESpecification] = None,
    ):
        """
        :param target_table_name: <p>The name of the new table to which the backup must
        be restored.</p>
        :param backup_arn: <p>The Amazon Resource Name (ARN) associated with the
        backup.</p>
        :param billing_mode_override: <p>The billing mode of the restored table.</p>
        :param global_secondary_index_override: <p>List of global secondary indexes for
        the restored table. The indexes provided should
                    match existing
        secondary indexes. You can choose to exclude some or all of the indexes

        at the time of restore.</p>
        :param local_secondary_index_override: <p>List of local secondary indexes for
        the restored table. The indexes provided should
                    match existing
        secondary indexes. You can choose to exclude some or all of the indexes

        at the time of restore.</p>
        :param provisioned_throughput_override: <p>Provisioned throughput settings for
        the restored table.</p>
        :param sse_specification_override: <p>The new server-side encryption settings
        for the restored table.</p>
        """
        self.target_table_name = target_table_name
        self.backup_arn = backup_arn
        self.billing_mode_override = billing_mode_override
        self.global_secondary_index_override = global_secondary_index_override
        self.local_secondary_index_override = local_secondary_index_override
        self.provisioned_throughput_override = provisioned_throughput_override
        self.sse_specification_override = sse_specification_override

    def as_dict(self) -> Dict[str, Any]:
        """Converts the RestoreTableFromBackupInput to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        d: Dict[str, Any] = {
            "TargetTableName": self.target_table_name,
            "BackupArn": self.backup_arn,
        }

        if self.billing_mode_override is not None:
            d["BillingModeOverride"] = self.billing_mode_override

        if self.global_secondary_index_override is not None:
            d["GlobalSecondaryIndexOverride"] = _global_secondary_index_list_as_dict(self.global_secondary_index_override),

        if self.local_secondary_index_override is not None:
            d["LocalSecondaryIndexOverride"] = _local_secondary_index_list_as_dict(self.local_secondary_index_override),

        if self.provisioned_throughput_override is not None:
            d["ProvisionedThroughputOverride"] = self.provisioned_throughput_override.as_dict()

        if self.sse_specification_override is not None:
            d["SSESpecificationOverride"] = self.sse_specification_override.as_dict()

        return d

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "RestoreTableFromBackupInput":
        """Creates a RestoreTableFromBackupInput from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {
            "target_table_name": d["TargetTableName"],
            "backup_arn": d["BackupArn"],
        }

        if "BillingModeOverride" in d:
            kwargs["billing_mode_override"] = d["BillingModeOverride"]

        if "GlobalSecondaryIndexOverride" in d:
            kwargs["global_secondary_index_override"] = _global_secondary_index_list_from_dict(d["GlobalSecondaryIndexOverride"]),

        if "LocalSecondaryIndexOverride" in d:
            kwargs["local_secondary_index_override"] = _local_secondary_index_list_from_dict(d["LocalSecondaryIndexOverride"]),

        if "ProvisionedThroughputOverride" in d:
            kwargs["provisioned_throughput_override"] = ProvisionedThroughput.from_dict(d["ProvisionedThroughputOverride"])

        if "SSESpecificationOverride" in d:
            kwargs["sse_specification_override"] = SSESpecification.from_dict(d["SSESpecificationOverride"])

        return RestoreTableFromBackupInput(**kwargs)

    def __repr__(self) -> str:
        result = "RestoreTableFromBackupInput("
        if self.target_table_name is not None:
            result += f"target_table_name={repr(self.target_table_name)}, "

        if self.backup_arn is not None:
            result += f"backup_arn={repr(self.backup_arn)}, "

        if self.billing_mode_override is not None:
            result += f"billing_mode_override={repr(self.billing_mode_override)}, "

        if self.global_secondary_index_override is not None:
            result += f"global_secondary_index_override={repr(self.global_secondary_index_override)}, "

        if self.local_secondary_index_override is not None:
            result += f"local_secondary_index_override={repr(self.local_secondary_index_override)}, "

        if self.provisioned_throughput_override is not None:
            result += f"provisioned_throughput_override={repr(self.provisioned_throughput_override)}, "

        if self.sse_specification_override is not None:
            result += f"sse_specification_override={repr(self.sse_specification_override)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, RestoreTableFromBackupInput):
            return False
        attributes: list[str] = ['target_table_name','backup_arn','billing_mode_override','global_secondary_index_override','local_secondary_index_override','provisioned_throughput_override','sse_specification_override',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class RestoreTableFromBackupOutput:
    table_description: Optional[TableDescription]
    def __init__(
        self,
        *,
        table_description: Optional[TableDescription] = None,
    ):
        """
        :param table_description: <p>The description of the table created from an
        existing backup.</p>
        """
        self.table_description = table_description

    def as_dict(self) -> Dict[str, Any]:
        """Converts the RestoreTableFromBackupOutput to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        d: Dict[str, Any] = {}

        if self.table_description is not None:
            d["TableDescription"] = self.table_description.as_dict()

        return d

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "RestoreTableFromBackupOutput":
        """Creates a RestoreTableFromBackupOutput from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {}

        if "TableDescription" in d:
            kwargs["table_description"] = TableDescription.from_dict(d["TableDescription"])

        return RestoreTableFromBackupOutput(**kwargs)

    def __repr__(self) -> str:
        result = "RestoreTableFromBackupOutput("
        if self.table_description is not None:
            result += f"table_description={repr(self.table_description)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, RestoreTableFromBackupOutput):
            return False
        attributes: list[str] = ['table_description',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class RestoreTableToPointInTimeInput:
    source_table_arn: Optional[str]
    source_table_name: Optional[str]
    target_table_name: str
    use_latest_restorable_time: Optional[bool]
    restore_date_time: Optional[datetime]
    billing_mode_override: Optional[str]
    global_secondary_index_override: Optional[list[GlobalSecondaryIndex]]
    local_secondary_index_override: Optional[list[LocalSecondaryIndex]]
    provisioned_throughput_override: Optional[ProvisionedThroughput]
    sse_specification_override: Optional[SSESpecification]
    def __init__(
        self,
        *,
        target_table_name: str,
        source_table_arn: Optional[str] = None,
        source_table_name: Optional[str] = None,
        use_latest_restorable_time: Optional[bool] = None,
        restore_date_time: Optional[datetime] = None,
        billing_mode_override: Optional[str] = None,
        global_secondary_index_override: Optional[list[GlobalSecondaryIndex]] = None,
        local_secondary_index_override: Optional[list[LocalSecondaryIndex]] = None,
        provisioned_throughput_override: Optional[ProvisionedThroughput] = None,
        sse_specification_override: Optional[SSESpecification] = None,
    ):
        """
        :param target_table_name: <p>The name of the new table to which it must be
        restored to.</p>
        :param source_table_arn: <p>The DynamoDB table that will be restored. This value
        is an Amazon Resource Name
                    (ARN).</p>
        :param source_table_name: <p>Name of the source table that is being
        restored.</p>
        :param use_latest_restorable_time: <p>Restore the table to the latest possible
        time. <code>LatestRestorableDateTime</code>
                    is typically 5 minutes
        before the current time. </p>
        :param restore_date_time: <p>Time in the past to restore the table to.</p>
        :param billing_mode_override: <p>The billing mode of the restored table.</p>
        :param global_secondary_index_override: <p>List of global secondary indexes for
        the restored table. The indexes provided should
                    match existing
        secondary indexes. You can choose to exclude some or all of the indexes

        at the time of restore.</p>
        :param local_secondary_index_override: <p>List of local secondary indexes for
        the restored table. The indexes provided should
                    match existing
        secondary indexes. You can choose to exclude some or all of the indexes

        at the time of restore.</p>
        :param provisioned_throughput_override: <p>Provisioned throughput settings for
        the restored table.</p>
        :param sse_specification_override: <p>The new server-side encryption settings
        for the restored table.</p>
        """
        self.target_table_name = target_table_name
        self.source_table_arn = source_table_arn
        self.source_table_name = source_table_name
        self.use_latest_restorable_time = use_latest_restorable_time
        self.restore_date_time = restore_date_time
        self.billing_mode_override = billing_mode_override
        self.global_secondary_index_override = global_secondary_index_override
        self.local_secondary_index_override = local_secondary_index_override
        self.provisioned_throughput_override = provisioned_throughput_override
        self.sse_specification_override = sse_specification_override

    def as_dict(self) -> Dict[str, Any]:
        """Converts the RestoreTableToPointInTimeInput to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        d: Dict[str, Any] = {
            "TargetTableName": self.target_table_name,
        }

        if self.source_table_arn is not None:
            d["SourceTableArn"] = self.source_table_arn

        if self.source_table_name is not None:
            d["SourceTableName"] = self.source_table_name

        if self.use_latest_restorable_time is not None:
            d["UseLatestRestorableTime"] = self.use_latest_restorable_time

        if self.restore_date_time is not None:
            d["RestoreDateTime"] = self.restore_date_time

        if self.billing_mode_override is not None:
            d["BillingModeOverride"] = self.billing_mode_override

        if self.global_secondary_index_override is not None:
            d["GlobalSecondaryIndexOverride"] = _global_secondary_index_list_as_dict(self.global_secondary_index_override),

        if self.local_secondary_index_override is not None:
            d["LocalSecondaryIndexOverride"] = _local_secondary_index_list_as_dict(self.local_secondary_index_override),

        if self.provisioned_throughput_override is not None:
            d["ProvisionedThroughputOverride"] = self.provisioned_throughput_override.as_dict()

        if self.sse_specification_override is not None:
            d["SSESpecificationOverride"] = self.sse_specification_override.as_dict()

        return d

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "RestoreTableToPointInTimeInput":
        """Creates a RestoreTableToPointInTimeInput from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {
            "target_table_name": d["TargetTableName"],
        }

        if "SourceTableArn" in d:
            kwargs["source_table_arn"] = d["SourceTableArn"]

        if "SourceTableName" in d:
            kwargs["source_table_name"] = d["SourceTableName"]

        if "UseLatestRestorableTime" in d:
            kwargs["use_latest_restorable_time"] = d["UseLatestRestorableTime"]

        if "RestoreDateTime" in d:
            kwargs["restore_date_time"] = d["RestoreDateTime"]

        if "BillingModeOverride" in d:
            kwargs["billing_mode_override"] = d["BillingModeOverride"]

        if "GlobalSecondaryIndexOverride" in d:
            kwargs["global_secondary_index_override"] = _global_secondary_index_list_from_dict(d["GlobalSecondaryIndexOverride"]),

        if "LocalSecondaryIndexOverride" in d:
            kwargs["local_secondary_index_override"] = _local_secondary_index_list_from_dict(d["LocalSecondaryIndexOverride"]),

        if "ProvisionedThroughputOverride" in d:
            kwargs["provisioned_throughput_override"] = ProvisionedThroughput.from_dict(d["ProvisionedThroughputOverride"])

        if "SSESpecificationOverride" in d:
            kwargs["sse_specification_override"] = SSESpecification.from_dict(d["SSESpecificationOverride"])

        return RestoreTableToPointInTimeInput(**kwargs)

    def __repr__(self) -> str:
        result = "RestoreTableToPointInTimeInput("
        if self.source_table_arn is not None:
            result += f"source_table_arn={repr(self.source_table_arn)}, "

        if self.source_table_name is not None:
            result += f"source_table_name={repr(self.source_table_name)}, "

        if self.target_table_name is not None:
            result += f"target_table_name={repr(self.target_table_name)}, "

        if self.use_latest_restorable_time is not None:
            result += f"use_latest_restorable_time={repr(self.use_latest_restorable_time)}, "

        if self.restore_date_time is not None:
            result += f"restore_date_time={repr(self.restore_date_time)}, "

        if self.billing_mode_override is not None:
            result += f"billing_mode_override={repr(self.billing_mode_override)}, "

        if self.global_secondary_index_override is not None:
            result += f"global_secondary_index_override={repr(self.global_secondary_index_override)}, "

        if self.local_secondary_index_override is not None:
            result += f"local_secondary_index_override={repr(self.local_secondary_index_override)}, "

        if self.provisioned_throughput_override is not None:
            result += f"provisioned_throughput_override={repr(self.provisioned_throughput_override)}, "

        if self.sse_specification_override is not None:
            result += f"sse_specification_override={repr(self.sse_specification_override)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, RestoreTableToPointInTimeInput):
            return False
        attributes: list[str] = ['source_table_arn','source_table_name','target_table_name','use_latest_restorable_time','restore_date_time','billing_mode_override','global_secondary_index_override','local_secondary_index_override','provisioned_throughput_override','sse_specification_override',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class RestoreTableToPointInTimeOutput:
    table_description: Optional[TableDescription]
    def __init__(
        self,
        *,
        table_description: Optional[TableDescription] = None,
    ):
        """
        :param table_description: <p>Represents the properties of a table.</p>
        """
        self.table_description = table_description

    def as_dict(self) -> Dict[str, Any]:
        """Converts the RestoreTableToPointInTimeOutput to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        d: Dict[str, Any] = {}

        if self.table_description is not None:
            d["TableDescription"] = self.table_description.as_dict()

        return d

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "RestoreTableToPointInTimeOutput":
        """Creates a RestoreTableToPointInTimeOutput from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {}

        if "TableDescription" in d:
            kwargs["table_description"] = TableDescription.from_dict(d["TableDescription"])

        return RestoreTableToPointInTimeOutput(**kwargs)

    def __repr__(self) -> str:
        result = "RestoreTableToPointInTimeOutput("
        if self.table_description is not None:
            result += f"table_description={repr(self.table_description)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, RestoreTableToPointInTimeOutput):
            return False
        attributes: list[str] = ['table_description',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class TagResourceInput:
    resource_arn: str
    tags: list[Tag]
    def __init__(
        self,
        *,
        resource_arn: str,
        tags: list[Tag],
    ):
        """
        :param resource_arn: <p>Identifies the Amazon DynamoDB resource to which tags
        should be added. This value is
                    an Amazon Resource Name (ARN).</p>
        :param tags: <p>The tags to be assigned to the Amazon DynamoDB resource.</p>
        """
        self.resource_arn = resource_arn
        self.tags = tags

    def as_dict(self) -> Dict[str, Any]:
        """Converts the TagResourceInput to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        return {
            "ResourceArn": self.resource_arn,
            "Tags": _tag_list_as_dict(self.tags),
        }

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "TagResourceInput":
        """Creates a TagResourceInput from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {
            "resource_arn": d["ResourceArn"],
            "tags": _tag_list_from_dict(d["Tags"]),
        }

        return TagResourceInput(**kwargs)

    def __repr__(self) -> str:
        result = "TagResourceInput("
        if self.resource_arn is not None:
            result += f"resource_arn={repr(self.resource_arn)}, "

        if self.tags is not None:
            result += f"tags={repr(self.tags)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, TagResourceInput):
            return False
        attributes: list[str] = ['resource_arn','tags',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class UntagResourceInput:
    resource_arn: str
    tag_keys: list[str]
    def __init__(
        self,
        *,
        resource_arn: str,
        tag_keys: list[str],
    ):
        """
        :param resource_arn: <p>The DynamoDB resource that the tags will be removed
        from. This value is an Amazon
                    Resource Name (ARN).</p>
        :param tag_keys: <p>A list of tag keys. Existing tags of the resource whose keys
        are members of this list
                    will be removed from the DynamoDB
        resource.</p>
        """
        self.resource_arn = resource_arn
        self.tag_keys = tag_keys

    def as_dict(self) -> Dict[str, Any]:
        """Converts the UntagResourceInput to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        return {
            "ResourceArn": self.resource_arn,
            "TagKeys": self.tag_keys,
        }

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "UntagResourceInput":
        """Creates a UntagResourceInput from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {
            "resource_arn": d["ResourceArn"],
            "tag_keys": d["TagKeys"],
        }

        return UntagResourceInput(**kwargs)

    def __repr__(self) -> str:
        result = "UntagResourceInput("
        if self.resource_arn is not None:
            result += f"resource_arn={repr(self.resource_arn)}, "

        if self.tag_keys is not None:
            result += f"tag_keys={repr(self.tag_keys)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, UntagResourceInput):
            return False
        attributes: list[str] = ['resource_arn','tag_keys',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class PointInTimeRecoverySpecification:
    point_in_time_recovery_enabled: bool
    def __init__(
        self,
        *,
        point_in_time_recovery_enabled: bool,
    ):
        """<p>Represents the settings used to enable point in time recovery.</p>

        :param point_in_time_recovery_enabled: <p>Indicates whether point in time
        recovery is enabled (true) or disabled (false) on the
                    table.</p>
        """
        self.point_in_time_recovery_enabled = point_in_time_recovery_enabled

    def as_dict(self) -> Dict[str, Any]:
        """Converts the PointInTimeRecoverySpecification to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        return {
            "PointInTimeRecoveryEnabled": self.point_in_time_recovery_enabled,
        }

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "PointInTimeRecoverySpecification":
        """Creates a PointInTimeRecoverySpecification from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {
            "point_in_time_recovery_enabled": d["PointInTimeRecoveryEnabled"],
        }

        return PointInTimeRecoverySpecification(**kwargs)

    def __repr__(self) -> str:
        result = "PointInTimeRecoverySpecification("
        if self.point_in_time_recovery_enabled is not None:
            result += f"point_in_time_recovery_enabled={repr(self.point_in_time_recovery_enabled)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, PointInTimeRecoverySpecification):
            return False
        attributes: list[str] = ['point_in_time_recovery_enabled',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class UpdateContinuousBackupsInput:
    table_name: str
    point_in_time_recovery_specification: PointInTimeRecoverySpecification
    def __init__(
        self,
        *,
        table_name: str,
        point_in_time_recovery_specification: PointInTimeRecoverySpecification,
    ):
        """
        :param table_name: <p>The name of the table.</p>
        :param point_in_time_recovery_specification: <p>Represents the settings used to
        enable point in time recovery.</p>
        """
        self.table_name = table_name
        self.point_in_time_recovery_specification = point_in_time_recovery_specification

    def as_dict(self) -> Dict[str, Any]:
        """Converts the UpdateContinuousBackupsInput to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        return {
            "TableName": self.table_name,
            "PointInTimeRecoverySpecification": self.point_in_time_recovery_specification.as_dict(),
        }

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "UpdateContinuousBackupsInput":
        """Creates a UpdateContinuousBackupsInput from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {
            "table_name": d["TableName"],
            "point_in_time_recovery_specification": PointInTimeRecoverySpecification.from_dict(d["PointInTimeRecoverySpecification"]),
        }

        return UpdateContinuousBackupsInput(**kwargs)

    def __repr__(self) -> str:
        result = "UpdateContinuousBackupsInput("
        if self.table_name is not None:
            result += f"table_name={repr(self.table_name)}, "

        if self.point_in_time_recovery_specification is not None:
            result += f"point_in_time_recovery_specification={repr(self.point_in_time_recovery_specification)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, UpdateContinuousBackupsInput):
            return False
        attributes: list[str] = ['table_name','point_in_time_recovery_specification',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class UpdateContinuousBackupsOutput:
    continuous_backups_description: Optional[ContinuousBackupsDescription]
    def __init__(
        self,
        *,
        continuous_backups_description: Optional[ContinuousBackupsDescription] = None,
    ):
        """
        :param continuous_backups_description: <p>Represents the continuous backups and
        point in time recovery settings on the
                    table.</p>
        """
        self.continuous_backups_description = continuous_backups_description

    def as_dict(self) -> Dict[str, Any]:
        """Converts the UpdateContinuousBackupsOutput to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        d: Dict[str, Any] = {}

        if self.continuous_backups_description is not None:
            d["ContinuousBackupsDescription"] = self.continuous_backups_description.as_dict()

        return d

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "UpdateContinuousBackupsOutput":
        """Creates a UpdateContinuousBackupsOutput from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {}

        if "ContinuousBackupsDescription" in d:
            kwargs["continuous_backups_description"] = ContinuousBackupsDescription.from_dict(d["ContinuousBackupsDescription"])

        return UpdateContinuousBackupsOutput(**kwargs)

    def __repr__(self) -> str:
        result = "UpdateContinuousBackupsOutput("
        if self.continuous_backups_description is not None:
            result += f"continuous_backups_description={repr(self.continuous_backups_description)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, UpdateContinuousBackupsOutput):
            return False
        attributes: list[str] = ['continuous_backups_description',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class UpdateContributorInsightsInput:
    table_name: str
    index_name: Optional[str]
    contributor_insights_action: str
    def __init__(
        self,
        *,
        table_name: str,
        contributor_insights_action: str,
        index_name: Optional[str] = None,
    ):
        """
        :param table_name: <p>The name of the table.</p>
        :param contributor_insights_action: <p>Represents the contributor insights
        action.</p>
        :param index_name: <p>The global secondary index name, if applicable.</p>
        """
        self.table_name = table_name
        self.contributor_insights_action = contributor_insights_action
        self.index_name = index_name

    def as_dict(self) -> Dict[str, Any]:
        """Converts the UpdateContributorInsightsInput to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        d: Dict[str, Any] = {
            "TableName": self.table_name,
            "ContributorInsightsAction": self.contributor_insights_action,
        }

        if self.index_name is not None:
            d["IndexName"] = self.index_name

        return d

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "UpdateContributorInsightsInput":
        """Creates a UpdateContributorInsightsInput from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {
            "table_name": d["TableName"],
            "contributor_insights_action": d["ContributorInsightsAction"],
        }

        if "IndexName" in d:
            kwargs["index_name"] = d["IndexName"]

        return UpdateContributorInsightsInput(**kwargs)

    def __repr__(self) -> str:
        result = "UpdateContributorInsightsInput("
        if self.table_name is not None:
            result += f"table_name={repr(self.table_name)}, "

        if self.index_name is not None:
            result += f"index_name={repr(self.index_name)}, "

        if self.contributor_insights_action is not None:
            result += f"contributor_insights_action={repr(self.contributor_insights_action)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, UpdateContributorInsightsInput):
            return False
        attributes: list[str] = ['table_name','index_name','contributor_insights_action',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class UpdateContributorInsightsOutput:
    table_name: Optional[str]
    index_name: Optional[str]
    contributor_insights_status: Optional[str]
    def __init__(
        self,
        *,
        table_name: Optional[str] = None,
        index_name: Optional[str] = None,
        contributor_insights_status: Optional[str] = None,
    ):
        """
        :param table_name: <p>The name of the table.</p>
        :param index_name: <p>The name of the global secondary index, if applicable.</p>
        :param contributor_insights_status: <p>The status of contributor insights</p>
        """
        self.table_name = table_name
        self.index_name = index_name
        self.contributor_insights_status = contributor_insights_status

    def as_dict(self) -> Dict[str, Any]:
        """Converts the UpdateContributorInsightsOutput to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        d: Dict[str, Any] = {}

        if self.table_name is not None:
            d["TableName"] = self.table_name

        if self.index_name is not None:
            d["IndexName"] = self.index_name

        if self.contributor_insights_status is not None:
            d["ContributorInsightsStatus"] = self.contributor_insights_status

        return d

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "UpdateContributorInsightsOutput":
        """Creates a UpdateContributorInsightsOutput from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {}

        if "TableName" in d:
            kwargs["table_name"] = d["TableName"]

        if "IndexName" in d:
            kwargs["index_name"] = d["IndexName"]

        if "ContributorInsightsStatus" in d:
            kwargs["contributor_insights_status"] = d["ContributorInsightsStatus"]

        return UpdateContributorInsightsOutput(**kwargs)

    def __repr__(self) -> str:
        result = "UpdateContributorInsightsOutput("
        if self.table_name is not None:
            result += f"table_name={repr(self.table_name)}, "

        if self.index_name is not None:
            result += f"index_name={repr(self.index_name)}, "

        if self.contributor_insights_status is not None:
            result += f"contributor_insights_status={repr(self.contributor_insights_status)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, UpdateContributorInsightsOutput):
            return False
        attributes: list[str] = ['table_name','index_name','contributor_insights_status',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class ReplicaUpdate:
    create: Optional[CreateReplicaAction]
    delete: Optional[DeleteReplicaAction]
    def __init__(
        self,
        *,
        create: Optional[CreateReplicaAction] = None,
        delete: Optional[DeleteReplicaAction] = None,
    ):
        """<p>Represents one of the following:</p>
                <ul>
                    <li>

        <p>A new replica to be added to an existing global table.</p>
                    </li>

        <li>
                        <p>New parameters for an existing replica.</p>

        </li>
                    <li>
                        <p>An existing replica to be removed from
        an existing global table.</p>
                    </li>
                 </ul>

        :param create: <p>The parameters required for creating a replica on an existing
        global table.</p>
        :param delete: <p>The name of the existing replica to be removed.</p>
        """
        self.create = create
        self.delete = delete

    def as_dict(self) -> Dict[str, Any]:
        """Converts the ReplicaUpdate to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        d: Dict[str, Any] = {}

        if self.create is not None:
            d["Create"] = self.create.as_dict()

        if self.delete is not None:
            d["Delete"] = self.delete.as_dict()

        return d

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "ReplicaUpdate":
        """Creates a ReplicaUpdate from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {}

        if "Create" in d:
            kwargs["create"] = CreateReplicaAction.from_dict(d["Create"])

        if "Delete" in d:
            kwargs["delete"] = DeleteReplicaAction.from_dict(d["Delete"])

        return ReplicaUpdate(**kwargs)

    def __repr__(self) -> str:
        result = "ReplicaUpdate("
        if self.create is not None:
            result += f"create={repr(self.create)}, "

        if self.delete is not None:
            result += f"delete={repr(self.delete)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, ReplicaUpdate):
            return False
        attributes: list[str] = ['create','delete',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class UpdateGlobalTableInput:
    global_table_name: str
    replica_updates: list[ReplicaUpdate]
    def __init__(
        self,
        *,
        global_table_name: str,
        replica_updates: list[ReplicaUpdate],
    ):
        """
        :param global_table_name: <p>The global table name.</p>
        :param replica_updates: <p>A list of Regions that should be added or removed
        from the global table.</p>
        """
        self.global_table_name = global_table_name
        self.replica_updates = replica_updates

    def as_dict(self) -> Dict[str, Any]:
        """Converts the UpdateGlobalTableInput to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        return {
            "GlobalTableName": self.global_table_name,
            "ReplicaUpdates": _replica_update_list_as_dict(self.replica_updates),
        }

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "UpdateGlobalTableInput":
        """Creates a UpdateGlobalTableInput from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {
            "global_table_name": d["GlobalTableName"],
            "replica_updates": _replica_update_list_from_dict(d["ReplicaUpdates"]),
        }

        return UpdateGlobalTableInput(**kwargs)

    def __repr__(self) -> str:
        result = "UpdateGlobalTableInput("
        if self.global_table_name is not None:
            result += f"global_table_name={repr(self.global_table_name)}, "

        if self.replica_updates is not None:
            result += f"replica_updates={repr(self.replica_updates)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, UpdateGlobalTableInput):
            return False
        attributes: list[str] = ['global_table_name','replica_updates',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class UpdateGlobalTableOutput:
    global_table_description: Optional[GlobalTableDescription]
    def __init__(
        self,
        *,
        global_table_description: Optional[GlobalTableDescription] = None,
    ):
        """
        :param global_table_description: <p>Contains the details of the global
        table.</p>
        """
        self.global_table_description = global_table_description

    def as_dict(self) -> Dict[str, Any]:
        """Converts the UpdateGlobalTableOutput to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        d: Dict[str, Any] = {}

        if self.global_table_description is not None:
            d["GlobalTableDescription"] = self.global_table_description.as_dict()

        return d

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "UpdateGlobalTableOutput":
        """Creates a UpdateGlobalTableOutput from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {}

        if "GlobalTableDescription" in d:
            kwargs["global_table_description"] = GlobalTableDescription.from_dict(d["GlobalTableDescription"])

        return UpdateGlobalTableOutput(**kwargs)

    def __repr__(self) -> str:
        result = "UpdateGlobalTableOutput("
        if self.global_table_description is not None:
            result += f"global_table_description={repr(self.global_table_description)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, UpdateGlobalTableOutput):
            return False
        attributes: list[str] = ['global_table_description',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class GlobalTableGlobalSecondaryIndexSettingsUpdate:
    index_name: str
    provisioned_write_capacity_units: Optional[int]
    provisioned_write_capacity_auto_scaling_settings_update: Optional[AutoScalingSettingsUpdate]
    def __init__(
        self,
        *,
        index_name: str,
        provisioned_write_capacity_units: Optional[int] = None,
        provisioned_write_capacity_auto_scaling_settings_update: Optional[AutoScalingSettingsUpdate] = None,
    ):
        """<p>Represents the settings of a global secondary index for a global table that
        will be
                    modified.</p>

        :param index_name: <p>The name of the global secondary index. The name must be
        unique among all other
                    indexes on this table.</p>
        :param provisioned_write_capacity_units: <p>The maximum number of writes
        consumed per second before DynamoDB returns a

        <code>ThrottlingException.</code>
                 </p>
        :param provisioned_write_capacity_auto_scaling_settings_update: <p>Auto scaling
        settings for managing a global secondary index's write capacity

        units.</p>
        """
        self.index_name = index_name
        self.provisioned_write_capacity_units = provisioned_write_capacity_units
        self.provisioned_write_capacity_auto_scaling_settings_update = provisioned_write_capacity_auto_scaling_settings_update

    def as_dict(self) -> Dict[str, Any]:
        """Converts the GlobalTableGlobalSecondaryIndexSettingsUpdate to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        d: Dict[str, Any] = {
            "IndexName": self.index_name,
        }

        if self.provisioned_write_capacity_units is not None:
            d["ProvisionedWriteCapacityUnits"] = self.provisioned_write_capacity_units

        if self.provisioned_write_capacity_auto_scaling_settings_update is not None:
            d["ProvisionedWriteCapacityAutoScalingSettingsUpdate"] = self.provisioned_write_capacity_auto_scaling_settings_update.as_dict()

        return d

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "GlobalTableGlobalSecondaryIndexSettingsUpdate":
        """Creates a GlobalTableGlobalSecondaryIndexSettingsUpdate from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {
            "index_name": d["IndexName"],
        }

        if "ProvisionedWriteCapacityUnits" in d:
            kwargs["provisioned_write_capacity_units"] = d["ProvisionedWriteCapacityUnits"]

        if "ProvisionedWriteCapacityAutoScalingSettingsUpdate" in d:
            kwargs["provisioned_write_capacity_auto_scaling_settings_update"] = AutoScalingSettingsUpdate.from_dict(d["ProvisionedWriteCapacityAutoScalingSettingsUpdate"])

        return GlobalTableGlobalSecondaryIndexSettingsUpdate(**kwargs)

    def __repr__(self) -> str:
        result = "GlobalTableGlobalSecondaryIndexSettingsUpdate("
        if self.index_name is not None:
            result += f"index_name={repr(self.index_name)}, "

        if self.provisioned_write_capacity_units is not None:
            result += f"provisioned_write_capacity_units={repr(self.provisioned_write_capacity_units)}, "

        if self.provisioned_write_capacity_auto_scaling_settings_update is not None:
            result += f"provisioned_write_capacity_auto_scaling_settings_update={repr(self.provisioned_write_capacity_auto_scaling_settings_update)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, GlobalTableGlobalSecondaryIndexSettingsUpdate):
            return False
        attributes: list[str] = ['index_name','provisioned_write_capacity_units','provisioned_write_capacity_auto_scaling_settings_update',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class ReplicaGlobalSecondaryIndexSettingsUpdate:
    index_name: str
    provisioned_read_capacity_units: Optional[int]
    provisioned_read_capacity_auto_scaling_settings_update: Optional[AutoScalingSettingsUpdate]
    def __init__(
        self,
        *,
        index_name: str,
        provisioned_read_capacity_units: Optional[int] = None,
        provisioned_read_capacity_auto_scaling_settings_update: Optional[AutoScalingSettingsUpdate] = None,
    ):
        """<p>Represents the settings of a global secondary index for a global table that
        will be
                    modified.</p>

        :param index_name: <p>The name of the global secondary index. The name must be
        unique among all other
                    indexes on this table.</p>
        :param provisioned_read_capacity_units: <p>The maximum number of strongly
        consistent reads consumed per second before DynamoDB
                    returns a
        <code>ThrottlingException</code>.</p>
        :param provisioned_read_capacity_auto_scaling_settings_update: <p>Auto scaling
        settings for managing a global secondary index replica's read capacity

        units.</p>
        """
        self.index_name = index_name
        self.provisioned_read_capacity_units = provisioned_read_capacity_units
        self.provisioned_read_capacity_auto_scaling_settings_update = provisioned_read_capacity_auto_scaling_settings_update

    def as_dict(self) -> Dict[str, Any]:
        """Converts the ReplicaGlobalSecondaryIndexSettingsUpdate to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        d: Dict[str, Any] = {
            "IndexName": self.index_name,
        }

        if self.provisioned_read_capacity_units is not None:
            d["ProvisionedReadCapacityUnits"] = self.provisioned_read_capacity_units

        if self.provisioned_read_capacity_auto_scaling_settings_update is not None:
            d["ProvisionedReadCapacityAutoScalingSettingsUpdate"] = self.provisioned_read_capacity_auto_scaling_settings_update.as_dict()

        return d

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "ReplicaGlobalSecondaryIndexSettingsUpdate":
        """Creates a ReplicaGlobalSecondaryIndexSettingsUpdate from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {
            "index_name": d["IndexName"],
        }

        if "ProvisionedReadCapacityUnits" in d:
            kwargs["provisioned_read_capacity_units"] = d["ProvisionedReadCapacityUnits"]

        if "ProvisionedReadCapacityAutoScalingSettingsUpdate" in d:
            kwargs["provisioned_read_capacity_auto_scaling_settings_update"] = AutoScalingSettingsUpdate.from_dict(d["ProvisionedReadCapacityAutoScalingSettingsUpdate"])

        return ReplicaGlobalSecondaryIndexSettingsUpdate(**kwargs)

    def __repr__(self) -> str:
        result = "ReplicaGlobalSecondaryIndexSettingsUpdate("
        if self.index_name is not None:
            result += f"index_name={repr(self.index_name)}, "

        if self.provisioned_read_capacity_units is not None:
            result += f"provisioned_read_capacity_units={repr(self.provisioned_read_capacity_units)}, "

        if self.provisioned_read_capacity_auto_scaling_settings_update is not None:
            result += f"provisioned_read_capacity_auto_scaling_settings_update={repr(self.provisioned_read_capacity_auto_scaling_settings_update)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, ReplicaGlobalSecondaryIndexSettingsUpdate):
            return False
        attributes: list[str] = ['index_name','provisioned_read_capacity_units','provisioned_read_capacity_auto_scaling_settings_update',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class ReplicaSettingsUpdate:
    region_name: str
    replica_provisioned_read_capacity_units: Optional[int]
    replica_provisioned_read_capacity_auto_scaling_settings_update: Optional[AutoScalingSettingsUpdate]
    replica_global_secondary_index_settings_update: Optional[list[ReplicaGlobalSecondaryIndexSettingsUpdate]]
    replica_table_class: Optional[str]
    def __init__(
        self,
        *,
        region_name: str,
        replica_provisioned_read_capacity_units: Optional[int] = None,
        replica_provisioned_read_capacity_auto_scaling_settings_update: Optional[AutoScalingSettingsUpdate] = None,
        replica_global_secondary_index_settings_update: Optional[list[ReplicaGlobalSecondaryIndexSettingsUpdate]] = None,
        replica_table_class: Optional[str] = None,
    ):
        """<p>Represents the settings for a global table in a Region that will be
        modified.</p>

        :param region_name: <p>The Region of the replica to be added.</p>
        :param replica_provisioned_read_capacity_units: <p>The maximum number of
        strongly consistent reads consumed per second before DynamoDB

        returns a <code>ThrottlingException</code>. For more information, see <a
        href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/WorkingWithTables.html#ProvisionedThroughput">Specifying
        Read and Write Requirements</a> in the <i>Amazon DynamoDB

        Developer Guide</i>. </p>
        :param replica_provisioned_read_capacity_auto_scaling_settings_update: <p>Auto
        scaling settings for managing a global table replica's read capacity

        units.</p>
        :param replica_global_secondary_index_settings_update: <p>Represents the
        settings of a global secondary index for a global table that will be

        modified.</p>
        :param replica_table_class: <p>Replica-specific table class. If not specified,
        uses the source table's
                    table class.</p>
        """
        self.region_name = region_name
        self.replica_provisioned_read_capacity_units = replica_provisioned_read_capacity_units
        self.replica_provisioned_read_capacity_auto_scaling_settings_update = replica_provisioned_read_capacity_auto_scaling_settings_update
        self.replica_global_secondary_index_settings_update = replica_global_secondary_index_settings_update
        self.replica_table_class = replica_table_class

    def as_dict(self) -> Dict[str, Any]:
        """Converts the ReplicaSettingsUpdate to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        d: Dict[str, Any] = {
            "RegionName": self.region_name,
        }

        if self.replica_provisioned_read_capacity_units is not None:
            d["ReplicaProvisionedReadCapacityUnits"] = self.replica_provisioned_read_capacity_units

        if self.replica_provisioned_read_capacity_auto_scaling_settings_update is not None:
            d["ReplicaProvisionedReadCapacityAutoScalingSettingsUpdate"] = self.replica_provisioned_read_capacity_auto_scaling_settings_update.as_dict()

        if self.replica_global_secondary_index_settings_update is not None:
            d["ReplicaGlobalSecondaryIndexSettingsUpdate"] = _replica_global_secondary_index_settings_update_list_as_dict(self.replica_global_secondary_index_settings_update),

        if self.replica_table_class is not None:
            d["ReplicaTableClass"] = self.replica_table_class

        return d

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "ReplicaSettingsUpdate":
        """Creates a ReplicaSettingsUpdate from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {
            "region_name": d["RegionName"],
        }

        if "ReplicaProvisionedReadCapacityUnits" in d:
            kwargs["replica_provisioned_read_capacity_units"] = d["ReplicaProvisionedReadCapacityUnits"]

        if "ReplicaProvisionedReadCapacityAutoScalingSettingsUpdate" in d:
            kwargs["replica_provisioned_read_capacity_auto_scaling_settings_update"] = AutoScalingSettingsUpdate.from_dict(d["ReplicaProvisionedReadCapacityAutoScalingSettingsUpdate"])

        if "ReplicaGlobalSecondaryIndexSettingsUpdate" in d:
            kwargs["replica_global_secondary_index_settings_update"] = _replica_global_secondary_index_settings_update_list_from_dict(d["ReplicaGlobalSecondaryIndexSettingsUpdate"]),

        if "ReplicaTableClass" in d:
            kwargs["replica_table_class"] = d["ReplicaTableClass"]

        return ReplicaSettingsUpdate(**kwargs)

    def __repr__(self) -> str:
        result = "ReplicaSettingsUpdate("
        if self.region_name is not None:
            result += f"region_name={repr(self.region_name)}, "

        if self.replica_provisioned_read_capacity_units is not None:
            result += f"replica_provisioned_read_capacity_units={repr(self.replica_provisioned_read_capacity_units)}, "

        if self.replica_provisioned_read_capacity_auto_scaling_settings_update is not None:
            result += f"replica_provisioned_read_capacity_auto_scaling_settings_update={repr(self.replica_provisioned_read_capacity_auto_scaling_settings_update)}, "

        if self.replica_global_secondary_index_settings_update is not None:
            result += f"replica_global_secondary_index_settings_update={repr(self.replica_global_secondary_index_settings_update)}, "

        if self.replica_table_class is not None:
            result += f"replica_table_class={repr(self.replica_table_class)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, ReplicaSettingsUpdate):
            return False
        attributes: list[str] = ['region_name','replica_provisioned_read_capacity_units','replica_provisioned_read_capacity_auto_scaling_settings_update','replica_global_secondary_index_settings_update','replica_table_class',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class UpdateGlobalTableSettingsInput:
    global_table_name: str
    global_table_billing_mode: Optional[str]
    global_table_provisioned_write_capacity_units: Optional[int]
    global_table_provisioned_write_capacity_auto_scaling_settings_update: Optional[AutoScalingSettingsUpdate]
    global_table_global_secondary_index_settings_update: Optional[list[GlobalTableGlobalSecondaryIndexSettingsUpdate]]
    replica_settings_update: Optional[list[ReplicaSettingsUpdate]]
    def __init__(
        self,
        *,
        global_table_name: str,
        global_table_billing_mode: Optional[str] = None,
        global_table_provisioned_write_capacity_units: Optional[int] = None,
        global_table_provisioned_write_capacity_auto_scaling_settings_update: Optional[AutoScalingSettingsUpdate] = None,
        global_table_global_secondary_index_settings_update: Optional[list[GlobalTableGlobalSecondaryIndexSettingsUpdate]] = None,
        replica_settings_update: Optional[list[ReplicaSettingsUpdate]] = None,
    ):
        """
        :param global_table_name: <p>The name of the global table</p>
        :param global_table_billing_mode: <p>The billing mode of the global table. If
        <code>GlobalTableBillingMode</code> is not
                    specified, the global
        table defaults to <code>PROVISIONED</code> capacity billing

        mode.</p>
                <ul>
                    <li>
                        <p>

        <code>PROVISIONED</code> - We recommend using <code>PROVISIONED</code> for

        predictable workloads. <code>PROVISIONED</code> sets the billing mode to <a
        href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/HowItWorks.ReadWriteCapacityMode.html#HowItWorks.ProvisionedThroughput.Manual">Provisioned
        Mode</a>.</p>
                    </li>
                    <li>
                        <p>

        <code>PAY_PER_REQUEST</code> - We recommend using <code>PAY_PER_REQUEST</code>

        for unpredictable workloads. <code>PAY_PER_REQUEST</code> sets the billing mode

        to <a
        href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/HowItWorks.ReadWriteCapacityMode.html#HowItWorks.OnDemand">On-Demand
        Mode</a>. </p>
                    </li>
                 </ul>
        :param global_table_provisioned_write_capacity_units: <p>The maximum number of
        writes consumed per second before DynamoDB returns a

        <code>ThrottlingException.</code>
                 </p>
        :param global_table_provisioned_write_capacity_auto_scaling_settings_update:
        <p>Auto scaling settings for managing provisioned write capacity for the global

        table.</p>
        :param global_table_global_secondary_index_settings_update: <p>Represents the
        settings of a global secondary index for a global table that will be

        modified.</p>
        :param replica_settings_update: <p>Represents the settings for a global table in
        a Region that will be modified.</p>
        """
        self.global_table_name = global_table_name
        self.global_table_billing_mode = global_table_billing_mode
        self.global_table_provisioned_write_capacity_units = global_table_provisioned_write_capacity_units
        self.global_table_provisioned_write_capacity_auto_scaling_settings_update = global_table_provisioned_write_capacity_auto_scaling_settings_update
        self.global_table_global_secondary_index_settings_update = global_table_global_secondary_index_settings_update
        self.replica_settings_update = replica_settings_update

    def as_dict(self) -> Dict[str, Any]:
        """Converts the UpdateGlobalTableSettingsInput to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        d: Dict[str, Any] = {
            "GlobalTableName": self.global_table_name,
        }

        if self.global_table_billing_mode is not None:
            d["GlobalTableBillingMode"] = self.global_table_billing_mode

        if self.global_table_provisioned_write_capacity_units is not None:
            d["GlobalTableProvisionedWriteCapacityUnits"] = self.global_table_provisioned_write_capacity_units

        if self.global_table_provisioned_write_capacity_auto_scaling_settings_update is not None:
            d["GlobalTableProvisionedWriteCapacityAutoScalingSettingsUpdate"] = self.global_table_provisioned_write_capacity_auto_scaling_settings_update.as_dict()

        if self.global_table_global_secondary_index_settings_update is not None:
            d["GlobalTableGlobalSecondaryIndexSettingsUpdate"] = _global_table_global_secondary_index_settings_update_list_as_dict(self.global_table_global_secondary_index_settings_update),

        if self.replica_settings_update is not None:
            d["ReplicaSettingsUpdate"] = _replica_settings_update_list_as_dict(self.replica_settings_update),

        return d

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "UpdateGlobalTableSettingsInput":
        """Creates a UpdateGlobalTableSettingsInput from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {
            "global_table_name": d["GlobalTableName"],
        }

        if "GlobalTableBillingMode" in d:
            kwargs["global_table_billing_mode"] = d["GlobalTableBillingMode"]

        if "GlobalTableProvisionedWriteCapacityUnits" in d:
            kwargs["global_table_provisioned_write_capacity_units"] = d["GlobalTableProvisionedWriteCapacityUnits"]

        if "GlobalTableProvisionedWriteCapacityAutoScalingSettingsUpdate" in d:
            kwargs["global_table_provisioned_write_capacity_auto_scaling_settings_update"] = AutoScalingSettingsUpdate.from_dict(d["GlobalTableProvisionedWriteCapacityAutoScalingSettingsUpdate"])

        if "GlobalTableGlobalSecondaryIndexSettingsUpdate" in d:
            kwargs["global_table_global_secondary_index_settings_update"] = _global_table_global_secondary_index_settings_update_list_from_dict(d["GlobalTableGlobalSecondaryIndexSettingsUpdate"]),

        if "ReplicaSettingsUpdate" in d:
            kwargs["replica_settings_update"] = _replica_settings_update_list_from_dict(d["ReplicaSettingsUpdate"]),

        return UpdateGlobalTableSettingsInput(**kwargs)

    def __repr__(self) -> str:
        result = "UpdateGlobalTableSettingsInput("
        if self.global_table_name is not None:
            result += f"global_table_name={repr(self.global_table_name)}, "

        if self.global_table_billing_mode is not None:
            result += f"global_table_billing_mode={repr(self.global_table_billing_mode)}, "

        if self.global_table_provisioned_write_capacity_units is not None:
            result += f"global_table_provisioned_write_capacity_units={repr(self.global_table_provisioned_write_capacity_units)}, "

        if self.global_table_provisioned_write_capacity_auto_scaling_settings_update is not None:
            result += f"global_table_provisioned_write_capacity_auto_scaling_settings_update={repr(self.global_table_provisioned_write_capacity_auto_scaling_settings_update)}, "

        if self.global_table_global_secondary_index_settings_update is not None:
            result += f"global_table_global_secondary_index_settings_update={repr(self.global_table_global_secondary_index_settings_update)}, "

        if self.replica_settings_update is not None:
            result += f"replica_settings_update={repr(self.replica_settings_update)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, UpdateGlobalTableSettingsInput):
            return False
        attributes: list[str] = ['global_table_name','global_table_billing_mode','global_table_provisioned_write_capacity_units','global_table_provisioned_write_capacity_auto_scaling_settings_update','global_table_global_secondary_index_settings_update','replica_settings_update',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class UpdateGlobalTableSettingsOutput:
    global_table_name: Optional[str]
    replica_settings: Optional[list[ReplicaSettingsDescription]]
    def __init__(
        self,
        *,
        global_table_name: Optional[str] = None,
        replica_settings: Optional[list[ReplicaSettingsDescription]] = None,
    ):
        """
        :param global_table_name: <p>The name of the global table.</p>
        :param replica_settings: <p>The Region-specific settings for the global
        table.</p>
        """
        self.global_table_name = global_table_name
        self.replica_settings = replica_settings

    def as_dict(self) -> Dict[str, Any]:
        """Converts the UpdateGlobalTableSettingsOutput to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        d: Dict[str, Any] = {}

        if self.global_table_name is not None:
            d["GlobalTableName"] = self.global_table_name

        if self.replica_settings is not None:
            d["ReplicaSettings"] = _replica_settings_description_list_as_dict(self.replica_settings),

        return d

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "UpdateGlobalTableSettingsOutput":
        """Creates a UpdateGlobalTableSettingsOutput from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {}

        if "GlobalTableName" in d:
            kwargs["global_table_name"] = d["GlobalTableName"]

        if "ReplicaSettings" in d:
            kwargs["replica_settings"] = _replica_settings_description_list_from_dict(d["ReplicaSettings"]),

        return UpdateGlobalTableSettingsOutput(**kwargs)

    def __repr__(self) -> str:
        result = "UpdateGlobalTableSettingsOutput("
        if self.global_table_name is not None:
            result += f"global_table_name={repr(self.global_table_name)}, "

        if self.replica_settings is not None:
            result += f"replica_settings={repr(self.replica_settings)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, UpdateGlobalTableSettingsOutput):
            return False
        attributes: list[str] = ['global_table_name','replica_settings',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class UpdateGlobalSecondaryIndexAction:
    index_name: str
    provisioned_throughput: ProvisionedThroughput
    def __init__(
        self,
        *,
        index_name: str,
        provisioned_throughput: ProvisionedThroughput,
    ):
        """<p>Represents the new provisioned throughput settings to be applied to a global
        secondary
                    index.</p>

        :param index_name: <p>The name of the global secondary index to be updated.</p>
        :param provisioned_throughput: <p>Represents the provisioned throughput settings
        for the specified global secondary
                    index.</p>
                <p>For current
        minimum and maximum provisioned throughput values, see <a
        href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Limits.html">Service,

        Account, and Table Quotas</a> in the <i>Amazon DynamoDB Developer

        Guide</i>.</p>
        """
        self.index_name = index_name
        self.provisioned_throughput = provisioned_throughput

    def as_dict(self) -> Dict[str, Any]:
        """Converts the UpdateGlobalSecondaryIndexAction to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        return {
            "IndexName": self.index_name,
            "ProvisionedThroughput": self.provisioned_throughput.as_dict(),
        }

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "UpdateGlobalSecondaryIndexAction":
        """Creates a UpdateGlobalSecondaryIndexAction from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {
            "index_name": d["IndexName"],
            "provisioned_throughput": ProvisionedThroughput.from_dict(d["ProvisionedThroughput"]),
        }

        return UpdateGlobalSecondaryIndexAction(**kwargs)

    def __repr__(self) -> str:
        result = "UpdateGlobalSecondaryIndexAction("
        if self.index_name is not None:
            result += f"index_name={repr(self.index_name)}, "

        if self.provisioned_throughput is not None:
            result += f"provisioned_throughput={repr(self.provisioned_throughput)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, UpdateGlobalSecondaryIndexAction):
            return False
        attributes: list[str] = ['index_name','provisioned_throughput',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class GlobalSecondaryIndexUpdate:
    update: Optional[UpdateGlobalSecondaryIndexAction]
    create: Optional[CreateGlobalSecondaryIndexAction]
    delete: Optional[DeleteGlobalSecondaryIndexAction]
    def __init__(
        self,
        *,
        update: Optional[UpdateGlobalSecondaryIndexAction] = None,
        create: Optional[CreateGlobalSecondaryIndexAction] = None,
        delete: Optional[DeleteGlobalSecondaryIndexAction] = None,
    ):
        """<p>Represents one of the following:</p>
                <ul>
                    <li>

        <p>A new global secondary index to be added to an existing table.</p>

        </li>
                    <li>
                        <p>New provisioned throughput parameters
        for an existing global secondary
                            index.</p>

        </li>
                    <li>
                        <p>An existing global secondary index to
        be removed from an existing
                            table.</p>
                    </li>

        </ul>

        :param update: <p>The name of an existing global secondary index, along with new
        provisioned throughput
                    settings to be applied to that index.</p>
        :param create: <p>The parameters required for creating a global secondary index
        on an existing
                    table:</p>
                <ul>
                    <li>

        <p>
                            <code>IndexName </code>
                        </p>

        </li>
                    <li>
                        <p>
                            <code>KeySchema
        </code>
                        </p>
                    </li>
                    <li>

        <p>
                            <code>AttributeDefinitions </code>
                        </p>

        </li>
                    <li>
                        <p>
                            <code>Projection
        </code>
                        </p>
                    </li>
                    <li>

        <p>
                            <code>ProvisionedThroughput </code>

        </p>
                    </li>
                 </ul>
        :param delete: <p>The name of an existing global secondary index to be
        removed.</p>
        """
        self.update = update
        self.create = create
        self.delete = delete

    def as_dict(self) -> Dict[str, Any]:
        """Converts the GlobalSecondaryIndexUpdate to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        d: Dict[str, Any] = {}

        if self.update is not None:
            d["Update"] = self.update.as_dict()

        if self.create is not None:
            d["Create"] = self.create.as_dict()

        if self.delete is not None:
            d["Delete"] = self.delete.as_dict()

        return d

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "GlobalSecondaryIndexUpdate":
        """Creates a GlobalSecondaryIndexUpdate from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {}

        if "Update" in d:
            kwargs["update"] = UpdateGlobalSecondaryIndexAction.from_dict(d["Update"])

        if "Create" in d:
            kwargs["create"] = CreateGlobalSecondaryIndexAction.from_dict(d["Create"])

        if "Delete" in d:
            kwargs["delete"] = DeleteGlobalSecondaryIndexAction.from_dict(d["Delete"])

        return GlobalSecondaryIndexUpdate(**kwargs)

    def __repr__(self) -> str:
        result = "GlobalSecondaryIndexUpdate("
        if self.update is not None:
            result += f"update={repr(self.update)}, "

        if self.create is not None:
            result += f"create={repr(self.create)}, "

        if self.delete is not None:
            result += f"delete={repr(self.delete)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, GlobalSecondaryIndexUpdate):
            return False
        attributes: list[str] = ['update','create','delete',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class UpdateReplicationGroupMemberAction:
    region_name: str
    kms_master_key_id: Optional[str]
    provisioned_throughput_override: Optional[ProvisionedThroughputOverride]
    global_secondary_indexes: Optional[list[ReplicaGlobalSecondaryIndex]]
    table_class_override: Optional[str]
    def __init__(
        self,
        *,
        region_name: str,
        kms_master_key_id: Optional[str] = None,
        provisioned_throughput_override: Optional[ProvisionedThroughputOverride] = None,
        global_secondary_indexes: Optional[list[ReplicaGlobalSecondaryIndex]] = None,
        table_class_override: Optional[str] = None,
    ):
        """<p>Represents a replica to be modified.</p>

        :param region_name: <p>The Region where the replica exists.</p>
        :param kms_master_key_id: <p>The KMS key of the replica that should be used

        for KMS encryption. To specify a key, use its key ID, Amazon Resource

        Name (ARN), alias name, or alias ARN. Note that you should only provide this
        parameter
                    if the key is different from the default DynamoDB KMS key

        <code>alias/aws/dynamodb</code>.</p>
        :param provisioned_throughput_override: <p>Replica-specific provisioned
        throughput. If not specified, uses the source table's
                    provisioned
        throughput settings.</p>
        :param global_secondary_indexes: <p>Replica-specific global secondary index
        settings.</p>
        :param table_class_override: <p>Replica-specific table class. If not specified,
        uses the source table's
                    table class.</p>
        """
        self.region_name = region_name
        self.kms_master_key_id = kms_master_key_id
        self.provisioned_throughput_override = provisioned_throughput_override
        self.global_secondary_indexes = global_secondary_indexes
        self.table_class_override = table_class_override

    def as_dict(self) -> Dict[str, Any]:
        """Converts the UpdateReplicationGroupMemberAction to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        d: Dict[str, Any] = {
            "RegionName": self.region_name,
        }

        if self.kms_master_key_id is not None:
            d["KMSMasterKeyId"] = self.kms_master_key_id

        if self.provisioned_throughput_override is not None:
            d["ProvisionedThroughputOverride"] = self.provisioned_throughput_override.as_dict()

        if self.global_secondary_indexes is not None:
            d["GlobalSecondaryIndexes"] = _replica_global_secondary_index_list_as_dict(self.global_secondary_indexes),

        if self.table_class_override is not None:
            d["TableClassOverride"] = self.table_class_override

        return d

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "UpdateReplicationGroupMemberAction":
        """Creates a UpdateReplicationGroupMemberAction from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {
            "region_name": d["RegionName"],
        }

        if "KMSMasterKeyId" in d:
            kwargs["kms_master_key_id"] = d["KMSMasterKeyId"]

        if "ProvisionedThroughputOverride" in d:
            kwargs["provisioned_throughput_override"] = ProvisionedThroughputOverride.from_dict(d["ProvisionedThroughputOverride"])

        if "GlobalSecondaryIndexes" in d:
            kwargs["global_secondary_indexes"] = _replica_global_secondary_index_list_from_dict(d["GlobalSecondaryIndexes"]),

        if "TableClassOverride" in d:
            kwargs["table_class_override"] = d["TableClassOverride"]

        return UpdateReplicationGroupMemberAction(**kwargs)

    def __repr__(self) -> str:
        result = "UpdateReplicationGroupMemberAction("
        if self.region_name is not None:
            result += f"region_name={repr(self.region_name)}, "

        if self.kms_master_key_id is not None:
            result += f"kms_master_key_id={repr(self.kms_master_key_id)}, "

        if self.provisioned_throughput_override is not None:
            result += f"provisioned_throughput_override={repr(self.provisioned_throughput_override)}, "

        if self.global_secondary_indexes is not None:
            result += f"global_secondary_indexes={repr(self.global_secondary_indexes)}, "

        if self.table_class_override is not None:
            result += f"table_class_override={repr(self.table_class_override)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, UpdateReplicationGroupMemberAction):
            return False
        attributes: list[str] = ['region_name','kms_master_key_id','provisioned_throughput_override','global_secondary_indexes','table_class_override',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class ReplicationGroupUpdate:
    create: Optional[CreateReplicationGroupMemberAction]
    update: Optional[UpdateReplicationGroupMemberAction]
    delete: Optional[DeleteReplicationGroupMemberAction]
    def __init__(
        self,
        *,
        create: Optional[CreateReplicationGroupMemberAction] = None,
        update: Optional[UpdateReplicationGroupMemberAction] = None,
        delete: Optional[DeleteReplicationGroupMemberAction] = None,
    ):
        """<p>Represents one of the following:</p>
                <ul>
                    <li>

        <p>A new replica to be added to an existing regional table or global table.
        This
                            request invokes the <code>CreateTableReplica</code>
        action in the destination
                            Region.</p>
                    </li>

        <li>
                        <p>New parameters for an existing replica. This request
        invokes the
                                <code>UpdateTable</code> action in the
        destination Region.</p>
                    </li>
                    <li>
                        <p>An
        existing replica to be deleted. The request invokes the

        <code>DeleteTableReplica</code> action in the destination Region, deleting

        the replica and all if its items in the destination Region.</p>

        </li>
                 </ul>
                <note>
                    <p>When you manually remove a
        table or global table replica, you do not
                        automatically remove
        any associated scalable targets, scaling policies, or

        CloudWatch alarms.</p>
                </note>

        :param create: <p>The parameters required for creating a replica for the
        table.</p>
        :param update: <p>The parameters required for updating a replica for the
        table.</p>
        :param delete: <p>The parameters required for deleting a replica for the
        table.</p>
        """
        self.create = create
        self.update = update
        self.delete = delete

    def as_dict(self) -> Dict[str, Any]:
        """Converts the ReplicationGroupUpdate to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        d: Dict[str, Any] = {}

        if self.create is not None:
            d["Create"] = self.create.as_dict()

        if self.update is not None:
            d["Update"] = self.update.as_dict()

        if self.delete is not None:
            d["Delete"] = self.delete.as_dict()

        return d

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "ReplicationGroupUpdate":
        """Creates a ReplicationGroupUpdate from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {}

        if "Create" in d:
            kwargs["create"] = CreateReplicationGroupMemberAction.from_dict(d["Create"])

        if "Update" in d:
            kwargs["update"] = UpdateReplicationGroupMemberAction.from_dict(d["Update"])

        if "Delete" in d:
            kwargs["delete"] = DeleteReplicationGroupMemberAction.from_dict(d["Delete"])

        return ReplicationGroupUpdate(**kwargs)

    def __repr__(self) -> str:
        result = "ReplicationGroupUpdate("
        if self.create is not None:
            result += f"create={repr(self.create)}, "

        if self.update is not None:
            result += f"update={repr(self.update)}, "

        if self.delete is not None:
            result += f"delete={repr(self.delete)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, ReplicationGroupUpdate):
            return False
        attributes: list[str] = ['create','update','delete',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class UpdateTableInput:
    attribute_definitions: Optional[list[AttributeDefinition]]
    table_name: str
    billing_mode: Optional[str]
    provisioned_throughput: Optional[ProvisionedThroughput]
    global_secondary_index_updates: Optional[list[GlobalSecondaryIndexUpdate]]
    stream_specification: Optional[StreamSpecification]
    sse_specification: Optional[SSESpecification]
    replica_updates: Optional[list[ReplicationGroupUpdate]]
    table_class: Optional[str]
    def __init__(
        self,
        *,
        table_name: str,
        attribute_definitions: Optional[list[AttributeDefinition]] = None,
        billing_mode: Optional[str] = None,
        provisioned_throughput: Optional[ProvisionedThroughput] = None,
        global_secondary_index_updates: Optional[list[GlobalSecondaryIndexUpdate]] = None,
        stream_specification: Optional[StreamSpecification] = None,
        sse_specification: Optional[SSESpecification] = None,
        replica_updates: Optional[list[ReplicationGroupUpdate]] = None,
        table_class: Optional[str] = None,
    ):
        """<p>Represents the input of an <code>UpdateTable</code> operation.</p>

        :param table_name: <p>The name of the table to be updated.</p>
        :param attribute_definitions: <p>An array of attributes that describe the key
        schema for the table and indexes. If you
                    are adding a new global
        secondary index to the table, <code>AttributeDefinitions</code>
                    must
        include the key element(s) of the new index.</p>
        :param billing_mode: <p>Controls how you are charged for read and write
        throughput and how you manage
                    capacity. When switching from
        pay-per-request to provisioned capacity, initial
                    provisioned
        capacity values must be set. The initial provisioned capacity values are

        estimated based on the consumed read and write capacity of your table and
        global
                    secondary indexes over the past 30 minutes.</p>
                <ul>

        <li>
                        <p>
                            <code>PROVISIONED</code> - We
        recommend using <code>PROVISIONED</code> for
                            predictable
        workloads. <code>PROVISIONED</code> sets the billing mode to <a
        href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/HowItWorks.ReadWriteCapacityMode.html#HowItWorks.ProvisionedThroughput.Manual">Provisioned
        Mode</a>.</p>
                    </li>
                    <li>
                        <p>

        <code>PAY_PER_REQUEST</code> - We recommend using <code>PAY_PER_REQUEST</code>

        for unpredictable workloads. <code>PAY_PER_REQUEST</code> sets the billing mode

        to <a
        href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/HowItWorks.ReadWriteCapacityMode.html#HowItWorks.OnDemand">On-Demand
        Mode</a>. </p>
                    </li>
                 </ul>
        :param provisioned_throughput: <p>The new provisioned throughput settings for
        the specified table or index.</p>
        :param global_secondary_index_updates: <p>An array of one or more global
        secondary indexes for the table. For each index in the
                    array, you
        can request one action:</p>
                <ul>
                    <li>
                        <p>

        <code>Create</code> - add a new global secondary index to the table.</p>

        </li>
                    <li>
                        <p>

        <code>Update</code> - modify the provisioned throughput settings of an existing

        global secondary index.</p>
                    </li>
                    <li>

        <p>
                            <code>Delete</code> - remove a global secondary index
        from the table.</p>
                    </li>
                 </ul>
                <p>You can create
        or delete only one global secondary index per <code>UpdateTable</code>

        operation.</p>
                <p>For more information, see <a
        href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/GSI.OnlineOps.html">Managing
        Global
                        Secondary Indexes</a> in the <i>Amazon DynamoDB
        Developer
                        Guide</i>. </p>
        :param stream_specification: <p>Represents the DynamoDB Streams configuration
        for the table.</p>
                <note>
                    <p>You receive a
        <code>ResourceInUseException</code> if you try to enable a stream on

        a table that already has a stream, or if you try to disable a stream on a table
        that
                        doesn't have a stream.</p>
                </note>
        :param sse_specification: <p>The new server-side encryption settings for the
        specified table.</p>
        :param replica_updates: <p>A list of replica update actions (create, delete, or
        update) for the table.</p>
                <note>
                    <p>This property only
        applies to <a
        href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/globaltables.V2.html">Version

        2019.11.21</a> of global tables.</p>
                </note>
        :param table_class: <p>The table class of the table to be updated. Valid values
        are <code>STANDARD</code> and

        <code>STANDARD_INFREQUENT_ACCESS</code>.</p>
        """
        self.table_name = table_name
        self.attribute_definitions = attribute_definitions
        self.billing_mode = billing_mode
        self.provisioned_throughput = provisioned_throughput
        self.global_secondary_index_updates = global_secondary_index_updates
        self.stream_specification = stream_specification
        self.sse_specification = sse_specification
        self.replica_updates = replica_updates
        self.table_class = table_class

    def as_dict(self) -> Dict[str, Any]:
        """Converts the UpdateTableInput to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        d: Dict[str, Any] = {
            "TableName": self.table_name,
        }

        if self.attribute_definitions is not None:
            d["AttributeDefinitions"] = _attribute_definitions_as_dict(self.attribute_definitions),

        if self.billing_mode is not None:
            d["BillingMode"] = self.billing_mode

        if self.provisioned_throughput is not None:
            d["ProvisionedThroughput"] = self.provisioned_throughput.as_dict()

        if self.global_secondary_index_updates is not None:
            d["GlobalSecondaryIndexUpdates"] = _global_secondary_index_update_list_as_dict(self.global_secondary_index_updates),

        if self.stream_specification is not None:
            d["StreamSpecification"] = self.stream_specification.as_dict()

        if self.sse_specification is not None:
            d["SSESpecification"] = self.sse_specification.as_dict()

        if self.replica_updates is not None:
            d["ReplicaUpdates"] = _replication_group_update_list_as_dict(self.replica_updates),

        if self.table_class is not None:
            d["TableClass"] = self.table_class

        return d

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "UpdateTableInput":
        """Creates a UpdateTableInput from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {
            "table_name": d["TableName"],
        }

        if "AttributeDefinitions" in d:
            kwargs["attribute_definitions"] = _attribute_definitions_from_dict(d["AttributeDefinitions"]),

        if "BillingMode" in d:
            kwargs["billing_mode"] = d["BillingMode"]

        if "ProvisionedThroughput" in d:
            kwargs["provisioned_throughput"] = ProvisionedThroughput.from_dict(d["ProvisionedThroughput"])

        if "GlobalSecondaryIndexUpdates" in d:
            kwargs["global_secondary_index_updates"] = _global_secondary_index_update_list_from_dict(d["GlobalSecondaryIndexUpdates"]),

        if "StreamSpecification" in d:
            kwargs["stream_specification"] = StreamSpecification.from_dict(d["StreamSpecification"])

        if "SSESpecification" in d:
            kwargs["sse_specification"] = SSESpecification.from_dict(d["SSESpecification"])

        if "ReplicaUpdates" in d:
            kwargs["replica_updates"] = _replication_group_update_list_from_dict(d["ReplicaUpdates"]),

        if "TableClass" in d:
            kwargs["table_class"] = d["TableClass"]

        return UpdateTableInput(**kwargs)

    def __repr__(self) -> str:
        result = "UpdateTableInput("
        if self.attribute_definitions is not None:
            result += f"attribute_definitions={repr(self.attribute_definitions)}, "

        if self.table_name is not None:
            result += f"table_name={repr(self.table_name)}, "

        if self.billing_mode is not None:
            result += f"billing_mode={repr(self.billing_mode)}, "

        if self.provisioned_throughput is not None:
            result += f"provisioned_throughput={repr(self.provisioned_throughput)}, "

        if self.global_secondary_index_updates is not None:
            result += f"global_secondary_index_updates={repr(self.global_secondary_index_updates)}, "

        if self.stream_specification is not None:
            result += f"stream_specification={repr(self.stream_specification)}, "

        if self.sse_specification is not None:
            result += f"sse_specification={repr(self.sse_specification)}, "

        if self.replica_updates is not None:
            result += f"replica_updates={repr(self.replica_updates)}, "

        if self.table_class is not None:
            result += f"table_class={repr(self.table_class)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, UpdateTableInput):
            return False
        attributes: list[str] = ['attribute_definitions','table_name','billing_mode','provisioned_throughput','global_secondary_index_updates','stream_specification','sse_specification','replica_updates','table_class',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class UpdateTableOutput:
    table_description: Optional[TableDescription]
    def __init__(
        self,
        *,
        table_description: Optional[TableDescription] = None,
    ):
        """<p>Represents the output of an <code>UpdateTable</code> operation.</p>

        :param table_description: <p>Represents the properties of the table.</p>
        """
        self.table_description = table_description

    def as_dict(self) -> Dict[str, Any]:
        """Converts the UpdateTableOutput to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        d: Dict[str, Any] = {}

        if self.table_description is not None:
            d["TableDescription"] = self.table_description.as_dict()

        return d

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "UpdateTableOutput":
        """Creates a UpdateTableOutput from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {}

        if "TableDescription" in d:
            kwargs["table_description"] = TableDescription.from_dict(d["TableDescription"])

        return UpdateTableOutput(**kwargs)

    def __repr__(self) -> str:
        result = "UpdateTableOutput("
        if self.table_description is not None:
            result += f"table_description={repr(self.table_description)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, UpdateTableOutput):
            return False
        attributes: list[str] = ['table_description',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class GlobalSecondaryIndexAutoScalingUpdate:
    index_name: Optional[str]
    provisioned_write_capacity_auto_scaling_update: Optional[AutoScalingSettingsUpdate]
    def __init__(
        self,
        *,
        index_name: Optional[str] = None,
        provisioned_write_capacity_auto_scaling_update: Optional[AutoScalingSettingsUpdate] = None,
    ):
        """<p>Represents the auto scaling settings of a global secondary index for a global
        table
                    that will be modified.</p>

        :param index_name: <p>The name of the global secondary index.</p>
        :param provisioned_write_capacity_auto_scaling_update: <p>Represents the auto
        scaling settings to be modified for a global table or global

        secondary index.</p>
        """
        self.index_name = index_name
        self.provisioned_write_capacity_auto_scaling_update = provisioned_write_capacity_auto_scaling_update

    def as_dict(self) -> Dict[str, Any]:
        """Converts the GlobalSecondaryIndexAutoScalingUpdate to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        d: Dict[str, Any] = {}

        if self.index_name is not None:
            d["IndexName"] = self.index_name

        if self.provisioned_write_capacity_auto_scaling_update is not None:
            d["ProvisionedWriteCapacityAutoScalingUpdate"] = self.provisioned_write_capacity_auto_scaling_update.as_dict()

        return d

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "GlobalSecondaryIndexAutoScalingUpdate":
        """Creates a GlobalSecondaryIndexAutoScalingUpdate from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {}

        if "IndexName" in d:
            kwargs["index_name"] = d["IndexName"]

        if "ProvisionedWriteCapacityAutoScalingUpdate" in d:
            kwargs["provisioned_write_capacity_auto_scaling_update"] = AutoScalingSettingsUpdate.from_dict(d["ProvisionedWriteCapacityAutoScalingUpdate"])

        return GlobalSecondaryIndexAutoScalingUpdate(**kwargs)

    def __repr__(self) -> str:
        result = "GlobalSecondaryIndexAutoScalingUpdate("
        if self.index_name is not None:
            result += f"index_name={repr(self.index_name)}, "

        if self.provisioned_write_capacity_auto_scaling_update is not None:
            result += f"provisioned_write_capacity_auto_scaling_update={repr(self.provisioned_write_capacity_auto_scaling_update)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, GlobalSecondaryIndexAutoScalingUpdate):
            return False
        attributes: list[str] = ['index_name','provisioned_write_capacity_auto_scaling_update',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class ReplicaGlobalSecondaryIndexAutoScalingUpdate:
    index_name: Optional[str]
    provisioned_read_capacity_auto_scaling_update: Optional[AutoScalingSettingsUpdate]
    def __init__(
        self,
        *,
        index_name: Optional[str] = None,
        provisioned_read_capacity_auto_scaling_update: Optional[AutoScalingSettingsUpdate] = None,
    ):
        """<p>Represents the auto scaling settings of a global secondary index for a
        replica that
                    will be modified.</p>

        :param index_name: <p>The name of the global secondary index.</p>
        :param provisioned_read_capacity_auto_scaling_update: <p>Represents the auto
        scaling settings to be modified for a global table or global

        secondary index.</p>
        """
        self.index_name = index_name
        self.provisioned_read_capacity_auto_scaling_update = provisioned_read_capacity_auto_scaling_update

    def as_dict(self) -> Dict[str, Any]:
        """Converts the ReplicaGlobalSecondaryIndexAutoScalingUpdate to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        d: Dict[str, Any] = {}

        if self.index_name is not None:
            d["IndexName"] = self.index_name

        if self.provisioned_read_capacity_auto_scaling_update is not None:
            d["ProvisionedReadCapacityAutoScalingUpdate"] = self.provisioned_read_capacity_auto_scaling_update.as_dict()

        return d

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "ReplicaGlobalSecondaryIndexAutoScalingUpdate":
        """Creates a ReplicaGlobalSecondaryIndexAutoScalingUpdate from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {}

        if "IndexName" in d:
            kwargs["index_name"] = d["IndexName"]

        if "ProvisionedReadCapacityAutoScalingUpdate" in d:
            kwargs["provisioned_read_capacity_auto_scaling_update"] = AutoScalingSettingsUpdate.from_dict(d["ProvisionedReadCapacityAutoScalingUpdate"])

        return ReplicaGlobalSecondaryIndexAutoScalingUpdate(**kwargs)

    def __repr__(self) -> str:
        result = "ReplicaGlobalSecondaryIndexAutoScalingUpdate("
        if self.index_name is not None:
            result += f"index_name={repr(self.index_name)}, "

        if self.provisioned_read_capacity_auto_scaling_update is not None:
            result += f"provisioned_read_capacity_auto_scaling_update={repr(self.provisioned_read_capacity_auto_scaling_update)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, ReplicaGlobalSecondaryIndexAutoScalingUpdate):
            return False
        attributes: list[str] = ['index_name','provisioned_read_capacity_auto_scaling_update',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class ReplicaAutoScalingUpdate:
    region_name: str
    replica_global_secondary_index_updates: Optional[list[ReplicaGlobalSecondaryIndexAutoScalingUpdate]]
    replica_provisioned_read_capacity_auto_scaling_update: Optional[AutoScalingSettingsUpdate]
    def __init__(
        self,
        *,
        region_name: str,
        replica_global_secondary_index_updates: Optional[list[ReplicaGlobalSecondaryIndexAutoScalingUpdate]] = None,
        replica_provisioned_read_capacity_auto_scaling_update: Optional[AutoScalingSettingsUpdate] = None,
    ):
        """<p>Represents the auto scaling settings of a replica that will be modified.</p>

        :param region_name: <p>The Region where the replica exists.</p>
        :param replica_global_secondary_index_updates: <p>Represents the auto scaling
        settings of global secondary indexes that will be
                    modified.</p>
        :param replica_provisioned_read_capacity_auto_scaling_update: <p>Represents the
        auto scaling settings to be modified for a global table or global

        secondary index.</p>
        """
        self.region_name = region_name
        self.replica_global_secondary_index_updates = replica_global_secondary_index_updates
        self.replica_provisioned_read_capacity_auto_scaling_update = replica_provisioned_read_capacity_auto_scaling_update

    def as_dict(self) -> Dict[str, Any]:
        """Converts the ReplicaAutoScalingUpdate to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        d: Dict[str, Any] = {
            "RegionName": self.region_name,
        }

        if self.replica_global_secondary_index_updates is not None:
            d["ReplicaGlobalSecondaryIndexUpdates"] = _replica_global_secondary_index_auto_scaling_update_list_as_dict(self.replica_global_secondary_index_updates),

        if self.replica_provisioned_read_capacity_auto_scaling_update is not None:
            d["ReplicaProvisionedReadCapacityAutoScalingUpdate"] = self.replica_provisioned_read_capacity_auto_scaling_update.as_dict()

        return d

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "ReplicaAutoScalingUpdate":
        """Creates a ReplicaAutoScalingUpdate from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {
            "region_name": d["RegionName"],
        }

        if "ReplicaGlobalSecondaryIndexUpdates" in d:
            kwargs["replica_global_secondary_index_updates"] = _replica_global_secondary_index_auto_scaling_update_list_from_dict(d["ReplicaGlobalSecondaryIndexUpdates"]),

        if "ReplicaProvisionedReadCapacityAutoScalingUpdate" in d:
            kwargs["replica_provisioned_read_capacity_auto_scaling_update"] = AutoScalingSettingsUpdate.from_dict(d["ReplicaProvisionedReadCapacityAutoScalingUpdate"])

        return ReplicaAutoScalingUpdate(**kwargs)

    def __repr__(self) -> str:
        result = "ReplicaAutoScalingUpdate("
        if self.region_name is not None:
            result += f"region_name={repr(self.region_name)}, "

        if self.replica_global_secondary_index_updates is not None:
            result += f"replica_global_secondary_index_updates={repr(self.replica_global_secondary_index_updates)}, "

        if self.replica_provisioned_read_capacity_auto_scaling_update is not None:
            result += f"replica_provisioned_read_capacity_auto_scaling_update={repr(self.replica_provisioned_read_capacity_auto_scaling_update)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, ReplicaAutoScalingUpdate):
            return False
        attributes: list[str] = ['region_name','replica_global_secondary_index_updates','replica_provisioned_read_capacity_auto_scaling_update',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class UpdateTableReplicaAutoScalingInput:
    global_secondary_index_updates: Optional[list[GlobalSecondaryIndexAutoScalingUpdate]]
    table_name: str
    provisioned_write_capacity_auto_scaling_update: Optional[AutoScalingSettingsUpdate]
    replica_updates: Optional[list[ReplicaAutoScalingUpdate]]
    def __init__(
        self,
        *,
        table_name: str,
        global_secondary_index_updates: Optional[list[GlobalSecondaryIndexAutoScalingUpdate]] = None,
        provisioned_write_capacity_auto_scaling_update: Optional[AutoScalingSettingsUpdate] = None,
        replica_updates: Optional[list[ReplicaAutoScalingUpdate]] = None,
    ):
        """
        :param table_name: <p>The name of the global table to be updated.</p>
        :param global_secondary_index_updates: <p>Represents the auto scaling settings
        of the global secondary indexes of the replica to
                    be updated.</p>
        :param provisioned_write_capacity_auto_scaling_update: <p>Represents the auto
        scaling settings to be modified for a global table or global

        secondary index.</p>
        :param replica_updates: <p>Represents the auto scaling settings of replicas of
        the table that will be
                    modified.</p>
        """
        self.table_name = table_name
        self.global_secondary_index_updates = global_secondary_index_updates
        self.provisioned_write_capacity_auto_scaling_update = provisioned_write_capacity_auto_scaling_update
        self.replica_updates = replica_updates

    def as_dict(self) -> Dict[str, Any]:
        """Converts the UpdateTableReplicaAutoScalingInput to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        d: Dict[str, Any] = {
            "TableName": self.table_name,
        }

        if self.global_secondary_index_updates is not None:
            d["GlobalSecondaryIndexUpdates"] = _global_secondary_index_auto_scaling_update_list_as_dict(self.global_secondary_index_updates),

        if self.provisioned_write_capacity_auto_scaling_update is not None:
            d["ProvisionedWriteCapacityAutoScalingUpdate"] = self.provisioned_write_capacity_auto_scaling_update.as_dict()

        if self.replica_updates is not None:
            d["ReplicaUpdates"] = _replica_auto_scaling_update_list_as_dict(self.replica_updates),

        return d

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "UpdateTableReplicaAutoScalingInput":
        """Creates a UpdateTableReplicaAutoScalingInput from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {
            "table_name": d["TableName"],
        }

        if "GlobalSecondaryIndexUpdates" in d:
            kwargs["global_secondary_index_updates"] = _global_secondary_index_auto_scaling_update_list_from_dict(d["GlobalSecondaryIndexUpdates"]),

        if "ProvisionedWriteCapacityAutoScalingUpdate" in d:
            kwargs["provisioned_write_capacity_auto_scaling_update"] = AutoScalingSettingsUpdate.from_dict(d["ProvisionedWriteCapacityAutoScalingUpdate"])

        if "ReplicaUpdates" in d:
            kwargs["replica_updates"] = _replica_auto_scaling_update_list_from_dict(d["ReplicaUpdates"]),

        return UpdateTableReplicaAutoScalingInput(**kwargs)

    def __repr__(self) -> str:
        result = "UpdateTableReplicaAutoScalingInput("
        if self.global_secondary_index_updates is not None:
            result += f"global_secondary_index_updates={repr(self.global_secondary_index_updates)}, "

        if self.table_name is not None:
            result += f"table_name={repr(self.table_name)}, "

        if self.provisioned_write_capacity_auto_scaling_update is not None:
            result += f"provisioned_write_capacity_auto_scaling_update={repr(self.provisioned_write_capacity_auto_scaling_update)}, "

        if self.replica_updates is not None:
            result += f"replica_updates={repr(self.replica_updates)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, UpdateTableReplicaAutoScalingInput):
            return False
        attributes: list[str] = ['global_secondary_index_updates','table_name','provisioned_write_capacity_auto_scaling_update','replica_updates',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class UpdateTableReplicaAutoScalingOutput:
    table_auto_scaling_description: Optional[TableAutoScalingDescription]
    def __init__(
        self,
        *,
        table_auto_scaling_description: Optional[TableAutoScalingDescription] = None,
    ):
        """
        :param table_auto_scaling_description: <p>Returns information about the auto
        scaling settings of a table with replicas.</p>
        """
        self.table_auto_scaling_description = table_auto_scaling_description

    def as_dict(self) -> Dict[str, Any]:
        """Converts the UpdateTableReplicaAutoScalingOutput to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        d: Dict[str, Any] = {}

        if self.table_auto_scaling_description is not None:
            d["TableAutoScalingDescription"] = self.table_auto_scaling_description.as_dict()

        return d

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "UpdateTableReplicaAutoScalingOutput":
        """Creates a UpdateTableReplicaAutoScalingOutput from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {}

        if "TableAutoScalingDescription" in d:
            kwargs["table_auto_scaling_description"] = TableAutoScalingDescription.from_dict(d["TableAutoScalingDescription"])

        return UpdateTableReplicaAutoScalingOutput(**kwargs)

    def __repr__(self) -> str:
        result = "UpdateTableReplicaAutoScalingOutput("
        if self.table_auto_scaling_description is not None:
            result += f"table_auto_scaling_description={repr(self.table_auto_scaling_description)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, UpdateTableReplicaAutoScalingOutput):
            return False
        attributes: list[str] = ['table_auto_scaling_description',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class TimeToLiveSpecification:
    enabled: bool
    attribute_name: str
    def __init__(
        self,
        *,
        enabled: bool,
        attribute_name: str,
    ):
        """<p>Represents the settings used to enable or disable Time to Live (TTL) for the
        specified
                    table.</p>

        :param enabled: <p>Indicates whether TTL is to be enabled (true) or disabled
        (false) on the table.</p>
        :param attribute_name: <p>The name of the TTL attribute used to store the
        expiration time for items in the
                    table.</p>
        """
        self.enabled = enabled
        self.attribute_name = attribute_name

    def as_dict(self) -> Dict[str, Any]:
        """Converts the TimeToLiveSpecification to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        return {
            "Enabled": self.enabled,
            "AttributeName": self.attribute_name,
        }

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "TimeToLiveSpecification":
        """Creates a TimeToLiveSpecification from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {
            "enabled": d["Enabled"],
            "attribute_name": d["AttributeName"],
        }

        return TimeToLiveSpecification(**kwargs)

    def __repr__(self) -> str:
        result = "TimeToLiveSpecification("
        if self.enabled is not None:
            result += f"enabled={repr(self.enabled)}, "

        if self.attribute_name is not None:
            result += f"attribute_name={repr(self.attribute_name)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, TimeToLiveSpecification):
            return False
        attributes: list[str] = ['enabled','attribute_name',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class UpdateTimeToLiveInput:
    table_name: str
    time_to_live_specification: TimeToLiveSpecification
    def __init__(
        self,
        *,
        table_name: str,
        time_to_live_specification: TimeToLiveSpecification,
    ):
        """<p>Represents the input of an <code>UpdateTimeToLive</code> operation.</p>

        :param table_name: <p>The name of the table to be configured.</p>
        :param time_to_live_specification: <p>Represents the settings used to enable or
        disable Time to Live for the specified
                    table.</p>
        """
        self.table_name = table_name
        self.time_to_live_specification = time_to_live_specification

    def as_dict(self) -> Dict[str, Any]:
        """Converts the UpdateTimeToLiveInput to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        return {
            "TableName": self.table_name,
            "TimeToLiveSpecification": self.time_to_live_specification.as_dict(),
        }

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "UpdateTimeToLiveInput":
        """Creates a UpdateTimeToLiveInput from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {
            "table_name": d["TableName"],
            "time_to_live_specification": TimeToLiveSpecification.from_dict(d["TimeToLiveSpecification"]),
        }

        return UpdateTimeToLiveInput(**kwargs)

    def __repr__(self) -> str:
        result = "UpdateTimeToLiveInput("
        if self.table_name is not None:
            result += f"table_name={repr(self.table_name)}, "

        if self.time_to_live_specification is not None:
            result += f"time_to_live_specification={repr(self.time_to_live_specification)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, UpdateTimeToLiveInput):
            return False
        attributes: list[str] = ['table_name','time_to_live_specification',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class UpdateTimeToLiveOutput:
    time_to_live_specification: Optional[TimeToLiveSpecification]
    def __init__(
        self,
        *,
        time_to_live_specification: Optional[TimeToLiveSpecification] = None,
    ):
        """
        :param time_to_live_specification: <p>Represents the output of an
        <code>UpdateTimeToLive</code> operation.</p>
        """
        self.time_to_live_specification = time_to_live_specification

    def as_dict(self) -> Dict[str, Any]:
        """Converts the UpdateTimeToLiveOutput to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        d: Dict[str, Any] = {}

        if self.time_to_live_specification is not None:
            d["TimeToLiveSpecification"] = self.time_to_live_specification.as_dict()

        return d

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "UpdateTimeToLiveOutput":
        """Creates a UpdateTimeToLiveOutput from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {}

        if "TimeToLiveSpecification" in d:
            kwargs["time_to_live_specification"] = TimeToLiveSpecification.from_dict(d["TimeToLiveSpecification"])

        return UpdateTimeToLiveOutput(**kwargs)

    def __repr__(self) -> str:
        result = "UpdateTimeToLiveOutput("
        if self.time_to_live_specification is not None:
            result += f"time_to_live_specification={repr(self.time_to_live_specification)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, UpdateTimeToLiveOutput):
            return False
        attributes: list[str] = ['time_to_live_specification',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class AttributeValueS():
    """<p>An attribute of type String. For example:</p>
            <p>

    <code>"S": "Hello"</code>
             </p>
    """
    def __init__(self, value: str):
        self.value = value

    def as_dict(self) -> Dict[str, Any]:
        return {"S": self.value}

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "AttributeValueS":
        if (len(d) != 1):
            raise TypeError(f"Unions may have exactly 1 value, but found {len(d)}")

        return AttributeValueS(d["S"])

    def __repr__(self) -> str:
        return f"AttributeValueS(value=repr(self.value))"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, AttributeValueS):
            return False
        return self.value == other.value

class AttributeValueN():
    """<p>An attribute of type Number. For example:</p>
            <p>

    <code>"N": "123.45"</code>
             </p>
            <p>Numbers are sent across the
    network to DynamoDB as strings, to maximize compatibility
                across
    languages and libraries. However, DynamoDB treats them as number type
    attributes
                for mathematical operations.</p>
    """
    def __init__(self, value: str):
        self.value = value

    def as_dict(self) -> Dict[str, Any]:
        return {"N": self.value}

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "AttributeValueN":
        if (len(d) != 1):
            raise TypeError(f"Unions may have exactly 1 value, but found {len(d)}")

        return AttributeValueN(d["N"])

    def __repr__(self) -> str:
        return f"AttributeValueN(value=repr(self.value))"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, AttributeValueN):
            return False
        return self.value == other.value

class AttributeValueB():
    """<p>An attribute of type Binary. For example:</p>
            <p>

    <code>"B": "dGhpcyB0ZXh0IGlzIGJhc2U2NC1lbmNvZGVk"</code>
             </p>
    """
    def __init__(self, value: bytes | bytearray):
        self.value = value

    def as_dict(self) -> Dict[str, Any]:
        return {"B": self.value}

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "AttributeValueB":
        if (len(d) != 1):
            raise TypeError(f"Unions may have exactly 1 value, but found {len(d)}")

        return AttributeValueB(d["B"])

    def __repr__(self) -> str:
        return f"AttributeValueB(value=repr(self.value))"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, AttributeValueB):
            return False
        return self.value == other.value

class AttributeValueSS():
    """<p>An attribute of type String Set. For example:</p>
            <p>

    <code>"SS": ["Giraffe", "Hippo" ,"Zebra"]</code>
             </p>
    """
    def __init__(self, value: list[str]):
        self.value = value

    def as_dict(self) -> Dict[str, Any]:
        return {"SS": self.value}

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "AttributeValueSS":
        if (len(d) != 1):
            raise TypeError(f"Unions may have exactly 1 value, but found {len(d)}")

        return AttributeValueSS(d["SS"])

    def __repr__(self) -> str:
        return f"AttributeValueSS(value=repr(self.value))"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, AttributeValueSS):
            return False
        return self.value == other.value

class AttributeValueNS():
    """<p>An attribute of type Number Set. For example:</p>
            <p>

    <code>"NS": ["42.2", "-19", "7.5", "3.14"]</code>
             </p>

    <p>Numbers are sent across the network to DynamoDB as strings, to maximize
    compatibility
                across languages and libraries. However, DynamoDB
    treats them as number type attributes
                for mathematical
    operations.</p>
    """
    def __init__(self, value: list[str]):
        self.value = value

    def as_dict(self) -> Dict[str, Any]:
        return {"NS": self.value}

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "AttributeValueNS":
        if (len(d) != 1):
            raise TypeError(f"Unions may have exactly 1 value, but found {len(d)}")

        return AttributeValueNS(d["NS"])

    def __repr__(self) -> str:
        return f"AttributeValueNS(value=repr(self.value))"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, AttributeValueNS):
            return False
        return self.value == other.value

class AttributeValueBS():
    """<p>An attribute of type Binary Set. For example:</p>
            <p>

    <code>"BS": ["U3Vubnk=", "UmFpbnk=", "U25vd3k="]</code>
             </p>
    """
    def __init__(self, value: list[bytes | bytearray]):
        self.value = value

    def as_dict(self) -> Dict[str, Any]:
        return {"BS": self.value}

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "AttributeValueBS":
        if (len(d) != 1):
            raise TypeError(f"Unions may have exactly 1 value, but found {len(d)}")

        return AttributeValueBS(d["BS"])

    def __repr__(self) -> str:
        return f"AttributeValueBS(value=repr(self.value))"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, AttributeValueBS):
            return False
        return self.value == other.value

class AttributeValueM():
    """<p>An attribute of type Map. For example:</p>
            <p>
                <code>"M":
    {"Name": {"S": "Joe"}, "Age": {"N": "35"}}</code>
             </p>
    """
    def __init__(self, value: dict[str, AttributeValue]):
        self.value = value

    def as_dict(self) -> Dict[str, Any]:
        return {"M": _map_attribute_value_as_dict(self.value)}

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "AttributeValueM":
        if (len(d) != 1):
            raise TypeError(f"Unions may have exactly 1 value, but found {len(d)}")

        return AttributeValueM(_map_attribute_value_from_dict(d["M"]))

    def __repr__(self) -> str:
        return f"AttributeValueM(value=repr(self.value))"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, AttributeValueM):
            return False
        return self.value == other.value

class AttributeValueL():
    """<p>An attribute of type List. For example:</p>
            <p>

    <code>"L": [ {"S": "Cookies"} , {"S": "Coffee"}, {"N": "3.14159"}]</code>

    </p>
    """
    def __init__(self, value: list[AttributeValue]):
        self.value = value

    def as_dict(self) -> Dict[str, Any]:
        return {"L": _list_attribute_value_as_dict(self.value)}

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "AttributeValueL":
        if (len(d) != 1):
            raise TypeError(f"Unions may have exactly 1 value, but found {len(d)}")

        return AttributeValueL(_list_attribute_value_from_dict(d["L"]))

    def __repr__(self) -> str:
        return f"AttributeValueL(value=repr(self.value))"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, AttributeValueL):
            return False
        return self.value == other.value

class AttributeValueNULL():
    """<p>An attribute of type Null. For example:</p>
            <p>

    <code>"NULL": true</code>
             </p>
    """
    def __init__(self, value: bool):
        self.value = value

    def as_dict(self) -> Dict[str, Any]:
        return {"NULL": self.value}

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "AttributeValueNULL":
        if (len(d) != 1):
            raise TypeError(f"Unions may have exactly 1 value, but found {len(d)}")

        return AttributeValueNULL(d["NULL"])

    def __repr__(self) -> str:
        return f"AttributeValueNULL(value=repr(self.value))"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, AttributeValueNULL):
            return False
        return self.value == other.value

class AttributeValueBOOL():
    """<p>An attribute of type Boolean. For example:</p>
            <p>

    <code>"BOOL": true</code>
             </p>
    """
    def __init__(self, value: bool):
        self.value = value

    def as_dict(self) -> Dict[str, Any]:
        return {"BOOL": self.value}

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "AttributeValueBOOL":
        if (len(d) != 1):
            raise TypeError(f"Unions may have exactly 1 value, but found {len(d)}")

        return AttributeValueBOOL(d["BOOL"])

    def __repr__(self) -> str:
        return f"AttributeValueBOOL(value=repr(self.value))"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, AttributeValueBOOL):
            return False
        return self.value == other.value

class AttributeValueUnknown():
    """Represents an unknown variant.

    If you receive this value, you will need to update your library to receive the
    parsed value.

    This value may not be deliberately sent.
    """

    def __init__(self, tag: str):
        self.tag = tag

    def as_dict(self) -> Dict[str, Any]:
        return {"SDK_UNKNOWN_MEMBER": {"name": self.tag}}

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "AttributeValueUnknown":
        if (len(d) != 1):
            raise TypeError(f"Unions may have exactly 1 value, but found {len(d)}")
        return AttributeValueUnknown(d["SDK_UNKNOWN_MEMBER"]["name"])

    def __repr__(self) -> str:
        return f"AttributeValueUnknown(tag={self.tag})"

# <p>Represents the data for an attribute.</p>         <p>Each attribute value is
# described as a name-value pair. The name is the data type, and             the
# value is the data itself.</p>         <p>For more information, see <a
# href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/HowItWorks.NamingRulesDataTypes.html#HowItWorks.DataTypes">Data
# Types</a> in the <i>Amazon DynamoDB Developer             Guide</i>.</p>
AttributeValue = Union[AttributeValueS, AttributeValueN, AttributeValueB, AttributeValueSS, AttributeValueNS, AttributeValueBS, AttributeValueM, AttributeValueL, AttributeValueNULL, AttributeValueBOOL, AttributeValueUnknown]
def _attribute_value_from_dict(d: Dict[str, Any]) -> AttributeValue:
    if "S" in d:
        return AttributeValueS.from_dict(d)

    if "N" in d:
        return AttributeValueN.from_dict(d)

    if "B" in d:
        return AttributeValueB.from_dict(d)

    if "SS" in d:
        return AttributeValueSS.from_dict(d)

    if "NS" in d:
        return AttributeValueNS.from_dict(d)

    if "BS" in d:
        return AttributeValueBS.from_dict(d)

    if "M" in d:
        return AttributeValueM.from_dict(d)

    if "L" in d:
        return AttributeValueL.from_dict(d)

    if "NULL" in d:
        return AttributeValueNULL.from_dict(d)

    if "BOOL" in d:
        return AttributeValueBOOL.from_dict(d)

    raise TypeError(f'Unions may have exactly 1 value, but found {len(d)}')

class AttributeValueUpdate:
    value: Optional['AttributeValue']
    action: Optional[str]
    def __init__(
        self,
        *,
        value: Optional['AttributeValue'] = None,
        action: Optional[str] = None,
    ):
        """<p>For the <code>UpdateItem</code> operation, represents the attributes to be
        modified,
                    the action to perform on each, and the new value for
        each.</p>
                <note>
                    <p>You cannot use <code>UpdateItem</code>
        to update any primary key attributes.
                        Instead, you will need to
        delete the item, and then use <code>PutItem</code> to
                        create a
        new item with new attributes.</p>
                </note>
                <p>Attribute values
        cannot be null; string and binary type attributes must have lengths

        greater than zero; and set type attributes must not be empty. Requests with
        empty values
                    will be rejected with a
        <code>ValidationException</code> exception.</p>

        :param value: <p>Represents the data for an attribute.</p>
                <p>Each
        attribute value is described as a name-value pair. The name is the data type,
        and
                    the value is the data itself.</p>
                <p>For more
        information, see <a
        href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/HowItWorks.NamingRulesDataTypes.html#HowItWorks.DataTypes">Data
        Types</a> in the <i>Amazon DynamoDB Developer Guide</i>.
                </p>
        :param action: <p>Specifies how to perform the update. Valid values are
        <code>PUT</code> (default),
                        <code>DELETE</code>, and
        <code>ADD</code>. The behavior depends on whether the
                    specified
        primary key already exists in the table.</p>

                <p>
                    <b>If an
        item with the specified <i>Key</i> is found in
                        the table:</b>

        </p>

                <ul>
                    <li>
                        <p>

        <code>PUT</code> - Adds the specified attribute to the item. If the attribute

        already exists, it is replaced by the new value. </p>
                    </li>

        <li>
                        <p>
                            <code>DELETE</code> - If no value
        is specified, the attribute and its value are
                            removed from
        the item. The data type of the specified value must match the

        existing value's data type.</p>
                        <p>If a <i>set</i> of values is
        specified, then those values are
                            subtracted from the old
        set. For example, if the attribute value was the set

        <code>[a,b,c]</code> and the <code>DELETE</code> action specified

        <code>[a,c]</code>, then the final attribute value would be

        <code>[b]</code>. Specifying an empty set is an error.</p>
                    </li>

        <li>
                        <p>
                            <code>ADD</code> - If the attribute
        does not already exist, then the attribute
                            and its values
        are added to the item. If the attribute does exist, then the

        behavior of <code>ADD</code> depends on the data type of the attribute:</p>

        <ul>
                          <li>
                                <p>If the existing attribute
        is a number, and if <code>Value</code> is
                                    also a
        number, then the <code>Value</code> is mathematically added to

        the existing attribute. If <code>Value</code> is a negative number, then

        it is subtracted from the existing attribute.</p>

        <note>
                                    <p> If you use <code>ADD</code> to increment
        or decrement a number
                                        value for an item that
        doesn't exist before the update, DynamoDB
                                        uses 0
        as the initial value.</p>
                                    <p>In addition, if you use
        <code>ADD</code> to update an existing
                                        item, and
        intend to increment or decrement an attribute value which

        does not yet exist, DynamoDB uses <code>0</code> as the initial

        value. For example, suppose that the item you want to update does

        not yet have an attribute named <i>itemcount</i>, but

        you decide to <code>ADD</code> the number <code>3</code> to this

        attribute anyway, even though it currently does not exist. DynamoDB

        will create the <i>itemcount</i> attribute, set its

        initial value to <code>0</code>, and finally add <code>3</code> to

        it. The result will be a new <i>itemcount</i>

        attribute in the item, with a value of <code>3</code>.</p>

        </note>
                            </li>
                          <li>

        <p>If the existing data type is a set, and if the <code>Value</code> is

        also a set, then the <code>Value</code> is added to the existing set.

        (This is a <i>set</i> operation, not mathematical

        addition.) For example, if the attribute value was the set

        <code>[1,2]</code>, and the <code>ADD</code> action specified

        <code>[3]</code>, then the final attribute value would be

        <code>[1,2,3]</code>. An error occurs if an Add action is specified

        for a set attribute and the attribute type specified does not match the

        existing set type. </p>
                                <p>Both sets must have the same
        primitive data type. For example, if the
                                    existing
        data type is a set of strings, the <code>Value</code> must also

        be a set of strings. The same holds true for number sets and binary

        sets.</p>
                            </li>
                       </ul>
                        <p>This
        action is only valid for an existing attribute whose data type is number

        or is a set. Do not use <code>ADD</code> for any other data types.</p>

        </li>
                 </ul>

                <p>
                    <b>If no item with the specified
        <i>Key</i> is
                        found:</b>
                </p>

                <ul>

        <li>
                        <p>
                            <code>PUT</code> - DynamoDB creates
        a new item with the specified primary key,
                            and then adds the
        attribute. </p>
                    </li>
                    <li>
                        <p>

        <code>DELETE</code> - Nothing happens; there is no attribute to delete.</p>

        </li>
                    <li>
                        <p>
                            <code>ADD</code>
        - DynamoDB creates a new item with the supplied primary key and

        number (or set) for the attribute value. The only data types allowed

        are number, number set, string set or binary set.</p>
                    </li>

        </ul>
        """
        self.value = value
        self.action = action

    def as_dict(self) -> Dict[str, Any]:
        """Converts the AttributeValueUpdate to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        d: Dict[str, Any] = {}

        if self.value is not None:
            d["Value"] = self.value.as_dict()

        if self.action is not None:
            d["Action"] = self.action

        return d

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "AttributeValueUpdate":
        """Creates a AttributeValueUpdate from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {}

        if "Value" in d:
            kwargs["value"] = _attribute_value_from_dict(d["Value"]),

        if "Action" in d:
            kwargs["action"] = d["Action"]

        return AttributeValueUpdate(**kwargs)

    def __repr__(self) -> str:
        result = "AttributeValueUpdate("
        if self.value is not None:
            result += f"value={repr(self.value)}, "

        if self.action is not None:
            result += f"action={repr(self.action)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, AttributeValueUpdate):
            return False
        attributes: list[str] = ['value','action',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class BatchStatementRequest:
    statement: str
    parameters: Optional['list[AttributeValue]']
    consistent_read: Optional[bool]
    def __init__(
        self,
        *,
        statement: str,
        parameters: Optional['list[AttributeValue]'] = None,
        consistent_read: Optional[bool] = None,
    ):
        """<p> A PartiQL batch statement request. </p>

        :param statement: <p> A valid PartiQL statement. </p>
        :param parameters: <p> The parameters associated with a PartiQL statement in the
        batch request. </p>
        :param consistent_read: <p> The read consistency of the PartiQL batch request.
        </p>
        """
        self.statement = statement
        self.parameters = parameters
        self.consistent_read = consistent_read

    def as_dict(self) -> Dict[str, Any]:
        """Converts the BatchStatementRequest to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        d: Dict[str, Any] = {
            "Statement": self.statement,
        }

        if self.parameters is not None:
            d["Parameters"] = _prepared_statement_parameters_as_dict(self.parameters),

        if self.consistent_read is not None:
            d["ConsistentRead"] = self.consistent_read

        return d

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "BatchStatementRequest":
        """Creates a BatchStatementRequest from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {
            "statement": d["Statement"],
        }

        if "Parameters" in d:
            kwargs["parameters"] = _prepared_statement_parameters_from_dict(d["Parameters"]),

        if "ConsistentRead" in d:
            kwargs["consistent_read"] = d["ConsistentRead"]

        return BatchStatementRequest(**kwargs)

    def __repr__(self) -> str:
        result = "BatchStatementRequest("
        if self.statement is not None:
            result += f"statement={repr(self.statement)}, "

        if self.parameters is not None:
            result += f"parameters={repr(self.parameters)}, "

        if self.consistent_read is not None:
            result += f"consistent_read={repr(self.consistent_read)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, BatchStatementRequest):
            return False
        attributes: list[str] = ['statement','parameters','consistent_read',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class BatchStatementResponse:
    error: Optional[BatchStatementError]
    table_name: Optional[str]
    item: Optional['dict[str, AttributeValue]']
    def __init__(
        self,
        *,
        error: Optional[BatchStatementError] = None,
        table_name: Optional[str] = None,
        item: Optional['dict[str, AttributeValue]'] = None,
    ):
        """<p> A PartiQL batch statement response.. </p>

        :param error: <p> The error associated with a failed PartiQL batch statement.
        </p>
        :param table_name: <p> The table name associated with a failed PartiQL batch
        statement. </p>
        :param item: <p> A DynamoDB item associated with a BatchStatementResponse </p>
        """
        self.error = error
        self.table_name = table_name
        self.item = item

    def as_dict(self) -> Dict[str, Any]:
        """Converts the BatchStatementResponse to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        d: Dict[str, Any] = {}

        if self.error is not None:
            d["Error"] = self.error.as_dict()

        if self.table_name is not None:
            d["TableName"] = self.table_name

        if self.item is not None:
            d["Item"] = _attribute_map_as_dict(self.item),

        return d

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "BatchStatementResponse":
        """Creates a BatchStatementResponse from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {}

        if "Error" in d:
            kwargs["error"] = BatchStatementError.from_dict(d["Error"])

        if "TableName" in d:
            kwargs["table_name"] = d["TableName"]

        if "Item" in d:
            kwargs["item"] = _attribute_map_from_dict(d["Item"]),

        return BatchStatementResponse(**kwargs)

    def __repr__(self) -> str:
        result = "BatchStatementResponse("
        if self.error is not None:
            result += f"error={repr(self.error)}, "

        if self.table_name is not None:
            result += f"table_name={repr(self.table_name)}, "

        if self.item is not None:
            result += f"item={repr(self.item)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, BatchStatementResponse):
            return False
        attributes: list[str] = ['error','table_name','item',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class CancellationReason:
    item: Optional['dict[str, AttributeValue]']
    code: Optional[str]
    message: Optional[str]
    def __init__(
        self,
        *,
        item: Optional['dict[str, AttributeValue]'] = None,
        code: Optional[str] = None,
        message: Optional[str] = None,
    ):
        """<p>An ordered list of errors for each item in the request which caused the
        transaction to
                    get cancelled. The values of the list are ordered
        according to the ordering of the
                        <code>TransactWriteItems</code>
        request parameter. If no error occurred for the
                    associated item an
        error with a Null code and Null message will be present. </p>

        :param item: <p>Item in the request which caused the transaction to get
        cancelled.</p>
        :param code: <p>Status code for the result of the cancelled transaction.</p>
        :param message: <p>Cancellation reason message description.</p>
        """
        self.item = item
        self.code = code
        self.message = message

    def as_dict(self) -> Dict[str, Any]:
        """Converts the CancellationReason to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        d: Dict[str, Any] = {}

        if self.item is not None:
            d["Item"] = _attribute_map_as_dict(self.item),

        if self.code is not None:
            d["Code"] = self.code

        if self.message is not None:
            d["Message"] = self.message

        return d

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "CancellationReason":
        """Creates a CancellationReason from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {}

        if "Item" in d:
            kwargs["item"] = _attribute_map_from_dict(d["Item"]),

        if "Code" in d:
            kwargs["code"] = d["Code"]

        if "Message" in d:
            kwargs["message"] = d["Message"]

        return CancellationReason(**kwargs)

    def __repr__(self) -> str:
        result = "CancellationReason("
        if self.item is not None:
            result += f"item={repr(self.item)}, "

        if self.code is not None:
            result += f"code={repr(self.code)}, "

        if self.message is not None:
            result += f"message={repr(self.message)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, CancellationReason):
            return False
        attributes: list[str] = ['item','code','message',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class Condition:
    attribute_value_list: Optional['list[AttributeValue]']
    comparison_operator: str
    def __init__(
        self,
        *,
        comparison_operator: str,
        attribute_value_list: Optional['list[AttributeValue]'] = None,
    ):
        """<p>Represents the selection criteria for a <code>Query</code> or
        <code>Scan</code>
                    operation:</p>
                <ul>
                    <li>

        <p>For a <code>Query</code> operation, <code>Condition</code> is used for

        specifying the <code>KeyConditions</code> to use when querying a table or an

        index. For <code>KeyConditions</code>, only the following comparison operators

        are supported:</p>
                        <p>
                            <code>EQ | LE | LT |
        GE | GT | BEGINS_WITH | BETWEEN</code>
                        </p>
                        <p>

        <code>Condition</code> is also used in a <code>QueryFilter</code>, which

        evaluates the query results and returns only the desired values.</p>

        </li>
                    <li>
                        <p>For a <code>Scan</code> operation,
        <code>Condition</code> is used in a

        <code>ScanFilter</code>, which evaluates the scan results and returns only

        the desired values.</p>
                    </li>
                 </ul>

        :param comparison_operator: <p>A comparator for evaluating attributes. For
        example, equals, greater than, less than,
                    etc.</p>
                <p>The
        following comparison operators are available:</p>
                <p>

        <code>EQ | NE | LE | LT | GE | GT | NOT_NULL | NULL | CONTAINS | NOT_CONTAINS |

        BEGINS_WITH | IN | BETWEEN</code>
                </p>
                <p>The following are
        descriptions of each comparison operator.</p>
                <ul>
                    <li>

        <p>
                            <code>EQ</code> : Equal. <code>EQ</code> is supported
        for all data types,
                            including lists and maps.</p>

        <p>
                            <code>AttributeValueList</code> can contain only one
        <code>AttributeValue</code>
                            element of type String, Number,
        Binary, String Set, Number Set, or Binary Set.
                            If an item
        contains an <code>AttributeValue</code> element of a different type

        than the one provided in the request, the value does not match. For example,

        <code>{"S":"6"}</code> does not equal <code>{"N":"6"}</code>. Also,

        <code>{"N":"6"}</code> does not equal <code>{"NS":["6", "2",

        "1"]}</code>.</p>
                        <p></p>
                    </li>
                    <li>

        <p>
                            <code>NE</code> : Not equal. <code>NE</code> is
        supported for all data types,
                            including lists and maps.</p>

        <p>
                            <code>AttributeValueList</code> can contain only one
        <code>AttributeValue</code>
                            of type String, Number, Binary,
        String Set, Number Set, or Binary Set. If an
                            item contains
        an <code>AttributeValue</code> of a different type than the one

        provided in the request, the value does not match. For example,

        <code>{"S":"6"}</code> does not equal <code>{"N":"6"}</code>. Also,

        <code>{"N":"6"}</code> does not equal <code>{"NS":["6", "2",

        "1"]}</code>.</p>
                        <p></p>
                    </li>
                    <li>

        <p>
                            <code>LE</code> : Less than or equal. </p>

        <p>
                            <code>AttributeValueList</code> can contain only one
        <code>AttributeValue</code>
                            element of type String, Number,
        or Binary (not a set type). If an item contains
                            an
        <code>AttributeValue</code> element of a different type than the one provided

        in the request, the value does not match. For example, <code>{"S":"6"}</code>

        does not equal <code>{"N":"6"}</code>. Also, <code>{"N":"6"}</code> does not

        compare to <code>{"NS":["6", "2", "1"]}</code>.</p>
                        <p></p>

        </li>
                    <li>
                        <p>
                            <code>LT</code> :
        Less than. </p>
                        <p>

        <code>AttributeValueList</code> can contain only one
        <code>AttributeValue</code>
                            of type String, Number, or
        Binary (not a set type). If an item contains an

        <code>AttributeValue</code> element of a different type than the one

        provided in the request, the value does not match. For example,

        <code>{"S":"6"}</code> does not equal <code>{"N":"6"}</code>. Also,

        <code>{"N":"6"}</code> does not compare to <code>{"NS":["6", "2",

        "1"]}</code>.</p>
                        <p></p>
                    </li>
                    <li>

        <p>
                            <code>GE</code> : Greater than or equal. </p>

        <p>
                            <code>AttributeValueList</code> can contain only one
        <code>AttributeValue</code>
                            element of type String, Number,
        or Binary (not a set type). If an item contains
                            an
        <code>AttributeValue</code> element of a different type than the one provided

        in the request, the value does not match. For example, <code>{"S":"6"}</code>

        does not equal <code>{"N":"6"}</code>. Also, <code>{"N":"6"}</code> does not

        compare to <code>{"NS":["6", "2", "1"]}</code>.</p>
                        <p></p>

        </li>
                    <li>
                        <p>
                            <code>GT</code> :
        Greater than. </p>
                        <p>

        <code>AttributeValueList</code> can contain only one
        <code>AttributeValue</code>
                            element of type String, Number,
        or Binary (not a set type). If an item contains
                            an
        <code>AttributeValue</code> element of a different type than the one provided

        in the request, the value does not match. For example, <code>{"S":"6"}</code>

        does not equal <code>{"N":"6"}</code>. Also, <code>{"N":"6"}</code> does not

        compare to <code>{"NS":["6", "2", "1"]}</code>.</p>
                        <p></p>

        </li>
                    <li>
                        <p>

        <code>NOT_NULL</code> : The attribute exists. <code>NOT_NULL</code> is
        supported
                            for all data types, including lists and maps.</p>

        <note>
                            <p>This operator tests for the existence of an
        attribute, not its data type.
                                If the data type of
        attribute "<code>a</code>" is null, and you evaluate it

        using <code>NOT_NULL</code>, the result is a Boolean <code>true</code>. This

        result is because the attribute "<code>a</code>" exists; its data type is

        not relevant to the <code>NOT_NULL</code> comparison operator.</p>

        </note>
                    </li>
                    <li>
                        <p>

        <code>NULL</code> : The attribute does not exist. <code>NULL</code> is
        supported
                            for all data types, including lists and maps.</p>

        <note>
                            <p>This operator tests for the nonexistence of an
        attribute, not its data
                                type. If the data type of
        attribute "<code>a</code>" is null, and you
                                evaluate it
        using <code>NULL</code>, the result is a Boolean

        <code>false</code>. This is because the attribute "<code>a</code>"

        exists; its data type is not relevant to the <code>NULL</code> comparison

        operator.</p>
                        </note>
                    </li>
                    <li>

        <p>
                            <code>CONTAINS</code> : Checks for a subsequence, or
        value in a set.</p>
                        <p>

        <code>AttributeValueList</code> can contain only one
        <code>AttributeValue</code>
                            element of type String, Number,
        or Binary (not a set type). If the target
                            attribute of the
        comparison is of type String, then the operator checks for a

        substring match. If the target attribute of the comparison is of type Binary,

        then the operator looks for a subsequence of the target that matches the input.

        If the target attribute of the comparison is a set ("<code>SS</code>",

        "<code>NS</code>", or "<code>BS</code>"), then the operator evaluates to

        true if it finds an exact match with any member of the set.</p>

        <p>CONTAINS is supported for lists: When evaluating "<code>a CONTAINS
        b</code>",
                                "<code>a</code>" can be a list; however,
        "<code>b</code>" cannot be a set, a
                            map, or a list.</p>

        </li>
                    <li>
                        <p>

        <code>NOT_CONTAINS</code> : Checks for absence of a subsequence, or absence of
        a
                            value in a set.</p>
                        <p>

        <code>AttributeValueList</code> can contain only one
        <code>AttributeValue</code>
                            element of type String, Number,
        or Binary (not a set type). If the target
                            attribute of the
        comparison is a String, then the operator checks for the

        absence of a substring match. If the target attribute of the comparison is

        Binary, then the operator checks for the absence of a subsequence of the target

        that matches the input. If the target attribute of the comparison is a set

        ("<code>SS</code>", "<code>NS</code>", or "<code>BS</code>"), then the

        operator evaluates to true if it <i>does not</i> find an exact

        match with any member of the set.</p>
                        <p>NOT_CONTAINS is
        supported for lists: When evaluating "<code>a NOT CONTAINS

        b</code>", "<code>a</code>" can be a list; however, "<code>b</code>" cannot

        be a set, a map, or a list.</p>
                    </li>
                    <li>

        <p>
                            <code>BEGINS_WITH</code> : Checks for a prefix. </p>

        <p>
                            <code>AttributeValueList</code> can contain only one
        <code>AttributeValue</code>
                            of type String or Binary (not a
        Number or a set type). The target attribute of
                            the
        comparison must be of type String or Binary (not a Number or a set

        type).</p>
                        <p></p>
                    </li>
                    <li>

        <p>
                            <code>IN</code> : Checks for matching elements in a
        list.</p>
                        <p>

        <code>AttributeValueList</code> can contain one or more

        <code>AttributeValue</code> elements of type String, Number, or Binary.

        These attributes are compared against an existing attribute of an item. If any

        elements of the input are equal to the item attribute, the expression evaluates

        to true.</p>
                    </li>
                    <li>
                        <p>

        <code>BETWEEN</code> : Greater than or equal to the first value, and less than

        or equal to the second value. </p>
                        <p>

        <code>AttributeValueList</code> must contain two <code>AttributeValue</code>

        elements of the same type, either String, Number, or Binary (not a set type). A

        target attribute matches if the target value is greater than, or equal to, the

        first element and less than, or equal to, the second element. If an item

        contains an <code>AttributeValue</code> element of a different type than the
        one
                            provided in the request, the value does not match. For
        example,
                                <code>{"S":"6"}</code> does not compare to
        <code>{"N":"6"}</code>. Also,
                                <code>{"N":"6"}</code>
        does not compare to <code>{"NS":["6", "2",
                                "1"]}</code>

        </p>
                    </li>
                 </ul>
                <p>For usage examples of
        <code>AttributeValueList</code> and

        <code>ComparisonOperator</code>, see <a
        href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/LegacyConditionalParameters.html">Legacy

        Conditional Parameters</a> in the <i>Amazon DynamoDB Developer

        Guide</i>.</p>
        :param attribute_value_list: <p>One or more values to evaluate against the
        supplied attribute. The number of values in
                    the list depends on the
        <code>ComparisonOperator</code> being used.</p>
                <p>For type Number,
        value comparisons are numeric.</p>
                <p>String value comparisons for
        greater than, equals, or less than are based on ASCII
                    character code
        values. For example, <code>a</code> is greater than <code>A</code>, and

        <code>a</code> is greater than <code>B</code>. For a list of code values, see <a
        href="http://en.wikipedia.org/wiki/ASCII#ASCII_printable_characters">http://en.wikipedia.org/wiki/ASCII#ASCII_printable_characters</a>.</p>

        <p>For Binary, DynamoDB treats each byte of the binary data as unsigned when it

        compares binary values.</p>
        """
        self.comparison_operator = comparison_operator
        self.attribute_value_list = attribute_value_list

    def as_dict(self) -> Dict[str, Any]:
        """Converts the Condition to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        d: Dict[str, Any] = {
            "ComparisonOperator": self.comparison_operator,
        }

        if self.attribute_value_list is not None:
            d["AttributeValueList"] = _attribute_value_list_as_dict(self.attribute_value_list),

        return d

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "Condition":
        """Creates a Condition from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {
            "comparison_operator": d["ComparisonOperator"],
        }

        if "AttributeValueList" in d:
            kwargs["attribute_value_list"] = _attribute_value_list_from_dict(d["AttributeValueList"]),

        return Condition(**kwargs)

    def __repr__(self) -> str:
        result = "Condition("
        if self.attribute_value_list is not None:
            result += f"attribute_value_list={repr(self.attribute_value_list)}, "

        if self.comparison_operator is not None:
            result += f"comparison_operator={repr(self.comparison_operator)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, Condition):
            return False
        attributes: list[str] = ['attribute_value_list','comparison_operator',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class DeleteRequest:
    key: 'dict[str, AttributeValue]'
    def __init__(
        self,
        *,
        key: 'dict[str, AttributeValue]',
    ):
        """<p>Represents a request to perform a <code>DeleteItem</code> operation on an
        item.</p>

        :param key: <p>A map of attribute name to attribute values, representing the
        primary key of the item
                    to delete. All of the table's primary key
        attributes must be specified, and their data
                    types must match those
        of the table's key schema.</p>
        """
        self.key = key

    def as_dict(self) -> Dict[str, Any]:
        """Converts the DeleteRequest to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        return {
            "Key": _key_as_dict(self.key),
        }

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "DeleteRequest":
        """Creates a DeleteRequest from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {
            "key": _key_from_dict(d["Key"]),
        }

        return DeleteRequest(**kwargs)

    def __repr__(self) -> str:
        result = "DeleteRequest("
        if self.key is not None:
            result += f"key={repr(self.key)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, DeleteRequest):
            return False
        attributes: list[str] = ['key',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class ExecuteStatementInput:
    statement: str
    parameters: Optional['list[AttributeValue]']
    consistent_read: Optional[bool]
    next_token: Optional[str]
    return_consumed_capacity: Optional[str]
    limit: Optional[int]
    def __init__(
        self,
        *,
        statement: str,
        parameters: Optional['list[AttributeValue]'] = None,
        consistent_read: Optional[bool] = None,
        next_token: Optional[str] = None,
        return_consumed_capacity: Optional[str] = None,
        limit: Optional[int] = None,
    ):
        """
        :param statement: <p>The PartiQL statement representing the operation to
        run.</p>
        :param parameters: <p>The parameters for the PartiQL statement, if any.</p>
        :param consistent_read: <p>The consistency of a read operation. If set to
        <code>true</code>, then a strongly
                    consistent read is used;
        otherwise, an eventually consistent read is used.</p>
        :param next_token: <p>Set this value to get remaining results, if
        <code>NextToken</code> was returned in the
                    statement response.</p>
        :param return_consumed_capacity: <p>Determines the level of detail about either
        provisioned or on-demand throughput
                    consumption that is returned in
        the response:</p>
                <ul>
                    <li>
                        <p>

        <code>INDEXES</code> - The response includes the aggregate

        <code>ConsumedCapacity</code> for the operation, together with

        <code>ConsumedCapacity</code> for each table and secondary index that was

        accessed.</p>
                        <p>Note that some operations, such as
        <code>GetItem</code> and
                                <code>BatchGetItem</code>, do
        not access any indexes at all. In these cases,
                            specifying
        <code>INDEXES</code> will only return <code>ConsumedCapacity</code>

        information for table(s).</p>
                    </li>
                    <li>

        <p>
                            <code>TOTAL</code> - The response includes only the
        aggregate
                                <code>ConsumedCapacity</code> for the
        operation.</p>
                    </li>
                    <li>
                        <p>

        <code>NONE</code> - No <code>ConsumedCapacity</code> details are included in
        the
                            response.</p>
                    </li>
                 </ul>
        :param limit: <p>The maximum number of items to evaluate (not necessarily the
        number of matching
                    items). If DynamoDB processes the number of items
        up to the limit while processing the
                    results, it stops the operation
        and returns the matching values up to that point, along
                    with a key
        in <code>LastEvaluatedKey</code> to apply in a subsequent operation so you

        can pick up where you left off. Also, if the processed dataset size exceeds 1 MB
        before
                    DynamoDB reaches this limit, it stops the operation and
        returns the matching values up
                    to the limit, and a key in
        <code>LastEvaluatedKey</code> to apply in a subsequent
                    operation to
        continue the operation. </p>
        """
        self.statement = statement
        self.parameters = parameters
        self.consistent_read = consistent_read
        self.next_token = next_token
        self.return_consumed_capacity = return_consumed_capacity
        self.limit = limit

    def as_dict(self) -> Dict[str, Any]:
        """Converts the ExecuteStatementInput to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        d: Dict[str, Any] = {
            "Statement": self.statement,
        }

        if self.parameters is not None:
            d["Parameters"] = _prepared_statement_parameters_as_dict(self.parameters),

        if self.consistent_read is not None:
            d["ConsistentRead"] = self.consistent_read

        if self.next_token is not None:
            d["NextToken"] = self.next_token

        if self.return_consumed_capacity is not None:
            d["ReturnConsumedCapacity"] = self.return_consumed_capacity

        if self.limit is not None:
            d["Limit"] = self.limit

        return d

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "ExecuteStatementInput":
        """Creates a ExecuteStatementInput from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {
            "statement": d["Statement"],
        }

        if "Parameters" in d:
            kwargs["parameters"] = _prepared_statement_parameters_from_dict(d["Parameters"]),

        if "ConsistentRead" in d:
            kwargs["consistent_read"] = d["ConsistentRead"]

        if "NextToken" in d:
            kwargs["next_token"] = d["NextToken"]

        if "ReturnConsumedCapacity" in d:
            kwargs["return_consumed_capacity"] = d["ReturnConsumedCapacity"]

        if "Limit" in d:
            kwargs["limit"] = d["Limit"]

        return ExecuteStatementInput(**kwargs)

    def __repr__(self) -> str:
        result = "ExecuteStatementInput("
        if self.statement is not None:
            result += f"statement={repr(self.statement)}, "

        if self.parameters is not None:
            result += f"parameters={repr(self.parameters)}, "

        if self.consistent_read is not None:
            result += f"consistent_read={repr(self.consistent_read)}, "

        if self.next_token is not None:
            result += f"next_token={repr(self.next_token)}, "

        if self.return_consumed_capacity is not None:
            result += f"return_consumed_capacity={repr(self.return_consumed_capacity)}, "

        if self.limit is not None:
            result += f"limit={repr(self.limit)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, ExecuteStatementInput):
            return False
        attributes: list[str] = ['statement','parameters','consistent_read','next_token','return_consumed_capacity','limit',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class Get:
    key: 'dict[str, AttributeValue]'
    table_name: str
    projection_expression: Optional[str]
    expression_attribute_names: Optional[dict[str, str]]
    def __init__(
        self,
        *,
        key: 'dict[str, AttributeValue]',
        table_name: str,
        projection_expression: Optional[str] = None,
        expression_attribute_names: Optional[dict[str, str]] = None,
    ):
        """<p>Specifies an item and related attribute values to retrieve in a

        <code>TransactGetItem</code> object.</p>

        :param key: <p>A map of attribute names to <code>AttributeValue</code> objects
        that specifies the
                    primary key of the item to retrieve.</p>
        :param table_name: <p>The name of the table from which to retrieve the specified
        item.</p>
        :param projection_expression: <p>A string that identifies one or more attributes
        of the specified item to retrieve from
                    the table. The attributes in
        the expression must be separated by commas. If no attribute
                    names
        are specified, then all attributes of the specified item are returned. If any
        of
                    the requested attributes are not found, they do not appear in the
        result.</p>
        :param expression_attribute_names: <p>One or more substitution tokens for
        attribute names in the ProjectionExpression
                    parameter.</p>
        """
        self.key = key
        self.table_name = table_name
        self.projection_expression = projection_expression
        self.expression_attribute_names = expression_attribute_names

    def as_dict(self) -> Dict[str, Any]:
        """Converts the Get to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        d: Dict[str, Any] = {
            "Key": _key_as_dict(self.key),
            "TableName": self.table_name,
        }

        if self.projection_expression is not None:
            d["ProjectionExpression"] = self.projection_expression

        if self.expression_attribute_names is not None:
            d["ExpressionAttributeNames"] = self.expression_attribute_names

        return d

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "Get":
        """Creates a Get from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {
            "key": _key_from_dict(d["Key"]),
            "table_name": d["TableName"],
        }

        if "ProjectionExpression" in d:
            kwargs["projection_expression"] = d["ProjectionExpression"]

        if "ExpressionAttributeNames" in d:
            kwargs["expression_attribute_names"] = d["ExpressionAttributeNames"]

        return Get(**kwargs)

    def __repr__(self) -> str:
        result = "Get("
        if self.key is not None:
            result += f"key={repr(self.key)}, "

        if self.table_name is not None:
            result += f"table_name={repr(self.table_name)}, "

        if self.projection_expression is not None:
            result += f"projection_expression={repr(self.projection_expression)}, "

        if self.expression_attribute_names is not None:
            result += f"expression_attribute_names={repr(self.expression_attribute_names)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, Get):
            return False
        attributes: list[str] = ['key','table_name','projection_expression','expression_attribute_names',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class GetItemInput:
    table_name: str
    key: 'dict[str, AttributeValue]'
    attributes_to_get: Optional[list[str]]
    consistent_read: Optional[bool]
    return_consumed_capacity: Optional[str]
    projection_expression: Optional[str]
    expression_attribute_names: Optional[dict[str, str]]
    def __init__(
        self,
        *,
        table_name: str,
        key: 'dict[str, AttributeValue]',
        attributes_to_get: Optional[list[str]] = None,
        consistent_read: Optional[bool] = None,
        return_consumed_capacity: Optional[str] = None,
        projection_expression: Optional[str] = None,
        expression_attribute_names: Optional[dict[str, str]] = None,
    ):
        """<p>Represents the input of a <code>GetItem</code> operation.</p>

        :param table_name: <p>The name of the table containing the requested item.</p>
        :param key: <p>A map of attribute names to <code>AttributeValue</code> objects,
        representing the
                    primary key of the item to retrieve.</p>

        <p>For the primary key, you must provide all of the attributes. For example,
        with a
                    simple primary key, you only need to provide a value for the
        partition key. For a
                    composite primary key, you must provide values
        for both the partition key and the sort
                    key.</p>
        :param attributes_to_get: <p>This is a legacy parameter. Use
        <code>ProjectionExpression</code> instead. For more
                    information, see
        <a
        href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/LegacyConditionalParameters.AttributesToGet.html">AttributesToGet</a>
        in the <i>Amazon DynamoDB Developer
                    Guide</i>.</p>
        :param consistent_read: <p>Determines the read consistency model: If set to
        <code>true</code>, then the operation
                    uses strongly consistent
        reads; otherwise, the operation uses eventually consistent

        reads.</p>
        :param return_consumed_capacity: <p>Determines the level of detail about either
        provisioned or on-demand throughput
                    consumption that is returned in
        the response:</p>
                <ul>
                    <li>
                        <p>

        <code>INDEXES</code> - The response includes the aggregate

        <code>ConsumedCapacity</code> for the operation, together with

        <code>ConsumedCapacity</code> for each table and secondary index that was

        accessed.</p>
                        <p>Note that some operations, such as
        <code>GetItem</code> and
                                <code>BatchGetItem</code>, do
        not access any indexes at all. In these cases,
                            specifying
        <code>INDEXES</code> will only return <code>ConsumedCapacity</code>

        information for table(s).</p>
                    </li>
                    <li>

        <p>
                            <code>TOTAL</code> - The response includes only the
        aggregate
                                <code>ConsumedCapacity</code> for the
        operation.</p>
                    </li>
                    <li>
                        <p>

        <code>NONE</code> - No <code>ConsumedCapacity</code> details are included in
        the
                            response.</p>
                    </li>
                 </ul>
        :param projection_expression: <p>A string that identifies one or more attributes
        to retrieve from the table. These
                    attributes can include scalars,
        sets, or elements of a JSON document. The attributes in
                    the
        expression must be separated by commas.</p>
                <p>If no attribute names are
        specified, then all attributes are returned. If any of the
                    requested
        attributes are not found, they do not appear in the result.</p>
                <p>For
        more information, see <a
        href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Expressions.AccessingItemAttributes.html">Specifying
        Item Attributes</a> in the <i>Amazon DynamoDB Developer

        Guide</i>.</p>
        :param expression_attribute_names: <p>One or more substitution tokens for
        attribute names in an expression. The following
                    are some use cases
        for using <code>ExpressionAttributeNames</code>:</p>
                <ul>

        <li>
                        <p>To access an attribute whose name conflicts with a
        DynamoDB reserved
                            word.</p>
                    </li>

        <li>
                        <p>To create a placeholder for repeating occurrences of an
        attribute name in an
                            expression.</p>
                    </li>

        <li>
                        <p>To prevent special characters in an attribute name from
        being misinterpreted
                            in an expression.</p>

        </li>
                 </ul>
                <p>Use the <b>#</b> character in an expression to
        dereference
                    an attribute name. For example, consider the following
        attribute name:</p>
                <ul>
                    <li>
                        <p>

        <code>Percentile</code>
                        </p>
                    </li>
                 </ul>

        <p>The name of this attribute conflicts with a reserved word, so it cannot be
        used
                    directly in an expression. (For the complete list of reserved
        words, see <a
        href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/ReservedWords.html">Reserved
        Words</a> in the <i>Amazon DynamoDB Developer
                    Guide</i>). To work
        around this, you could specify the following for

        <code>ExpressionAttributeNames</code>:</p>
                <ul>
                    <li>

        <p>
                            <code>{"#P":"Percentile"}</code>
                        </p>

        </li>
                 </ul>
                <p>You could then use this substitution in an
        expression, as in this example:</p>
                <ul>
                    <li>

        <p>
                            <code>#P = :val</code>
                        </p>

        </li>
                 </ul>
                <note>
                    <p>Tokens that begin with the
        <b>:</b> character are
                            <i>expression attribute values</i>,
        which are placeholders for the
                        actual value at runtime.</p>

        </note>
                <p>For more information on expression attribute names, see <a
        href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Expressions.AccessingItemAttributes.html">Specifying
        Item Attributes</a> in the <i>Amazon DynamoDB Developer

        Guide</i>.</p>
        """
        self.table_name = table_name
        self.key = key
        self.attributes_to_get = attributes_to_get
        self.consistent_read = consistent_read
        self.return_consumed_capacity = return_consumed_capacity
        self.projection_expression = projection_expression
        self.expression_attribute_names = expression_attribute_names

    def as_dict(self) -> Dict[str, Any]:
        """Converts the GetItemInput to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        d: Dict[str, Any] = {
            "TableName": self.table_name,
            "Key": _key_as_dict(self.key),
        }

        if self.attributes_to_get is not None:
            d["AttributesToGet"] = self.attributes_to_get

        if self.consistent_read is not None:
            d["ConsistentRead"] = self.consistent_read

        if self.return_consumed_capacity is not None:
            d["ReturnConsumedCapacity"] = self.return_consumed_capacity

        if self.projection_expression is not None:
            d["ProjectionExpression"] = self.projection_expression

        if self.expression_attribute_names is not None:
            d["ExpressionAttributeNames"] = self.expression_attribute_names

        return d

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "GetItemInput":
        """Creates a GetItemInput from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {
            "table_name": d["TableName"],
            "key": _key_from_dict(d["Key"]),
        }

        if "AttributesToGet" in d:
            kwargs["attributes_to_get"] = d["AttributesToGet"]

        if "ConsistentRead" in d:
            kwargs["consistent_read"] = d["ConsistentRead"]

        if "ReturnConsumedCapacity" in d:
            kwargs["return_consumed_capacity"] = d["ReturnConsumedCapacity"]

        if "ProjectionExpression" in d:
            kwargs["projection_expression"] = d["ProjectionExpression"]

        if "ExpressionAttributeNames" in d:
            kwargs["expression_attribute_names"] = d["ExpressionAttributeNames"]

        return GetItemInput(**kwargs)

    def __repr__(self) -> str:
        result = "GetItemInput("
        if self.table_name is not None:
            result += f"table_name={repr(self.table_name)}, "

        if self.key is not None:
            result += f"key={repr(self.key)}, "

        if self.attributes_to_get is not None:
            result += f"attributes_to_get={repr(self.attributes_to_get)}, "

        if self.consistent_read is not None:
            result += f"consistent_read={repr(self.consistent_read)}, "

        if self.return_consumed_capacity is not None:
            result += f"return_consumed_capacity={repr(self.return_consumed_capacity)}, "

        if self.projection_expression is not None:
            result += f"projection_expression={repr(self.projection_expression)}, "

        if self.expression_attribute_names is not None:
            result += f"expression_attribute_names={repr(self.expression_attribute_names)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, GetItemInput):
            return False
        attributes: list[str] = ['table_name','key','attributes_to_get','consistent_read','return_consumed_capacity','projection_expression','expression_attribute_names',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class GetItemOutput:
    item: Optional['dict[str, AttributeValue]']
    consumed_capacity: Optional[ConsumedCapacity]
    def __init__(
        self,
        *,
        item: Optional['dict[str, AttributeValue]'] = None,
        consumed_capacity: Optional[ConsumedCapacity] = None,
    ):
        """<p>Represents the output of a <code>GetItem</code> operation.</p>

        :param item: <p>A map of attribute names to <code>AttributeValue</code> objects,
        as specified by
                        <code>ProjectionExpression</code>.</p>
        :param consumed_capacity: <p>The capacity units consumed by the
        <code>GetItem</code> operation. The data returned
                    includes the total
        provisioned throughput consumed, along with statistics for the table

        and any indexes involved in the operation. <code>ConsumedCapacity</code> is
        only
                    returned if the <code>ReturnConsumedCapacity</code> parameter
        was specified. For more
                    information, see <a
        href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/ProvisionedThroughputIntro.html">Read/Write
        Capacity Mode</a> in the <i>Amazon DynamoDB Developer

        Guide</i>.</p>
        """
        self.item = item
        self.consumed_capacity = consumed_capacity

    def as_dict(self) -> Dict[str, Any]:
        """Converts the GetItemOutput to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        d: Dict[str, Any] = {}

        if self.item is not None:
            d["Item"] = _attribute_map_as_dict(self.item),

        if self.consumed_capacity is not None:
            d["ConsumedCapacity"] = self.consumed_capacity.as_dict()

        return d

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "GetItemOutput":
        """Creates a GetItemOutput from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {}

        if "Item" in d:
            kwargs["item"] = _attribute_map_from_dict(d["Item"]),

        if "ConsumedCapacity" in d:
            kwargs["consumed_capacity"] = ConsumedCapacity.from_dict(d["ConsumedCapacity"])

        return GetItemOutput(**kwargs)

    def __repr__(self) -> str:
        result = "GetItemOutput("
        if self.item is not None:
            result += f"item={repr(self.item)}, "

        if self.consumed_capacity is not None:
            result += f"consumed_capacity={repr(self.consumed_capacity)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, GetItemOutput):
            return False
        attributes: list[str] = ['item','consumed_capacity',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class ItemCollectionMetrics:
    item_collection_key: Optional['dict[str, AttributeValue]']
    size_estimate_range_gb: Optional[list[float]]
    def __init__(
        self,
        *,
        item_collection_key: Optional['dict[str, AttributeValue]'] = None,
        size_estimate_range_gb: Optional[list[float]] = None,
    ):
        """<p>Information about item collections, if any, that were affected by the
        operation.
                        <code>ItemCollectionMetrics</code> is only returned
        if the request asked for it. If
                    the table does not have any local
        secondary indexes, this information is not returned in
                    the
        response.</p>

        :param item_collection_key: <p>The partition key value of the item collection.
        This value is the same as the
                    partition key value of the item.</p>
        :param size_estimate_range_gb: <p>An estimate of item collection size, in
        gigabytes. This value is a two-element array
                    containing a lower
        bound and an upper bound for the estimate. The estimate includes the

        size of all the items in the table, plus the size of all attributes projected
        into all
                    of the local secondary indexes on that table. Use this
        estimate to measure whether a
                    local secondary index is approaching
        its size limit.</p>
                <p>The estimate is subject to change over time;
        therefore, do not rely on the precision
                    or accuracy of the
        estimate.</p>
        """
        self.item_collection_key = item_collection_key
        self.size_estimate_range_gb = size_estimate_range_gb

    def as_dict(self) -> Dict[str, Any]:
        """Converts the ItemCollectionMetrics to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        d: Dict[str, Any] = {}

        if self.item_collection_key is not None:
            d["ItemCollectionKey"] = _item_collection_key_attribute_map_as_dict(self.item_collection_key),

        if self.size_estimate_range_gb is not None:
            d["SizeEstimateRangeGB"] = self.size_estimate_range_gb

        return d

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "ItemCollectionMetrics":
        """Creates a ItemCollectionMetrics from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {}

        if "ItemCollectionKey" in d:
            kwargs["item_collection_key"] = _item_collection_key_attribute_map_from_dict(d["ItemCollectionKey"]),

        if "SizeEstimateRangeGB" in d:
            kwargs["size_estimate_range_gb"] = d["SizeEstimateRangeGB"]

        return ItemCollectionMetrics(**kwargs)

    def __repr__(self) -> str:
        result = "ItemCollectionMetrics("
        if self.item_collection_key is not None:
            result += f"item_collection_key={repr(self.item_collection_key)}, "

        if self.size_estimate_range_gb is not None:
            result += f"size_estimate_range_gb={repr(self.size_estimate_range_gb)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, ItemCollectionMetrics):
            return False
        attributes: list[str] = ['item_collection_key','size_estimate_range_gb',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class ItemResponse:
    item: Optional['dict[str, AttributeValue]']
    def __init__(
        self,
        *,
        item: Optional['dict[str, AttributeValue]'] = None,
    ):
        """<p>Details for the requested item.</p>

        :param item: <p>Map of attribute data consisting of the data type and attribute
        value.</p>
        """
        self.item = item

    def as_dict(self) -> Dict[str, Any]:
        """Converts the ItemResponse to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        d: Dict[str, Any] = {}

        if self.item is not None:
            d["Item"] = _attribute_map_as_dict(self.item),

        return d

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "ItemResponse":
        """Creates a ItemResponse from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {}

        if "Item" in d:
            kwargs["item"] = _attribute_map_from_dict(d["Item"]),

        return ItemResponse(**kwargs)

    def __repr__(self) -> str:
        result = "ItemResponse("
        if self.item is not None:
            result += f"item={repr(self.item)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, ItemResponse):
            return False
        attributes: list[str] = ['item',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class ParameterizedStatement:
    statement: str
    parameters: Optional['list[AttributeValue]']
    def __init__(
        self,
        *,
        statement: str,
        parameters: Optional['list[AttributeValue]'] = None,
    ):
        """<p> Represents a PartiQL statment that uses parameters. </p>

        :param statement: <p> A PartiQL statment that uses parameters. </p>
        :param parameters: <p> The parameter values. </p>
        """
        self.statement = statement
        self.parameters = parameters

    def as_dict(self) -> Dict[str, Any]:
        """Converts the ParameterizedStatement to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        d: Dict[str, Any] = {
            "Statement": self.statement,
        }

        if self.parameters is not None:
            d["Parameters"] = _prepared_statement_parameters_as_dict(self.parameters),

        return d

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "ParameterizedStatement":
        """Creates a ParameterizedStatement from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {
            "statement": d["Statement"],
        }

        if "Parameters" in d:
            kwargs["parameters"] = _prepared_statement_parameters_from_dict(d["Parameters"]),

        return ParameterizedStatement(**kwargs)

    def __repr__(self) -> str:
        result = "ParameterizedStatement("
        if self.statement is not None:
            result += f"statement={repr(self.statement)}, "

        if self.parameters is not None:
            result += f"parameters={repr(self.parameters)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, ParameterizedStatement):
            return False
        attributes: list[str] = ['statement','parameters',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class PutRequest:
    item: 'dict[str, AttributeValue]'
    def __init__(
        self,
        *,
        item: 'dict[str, AttributeValue]',
    ):
        """<p>Represents a request to perform a <code>PutItem</code> operation on an
        item.</p>

        :param item: <p>A map of attribute name to attribute values, representing the
        primary key of an item
                    to be processed by <code>PutItem</code>. All
        of the table's primary key attributes must
                    be specified, and their
        data types must match those of the table's key schema. If any

        attributes are present in the item that are part of an index key schema for the
        table,
                    their types must match the index key schema.</p>
        """
        self.item = item

    def as_dict(self) -> Dict[str, Any]:
        """Converts the PutRequest to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        return {
            "Item": _put_item_input_attribute_map_as_dict(self.item),
        }

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "PutRequest":
        """Creates a PutRequest from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {
            "item": _put_item_input_attribute_map_from_dict(d["Item"]),
        }

        return PutRequest(**kwargs)

    def __repr__(self) -> str:
        result = "PutRequest("
        if self.item is not None:
            result += f"item={repr(self.item)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, PutRequest):
            return False
        attributes: list[str] = ['item',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class KeysAndAttributes:
    keys: 'list[dict[str, AttributeValue]]'
    attributes_to_get: Optional[list[str]]
    consistent_read: Optional[bool]
    projection_expression: Optional[str]
    expression_attribute_names: Optional[dict[str, str]]
    def __init__(
        self,
        *,
        keys: 'list[dict[str, AttributeValue]]',
        attributes_to_get: Optional[list[str]] = None,
        consistent_read: Optional[bool] = None,
        projection_expression: Optional[str] = None,
        expression_attribute_names: Optional[dict[str, str]] = None,
    ):
        """<p>Represents a set of primary keys and, for each key, the attributes to
        retrieve from
                    the table.</p>
                <p>For each primary key, you
        must provide <i>all</i> of the key attributes.
                    For example, with a
        simple primary key, you only need to provide the partition key. For

        a composite primary key, you must provide <i>both</i> the partition key

        and the sort key.</p>

        :param keys: <p>The primary key attribute values that define the items and the
        attributes associated
                    with the items.</p>
        :param attributes_to_get: <p>This is a legacy parameter. Use
        <code>ProjectionExpression</code> instead. For more
                    information, see
        <a
        href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/LegacyConditionalParameters.html">Legacy

        Conditional Parameters</a> in the <i>Amazon DynamoDB Developer

        Guide</i>.</p>
        :param consistent_read: <p>The consistency of a read operation. If set to
        <code>true</code>, then a strongly
                    consistent read is used;
        otherwise, an eventually consistent read is used.</p>
        :param projection_expression: <p>A string that identifies one or more attributes
        to retrieve from the table. These
                    attributes can include scalars,
        sets, or elements of a JSON document. The attributes in
                    the
        <code>ProjectionExpression</code> must be separated by commas.</p>
                <p>If
        no attribute names are specified, then all attributes will be returned. If any
        of
                    the requested attributes are not found, they will not appear in
        the result.</p>
                <p>For more information, see <a
        href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Expressions.AccessingItemAttributes.html">Accessing
        Item Attributes</a> in the <i>Amazon DynamoDB Developer

        Guide</i>.</p>
        :param expression_attribute_names: <p>One or more substitution tokens for
        attribute names in an expression. The following
                    are some use cases
        for using <code>ExpressionAttributeNames</code>:</p>
                <ul>

        <li>
                        <p>To access an attribute whose name conflicts with a
        DynamoDB reserved
                            word.</p>
                    </li>

        <li>
                        <p>To create a placeholder for repeating occurrences of an
        attribute name in an
                            expression.</p>
                    </li>

        <li>
                        <p>To prevent special characters in an attribute name from
        being misinterpreted
                            in an expression.</p>

        </li>
                 </ul>
                <p>Use the <b>#</b> character in an expression to
        dereference
                    an attribute name. For example, consider the following
        attribute name:</p>
                <ul>
                    <li>
                        <p>

        <code>Percentile</code>
                        </p>
                    </li>
                 </ul>

        <p>The name of this attribute conflicts with a reserved word, so it cannot be
        used
                    directly in an expression. (For the complete list of reserved
        words, see <a
        href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/ReservedWords.html">Reserved
        Words</a> in the <i>Amazon DynamoDB Developer
                        Guide</i>). To
        work around this, you could specify the following for

        <code>ExpressionAttributeNames</code>:</p>
                <ul>
                    <li>

        <p>
                            <code>{"#P":"Percentile"}</code>
                        </p>

        </li>
                 </ul>
                <p>You could then use this substitution in an
        expression, as in this example:</p>
                <ul>
                    <li>

        <p>
                            <code>#P = :val</code>
                        </p>

        </li>
                 </ul>
                <note>
                    <p>Tokens that begin with the
        <b>:</b> character are
                            <i>expression attribute values</i>,
        which are placeholders for the
                        actual value at runtime.</p>

        </note>
                <p>For more information on expression attribute names, see <a
        href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Expressions.AccessingItemAttributes.html">Accessing
        Item Attributes</a> in the <i>Amazon DynamoDB Developer

        Guide</i>.</p>
        """
        self.keys = keys
        self.attributes_to_get = attributes_to_get
        self.consistent_read = consistent_read
        self.projection_expression = projection_expression
        self.expression_attribute_names = expression_attribute_names

    def as_dict(self) -> Dict[str, Any]:
        """Converts the KeysAndAttributes to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        d: Dict[str, Any] = {
            "Keys": _key_list_as_dict(self.keys),
        }

        if self.attributes_to_get is not None:
            d["AttributesToGet"] = self.attributes_to_get

        if self.consistent_read is not None:
            d["ConsistentRead"] = self.consistent_read

        if self.projection_expression is not None:
            d["ProjectionExpression"] = self.projection_expression

        if self.expression_attribute_names is not None:
            d["ExpressionAttributeNames"] = self.expression_attribute_names

        return d

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "KeysAndAttributes":
        """Creates a KeysAndAttributes from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {
            "keys": _key_list_from_dict(d["Keys"]),
        }

        if "AttributesToGet" in d:
            kwargs["attributes_to_get"] = d["AttributesToGet"]

        if "ConsistentRead" in d:
            kwargs["consistent_read"] = d["ConsistentRead"]

        if "ProjectionExpression" in d:
            kwargs["projection_expression"] = d["ProjectionExpression"]

        if "ExpressionAttributeNames" in d:
            kwargs["expression_attribute_names"] = d["ExpressionAttributeNames"]

        return KeysAndAttributes(**kwargs)

    def __repr__(self) -> str:
        result = "KeysAndAttributes("
        if self.keys is not None:
            result += f"keys={repr(self.keys)}, "

        if self.attributes_to_get is not None:
            result += f"attributes_to_get={repr(self.attributes_to_get)}, "

        if self.consistent_read is not None:
            result += f"consistent_read={repr(self.consistent_read)}, "

        if self.projection_expression is not None:
            result += f"projection_expression={repr(self.projection_expression)}, "

        if self.expression_attribute_names is not None:
            result += f"expression_attribute_names={repr(self.expression_attribute_names)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, KeysAndAttributes):
            return False
        attributes: list[str] = ['keys','attributes_to_get','consistent_read','projection_expression','expression_attribute_names',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class TransactGetItem:
    get: 'Get'
    def __init__(
        self,
        *,
        get: 'Get',
    ):
        """<p>Specifies an item to be retrieved as part of the transaction.</p>

        :param get: <p>Contains the primary key that identifies the item to get,
        together with the name of
                    the table that contains the item, and
        optionally the specific attributes of the item to
                    retrieve.</p>
        """
        self.get = get

    def as_dict(self) -> Dict[str, Any]:
        """Converts the TransactGetItem to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        return {
            "Get": self.get.as_dict(),
        }

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "TransactGetItem":
        """Creates a TransactGetItem from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {
            "get": Get.from_dict(d["Get"]),
        }

        return TransactGetItem(**kwargs)

    def __repr__(self) -> str:
        result = "TransactGetItem("
        if self.get is not None:
            result += f"get={repr(self.get)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, TransactGetItem):
            return False
        attributes: list[str] = ['get',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class BatchExecuteStatementInput:
    statements: 'list[BatchStatementRequest]'
    return_consumed_capacity: Optional[str]
    def __init__(
        self,
        *,
        statements: 'list[BatchStatementRequest]',
        return_consumed_capacity: Optional[str] = None,
    ):
        """
        :param statements: <p>The list of PartiQL statements representing the batch to
        run.</p>
        :param return_consumed_capacity: <p>Determines the level of detail about either
        provisioned or on-demand throughput
                    consumption that is returned in
        the response:</p>
                <ul>
                    <li>
                        <p>

        <code>INDEXES</code> - The response includes the aggregate

        <code>ConsumedCapacity</code> for the operation, together with

        <code>ConsumedCapacity</code> for each table and secondary index that was

        accessed.</p>
                        <p>Note that some operations, such as
        <code>GetItem</code> and
                                <code>BatchGetItem</code>, do
        not access any indexes at all. In these cases,
                            specifying
        <code>INDEXES</code> will only return <code>ConsumedCapacity</code>

        information for table(s).</p>
                    </li>
                    <li>

        <p>
                            <code>TOTAL</code> - The response includes only the
        aggregate
                                <code>ConsumedCapacity</code> for the
        operation.</p>
                    </li>
                    <li>
                        <p>

        <code>NONE</code> - No <code>ConsumedCapacity</code> details are included in
        the
                            response.</p>
                    </li>
                 </ul>
        """
        self.statements = statements
        self.return_consumed_capacity = return_consumed_capacity

    def as_dict(self) -> Dict[str, Any]:
        """Converts the BatchExecuteStatementInput to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        d: Dict[str, Any] = {
            "Statements": _parti_ql_batch_request_as_dict(self.statements),
        }

        if self.return_consumed_capacity is not None:
            d["ReturnConsumedCapacity"] = self.return_consumed_capacity

        return d

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "BatchExecuteStatementInput":
        """Creates a BatchExecuteStatementInput from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {
            "statements": _parti_ql_batch_request_from_dict(d["Statements"]),
        }

        if "ReturnConsumedCapacity" in d:
            kwargs["return_consumed_capacity"] = d["ReturnConsumedCapacity"]

        return BatchExecuteStatementInput(**kwargs)

    def __repr__(self) -> str:
        result = "BatchExecuteStatementInput("
        if self.statements is not None:
            result += f"statements={repr(self.statements)}, "

        if self.return_consumed_capacity is not None:
            result += f"return_consumed_capacity={repr(self.return_consumed_capacity)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, BatchExecuteStatementInput):
            return False
        attributes: list[str] = ['statements','return_consumed_capacity',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class BatchExecuteStatementOutput:
    responses: Optional['list[BatchStatementResponse]']
    consumed_capacity: Optional[list[ConsumedCapacity]]
    def __init__(
        self,
        *,
        responses: Optional['list[BatchStatementResponse]'] = None,
        consumed_capacity: Optional[list[ConsumedCapacity]] = None,
    ):
        """
        :param responses: <p>The response to each PartiQL statement in the batch.</p>
        :param consumed_capacity: <p>The capacity units consumed by the entire
        operation. The values of the list are
                    ordered according to the
        ordering of the statements.</p>
        """
        self.responses = responses
        self.consumed_capacity = consumed_capacity

    def as_dict(self) -> Dict[str, Any]:
        """Converts the BatchExecuteStatementOutput to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        d: Dict[str, Any] = {}

        if self.responses is not None:
            d["Responses"] = _parti_ql_batch_response_as_dict(self.responses),

        if self.consumed_capacity is not None:
            d["ConsumedCapacity"] = _consumed_capacity_multiple_as_dict(self.consumed_capacity),

        return d

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "BatchExecuteStatementOutput":
        """Creates a BatchExecuteStatementOutput from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {}

        if "Responses" in d:
            kwargs["responses"] = _parti_ql_batch_response_from_dict(d["Responses"]),

        if "ConsumedCapacity" in d:
            kwargs["consumed_capacity"] = _consumed_capacity_multiple_from_dict(d["ConsumedCapacity"]),

        return BatchExecuteStatementOutput(**kwargs)

    def __repr__(self) -> str:
        result = "BatchExecuteStatementOutput("
        if self.responses is not None:
            result += f"responses={repr(self.responses)}, "

        if self.consumed_capacity is not None:
            result += f"consumed_capacity={repr(self.consumed_capacity)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, BatchExecuteStatementOutput):
            return False
        attributes: list[str] = ['responses','consumed_capacity',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class ExecuteTransactionInput:
    transact_statements: 'list[ParameterizedStatement]'
    client_request_token: Optional[str]
    return_consumed_capacity: Optional[str]
    def __init__(
        self,
        *,
        transact_statements: 'list[ParameterizedStatement]',
        client_request_token: Optional[str] = None,
        return_consumed_capacity: Optional[str] = None,
    ):
        """
        :param transact_statements: <p>The list of PartiQL statements representing the
        transaction to run.</p>
        :param client_request_token: <p>Set this value to get remaining results, if
        <code>NextToken</code> was returned in the
                    statement response.</p>
        :param return_consumed_capacity: <p>Determines the level of detail about either
        provisioned or on-demand throughput
                    consumption that is returned in
        the response. For more information, see <a
        href="https://docs.aws.amazon.com/amazondynamodb/latest/APIReference/API_TransactGetItems.html">TransactGetItems</a>
        and <a
        href="https://docs.aws.amazon.com/amazondynamodb/latest/APIReference/API_TransactWriteItems.html">TransactWriteItems</a>.</p>
        """
        self.transact_statements = transact_statements
        self.client_request_token = client_request_token
        self.return_consumed_capacity = return_consumed_capacity

    def as_dict(self) -> Dict[str, Any]:
        """Converts the ExecuteTransactionInput to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        d: Dict[str, Any] = {
            "TransactStatements": _parameterized_statements_as_dict(self.transact_statements),
        }

        if self.client_request_token is not None:
            d["ClientRequestToken"] = self.client_request_token

        if self.return_consumed_capacity is not None:
            d["ReturnConsumedCapacity"] = self.return_consumed_capacity

        return d

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "ExecuteTransactionInput":
        """Creates a ExecuteTransactionInput from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {
            "transact_statements": _parameterized_statements_from_dict(d["TransactStatements"]),
        }

        if "ClientRequestToken" in d:
            kwargs["client_request_token"] = d["ClientRequestToken"]

        if "ReturnConsumedCapacity" in d:
            kwargs["return_consumed_capacity"] = d["ReturnConsumedCapacity"]

        return ExecuteTransactionInput(**kwargs)

    def __repr__(self) -> str:
        result = "ExecuteTransactionInput("
        if self.transact_statements is not None:
            result += f"transact_statements={repr(self.transact_statements)}, "

        if self.client_request_token is not None:
            result += f"client_request_token={repr(self.client_request_token)}, "

        if self.return_consumed_capacity is not None:
            result += f"return_consumed_capacity={repr(self.return_consumed_capacity)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, ExecuteTransactionInput):
            return False
        attributes: list[str] = ['transact_statements','client_request_token','return_consumed_capacity',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class ExecuteTransactionOutput:
    responses: Optional['list[ItemResponse]']
    consumed_capacity: Optional[list[ConsumedCapacity]]
    def __init__(
        self,
        *,
        responses: Optional['list[ItemResponse]'] = None,
        consumed_capacity: Optional[list[ConsumedCapacity]] = None,
    ):
        """
        :param responses: <p>The response to a PartiQL transaction.</p>
        :param consumed_capacity: <p>The capacity units consumed by the entire
        operation. The values of the list are
                    ordered according to the
        ordering of the statements.</p>
        """
        self.responses = responses
        self.consumed_capacity = consumed_capacity

    def as_dict(self) -> Dict[str, Any]:
        """Converts the ExecuteTransactionOutput to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        d: Dict[str, Any] = {}

        if self.responses is not None:
            d["Responses"] = _item_response_list_as_dict(self.responses),

        if self.consumed_capacity is not None:
            d["ConsumedCapacity"] = _consumed_capacity_multiple_as_dict(self.consumed_capacity),

        return d

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "ExecuteTransactionOutput":
        """Creates a ExecuteTransactionOutput from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {}

        if "Responses" in d:
            kwargs["responses"] = _item_response_list_from_dict(d["Responses"]),

        if "ConsumedCapacity" in d:
            kwargs["consumed_capacity"] = _consumed_capacity_multiple_from_dict(d["ConsumedCapacity"]),

        return ExecuteTransactionOutput(**kwargs)

    def __repr__(self) -> str:
        result = "ExecuteTransactionOutput("
        if self.responses is not None:
            result += f"responses={repr(self.responses)}, "

        if self.consumed_capacity is not None:
            result += f"consumed_capacity={repr(self.consumed_capacity)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, ExecuteTransactionOutput):
            return False
        attributes: list[str] = ['responses','consumed_capacity',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class TransactGetItemsOutput:
    consumed_capacity: Optional[list[ConsumedCapacity]]
    responses: Optional['list[ItemResponse]']
    def __init__(
        self,
        *,
        consumed_capacity: Optional[list[ConsumedCapacity]] = None,
        responses: Optional['list[ItemResponse]'] = None,
    ):
        """
        :param consumed_capacity: <p>If the <i>ReturnConsumedCapacity</i> value was
        <code>TOTAL</code>, this
                    is an array of
        <code>ConsumedCapacity</code> objects, one for each table addressed by

        <code>TransactGetItem</code> objects in the <i>TransactItems</i>

        parameter. These <code>ConsumedCapacity</code> objects report the read-capacity
        units
                    consumed by the <code>TransactGetItems</code> call in that
        table.</p>
        :param responses: <p>An ordered array of up to 25 <code>ItemResponse</code>
        objects, each of which
                    corresponds to the
        <code>TransactGetItem</code> object in the same position in the

        <i>TransactItems</i> array. Each <code>ItemResponse</code> object

        contains a Map of the name-value pairs that are the projected attributes of the

        requested item.</p>
                <p>If a requested item could not be retrieved, the
        corresponding
                        <code>ItemResponse</code> object is Null, or if
        the requested item has no projected
                    attributes, the corresponding
        <code>ItemResponse</code> object is an empty Map. </p>
        """
        self.consumed_capacity = consumed_capacity
        self.responses = responses

    def as_dict(self) -> Dict[str, Any]:
        """Converts the TransactGetItemsOutput to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        d: Dict[str, Any] = {}

        if self.consumed_capacity is not None:
            d["ConsumedCapacity"] = _consumed_capacity_multiple_as_dict(self.consumed_capacity),

        if self.responses is not None:
            d["Responses"] = _item_response_list_as_dict(self.responses),

        return d

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "TransactGetItemsOutput":
        """Creates a TransactGetItemsOutput from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {}

        if "ConsumedCapacity" in d:
            kwargs["consumed_capacity"] = _consumed_capacity_multiple_from_dict(d["ConsumedCapacity"]),

        if "Responses" in d:
            kwargs["responses"] = _item_response_list_from_dict(d["Responses"]),

        return TransactGetItemsOutput(**kwargs)

    def __repr__(self) -> str:
        result = "TransactGetItemsOutput("
        if self.consumed_capacity is not None:
            result += f"consumed_capacity={repr(self.consumed_capacity)}, "

        if self.responses is not None:
            result += f"responses={repr(self.responses)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, TransactGetItemsOutput):
            return False
        attributes: list[str] = ['consumed_capacity','responses',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class BatchGetItemInput:
    request_items: 'dict[str, KeysAndAttributes]'
    return_consumed_capacity: Optional[str]
    def __init__(
        self,
        *,
        request_items: 'dict[str, KeysAndAttributes]',
        return_consumed_capacity: Optional[str] = None,
    ):
        """<p>Represents the input of a <code>BatchGetItem</code> operation.</p>

        :param request_items: <p>A map of one or more table names and, for each table, a
        map that describes one or more
                    items to retrieve from that table.
        Each table name can be used only once per

        <code>BatchGetItem</code> request.</p>
                <p>Each element in the map of
        items to retrieve consists of the following:</p>
                <ul>
                    <li>

        <p>
                            <code>ConsistentRead</code> - If <code>true</code>, a
        strongly consistent read
                            is used; if <code>false</code> (the
        default), an eventually consistent read is
                            used.</p>

        </li>
                    <li>
                        <p>

        <code>ExpressionAttributeNames</code> - One or more substitution tokens for

        attribute names in the <code>ProjectionExpression</code> parameter. The

        following are some use cases for using

        <code>ExpressionAttributeNames</code>:</p>
                        <ul>

        <li>
                                <p>To access an attribute whose name conflicts with
        a DynamoDB reserved
                                    word.</p>

        </li>
                          <li>
                                <p>To create a placeholder
        for repeating occurrences of an attribute name
                                    in an
        expression.</p>
                            </li>
                          <li>

        <p>To prevent special characters in an attribute name from being

        misinterpreted in an expression.</p>
                            </li>

        </ul>
                        <p>Use the <b>#</b> character in an expression to

        dereference an attribute name. For example, consider the following attribute

        name:</p>
                        <ul>
                          <li>

        <p>
                                    <code>Percentile</code>

        </p>
                            </li>
                       </ul>
                        <p>The name
        of this attribute conflicts with a reserved word, so it cannot be

        used directly in an expression. (For the complete list of reserved words, see

        <a
        href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/ReservedWords.html">Reserved

        Words</a> in the <i>Amazon DynamoDB Developer Guide</i>).
                            To
        work around this, you could specify the following for

        <code>ExpressionAttributeNames</code>:</p>
                        <ul>

        <li>
                                <p>

        <code>{"#P":"Percentile"}</code>
                                </p>

        </li>
                       </ul>
                        <p>You could then use this
        substitution in an expression, as in this
                            example:</p>

        <ul>
                          <li>
                                <p>

        <code>#P = :val</code>
                                </p>
                            </li>

        </ul>
                        <note>
                            <p>Tokens that begin with the
        <b>:</b> character
                                are <i>expression attribute
        values</i>, which are placeholders
                                for the actual value
        at runtime.</p>
                        </note>
                        <p>For more information
        about expression attribute names, see <a
        href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Expressions.AccessingItemAttributes.html">Accessing
        Item Attributes</a> in the <i>Amazon DynamoDB
                                Developer
        Guide</i>.</p>
                    </li>
                    <li>
                        <p>

        <code>Keys</code> - An array of primary key attribute values that define

        specific items in the table. For each primary key, you must provide

        <i>all</i> of the key attributes. For example, with a simple

        primary key, you only need to provide the partition key value. For a composite

        key, you must provide <i>both</i> the partition key value and the

        sort key value.</p>
                    </li>
                    <li>
                        <p>

        <code>ProjectionExpression</code> - A string that identifies one or more

        attributes to retrieve from the table. These attributes can include scalars,

        sets, or elements of a JSON document. The attributes in the expression must be

        separated by commas.</p>
                        <p>If no attribute names are specified,
        then all attributes are returned. If any
                            of the requested
        attributes are not found, they do not appear in the

        result.</p>
                        <p>For more information, see <a
        href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Expressions.AccessingItemAttributes.html">Accessing
        Item Attributes</a> in the <i>Amazon DynamoDB
                                Developer
        Guide</i>.</p>
                    </li>
                    <li>
                        <p>

        <code>AttributesToGet</code> - This is a legacy parameter. Use

        <code>ProjectionExpression</code> instead. For more information, see <a
        href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/LegacyConditionalParameters.AttributesToGet.html">AttributesToGet</a>
        in the <i>Amazon DynamoDB Developer
                                Guide</i>. </p>

        </li>
                 </ul>
        :param return_consumed_capacity: <p>Determines the level of detail about either
        provisioned or on-demand throughput
                    consumption that is returned in
        the response:</p>
                <ul>
                    <li>
                        <p>

        <code>INDEXES</code> - The response includes the aggregate

        <code>ConsumedCapacity</code> for the operation, together with

        <code>ConsumedCapacity</code> for each table and secondary index that was

        accessed.</p>
                        <p>Note that some operations, such as
        <code>GetItem</code> and
                                <code>BatchGetItem</code>, do
        not access any indexes at all. In these cases,
                            specifying
        <code>INDEXES</code> will only return <code>ConsumedCapacity</code>

        information for table(s).</p>
                    </li>
                    <li>

        <p>
                            <code>TOTAL</code> - The response includes only the
        aggregate
                                <code>ConsumedCapacity</code> for the
        operation.</p>
                    </li>
                    <li>
                        <p>

        <code>NONE</code> - No <code>ConsumedCapacity</code> details are included in
        the
                            response.</p>
                    </li>
                 </ul>
        """
        self.request_items = request_items
        self.return_consumed_capacity = return_consumed_capacity

    def as_dict(self) -> Dict[str, Any]:
        """Converts the BatchGetItemInput to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        d: Dict[str, Any] = {
            "RequestItems": _batch_get_request_map_as_dict(self.request_items),
        }

        if self.return_consumed_capacity is not None:
            d["ReturnConsumedCapacity"] = self.return_consumed_capacity

        return d

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "BatchGetItemInput":
        """Creates a BatchGetItemInput from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {
            "request_items": _batch_get_request_map_from_dict(d["RequestItems"]),
        }

        if "ReturnConsumedCapacity" in d:
            kwargs["return_consumed_capacity"] = d["ReturnConsumedCapacity"]

        return BatchGetItemInput(**kwargs)

    def __repr__(self) -> str:
        result = "BatchGetItemInput("
        if self.request_items is not None:
            result += f"request_items={repr(self.request_items)}, "

        if self.return_consumed_capacity is not None:
            result += f"return_consumed_capacity={repr(self.return_consumed_capacity)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, BatchGetItemInput):
            return False
        attributes: list[str] = ['request_items','return_consumed_capacity',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class ExpectedAttributeValue:
    value: Optional['AttributeValue']
    exists: Optional[bool]
    comparison_operator: Optional[str]
    attribute_value_list: Optional['list[AttributeValue]']
    def __init__(
        self,
        *,
        value: Optional['AttributeValue'] = None,
        exists: Optional[bool] = None,
        comparison_operator: Optional[str] = None,
        attribute_value_list: Optional['list[AttributeValue]'] = None,
    ):
        """<p>Represents a condition to be compared with an attribute value. This condition
        can be
                    used with <code>DeleteItem</code>, <code>PutItem</code>, or
        <code>UpdateItem</code>
                    operations; if the comparison evaluates to
        true, the operation succeeds; if not, the
                    operation fails. You can
        use <code>ExpectedAttributeValue</code> in one of two different

        ways:</p>
                <ul>
                    <li>
                        <p>Use
        <code>AttributeValueList</code> to specify one or more values to compare

        against an attribute. Use <code>ComparisonOperator</code> to specify how you

        want to perform the comparison. If the comparison evaluates to true, then the

        conditional operation succeeds.</p>
                    </li>
                    <li>

        <p>Use <code>Value</code> to specify a value that DynamoDB will compare against

        an attribute. If the values match, then <code>ExpectedAttributeValue</code>

        evaluates to true and the conditional operation succeeds. Optionally, you can

        also set <code>Exists</code> to false, indicating that you <i>do

        not</i> expect to find the attribute value in the table. In this

        case, the conditional operation succeeds only if the comparison evaluates to

        false.</p>
                    </li>
                 </ul>
                <p>

        <code>Value</code> and <code>Exists</code> are incompatible with

        <code>AttributeValueList</code> and <code>ComparisonOperator</code>. Note that
        if
                    you use both sets of parameters at once, DynamoDB will return a

        <code>ValidationException</code> exception.</p>

        :param value: <p>Represents the data for the expected attribute.</p>

        <p>Each attribute value is described as a name-value pair. The name is the data
        type, and
                    the value is the data itself.</p>
                <p>For more
        information, see <a
        href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/HowItWorks.NamingRulesDataTypes.html#HowItWorks.DataTypes">Data
        Types</a> in the <i>Amazon DynamoDB Developer
                        Guide</i>.</p>
        :param exists: <p>Causes DynamoDB to evaluate the value before attempting a
        conditional
                    operation:</p>
                <ul>
                    <li>

        <p>If <code>Exists</code> is <code>true</code>, DynamoDB will check to

        see if that attribute value already exists in the table. If it is found, then

        the operation succeeds. If it is not found, the operation fails with a

        <code>ConditionCheckFailedException</code>.</p>
                    </li>

        <li>
                        <p>If <code>Exists</code> is <code>false</code>, DynamoDB
        assumes that
                            the attribute value does not exist in the
        table. If in fact the value does not
                            exist, then the
        assumption is valid and the operation succeeds. If the value is

        found, despite the assumption that it does not exist, the operation fails with
        a
                                <code>ConditionCheckFailedException</code>.</p>

        </li>
                 </ul>
                <p>The default setting for <code>Exists</code> is
        <code>true</code>. If you supply a
                        <code>Value</code> all by
        itself, DynamoDB assumes the attribute exists:
                    You don't have to set
        <code>Exists</code> to <code>true</code>, because it is

        implied.</p>
                <p>DynamoDB returns a <code>ValidationException</code>
        if:</p>
                <ul>
                    <li>
                        <p>

        <code>Exists</code> is <code>true</code> but there is no <code>Value</code> to

        check. (You expect a value to exist, but don't specify what that value

        is.)</p>
                    </li>
                    <li>
                        <p>

        <code>Exists</code> is <code>false</code> but you also provide a

        <code>Value</code>. (You cannot expect an attribute to have a value, while

        also expecting it not to exist.)</p>
                    </li>
                 </ul>
        :param comparison_operator: <p>A comparator for evaluating attributes in the
        <code>AttributeValueList</code>. For
                    example, equals, greater than,
        less than, etc.</p>
                <p>The following comparison operators are
        available:</p>
                <p>
                    <code>EQ | NE | LE | LT | GE | GT |
        NOT_NULL | NULL | CONTAINS | NOT_CONTAINS |
                        BEGINS_WITH | IN |
        BETWEEN</code>
                </p>
                <p>The following are descriptions of each
        comparison operator.</p>
                <ul>
                    <li>
                        <p>

        <code>EQ</code> : Equal. <code>EQ</code> is supported for all data types,

        including lists and maps.</p>
                        <p>

        <code>AttributeValueList</code> can contain only one
        <code>AttributeValue</code>
                            element of type String, Number,
        Binary, String Set, Number Set, or Binary Set.
                            If an item
        contains an <code>AttributeValue</code> element of a different type

        than the one provided in the request, the value does not match. For example,

        <code>{"S":"6"}</code> does not equal <code>{"N":"6"}</code>. Also,

        <code>{"N":"6"}</code> does not equal <code>{"NS":["6", "2",

        "1"]}</code>.</p>
                        <p></p>
                    </li>
                    <li>

        <p>
                            <code>NE</code> : Not equal. <code>NE</code> is
        supported for all data types,
                            including lists and maps.</p>

        <p>
                            <code>AttributeValueList</code> can contain only one
        <code>AttributeValue</code>
                            of type String, Number, Binary,
        String Set, Number Set, or Binary Set. If an
                            item contains
        an <code>AttributeValue</code> of a different type than the one

        provided in the request, the value does not match. For example,

        <code>{"S":"6"}</code> does not equal <code>{"N":"6"}</code>. Also,

        <code>{"N":"6"}</code> does not equal <code>{"NS":["6", "2",

        "1"]}</code>.</p>
                        <p></p>
                    </li>
                    <li>

        <p>
                            <code>LE</code> : Less than or equal. </p>

        <p>
                            <code>AttributeValueList</code> can contain only one
        <code>AttributeValue</code>
                            element of type String, Number,
        or Binary (not a set type). If an item contains
                            an
        <code>AttributeValue</code> element of a different type than the one provided

        in the request, the value does not match. For example, <code>{"S":"6"}</code>

        does not equal <code>{"N":"6"}</code>. Also, <code>{"N":"6"}</code> does not

        compare to <code>{"NS":["6", "2", "1"]}</code>.</p>
                        <p></p>

        </li>
                    <li>
                        <p>
                            <code>LT</code> :
        Less than. </p>
                        <p>

        <code>AttributeValueList</code> can contain only one
        <code>AttributeValue</code>
                            of type String, Number, or
        Binary (not a set type). If an item contains an

        <code>AttributeValue</code> element of a different type than the one

        provided in the request, the value does not match. For example,

        <code>{"S":"6"}</code> does not equal <code>{"N":"6"}</code>. Also,

        <code>{"N":"6"}</code> does not compare to <code>{"NS":["6", "2",

        "1"]}</code>.</p>
                        <p></p>
                    </li>
                    <li>

        <p>
                            <code>GE</code> : Greater than or equal. </p>

        <p>
                            <code>AttributeValueList</code> can contain only one
        <code>AttributeValue</code>
                            element of type String, Number,
        or Binary (not a set type). If an item contains
                            an
        <code>AttributeValue</code> element of a different type than the one provided

        in the request, the value does not match. For example, <code>{"S":"6"}</code>

        does not equal <code>{"N":"6"}</code>. Also, <code>{"N":"6"}</code> does not

        compare to <code>{"NS":["6", "2", "1"]}</code>.</p>
                        <p></p>

        </li>
                    <li>
                        <p>
                            <code>GT</code> :
        Greater than. </p>
                        <p>

        <code>AttributeValueList</code> can contain only one
        <code>AttributeValue</code>
                            element of type String, Number,
        or Binary (not a set type). If an item contains
                            an
        <code>AttributeValue</code> element of a different type than the one provided

        in the request, the value does not match. For example, <code>{"S":"6"}</code>

        does not equal <code>{"N":"6"}</code>. Also, <code>{"N":"6"}</code> does not

        compare to <code>{"NS":["6", "2", "1"]}</code>.</p>
                        <p></p>

        </li>
                    <li>
                        <p>

        <code>NOT_NULL</code> : The attribute exists. <code>NOT_NULL</code> is
        supported
                            for all data types, including lists and maps.</p>

        <note>
                            <p>This operator tests for the existence of an
        attribute, not its data type.
                                If the data type of
        attribute "<code>a</code>" is null, and you evaluate it

        using <code>NOT_NULL</code>, the result is a Boolean <code>true</code>. This

        result is because the attribute "<code>a</code>" exists; its data type is

        not relevant to the <code>NOT_NULL</code> comparison operator.</p>

        </note>
                    </li>
                    <li>
                        <p>

        <code>NULL</code> : The attribute does not exist. <code>NULL</code> is
        supported
                            for all data types, including lists and maps.</p>

        <note>
                            <p>This operator tests for the nonexistence of an
        attribute, not its data
                                type. If the data type of
        attribute "<code>a</code>" is null, and you
                                evaluate it
        using <code>NULL</code>, the result is a Boolean

        <code>false</code>. This is because the attribute "<code>a</code>"

        exists; its data type is not relevant to the <code>NULL</code> comparison

        operator.</p>
                        </note>
                    </li>
                    <li>

        <p>
                            <code>CONTAINS</code> : Checks for a subsequence, or
        value in a set.</p>
                        <p>

        <code>AttributeValueList</code> can contain only one
        <code>AttributeValue</code>
                            element of type String, Number,
        or Binary (not a set type). If the target
                            attribute of the
        comparison is of type String, then the operator checks for a

        substring match. If the target attribute of the comparison is of type Binary,

        then the operator looks for a subsequence of the target that matches the input.

        If the target attribute of the comparison is a set ("<code>SS</code>",

        "<code>NS</code>", or "<code>BS</code>"), then the operator evaluates to

        true if it finds an exact match with any member of the set.</p>

        <p>CONTAINS is supported for lists: When evaluating "<code>a CONTAINS
        b</code>",
                                "<code>a</code>" can be a list; however,
        "<code>b</code>" cannot be a set, a
                            map, or a list.</p>

        </li>
                    <li>
                        <p>

        <code>NOT_CONTAINS</code> : Checks for absence of a subsequence, or absence of
        a
                            value in a set.</p>
                        <p>

        <code>AttributeValueList</code> can contain only one
        <code>AttributeValue</code>
                            element of type String, Number,
        or Binary (not a set type). If the target
                            attribute of the
        comparison is a String, then the operator checks for the

        absence of a substring match. If the target attribute of the comparison is

        Binary, then the operator checks for the absence of a subsequence of the target

        that matches the input. If the target attribute of the comparison is a set

        ("<code>SS</code>", "<code>NS</code>", or "<code>BS</code>"), then the

        operator evaluates to true if it <i>does not</i> find an exact

        match with any member of the set.</p>
                        <p>NOT_CONTAINS is
        supported for lists: When evaluating "<code>a NOT CONTAINS

        b</code>", "<code>a</code>" can be a list; however, "<code>b</code>" cannot

        be a set, a map, or a list.</p>
                    </li>
                    <li>

        <p>
                            <code>BEGINS_WITH</code> : Checks for a prefix. </p>

        <p>
                            <code>AttributeValueList</code> can contain only one
        <code>AttributeValue</code>
                            of type String or Binary (not a
        Number or a set type). The target attribute of
                            the
        comparison must be of type String or Binary (not a Number or a set

        type).</p>
                        <p></p>
                    </li>
                    <li>

        <p>
                            <code>IN</code> : Checks for matching elements in a
        list.</p>
                        <p>

        <code>AttributeValueList</code> can contain one or more

        <code>AttributeValue</code> elements of type String, Number, or Binary.

        These attributes are compared against an existing attribute of an item. If any

        elements of the input are equal to the item attribute, the expression evaluates

        to true.</p>
                    </li>
                    <li>
                        <p>

        <code>BETWEEN</code> : Greater than or equal to the first value, and less than

        or equal to the second value. </p>
                        <p>

        <code>AttributeValueList</code> must contain two <code>AttributeValue</code>

        elements of the same type, either String, Number, or Binary (not a set type). A

        target attribute matches if the target value is greater than, or equal to, the

        first element and less than, or equal to, the second element. If an item

        contains an <code>AttributeValue</code> element of a different type than the
        one
                            provided in the request, the value does not match. For
        example,
                                <code>{"S":"6"}</code> does not compare to
        <code>{"N":"6"}</code>. Also,
                                <code>{"N":"6"}</code>
        does not compare to <code>{"NS":["6", "2",
                                "1"]}</code>

        </p>
                    </li>
                 </ul>
        :param attribute_value_list: <p>One or more values to evaluate against the
        supplied attribute. The number of values in
                    the list depends on the
        <code>ComparisonOperator</code> being used.</p>
                <p>For type Number,
        value comparisons are numeric.</p>
                <p>String value comparisons for
        greater than, equals, or less than are based on ASCII
                    character code
        values. For example, <code>a</code> is greater than <code>A</code>, and

        <code>a</code> is greater than <code>B</code>. For a list of code values, see <a
        href="http://en.wikipedia.org/wiki/ASCII#ASCII_printable_characters">http://en.wikipedia.org/wiki/ASCII#ASCII_printable_characters</a>.</p>

        <p>For Binary, DynamoDB treats each byte of the binary data as unsigned when it

        compares binary values.</p>
                <p>For information on specifying data types
        in JSON, see <a
        href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/DataFormat.html">JSON
        Data Format</a>
                    in the <i>Amazon DynamoDB Developer Guide</i>.</p>
        """
        self.value = value
        self.exists = exists
        self.comparison_operator = comparison_operator
        self.attribute_value_list = attribute_value_list

    def as_dict(self) -> Dict[str, Any]:
        """Converts the ExpectedAttributeValue to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        d: Dict[str, Any] = {}

        if self.value is not None:
            d["Value"] = self.value.as_dict()

        if self.exists is not None:
            d["Exists"] = self.exists

        if self.comparison_operator is not None:
            d["ComparisonOperator"] = self.comparison_operator

        if self.attribute_value_list is not None:
            d["AttributeValueList"] = _attribute_value_list_as_dict(self.attribute_value_list),

        return d

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "ExpectedAttributeValue":
        """Creates a ExpectedAttributeValue from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {}

        if "Value" in d:
            kwargs["value"] = _attribute_value_from_dict(d["Value"]),

        if "Exists" in d:
            kwargs["exists"] = d["Exists"]

        if "ComparisonOperator" in d:
            kwargs["comparison_operator"] = d["ComparisonOperator"]

        if "AttributeValueList" in d:
            kwargs["attribute_value_list"] = _attribute_value_list_from_dict(d["AttributeValueList"]),

        return ExpectedAttributeValue(**kwargs)

    def __repr__(self) -> str:
        result = "ExpectedAttributeValue("
        if self.value is not None:
            result += f"value={repr(self.value)}, "

        if self.exists is not None:
            result += f"exists={repr(self.exists)}, "

        if self.comparison_operator is not None:
            result += f"comparison_operator={repr(self.comparison_operator)}, "

        if self.attribute_value_list is not None:
            result += f"attribute_value_list={repr(self.attribute_value_list)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, ExpectedAttributeValue):
            return False
        attributes: list[str] = ['value','exists','comparison_operator','attribute_value_list',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class TransactGetItemsInput:
    transact_items: 'list[TransactGetItem]'
    return_consumed_capacity: Optional[str]
    def __init__(
        self,
        *,
        transact_items: 'list[TransactGetItem]',
        return_consumed_capacity: Optional[str] = None,
    ):
        """
        :param transact_items: <p>An ordered array of up to 25
        <code>TransactGetItem</code> objects, each of which
                    contains a
        <code>Get</code> structure.</p>
        :param return_consumed_capacity: <p>A value of <code>TOTAL</code> causes
        consumed capacity information to be returned, and
                    a value of
        <code>NONE</code> prevents that information from being returned. No other

        value is valid.</p>
        """
        self.transact_items = transact_items
        self.return_consumed_capacity = return_consumed_capacity

    def as_dict(self) -> Dict[str, Any]:
        """Converts the TransactGetItemsInput to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        d: Dict[str, Any] = {
            "TransactItems": _transact_get_item_list_as_dict(self.transact_items),
        }

        if self.return_consumed_capacity is not None:
            d["ReturnConsumedCapacity"] = self.return_consumed_capacity

        return d

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "TransactGetItemsInput":
        """Creates a TransactGetItemsInput from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {
            "transact_items": _transact_get_item_list_from_dict(d["TransactItems"]),
        }

        if "ReturnConsumedCapacity" in d:
            kwargs["return_consumed_capacity"] = d["ReturnConsumedCapacity"]

        return TransactGetItemsInput(**kwargs)

    def __repr__(self) -> str:
        result = "TransactGetItemsInput("
        if self.transact_items is not None:
            result += f"transact_items={repr(self.transact_items)}, "

        if self.return_consumed_capacity is not None:
            result += f"return_consumed_capacity={repr(self.return_consumed_capacity)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, TransactGetItemsInput):
            return False
        attributes: list[str] = ['transact_items','return_consumed_capacity',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class TransactWriteItemsOutput:
    consumed_capacity: Optional[list[ConsumedCapacity]]
    item_collection_metrics: Optional['dict[str, list[ItemCollectionMetrics]]']
    def __init__(
        self,
        *,
        consumed_capacity: Optional[list[ConsumedCapacity]] = None,
        item_collection_metrics: Optional['dict[str, list[ItemCollectionMetrics]]'] = None,
    ):
        """
        :param consumed_capacity: <p>The capacity units consumed by the entire
        <code>TransactWriteItems</code> operation.
                    The values of the list
        are ordered according to the ordering of the

        <code>TransactItems</code> request parameter. </p>
        :param item_collection_metrics: <p>A list of tables that were processed by
        <code>TransactWriteItems</code> and, for each
                    table, information
        about any item collections that were affected by individual

        <code>UpdateItem</code>, <code>PutItem</code>, or <code>DeleteItem</code>

        operations. </p>
        """
        self.consumed_capacity = consumed_capacity
        self.item_collection_metrics = item_collection_metrics

    def as_dict(self) -> Dict[str, Any]:
        """Converts the TransactWriteItemsOutput to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        d: Dict[str, Any] = {}

        if self.consumed_capacity is not None:
            d["ConsumedCapacity"] = _consumed_capacity_multiple_as_dict(self.consumed_capacity),

        if self.item_collection_metrics is not None:
            d["ItemCollectionMetrics"] = _item_collection_metrics_per_table_as_dict(self.item_collection_metrics),

        return d

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "TransactWriteItemsOutput":
        """Creates a TransactWriteItemsOutput from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {}

        if "ConsumedCapacity" in d:
            kwargs["consumed_capacity"] = _consumed_capacity_multiple_from_dict(d["ConsumedCapacity"]),

        if "ItemCollectionMetrics" in d:
            kwargs["item_collection_metrics"] = _item_collection_metrics_per_table_from_dict(d["ItemCollectionMetrics"]),

        return TransactWriteItemsOutput(**kwargs)

    def __repr__(self) -> str:
        result = "TransactWriteItemsOutput("
        if self.consumed_capacity is not None:
            result += f"consumed_capacity={repr(self.consumed_capacity)}, "

        if self.item_collection_metrics is not None:
            result += f"item_collection_metrics={repr(self.item_collection_metrics)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, TransactWriteItemsOutput):
            return False
        attributes: list[str] = ['consumed_capacity','item_collection_metrics',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class ConditionCheck:
    key: 'dict[str, AttributeValue]'
    table_name: str
    condition_expression: str
    expression_attribute_names: Optional[dict[str, str]]
    expression_attribute_values: Optional['dict[str, AttributeValue]']
    return_values_on_condition_check_failure: Optional[str]
    def __init__(
        self,
        *,
        key: 'dict[str, AttributeValue]',
        table_name: str,
        condition_expression: str,
        expression_attribute_names: Optional[dict[str, str]] = None,
        expression_attribute_values: Optional['dict[str, AttributeValue]'] = None,
        return_values_on_condition_check_failure: Optional[str] = None,
    ):
        """<p>Represents a request to perform a check that an item exists or to check the
        condition
                    of specific attributes of the item.</p>

        :param key: <p>The primary key of the item to be checked. Each element consists
        of an attribute name
                    and a value for that attribute.</p>
        :param table_name: <p>Name of the table for the check item request.</p>
        :param condition_expression: <p>A condition that must be satisfied in order for
        a conditional update to
                    succeed.</p>
        :param expression_attribute_names: <p>One or more substitution tokens for
        attribute names in an expression.</p>
        :param expression_attribute_values: <p>One or more values that can be
        substituted in an expression.</p>
        :param return_values_on_condition_check_failure: <p>Use
        <code>ReturnValuesOnConditionCheckFailure</code> to get the item attributes if
        the
                        <code>ConditionCheck</code> condition fails. For

        <code>ReturnValuesOnConditionCheckFailure</code>, the valid values are: NONE
        and
                    ALL_OLD.</p>
        """
        self.key = key
        self.table_name = table_name
        self.condition_expression = condition_expression
        self.expression_attribute_names = expression_attribute_names
        self.expression_attribute_values = expression_attribute_values
        self.return_values_on_condition_check_failure = return_values_on_condition_check_failure

    def as_dict(self) -> Dict[str, Any]:
        """Converts the ConditionCheck to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        d: Dict[str, Any] = {
            "Key": _key_as_dict(self.key),
            "TableName": self.table_name,
            "ConditionExpression": self.condition_expression,
        }

        if self.expression_attribute_names is not None:
            d["ExpressionAttributeNames"] = self.expression_attribute_names

        if self.expression_attribute_values is not None:
            d["ExpressionAttributeValues"] = _expression_attribute_value_map_as_dict(self.expression_attribute_values),

        if self.return_values_on_condition_check_failure is not None:
            d["ReturnValuesOnConditionCheckFailure"] = self.return_values_on_condition_check_failure

        return d

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "ConditionCheck":
        """Creates a ConditionCheck from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {
            "key": _key_from_dict(d["Key"]),
            "table_name": d["TableName"],
            "condition_expression": d["ConditionExpression"],
        }

        if "ExpressionAttributeNames" in d:
            kwargs["expression_attribute_names"] = d["ExpressionAttributeNames"]

        if "ExpressionAttributeValues" in d:
            kwargs["expression_attribute_values"] = _expression_attribute_value_map_from_dict(d["ExpressionAttributeValues"]),

        if "ReturnValuesOnConditionCheckFailure" in d:
            kwargs["return_values_on_condition_check_failure"] = d["ReturnValuesOnConditionCheckFailure"]

        return ConditionCheck(**kwargs)

    def __repr__(self) -> str:
        result = "ConditionCheck("
        if self.key is not None:
            result += f"key={repr(self.key)}, "

        if self.table_name is not None:
            result += f"table_name={repr(self.table_name)}, "

        if self.condition_expression is not None:
            result += f"condition_expression={repr(self.condition_expression)}, "

        if self.expression_attribute_names is not None:
            result += f"expression_attribute_names={repr(self.expression_attribute_names)}, "

        if self.expression_attribute_values is not None:
            result += f"expression_attribute_values={repr(self.expression_attribute_values)}, "

        if self.return_values_on_condition_check_failure is not None:
            result += f"return_values_on_condition_check_failure={repr(self.return_values_on_condition_check_failure)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, ConditionCheck):
            return False
        attributes: list[str] = ['key','table_name','condition_expression','expression_attribute_names','expression_attribute_values','return_values_on_condition_check_failure',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class Delete:
    key: 'dict[str, AttributeValue]'
    table_name: str
    condition_expression: Optional[str]
    expression_attribute_names: Optional[dict[str, str]]
    expression_attribute_values: Optional['dict[str, AttributeValue]']
    return_values_on_condition_check_failure: Optional[str]
    def __init__(
        self,
        *,
        key: 'dict[str, AttributeValue]',
        table_name: str,
        condition_expression: Optional[str] = None,
        expression_attribute_names: Optional[dict[str, str]] = None,
        expression_attribute_values: Optional['dict[str, AttributeValue]'] = None,
        return_values_on_condition_check_failure: Optional[str] = None,
    ):
        """<p>Represents a request to perform a <code>DeleteItem</code> operation.</p>

        :param key: <p>The primary key of the item to be deleted. Each element consists
        of an attribute name
                    and a value for that attribute.</p>
        :param table_name: <p>Name of the table in which the item to be deleted
        resides.</p>
        :param condition_expression: <p>A condition that must be satisfied in order for
        a conditional delete to
                    succeed.</p>
        :param expression_attribute_names: <p>One or more substitution tokens for
        attribute names in an expression.</p>
        :param expression_attribute_values: <p>One or more values that can be
        substituted in an expression.</p>
        :param return_values_on_condition_check_failure: <p>Use
        <code>ReturnValuesOnConditionCheckFailure</code> to get the item attributes if
        the
                        <code>Delete</code> condition fails. For

        <code>ReturnValuesOnConditionCheckFailure</code>, the valid values are: NONE
        and
                    ALL_OLD.</p>
        """
        self.key = key
        self.table_name = table_name
        self.condition_expression = condition_expression
        self.expression_attribute_names = expression_attribute_names
        self.expression_attribute_values = expression_attribute_values
        self.return_values_on_condition_check_failure = return_values_on_condition_check_failure

    def as_dict(self) -> Dict[str, Any]:
        """Converts the Delete to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        d: Dict[str, Any] = {
            "Key": _key_as_dict(self.key),
            "TableName": self.table_name,
        }

        if self.condition_expression is not None:
            d["ConditionExpression"] = self.condition_expression

        if self.expression_attribute_names is not None:
            d["ExpressionAttributeNames"] = self.expression_attribute_names

        if self.expression_attribute_values is not None:
            d["ExpressionAttributeValues"] = _expression_attribute_value_map_as_dict(self.expression_attribute_values),

        if self.return_values_on_condition_check_failure is not None:
            d["ReturnValuesOnConditionCheckFailure"] = self.return_values_on_condition_check_failure

        return d

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "Delete":
        """Creates a Delete from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {
            "key": _key_from_dict(d["Key"]),
            "table_name": d["TableName"],
        }

        if "ConditionExpression" in d:
            kwargs["condition_expression"] = d["ConditionExpression"]

        if "ExpressionAttributeNames" in d:
            kwargs["expression_attribute_names"] = d["ExpressionAttributeNames"]

        if "ExpressionAttributeValues" in d:
            kwargs["expression_attribute_values"] = _expression_attribute_value_map_from_dict(d["ExpressionAttributeValues"]),

        if "ReturnValuesOnConditionCheckFailure" in d:
            kwargs["return_values_on_condition_check_failure"] = d["ReturnValuesOnConditionCheckFailure"]

        return Delete(**kwargs)

    def __repr__(self) -> str:
        result = "Delete("
        if self.key is not None:
            result += f"key={repr(self.key)}, "

        if self.table_name is not None:
            result += f"table_name={repr(self.table_name)}, "

        if self.condition_expression is not None:
            result += f"condition_expression={repr(self.condition_expression)}, "

        if self.expression_attribute_names is not None:
            result += f"expression_attribute_names={repr(self.expression_attribute_names)}, "

        if self.expression_attribute_values is not None:
            result += f"expression_attribute_values={repr(self.expression_attribute_values)}, "

        if self.return_values_on_condition_check_failure is not None:
            result += f"return_values_on_condition_check_failure={repr(self.return_values_on_condition_check_failure)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, Delete):
            return False
        attributes: list[str] = ['key','table_name','condition_expression','expression_attribute_names','expression_attribute_values','return_values_on_condition_check_failure',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class Put:
    item: 'dict[str, AttributeValue]'
    table_name: str
    condition_expression: Optional[str]
    expression_attribute_names: Optional[dict[str, str]]
    expression_attribute_values: Optional['dict[str, AttributeValue]']
    return_values_on_condition_check_failure: Optional[str]
    def __init__(
        self,
        *,
        item: 'dict[str, AttributeValue]',
        table_name: str,
        condition_expression: Optional[str] = None,
        expression_attribute_names: Optional[dict[str, str]] = None,
        expression_attribute_values: Optional['dict[str, AttributeValue]'] = None,
        return_values_on_condition_check_failure: Optional[str] = None,
    ):
        """<p>Represents a request to perform a <code>PutItem</code> operation.</p>

        :param item: <p>A map of attribute name to attribute values, representing the
        primary key of the item
                    to be written by <code>PutItem</code>. All
        of the table's primary key attributes must be
                    specified, and their
        data types must match those of the table's key schema. If any

        attributes are present in the item that are part of an index key schema for the
        table,
                    their types must match the index key schema. </p>
        :param table_name: <p>Name of the table in which to write the item.</p>
        :param condition_expression: <p>A condition that must be satisfied in order for
        a conditional update to
                    succeed.</p>
        :param expression_attribute_names: <p>One or more substitution tokens for
        attribute names in an expression.</p>
        :param expression_attribute_values: <p>One or more values that can be
        substituted in an expression.</p>
        :param return_values_on_condition_check_failure: <p>Use
        <code>ReturnValuesOnConditionCheckFailure</code> to get the item attributes if
        the
                        <code>Put</code> condition fails. For

        <code>ReturnValuesOnConditionCheckFailure</code>, the valid values are: NONE
        and
                    ALL_OLD.</p>
        """
        self.item = item
        self.table_name = table_name
        self.condition_expression = condition_expression
        self.expression_attribute_names = expression_attribute_names
        self.expression_attribute_values = expression_attribute_values
        self.return_values_on_condition_check_failure = return_values_on_condition_check_failure

    def as_dict(self) -> Dict[str, Any]:
        """Converts the Put to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        d: Dict[str, Any] = {
            "Item": _put_item_input_attribute_map_as_dict(self.item),
            "TableName": self.table_name,
        }

        if self.condition_expression is not None:
            d["ConditionExpression"] = self.condition_expression

        if self.expression_attribute_names is not None:
            d["ExpressionAttributeNames"] = self.expression_attribute_names

        if self.expression_attribute_values is not None:
            d["ExpressionAttributeValues"] = _expression_attribute_value_map_as_dict(self.expression_attribute_values),

        if self.return_values_on_condition_check_failure is not None:
            d["ReturnValuesOnConditionCheckFailure"] = self.return_values_on_condition_check_failure

        return d

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "Put":
        """Creates a Put from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {
            "item": _put_item_input_attribute_map_from_dict(d["Item"]),
            "table_name": d["TableName"],
        }

        if "ConditionExpression" in d:
            kwargs["condition_expression"] = d["ConditionExpression"]

        if "ExpressionAttributeNames" in d:
            kwargs["expression_attribute_names"] = d["ExpressionAttributeNames"]

        if "ExpressionAttributeValues" in d:
            kwargs["expression_attribute_values"] = _expression_attribute_value_map_from_dict(d["ExpressionAttributeValues"]),

        if "ReturnValuesOnConditionCheckFailure" in d:
            kwargs["return_values_on_condition_check_failure"] = d["ReturnValuesOnConditionCheckFailure"]

        return Put(**kwargs)

    def __repr__(self) -> str:
        result = "Put("
        if self.item is not None:
            result += f"item={repr(self.item)}, "

        if self.table_name is not None:
            result += f"table_name={repr(self.table_name)}, "

        if self.condition_expression is not None:
            result += f"condition_expression={repr(self.condition_expression)}, "

        if self.expression_attribute_names is not None:
            result += f"expression_attribute_names={repr(self.expression_attribute_names)}, "

        if self.expression_attribute_values is not None:
            result += f"expression_attribute_values={repr(self.expression_attribute_values)}, "

        if self.return_values_on_condition_check_failure is not None:
            result += f"return_values_on_condition_check_failure={repr(self.return_values_on_condition_check_failure)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, Put):
            return False
        attributes: list[str] = ['item','table_name','condition_expression','expression_attribute_names','expression_attribute_values','return_values_on_condition_check_failure',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class Update:
    key: 'dict[str, AttributeValue]'
    update_expression: str
    table_name: str
    condition_expression: Optional[str]
    expression_attribute_names: Optional[dict[str, str]]
    expression_attribute_values: Optional['dict[str, AttributeValue]']
    return_values_on_condition_check_failure: Optional[str]
    def __init__(
        self,
        *,
        key: 'dict[str, AttributeValue]',
        update_expression: str,
        table_name: str,
        condition_expression: Optional[str] = None,
        expression_attribute_names: Optional[dict[str, str]] = None,
        expression_attribute_values: Optional['dict[str, AttributeValue]'] = None,
        return_values_on_condition_check_failure: Optional[str] = None,
    ):
        """<p>Represents a request to perform an <code>UpdateItem</code> operation.</p>

        :param key: <p>The primary key of the item to be updated. Each element consists
        of an attribute name
                    and a value for that attribute.</p>
        :param update_expression: <p>An expression that defines one or more attributes
        to be updated, the action to be
                    performed on them, and new value(s)
        for them.</p>
        :param table_name: <p>Name of the table for the <code>UpdateItem</code>
        request.</p>
        :param condition_expression: <p>A condition that must be satisfied in order for
        a conditional update to
                    succeed.</p>
        :param expression_attribute_names: <p>One or more substitution tokens for
        attribute names in an expression.</p>
        :param expression_attribute_values: <p>One or more values that can be
        substituted in an expression.</p>
        :param return_values_on_condition_check_failure: <p>Use
        <code>ReturnValuesOnConditionCheckFailure</code> to get the item attributes if
        the
                        <code>Update</code> condition fails. For

        <code>ReturnValuesOnConditionCheckFailure</code>, the valid values are: NONE,

        ALL_OLD, UPDATED_OLD, ALL_NEW, UPDATED_NEW.</p>
        """
        self.key = key
        self.update_expression = update_expression
        self.table_name = table_name
        self.condition_expression = condition_expression
        self.expression_attribute_names = expression_attribute_names
        self.expression_attribute_values = expression_attribute_values
        self.return_values_on_condition_check_failure = return_values_on_condition_check_failure

    def as_dict(self) -> Dict[str, Any]:
        """Converts the Update to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        d: Dict[str, Any] = {
            "Key": _key_as_dict(self.key),
            "UpdateExpression": self.update_expression,
            "TableName": self.table_name,
        }

        if self.condition_expression is not None:
            d["ConditionExpression"] = self.condition_expression

        if self.expression_attribute_names is not None:
            d["ExpressionAttributeNames"] = self.expression_attribute_names

        if self.expression_attribute_values is not None:
            d["ExpressionAttributeValues"] = _expression_attribute_value_map_as_dict(self.expression_attribute_values),

        if self.return_values_on_condition_check_failure is not None:
            d["ReturnValuesOnConditionCheckFailure"] = self.return_values_on_condition_check_failure

        return d

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "Update":
        """Creates a Update from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {
            "key": _key_from_dict(d["Key"]),
            "update_expression": d["UpdateExpression"],
            "table_name": d["TableName"],
        }

        if "ConditionExpression" in d:
            kwargs["condition_expression"] = d["ConditionExpression"]

        if "ExpressionAttributeNames" in d:
            kwargs["expression_attribute_names"] = d["ExpressionAttributeNames"]

        if "ExpressionAttributeValues" in d:
            kwargs["expression_attribute_values"] = _expression_attribute_value_map_from_dict(d["ExpressionAttributeValues"]),

        if "ReturnValuesOnConditionCheckFailure" in d:
            kwargs["return_values_on_condition_check_failure"] = d["ReturnValuesOnConditionCheckFailure"]

        return Update(**kwargs)

    def __repr__(self) -> str:
        result = "Update("
        if self.key is not None:
            result += f"key={repr(self.key)}, "

        if self.update_expression is not None:
            result += f"update_expression={repr(self.update_expression)}, "

        if self.table_name is not None:
            result += f"table_name={repr(self.table_name)}, "

        if self.condition_expression is not None:
            result += f"condition_expression={repr(self.condition_expression)}, "

        if self.expression_attribute_names is not None:
            result += f"expression_attribute_names={repr(self.expression_attribute_names)}, "

        if self.expression_attribute_values is not None:
            result += f"expression_attribute_values={repr(self.expression_attribute_values)}, "

        if self.return_values_on_condition_check_failure is not None:
            result += f"return_values_on_condition_check_failure={repr(self.return_values_on_condition_check_failure)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, Update):
            return False
        attributes: list[str] = ['key','update_expression','table_name','condition_expression','expression_attribute_names','expression_attribute_values','return_values_on_condition_check_failure',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class DeleteItemOutput:
    attributes: Optional['dict[str, AttributeValue]']
    consumed_capacity: Optional[ConsumedCapacity]
    item_collection_metrics: Optional['ItemCollectionMetrics']
    def __init__(
        self,
        *,
        attributes: Optional['dict[str, AttributeValue]'] = None,
        consumed_capacity: Optional[ConsumedCapacity] = None,
        item_collection_metrics: Optional['ItemCollectionMetrics'] = None,
    ):
        """<p>Represents the output of a <code>DeleteItem</code> operation.</p>

        :param attributes: <p>A map of attribute names to <code>AttributeValue</code>
        objects, representing the item
                    as it appeared before the
        <code>DeleteItem</code> operation. This map appears in the
                    response
        only if <code>ReturnValues</code> was specified as <code>ALL_OLD</code> in the

        request.</p>
        :param consumed_capacity: <p>The capacity units consumed by the
        <code>DeleteItem</code> operation. The data
                    returned includes the
        total provisioned throughput consumed, along with statistics for
                    the
        table and any indexes involved in the operation. <code>ConsumedCapacity</code>
        is
                    only returned if the <code>ReturnConsumedCapacity</code>
        parameter was specified. For
                    more information, see <a
        href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/ProvisionedThroughputIntro.html">Provisioned
        Mode</a> in the <i>Amazon DynamoDB Developer
                        Guide</i>.</p>
        :param item_collection_metrics: <p>Information about item collections, if any,
        that were affected by the
                        <code>DeleteItem</code> operation.
        <code>ItemCollectionMetrics</code> is only
                    returned if the
        <code>ReturnItemCollectionMetrics</code> parameter was specified. If the

        table does not have any local secondary indexes, this information is not
        returned in the
                    response.</p>
                <p>Each
        <code>ItemCollectionMetrics</code> element consists of:</p>
                <ul>

        <li>
                        <p>
                            <code>ItemCollectionKey</code> -
        The partition key value of the item collection.
                            This is the
        same as the partition key value of the item itself.</p>
                    </li>

        <li>
                        <p>
                            <code>SizeEstimateRangeGB</code> -
        An estimate of item collection size, in
                            gigabytes. This
        value is a two-element array containing a lower bound and an

        upper bound for the estimate. The estimate includes the size of all the items
        in
                            the table, plus the size of all attributes projected into
        all of the local
                            secondary indexes on that table. Use this
        estimate to measure whether a local
                            secondary index is
        approaching its size limit.</p>
                        <p>The estimate is subject to
        change over time; therefore, do not rely on the
                            precision or
        accuracy of the estimate.</p>
                    </li>
                 </ul>
        """
        self.attributes = attributes
        self.consumed_capacity = consumed_capacity
        self.item_collection_metrics = item_collection_metrics

    def as_dict(self) -> Dict[str, Any]:
        """Converts the DeleteItemOutput to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        d: Dict[str, Any] = {}

        if self.attributes is not None:
            d["Attributes"] = _attribute_map_as_dict(self.attributes),

        if self.consumed_capacity is not None:
            d["ConsumedCapacity"] = self.consumed_capacity.as_dict()

        if self.item_collection_metrics is not None:
            d["ItemCollectionMetrics"] = self.item_collection_metrics.as_dict()

        return d

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "DeleteItemOutput":
        """Creates a DeleteItemOutput from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {}

        if "Attributes" in d:
            kwargs["attributes"] = _attribute_map_from_dict(d["Attributes"]),

        if "ConsumedCapacity" in d:
            kwargs["consumed_capacity"] = ConsumedCapacity.from_dict(d["ConsumedCapacity"])

        if "ItemCollectionMetrics" in d:
            kwargs["item_collection_metrics"] = ItemCollectionMetrics.from_dict(d["ItemCollectionMetrics"])

        return DeleteItemOutput(**kwargs)

    def __repr__(self) -> str:
        result = "DeleteItemOutput("
        if self.attributes is not None:
            result += f"attributes={repr(self.attributes)}, "

        if self.consumed_capacity is not None:
            result += f"consumed_capacity={repr(self.consumed_capacity)}, "

        if self.item_collection_metrics is not None:
            result += f"item_collection_metrics={repr(self.item_collection_metrics)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, DeleteItemOutput):
            return False
        attributes: list[str] = ['attributes','consumed_capacity','item_collection_metrics',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class ExecuteStatementOutput:
    items: Optional['list[dict[str, AttributeValue]]']
    next_token: Optional[str]
    consumed_capacity: Optional[ConsumedCapacity]
    last_evaluated_key: Optional['dict[str, AttributeValue]']
    def __init__(
        self,
        *,
        items: Optional['list[dict[str, AttributeValue]]'] = None,
        next_token: Optional[str] = None,
        consumed_capacity: Optional[ConsumedCapacity] = None,
        last_evaluated_key: Optional['dict[str, AttributeValue]'] = None,
    ):
        """
        :param items: <p>If a read operation was used, this property will contain the
        result of the read
                    operation; a map of attribute names and their
        values. For the write operations this
                    value will be empty.</p>
        :param next_token: <p>If the response of a read request exceeds the response
        payload limit DynamoDB will set
                    this value in the response. If set,
        you can use that this value in the subsequent
                    request to get the
        remaining results.</p>
        :param consumed_capacity: <p>The capacity units consumed by an operation. The
        data returned includes the total
                    provisioned throughput consumed,
        along with statistics for the table and any indexes
                    involved in the
        operation. <code>ConsumedCapacity</code> is only returned if the request

        asked for it. For more information, see <a
        href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/ProvisionedThroughputIntro.html">Provisioned
        Throughput</a> in the <i>Amazon DynamoDB Developer

        Guide</i>.</p>
        :param last_evaluated_key: <p>The primary key of the item where the operation
        stopped, inclusive of the previous
                    result set. Use this value to
        start a new operation, excluding this value in the new
                    request. If
        <code>LastEvaluatedKey</code> is empty, then the "last page" of results has

        been processed and there is no more data to be retrieved. If

        <code>LastEvaluatedKey</code> is not empty, it does not necessarily mean that
        there
                    is more data in the result set. The only way to know when you
        have reached the end of
                    the result set is when
        <code>LastEvaluatedKey</code> is empty. </p>
        """
        self.items = items
        self.next_token = next_token
        self.consumed_capacity = consumed_capacity
        self.last_evaluated_key = last_evaluated_key

    def as_dict(self) -> Dict[str, Any]:
        """Converts the ExecuteStatementOutput to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        d: Dict[str, Any] = {}

        if self.items is not None:
            d["Items"] = _item_list_as_dict(self.items),

        if self.next_token is not None:
            d["NextToken"] = self.next_token

        if self.consumed_capacity is not None:
            d["ConsumedCapacity"] = self.consumed_capacity.as_dict()

        if self.last_evaluated_key is not None:
            d["LastEvaluatedKey"] = _key_as_dict(self.last_evaluated_key),

        return d

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "ExecuteStatementOutput":
        """Creates a ExecuteStatementOutput from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {}

        if "Items" in d:
            kwargs["items"] = _item_list_from_dict(d["Items"]),

        if "NextToken" in d:
            kwargs["next_token"] = d["NextToken"]

        if "ConsumedCapacity" in d:
            kwargs["consumed_capacity"] = ConsumedCapacity.from_dict(d["ConsumedCapacity"])

        if "LastEvaluatedKey" in d:
            kwargs["last_evaluated_key"] = _key_from_dict(d["LastEvaluatedKey"]),

        return ExecuteStatementOutput(**kwargs)

    def __repr__(self) -> str:
        result = "ExecuteStatementOutput("
        if self.items is not None:
            result += f"items={repr(self.items)}, "

        if self.next_token is not None:
            result += f"next_token={repr(self.next_token)}, "

        if self.consumed_capacity is not None:
            result += f"consumed_capacity={repr(self.consumed_capacity)}, "

        if self.last_evaluated_key is not None:
            result += f"last_evaluated_key={repr(self.last_evaluated_key)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, ExecuteStatementOutput):
            return False
        attributes: list[str] = ['items','next_token','consumed_capacity','last_evaluated_key',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class PutItemOutput:
    attributes: Optional['dict[str, AttributeValue]']
    consumed_capacity: Optional[ConsumedCapacity]
    item_collection_metrics: Optional['ItemCollectionMetrics']
    def __init__(
        self,
        *,
        attributes: Optional['dict[str, AttributeValue]'] = None,
        consumed_capacity: Optional[ConsumedCapacity] = None,
        item_collection_metrics: Optional['ItemCollectionMetrics'] = None,
    ):
        """<p>Represents the output of a <code>PutItem</code> operation.</p>

        :param attributes: <p>The attribute values as they appeared before the
        <code>PutItem</code> operation, but
                    only if
        <code>ReturnValues</code> is specified as <code>ALL_OLD</code> in the request.

        Each element consists of an attribute name and an attribute value.</p>
        :param consumed_capacity: <p>The capacity units consumed by the
        <code>PutItem</code> operation. The data returned
                    includes the total
        provisioned throughput consumed, along with statistics for the table

        and any indexes involved in the operation. <code>ConsumedCapacity</code> is
        only
                    returned if the <code>ReturnConsumedCapacity</code> parameter
        was specified. For more
                    information, see <a
        href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/ProvisionedThroughputIntro.html">Read/Write
        Capacity Mode</a> in the <i>Amazon DynamoDB Developer

        Guide</i>.</p>
        :param item_collection_metrics: <p>Information about item collections, if any,
        that were affected by the
                        <code>PutItem</code> operation.
        <code>ItemCollectionMetrics</code> is only returned
                    if the
        <code>ReturnItemCollectionMetrics</code> parameter was specified. If the table

        does not have any local secondary indexes, this information is not returned in
        the
                    response.</p>
                <p>Each <code>ItemCollectionMetrics</code>
        element consists of:</p>
                <ul>
                    <li>
                        <p>

        <code>ItemCollectionKey</code> - The partition key value of the item
        collection.
                            This is the same as the partition key value of
        the item itself.</p>
                    </li>
                    <li>
                        <p>

        <code>SizeEstimateRangeGB</code> - An estimate of item collection size, in

        gigabytes. This value is a two-element array containing a lower bound and an

        upper bound for the estimate. The estimate includes the size of all the items
        in
                            the table, plus the size of all attributes projected into
        all of the local
                            secondary indexes on that table. Use this
        estimate to measure whether a local
                            secondary index is
        approaching its size limit.</p>
                        <p>The estimate is subject to
        change over time; therefore, do not rely on the
                            precision or
        accuracy of the estimate.</p>
                    </li>
                 </ul>
        """
        self.attributes = attributes
        self.consumed_capacity = consumed_capacity
        self.item_collection_metrics = item_collection_metrics

    def as_dict(self) -> Dict[str, Any]:
        """Converts the PutItemOutput to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        d: Dict[str, Any] = {}

        if self.attributes is not None:
            d["Attributes"] = _attribute_map_as_dict(self.attributes),

        if self.consumed_capacity is not None:
            d["ConsumedCapacity"] = self.consumed_capacity.as_dict()

        if self.item_collection_metrics is not None:
            d["ItemCollectionMetrics"] = self.item_collection_metrics.as_dict()

        return d

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "PutItemOutput":
        """Creates a PutItemOutput from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {}

        if "Attributes" in d:
            kwargs["attributes"] = _attribute_map_from_dict(d["Attributes"]),

        if "ConsumedCapacity" in d:
            kwargs["consumed_capacity"] = ConsumedCapacity.from_dict(d["ConsumedCapacity"])

        if "ItemCollectionMetrics" in d:
            kwargs["item_collection_metrics"] = ItemCollectionMetrics.from_dict(d["ItemCollectionMetrics"])

        return PutItemOutput(**kwargs)

    def __repr__(self) -> str:
        result = "PutItemOutput("
        if self.attributes is not None:
            result += f"attributes={repr(self.attributes)}, "

        if self.consumed_capacity is not None:
            result += f"consumed_capacity={repr(self.consumed_capacity)}, "

        if self.item_collection_metrics is not None:
            result += f"item_collection_metrics={repr(self.item_collection_metrics)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, PutItemOutput):
            return False
        attributes: list[str] = ['attributes','consumed_capacity','item_collection_metrics',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class QueryOutput:
    items: Optional['list[dict[str, AttributeValue]]']
    count: int
    scanned_count: int
    last_evaluated_key: Optional['dict[str, AttributeValue]']
    consumed_capacity: Optional[ConsumedCapacity]
    def __init__(
        self,
        *,
        items: Optional['list[dict[str, AttributeValue]]'] = None,
        count: int = 0,
        scanned_count: int = 0,
        last_evaluated_key: Optional['dict[str, AttributeValue]'] = None,
        consumed_capacity: Optional[ConsumedCapacity] = None,
    ):
        """<p>Represents the output of a <code>Query</code> operation.</p>

        :param items: <p>An array of item attributes that match the query criteria. Each
        element in this array
                    consists of an attribute name and the value
        for that attribute.</p>
        :param count: <p>The number of items in the response.</p>
                <p>If you used
        a <code>QueryFilter</code> in the request, then <code>Count</code> is the

        number of items returned after the filter was applied, and
        <code>ScannedCount</code> is
                    the number of matching items before the
        filter was applied.</p>
                <p>If you did not use a filter in the request,
        then <code>Count</code> and
                        <code>ScannedCount</code> are the
        same.</p>
        :param scanned_count: <p>The number of items evaluated, before any
        <code>QueryFilter</code> is applied. A high

        <code>ScannedCount</code> value with few, or no, <code>Count</code> results

        indicates an inefficient <code>Query</code> operation. For more information, see
        <a
        href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/QueryAndScan.html#Count">Count
        and
                        ScannedCount</a> in the <i>Amazon DynamoDB Developer

        Guide</i>.</p>
                <p>If you did not use a filter in the request, then
        <code>ScannedCount</code> is the same
                    as <code>Count</code>.</p>
        :param last_evaluated_key: <p>The primary key of the item where the operation
        stopped, inclusive of the previous
                    result set. Use this value to
        start a new operation, excluding this value in the new
                    request.</p>

        <p>If <code>LastEvaluatedKey</code> is empty, then the "last page" of results
        has been
                    processed and there is no more data to be retrieved.</p>

        <p>If <code>LastEvaluatedKey</code> is not empty, it does not necessarily mean
        that there
                    is more data in the result set. The only way to know when
        you have reached the end of
                    the result set is when
        <code>LastEvaluatedKey</code> is empty.</p>
        :param consumed_capacity: <p>The capacity units consumed by the
        <code>Query</code> operation. The data returned
                    includes the total
        provisioned throughput consumed, along with statistics for the table

        and any indexes involved in the operation. <code>ConsumedCapacity</code> is
        only
                    returned if the <code>ReturnConsumedCapacity</code> parameter
        was specified. For more
                    information, see <a
        href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/ProvisionedThroughputIntro.html">Provisioned
        Throughput</a> in the <i>Amazon DynamoDB Developer

        Guide</i>.</p>
        """
        self.items = items
        self.count = count
        self.scanned_count = scanned_count
        self.last_evaluated_key = last_evaluated_key
        self.consumed_capacity = consumed_capacity

    def as_dict(self) -> Dict[str, Any]:
        """Converts the QueryOutput to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        d: Dict[str, Any] = {}

        if self.items is not None:
            d["Items"] = _item_list_as_dict(self.items),

        if self.count is not None:
            d["Count"] = self.count

        if self.scanned_count is not None:
            d["ScannedCount"] = self.scanned_count

        if self.last_evaluated_key is not None:
            d["LastEvaluatedKey"] = _key_as_dict(self.last_evaluated_key),

        if self.consumed_capacity is not None:
            d["ConsumedCapacity"] = self.consumed_capacity.as_dict()

        return d

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "QueryOutput":
        """Creates a QueryOutput from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {}

        if "Items" in d:
            kwargs["items"] = _item_list_from_dict(d["Items"]),

        if "Count" in d:
            kwargs["count"] = d["Count"]

        if "ScannedCount" in d:
            kwargs["scanned_count"] = d["ScannedCount"]

        if "LastEvaluatedKey" in d:
            kwargs["last_evaluated_key"] = _key_from_dict(d["LastEvaluatedKey"]),

        if "ConsumedCapacity" in d:
            kwargs["consumed_capacity"] = ConsumedCapacity.from_dict(d["ConsumedCapacity"])

        return QueryOutput(**kwargs)

    def __repr__(self) -> str:
        result = "QueryOutput("
        if self.items is not None:
            result += f"items={repr(self.items)}, "

        if self.count is not None:
            result += f"count={repr(self.count)}, "

        if self.scanned_count is not None:
            result += f"scanned_count={repr(self.scanned_count)}, "

        if self.last_evaluated_key is not None:
            result += f"last_evaluated_key={repr(self.last_evaluated_key)}, "

        if self.consumed_capacity is not None:
            result += f"consumed_capacity={repr(self.consumed_capacity)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, QueryOutput):
            return False
        attributes: list[str] = ['items','count','scanned_count','last_evaluated_key','consumed_capacity',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class ScanOutput:
    items: Optional['list[dict[str, AttributeValue]]']
    count: int
    scanned_count: int
    last_evaluated_key: Optional['dict[str, AttributeValue]']
    consumed_capacity: Optional[ConsumedCapacity]
    def __init__(
        self,
        *,
        items: Optional['list[dict[str, AttributeValue]]'] = None,
        count: int = 0,
        scanned_count: int = 0,
        last_evaluated_key: Optional['dict[str, AttributeValue]'] = None,
        consumed_capacity: Optional[ConsumedCapacity] = None,
    ):
        """<p>Represents the output of a <code>Scan</code> operation.</p>

        :param items: <p>An array of item attributes that match the scan criteria. Each
        element in this array
                    consists of an attribute name and the value
        for that attribute.</p>
        :param count: <p>The number of items in the response.</p>
                <p>If you set
        <code>ScanFilter</code> in the request, then <code>Count</code> is the

        number of items returned after the filter was applied, and
        <code>ScannedCount</code> is
                    the number of matching items before the
        filter was applied.</p>
                <p>If you did not use a filter in the request,
        then <code>Count</code> is the same as

        <code>ScannedCount</code>.</p>
        :param scanned_count: <p>The number of items evaluated, before any
        <code>ScanFilter</code> is applied. A high

        <code>ScannedCount</code> value with few, or no, <code>Count</code> results

        indicates an inefficient <code>Scan</code> operation. For more information, see
        <a
        href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/QueryAndScan.html#Count">Count
        and
                        ScannedCount</a> in the <i>Amazon DynamoDB Developer

        Guide</i>.</p>
                <p>If you did not use a filter in the request, then
        <code>ScannedCount</code> is the same
                    as <code>Count</code>.</p>
        :param last_evaluated_key: <p>The primary key of the item where the operation
        stopped, inclusive of the previous
                    result set. Use this value to
        start a new operation, excluding this value in the new
                    request.</p>

        <p>If <code>LastEvaluatedKey</code> is empty, then the "last page" of results
        has been
                    processed and there is no more data to be retrieved.</p>

        <p>If <code>LastEvaluatedKey</code> is not empty, it does not necessarily mean
        that there
                    is more data in the result set. The only way to know when
        you have reached the end of
                    the result set is when
        <code>LastEvaluatedKey</code> is empty.</p>
        :param consumed_capacity: <p>The capacity units consumed by the
        <code>Scan</code> operation. The data returned
                    includes the total
        provisioned throughput consumed, along with statistics for the table

        and any indexes involved in the operation. <code>ConsumedCapacity</code> is
        only
                    returned if the <code>ReturnConsumedCapacity</code> parameter
        was specified. For more
                    information, see <a
        href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/ProvisionedThroughputIntro.html">Provisioned
        Throughput</a> in the <i>Amazon DynamoDB Developer

        Guide</i>.</p>
        """
        self.items = items
        self.count = count
        self.scanned_count = scanned_count
        self.last_evaluated_key = last_evaluated_key
        self.consumed_capacity = consumed_capacity

    def as_dict(self) -> Dict[str, Any]:
        """Converts the ScanOutput to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        d: Dict[str, Any] = {}

        if self.items is not None:
            d["Items"] = _item_list_as_dict(self.items),

        if self.count is not None:
            d["Count"] = self.count

        if self.scanned_count is not None:
            d["ScannedCount"] = self.scanned_count

        if self.last_evaluated_key is not None:
            d["LastEvaluatedKey"] = _key_as_dict(self.last_evaluated_key),

        if self.consumed_capacity is not None:
            d["ConsumedCapacity"] = self.consumed_capacity.as_dict()

        return d

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "ScanOutput":
        """Creates a ScanOutput from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {}

        if "Items" in d:
            kwargs["items"] = _item_list_from_dict(d["Items"]),

        if "Count" in d:
            kwargs["count"] = d["Count"]

        if "ScannedCount" in d:
            kwargs["scanned_count"] = d["ScannedCount"]

        if "LastEvaluatedKey" in d:
            kwargs["last_evaluated_key"] = _key_from_dict(d["LastEvaluatedKey"]),

        if "ConsumedCapacity" in d:
            kwargs["consumed_capacity"] = ConsumedCapacity.from_dict(d["ConsumedCapacity"])

        return ScanOutput(**kwargs)

    def __repr__(self) -> str:
        result = "ScanOutput("
        if self.items is not None:
            result += f"items={repr(self.items)}, "

        if self.count is not None:
            result += f"count={repr(self.count)}, "

        if self.scanned_count is not None:
            result += f"scanned_count={repr(self.scanned_count)}, "

        if self.last_evaluated_key is not None:
            result += f"last_evaluated_key={repr(self.last_evaluated_key)}, "

        if self.consumed_capacity is not None:
            result += f"consumed_capacity={repr(self.consumed_capacity)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, ScanOutput):
            return False
        attributes: list[str] = ['items','count','scanned_count','last_evaluated_key','consumed_capacity',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class UpdateItemOutput:
    attributes: Optional['dict[str, AttributeValue]']
    consumed_capacity: Optional[ConsumedCapacity]
    item_collection_metrics: Optional['ItemCollectionMetrics']
    def __init__(
        self,
        *,
        attributes: Optional['dict[str, AttributeValue]'] = None,
        consumed_capacity: Optional[ConsumedCapacity] = None,
        item_collection_metrics: Optional['ItemCollectionMetrics'] = None,
    ):
        """<p>Represents the output of an <code>UpdateItem</code> operation.</p>

        :param attributes: <p>A map of attribute values as they appear before or after
        the <code>UpdateItem</code>
                    operation, as determined by the
        <code>ReturnValues</code> parameter.</p>
                <p>The <code>Attributes</code>
        map is only present if <code>ReturnValues</code> was
                    specified as
        something other than <code>NONE</code> in the request. Each element

        represents one attribute.</p>
        :param consumed_capacity: <p>The capacity units consumed by the
        <code>UpdateItem</code> operation. The data
                    returned includes the
        total provisioned throughput consumed, along with statistics for
                    the
        table and any indexes involved in the operation. <code>ConsumedCapacity</code>
        is
                    only returned if the <code>ReturnConsumedCapacity</code>
        parameter was specified. For
                    more information, see <a
        href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/ProvisionedThroughputIntro.html">Provisioned
        Throughput</a> in the <i>Amazon DynamoDB Developer

        Guide</i>.</p>
        :param item_collection_metrics: <p>Information about item collections, if any,
        that were affected by the
                        <code>UpdateItem</code> operation.
        <code>ItemCollectionMetrics</code> is only
                    returned if the
        <code>ReturnItemCollectionMetrics</code> parameter was specified. If the

        table does not have any local secondary indexes, this information is not
        returned in the
                    response.</p>
                <p>Each
        <code>ItemCollectionMetrics</code> element consists of:</p>
                <ul>

        <li>
                        <p>
                            <code>ItemCollectionKey</code> -
        The partition key value of the item collection.
                            This is the
        same as the partition key value of the item itself.</p>
                    </li>

        <li>
                        <p>
                            <code>SizeEstimateRangeGB</code> -
        An estimate of item collection size, in
                            gigabytes. This
        value is a two-element array containing a lower bound and an

        upper bound for the estimate. The estimate includes the size of all the items
        in
                            the table, plus the size of all attributes projected into
        all of the local
                            secondary indexes on that table. Use this
        estimate to measure whether a local
                            secondary index is
        approaching its size limit.</p>
                        <p>The estimate is subject to
        change over time; therefore, do not rely on the
                            precision or
        accuracy of the estimate.</p>
                    </li>
                 </ul>
        """
        self.attributes = attributes
        self.consumed_capacity = consumed_capacity
        self.item_collection_metrics = item_collection_metrics

    def as_dict(self) -> Dict[str, Any]:
        """Converts the UpdateItemOutput to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        d: Dict[str, Any] = {}

        if self.attributes is not None:
            d["Attributes"] = _attribute_map_as_dict(self.attributes),

        if self.consumed_capacity is not None:
            d["ConsumedCapacity"] = self.consumed_capacity.as_dict()

        if self.item_collection_metrics is not None:
            d["ItemCollectionMetrics"] = self.item_collection_metrics.as_dict()

        return d

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "UpdateItemOutput":
        """Creates a UpdateItemOutput from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {}

        if "Attributes" in d:
            kwargs["attributes"] = _attribute_map_from_dict(d["Attributes"]),

        if "ConsumedCapacity" in d:
            kwargs["consumed_capacity"] = ConsumedCapacity.from_dict(d["ConsumedCapacity"])

        if "ItemCollectionMetrics" in d:
            kwargs["item_collection_metrics"] = ItemCollectionMetrics.from_dict(d["ItemCollectionMetrics"])

        return UpdateItemOutput(**kwargs)

    def __repr__(self) -> str:
        result = "UpdateItemOutput("
        if self.attributes is not None:
            result += f"attributes={repr(self.attributes)}, "

        if self.consumed_capacity is not None:
            result += f"consumed_capacity={repr(self.consumed_capacity)}, "

        if self.item_collection_metrics is not None:
            result += f"item_collection_metrics={repr(self.item_collection_metrics)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, UpdateItemOutput):
            return False
        attributes: list[str] = ['attributes','consumed_capacity','item_collection_metrics',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class WriteRequest:
    put_request: Optional['PutRequest']
    delete_request: Optional['DeleteRequest']
    def __init__(
        self,
        *,
        put_request: Optional['PutRequest'] = None,
        delete_request: Optional['DeleteRequest'] = None,
    ):
        """<p>Represents an operation to perform - either <code>DeleteItem</code> or

        <code>PutItem</code>. You can only request one of these operations, not both, in
        a
                    single <code>WriteRequest</code>. If you do need to perform both
        of these operations,
                    you need to provide two separate
        <code>WriteRequest</code> objects.</p>

        :param put_request: <p>A request to perform a <code>PutItem</code>
        operation.</p>
        :param delete_request: <p>A request to perform a <code>DeleteItem</code>
        operation.</p>
        """
        self.put_request = put_request
        self.delete_request = delete_request

    def as_dict(self) -> Dict[str, Any]:
        """Converts the WriteRequest to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        d: Dict[str, Any] = {}

        if self.put_request is not None:
            d["PutRequest"] = self.put_request.as_dict()

        if self.delete_request is not None:
            d["DeleteRequest"] = self.delete_request.as_dict()

        return d

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "WriteRequest":
        """Creates a WriteRequest from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {}

        if "PutRequest" in d:
            kwargs["put_request"] = PutRequest.from_dict(d["PutRequest"])

        if "DeleteRequest" in d:
            kwargs["delete_request"] = DeleteRequest.from_dict(d["DeleteRequest"])

        return WriteRequest(**kwargs)

    def __repr__(self) -> str:
        result = "WriteRequest("
        if self.put_request is not None:
            result += f"put_request={repr(self.put_request)}, "

        if self.delete_request is not None:
            result += f"delete_request={repr(self.delete_request)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, WriteRequest):
            return False
        attributes: list[str] = ['put_request','delete_request',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class BatchGetItemOutput:
    responses: Optional['dict[str, list[dict[str, AttributeValue]]]']
    unprocessed_keys: Optional['dict[str, KeysAndAttributes]']
    consumed_capacity: Optional[list[ConsumedCapacity]]
    def __init__(
        self,
        *,
        responses: Optional['dict[str, list[dict[str, AttributeValue]]]'] = None,
        unprocessed_keys: Optional['dict[str, KeysAndAttributes]'] = None,
        consumed_capacity: Optional[list[ConsumedCapacity]] = None,
    ):
        """<p>Represents the output of a <code>BatchGetItem</code> operation.</p>

        :param responses: <p>A map of table name to a list of items. Each object in
        <code>Responses</code> consists
                    of a table name, along with a map of
        attribute data consisting of the data type and
                    attribute value.</p>
        :param unprocessed_keys: <p>A map of tables and their respective keys that were
        not processed with the current
                    response. The
        <code>UnprocessedKeys</code> value is in the same form as

        <code>RequestItems</code>, so the value can be provided directly to a
        subsequent
                        <code>BatchGetItem</code> operation. For more
        information, see
                        <code>RequestItems</code> in the Request
        Parameters section.</p>
                <p>Each element consists of:</p>
                <ul>

        <li>
                        <p>
                            <code>Keys</code> - An array of
        primary key attribute values that define
                            specific items in
        the table.</p>
                    </li>
                    <li>
                        <p>

        <code>ProjectionExpression</code> - One or more attributes to be retrieved from

        the table or index. By default, all attributes are returned. If a requested

        attribute is not found, it does not appear in the result.</p>
                    </li>

        <li>
                        <p>
                            <code>ConsistentRead</code> - The
        consistency of a read operation. If set to

        <code>true</code>, then a strongly consistent read is used; otherwise, an

        eventually consistent read is used.</p>
                    </li>
                 </ul>

        <p>If there are no unprocessed keys remaining, the response contains an empty

        <code>UnprocessedKeys</code> map.</p>
        :param consumed_capacity: <p>The read capacity units consumed by the entire
        <code>BatchGetItem</code>
                    operation.</p>
                <p>Each element
        consists of:</p>
                <ul>
                    <li>
                        <p>

        <code>TableName</code> - The table that consumed the provisioned

        throughput.</p>
                    </li>
                    <li>
                        <p>

        <code>CapacityUnits</code> - The total number of capacity units consumed.</p>

        </li>
                 </ul>
        """
        self.responses = responses
        self.unprocessed_keys = unprocessed_keys
        self.consumed_capacity = consumed_capacity

    def as_dict(self) -> Dict[str, Any]:
        """Converts the BatchGetItemOutput to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        d: Dict[str, Any] = {}

        if self.responses is not None:
            d["Responses"] = _batch_get_response_map_as_dict(self.responses),

        if self.unprocessed_keys is not None:
            d["UnprocessedKeys"] = _batch_get_request_map_as_dict(self.unprocessed_keys),

        if self.consumed_capacity is not None:
            d["ConsumedCapacity"] = _consumed_capacity_multiple_as_dict(self.consumed_capacity),

        return d

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "BatchGetItemOutput":
        """Creates a BatchGetItemOutput from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {}

        if "Responses" in d:
            kwargs["responses"] = _batch_get_response_map_from_dict(d["Responses"]),

        if "UnprocessedKeys" in d:
            kwargs["unprocessed_keys"] = _batch_get_request_map_from_dict(d["UnprocessedKeys"]),

        if "ConsumedCapacity" in d:
            kwargs["consumed_capacity"] = _consumed_capacity_multiple_from_dict(d["ConsumedCapacity"]),

        return BatchGetItemOutput(**kwargs)

    def __repr__(self) -> str:
        result = "BatchGetItemOutput("
        if self.responses is not None:
            result += f"responses={repr(self.responses)}, "

        if self.unprocessed_keys is not None:
            result += f"unprocessed_keys={repr(self.unprocessed_keys)}, "

        if self.consumed_capacity is not None:
            result += f"consumed_capacity={repr(self.consumed_capacity)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, BatchGetItemOutput):
            return False
        attributes: list[str] = ['responses','unprocessed_keys','consumed_capacity',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class ScanInput:
    table_name: str
    index_name: Optional[str]
    attributes_to_get: Optional[list[str]]
    limit: Optional[int]
    select: Optional[str]
    scan_filter: Optional['dict[str, Condition]']
    conditional_operator: Optional[str]
    exclusive_start_key: Optional['dict[str, AttributeValue]']
    return_consumed_capacity: Optional[str]
    total_segments: Optional[int]
    segment: Optional[int]
    projection_expression: Optional[str]
    filter_expression: Optional[str]
    expression_attribute_names: Optional[dict[str, str]]
    expression_attribute_values: Optional['dict[str, AttributeValue]']
    consistent_read: Optional[bool]
    def __init__(
        self,
        *,
        table_name: str,
        index_name: Optional[str] = None,
        attributes_to_get: Optional[list[str]] = None,
        limit: Optional[int] = None,
        select: Optional[str] = None,
        scan_filter: Optional['dict[str, Condition]'] = None,
        conditional_operator: Optional[str] = None,
        exclusive_start_key: Optional['dict[str, AttributeValue]'] = None,
        return_consumed_capacity: Optional[str] = None,
        total_segments: Optional[int] = None,
        segment: Optional[int] = None,
        projection_expression: Optional[str] = None,
        filter_expression: Optional[str] = None,
        expression_attribute_names: Optional[dict[str, str]] = None,
        expression_attribute_values: Optional['dict[str, AttributeValue]'] = None,
        consistent_read: Optional[bool] = None,
    ):
        """<p>Represents the input of a <code>Scan</code> operation.</p>

        :param table_name: <p>The name of the table containing the requested items; or,
        if you provide
                        <code>IndexName</code>, the name of the table to
        which that index belongs.</p>
        :param index_name: <p>The name of a secondary index to scan. This index can be
        any local secondary index or
                    global secondary index. Note that if
        you use the <code>IndexName</code> parameter, you
                    must also provide
        <code>TableName</code>.</p>
        :param attributes_to_get: <p>This is a legacy parameter. Use
        <code>ProjectionExpression</code> instead. For more
                    information, see
        <a
        href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/LegacyConditionalParameters.AttributesToGet.html">AttributesToGet</a>
        in the <i>Amazon DynamoDB Developer
                    Guide</i>.</p>
        :param limit: <p>The maximum number of items to evaluate (not necessarily the
        number of matching
                    items). If DynamoDB processes the number of items
        up to the limit while processing the
                    results, it stops the operation
        and returns the matching values up to that point, and a
                    key in
        <code>LastEvaluatedKey</code> to apply in a subsequent operation, so that you
        can
                    pick up where you left off. Also, if the processed dataset size
        exceeds 1 MB before
                    DynamoDB reaches this limit, it stops the
        operation and returns the matching values up
                    to the limit, and a key
        in <code>LastEvaluatedKey</code> to apply in a subsequent
                    operation
        to continue the operation. For more information, see <a
        href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/QueryAndScan.html">Working
        with Queries</a> in the <i>Amazon DynamoDB Developer

        Guide</i>.</p>
        :param select: <p>The attributes to be returned in the result. You can retrieve
        all item attributes,
                    specific item attributes, the count of matching
        items, or in the case of an index, some
                    or all of the attributes
        projected into the index.</p>
                <ul>
                    <li>
                        <p>

        <code>ALL_ATTRIBUTES</code> - Returns all of the item attributes from the

        specified table or index. If you query a local secondary index, then for each

        matching item in the index, DynamoDB fetches the entire item from the parent

        table. If the index is configured to project all item attributes, then all of

        the data can be obtained from the local secondary index, and no fetching is

        required.</p>
                    </li>
                    <li>
                        <p>

        <code>ALL_PROJECTED_ATTRIBUTES</code> - Allowed only when querying an index.

        Retrieves all attributes that have been projected into the index. If the index

        is configured to project all attributes, this return value is equivalent to

        specifying <code>ALL_ATTRIBUTES</code>.</p>
                    </li>
                    <li>

        <p>
                            <code>COUNT</code> - Returns the number of matching
        items, rather than the
                            matching items themselves.</p>

        </li>
                    <li>
                        <p>

        <code>SPECIFIC_ATTRIBUTES</code> - Returns only the attributes listed in

        <code>ProjectionExpression</code>. This return value is equivalent to

        specifying <code>ProjectionExpression</code> without specifying any value for

        <code>Select</code>.</p>
                        <p>If you query or scan a local
        secondary index and request only attributes that
                            are
        projected into that index, the operation reads only the index and not the

        table. If any of the requested attributes are not projected into the local

        secondary index, DynamoDB fetches each of these attributes from the parent

        table. This extra fetching incurs additional throughput cost and latency.</p>

        <p>If you query or scan a global secondary index, you can only request
        attributes
                            that are projected into the index. Global
        secondary index queries cannot fetch
                            attributes from the
        parent table.</p>
                    </li>
                 </ul>
                <p>If neither
        <code>Select</code> nor <code>ProjectionExpression</code> are specified,

        DynamoDB defaults to <code>ALL_ATTRIBUTES</code> when accessing a table, and

        <code>ALL_PROJECTED_ATTRIBUTES</code> when accessing an index. You cannot use
        both
                        <code>Select</code> and <code>ProjectionExpression</code>
        together in a single
                    request, unless the value for
        <code>Select</code> is <code>SPECIFIC_ATTRIBUTES</code>.
                    (This usage
        is equivalent to specifying <code>ProjectionExpression</code> without any

        value for <code>Select</code>.)</p>
                <note>
                    <p>If you use the
        <code>ProjectionExpression</code> parameter, then the value for

        <code>Select</code> can only be <code>SPECIFIC_ATTRIBUTES</code>. Any other

        value for <code>Select</code> will return an error.</p>
                </note>
        :param scan_filter: <p>This is a legacy parameter. Use
        <code>FilterExpression</code> instead. For more
                    information, see <a
        href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/LegacyConditionalParameters.ScanFilter.html">ScanFilter</a>
        in the <i>Amazon DynamoDB Developer
                    Guide</i>.</p>
        :param conditional_operator: <p>This is a legacy parameter. Use
        <code>FilterExpression</code> instead. For more
                    information, see <a
        href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/LegacyConditionalParameters.ConditionalOperator.html">ConditionalOperator</a>
        in the <i>Amazon DynamoDB Developer
                        Guide</i>.</p>
        :param exclusive_start_key: <p>The primary key of the first item that this
        operation will evaluate. Use the value
                    that was returned for
        <code>LastEvaluatedKey</code> in the previous operation.</p>
                <p>The data
        type for <code>ExclusiveStartKey</code> must be String, Number or Binary. No

        set data types are allowed.</p>
                <p>In a parallel scan, a
        <code>Scan</code> request that includes

        <code>ExclusiveStartKey</code> must specify the same segment whose previous

        <code>Scan</code> returned the corresponding value of

        <code>LastEvaluatedKey</code>.</p>
        :param return_consumed_capacity: <p>Determines the level of detail about either
        provisioned or on-demand throughput
                    consumption that is returned in
        the response:</p>
                <ul>
                    <li>
                        <p>

        <code>INDEXES</code> - The response includes the aggregate

        <code>ConsumedCapacity</code> for the operation, together with

        <code>ConsumedCapacity</code> for each table and secondary index that was

        accessed.</p>
                        <p>Note that some operations, such as
        <code>GetItem</code> and
                                <code>BatchGetItem</code>, do
        not access any indexes at all. In these cases,
                            specifying
        <code>INDEXES</code> will only return <code>ConsumedCapacity</code>

        information for table(s).</p>
                    </li>
                    <li>

        <p>
                            <code>TOTAL</code> - The response includes only the
        aggregate
                                <code>ConsumedCapacity</code> for the
        operation.</p>
                    </li>
                    <li>
                        <p>

        <code>NONE</code> - No <code>ConsumedCapacity</code> details are included in
        the
                            response.</p>
                    </li>
                 </ul>
        :param total_segments: <p>For a parallel <code>Scan</code> request,
        <code>TotalSegments</code> represents the
                    total number of segments
        into which the <code>Scan</code> operation will be divided. The

        value of <code>TotalSegments</code> corresponds to the number of application
        workers
                    that will perform the parallel scan. For example, if you
        want to use four application
                    threads to scan a table or an index,
        specify a <code>TotalSegments</code> value of
                    4.</p>
                <p>The
        value for <code>TotalSegments</code> must be greater than or equal to 1, and
        less
                    than or equal to 1000000. If you specify a
        <code>TotalSegments</code> value of 1, the
                        <code>Scan</code>
        operation will be sequential rather than parallel.</p>
                <p>If you specify
        <code>TotalSegments</code>, you must also specify

        <code>Segment</code>.</p>
        :param segment: <p>For a parallel <code>Scan</code> request,
        <code>Segment</code> identifies an
                    individual segment to be scanned
        by an application worker.</p>
                <p>Segment IDs are zero-based, so the
        first segment is always 0. For example, if you want
                    to use four
        application threads to scan a table or an index, then the first thread

        specifies a <code>Segment</code> value of 0, the second thread specifies 1, and
        so
                    on.</p>
                <p>The value of <code>LastEvaluatedKey</code>
        returned from a parallel <code>Scan</code>
                    request must be used as
        <code>ExclusiveStartKey</code> with the same segment ID in a

        subsequent <code>Scan</code> operation.</p>
                <p>The value for
        <code>Segment</code> must be greater than or equal to 0, and less than

        the value provided for <code>TotalSegments</code>.</p>
                <p>If you provide
        <code>Segment</code>, you must also provide

        <code>TotalSegments</code>.</p>
        :param projection_expression: <p>A string that identifies one or more attributes
        to retrieve from the specified table
                    or index. These attributes can
        include scalars, sets, or elements of a JSON document.
                    The
        attributes in the expression must be separated by commas.</p>
                <p>If no
        attribute names are specified, then all attributes will be returned. If any of

        the requested attributes are not found, they will not appear in the result.</p>

        <p>For more information, see <a
        href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Expressions.AccessingItemAttributes.html">Specifying
        Item Attributes</a> in the <i>Amazon DynamoDB Developer

        Guide</i>.</p>
        :param filter_expression: <p>A string that contains conditions that DynamoDB
        applies after the <code>Scan</code>
                    operation, but before the data
        is returned to you. Items that do not satisfy the

        <code>FilterExpression</code> criteria are not returned.</p>
                <note>

        <p>A <code>FilterExpression</code> is applied after the items have already been
        read;
                        the process of filtering does not consume any additional
        read capacity units.</p>
                </note>
                <p>For more information, see <a
        href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/QueryAndScan.html#Query.FilterExpression">Filter
        Expressions</a> in the <i>Amazon DynamoDB Developer

        Guide</i>.</p>
        :param expression_attribute_names: <p>One or more substitution tokens for
        attribute names in an expression. The following
                    are some use cases
        for using <code>ExpressionAttributeNames</code>:</p>
                <ul>

        <li>
                        <p>To access an attribute whose name conflicts with a
        DynamoDB reserved
                            word.</p>
                    </li>

        <li>
                        <p>To create a placeholder for repeating occurrences of an
        attribute name in an
                            expression.</p>
                    </li>

        <li>
                        <p>To prevent special characters in an attribute name from
        being misinterpreted
                            in an expression.</p>

        </li>
                 </ul>
                <p>Use the <b>#</b> character in an expression to
        dereference
                    an attribute name. For example, consider the following
        attribute name:</p>
                <ul>
                    <li>
                        <p>

        <code>Percentile</code>
                        </p>
                    </li>
                 </ul>

        <p>The name of this attribute conflicts with a reserved word, so it cannot be
        used
                    directly in an expression. (For the complete list of reserved
        words, see <a
        href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/ReservedWords.html">Reserved
        Words</a> in the <i>Amazon DynamoDB Developer
                    Guide</i>). To work
        around this, you could specify the following for

        <code>ExpressionAttributeNames</code>:</p>
                <ul>
                    <li>

        <p>
                            <code>{"#P":"Percentile"}</code>
                        </p>

        </li>
                 </ul>
                <p>You could then use this substitution in an
        expression, as in this example:</p>
                <ul>
                    <li>

        <p>
                            <code>#P = :val</code>
                        </p>

        </li>
                 </ul>
                <note>
                    <p>Tokens that begin with the
        <b>:</b> character are
                            <i>expression attribute values</i>,
        which are placeholders for the
                        actual value at runtime.</p>

        </note>
                <p>For more information on expression attribute names, see <a
        href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Expressions.AccessingItemAttributes.html">Specifying
        Item Attributes</a> in the <i>Amazon DynamoDB Developer

        Guide</i>.</p>
        :param expression_attribute_values: <p>One or more values that can be
        substituted in an expression.</p>
                <p>Use the <b>:</b> (colon) character
        in an expression to
                    dereference an attribute value. For example,
        suppose that you wanted to check whether
                    the value of the
        <code>ProductStatus</code> attribute was one of the following: </p>
                <p>

        <code>Available | Backordered | Discontinued</code>
                </p>
                <p>You
        would first need to specify <code>ExpressionAttributeValues</code> as

        follows:</p>
                <p>
                    <code>{ ":avail":{"S":"Available"},
        ":back":{"S":"Backordered"},
                        ":disc":{"S":"Discontinued"}
        }</code>
                </p>
                <p>You could then use these values in an
        expression, such as this:</p>
                <p>
                    <code>ProductStatus IN
        (:avail, :back, :disc)</code>
                </p>
                <p>For more information on
        expression attribute values, see <a
        href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Expressions.SpecifyingConditions.html">Condition
        Expressions</a> in the <i>Amazon DynamoDB Developer

        Guide</i>.</p>
        :param consistent_read: <p>A Boolean value that determines the read consistency
        model during the scan:</p>
                <ul>
                    <li>
                        <p>If
        <code>ConsistentRead</code> is <code>false</code>, then the data returned

        from <code>Scan</code> might not contain the results from other recently

        completed write operations (<code>PutItem</code>, <code>UpdateItem</code>, or

        <code>DeleteItem</code>).</p>
                    </li>
                    <li>

        <p>If <code>ConsistentRead</code> is <code>true</code>, then all of the write

        operations that completed before the <code>Scan</code> began are guaranteed to

        be contained in the <code>Scan</code> response.</p>
                    </li>

        </ul>
                <p>The default setting for <code>ConsistentRead</code> is
        <code>false</code>.</p>
                <p>The <code>ConsistentRead</code> parameter is
        not supported on global secondary
                    indexes. If you scan a global
        secondary index with <code>ConsistentRead</code> set to
                    true, you
        will receive a <code>ValidationException</code>.</p>
        """
        self.table_name = table_name
        self.index_name = index_name
        self.attributes_to_get = attributes_to_get
        self.limit = limit
        self.select = select
        self.scan_filter = scan_filter
        self.conditional_operator = conditional_operator
        self.exclusive_start_key = exclusive_start_key
        self.return_consumed_capacity = return_consumed_capacity
        self.total_segments = total_segments
        self.segment = segment
        self.projection_expression = projection_expression
        self.filter_expression = filter_expression
        self.expression_attribute_names = expression_attribute_names
        self.expression_attribute_values = expression_attribute_values
        self.consistent_read = consistent_read

    def as_dict(self) -> Dict[str, Any]:
        """Converts the ScanInput to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        d: Dict[str, Any] = {
            "TableName": self.table_name,
        }

        if self.index_name is not None:
            d["IndexName"] = self.index_name

        if self.attributes_to_get is not None:
            d["AttributesToGet"] = self.attributes_to_get

        if self.limit is not None:
            d["Limit"] = self.limit

        if self.select is not None:
            d["Select"] = self.select

        if self.scan_filter is not None:
            d["ScanFilter"] = _filter_condition_map_as_dict(self.scan_filter),

        if self.conditional_operator is not None:
            d["ConditionalOperator"] = self.conditional_operator

        if self.exclusive_start_key is not None:
            d["ExclusiveStartKey"] = _key_as_dict(self.exclusive_start_key),

        if self.return_consumed_capacity is not None:
            d["ReturnConsumedCapacity"] = self.return_consumed_capacity

        if self.total_segments is not None:
            d["TotalSegments"] = self.total_segments

        if self.segment is not None:
            d["Segment"] = self.segment

        if self.projection_expression is not None:
            d["ProjectionExpression"] = self.projection_expression

        if self.filter_expression is not None:
            d["FilterExpression"] = self.filter_expression

        if self.expression_attribute_names is not None:
            d["ExpressionAttributeNames"] = self.expression_attribute_names

        if self.expression_attribute_values is not None:
            d["ExpressionAttributeValues"] = _expression_attribute_value_map_as_dict(self.expression_attribute_values),

        if self.consistent_read is not None:
            d["ConsistentRead"] = self.consistent_read

        return d

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "ScanInput":
        """Creates a ScanInput from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {
            "table_name": d["TableName"],
        }

        if "IndexName" in d:
            kwargs["index_name"] = d["IndexName"]

        if "AttributesToGet" in d:
            kwargs["attributes_to_get"] = d["AttributesToGet"]

        if "Limit" in d:
            kwargs["limit"] = d["Limit"]

        if "Select" in d:
            kwargs["select"] = d["Select"]

        if "ScanFilter" in d:
            kwargs["scan_filter"] = _filter_condition_map_from_dict(d["ScanFilter"]),

        if "ConditionalOperator" in d:
            kwargs["conditional_operator"] = d["ConditionalOperator"]

        if "ExclusiveStartKey" in d:
            kwargs["exclusive_start_key"] = _key_from_dict(d["ExclusiveStartKey"]),

        if "ReturnConsumedCapacity" in d:
            kwargs["return_consumed_capacity"] = d["ReturnConsumedCapacity"]

        if "TotalSegments" in d:
            kwargs["total_segments"] = d["TotalSegments"]

        if "Segment" in d:
            kwargs["segment"] = d["Segment"]

        if "ProjectionExpression" in d:
            kwargs["projection_expression"] = d["ProjectionExpression"]

        if "FilterExpression" in d:
            kwargs["filter_expression"] = d["FilterExpression"]

        if "ExpressionAttributeNames" in d:
            kwargs["expression_attribute_names"] = d["ExpressionAttributeNames"]

        if "ExpressionAttributeValues" in d:
            kwargs["expression_attribute_values"] = _expression_attribute_value_map_from_dict(d["ExpressionAttributeValues"]),

        if "ConsistentRead" in d:
            kwargs["consistent_read"] = d["ConsistentRead"]

        return ScanInput(**kwargs)

    def __repr__(self) -> str:
        result = "ScanInput("
        if self.table_name is not None:
            result += f"table_name={repr(self.table_name)}, "

        if self.index_name is not None:
            result += f"index_name={repr(self.index_name)}, "

        if self.attributes_to_get is not None:
            result += f"attributes_to_get={repr(self.attributes_to_get)}, "

        if self.limit is not None:
            result += f"limit={repr(self.limit)}, "

        if self.select is not None:
            result += f"select={repr(self.select)}, "

        if self.scan_filter is not None:
            result += f"scan_filter={repr(self.scan_filter)}, "

        if self.conditional_operator is not None:
            result += f"conditional_operator={repr(self.conditional_operator)}, "

        if self.exclusive_start_key is not None:
            result += f"exclusive_start_key={repr(self.exclusive_start_key)}, "

        if self.return_consumed_capacity is not None:
            result += f"return_consumed_capacity={repr(self.return_consumed_capacity)}, "

        if self.total_segments is not None:
            result += f"total_segments={repr(self.total_segments)}, "

        if self.segment is not None:
            result += f"segment={repr(self.segment)}, "

        if self.projection_expression is not None:
            result += f"projection_expression={repr(self.projection_expression)}, "

        if self.filter_expression is not None:
            result += f"filter_expression={repr(self.filter_expression)}, "

        if self.expression_attribute_names is not None:
            result += f"expression_attribute_names={repr(self.expression_attribute_names)}, "

        if self.expression_attribute_values is not None:
            result += f"expression_attribute_values={repr(self.expression_attribute_values)}, "

        if self.consistent_read is not None:
            result += f"consistent_read={repr(self.consistent_read)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, ScanInput):
            return False
        attributes: list[str] = ['table_name','index_name','attributes_to_get','limit','select','scan_filter','conditional_operator','exclusive_start_key','return_consumed_capacity','total_segments','segment','projection_expression','filter_expression','expression_attribute_names','expression_attribute_values','consistent_read',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class BatchWriteItemInput:
    request_items: 'dict[str, list[WriteRequest]]'
    return_consumed_capacity: Optional[str]
    return_item_collection_metrics: Optional[str]
    def __init__(
        self,
        *,
        request_items: 'dict[str, list[WriteRequest]]',
        return_consumed_capacity: Optional[str] = None,
        return_item_collection_metrics: Optional[str] = None,
    ):
        """<p>Represents the input of a <code>BatchWriteItem</code> operation.</p>

        :param request_items: <p>A map of one or more table names and, for each table, a
        list of operations to be
                    performed (<code>DeleteRequest</code> or
        <code>PutRequest</code>). Each element in the
                    map consists of the
        following:</p>
                <ul>
                    <li>
                        <p>

        <code>DeleteRequest</code> - Perform a <code>DeleteItem</code> operation on the

        specified item. The item to be deleted is identified by a <code>Key</code>

        subelement:</p>
                        <ul>
                          <li>

        <p>
                                    <code>Key</code> - A map of primary key
        attribute values that uniquely
                                    identify the item.
        Each entry in this map consists of an attribute name

        and an attribute value. For each primary key, you must provide

        <i>all</i> of the key attributes. For example, with a

        simple primary key, you only need to provide a value for the partition

        key. For a composite primary key, you must provide values for

        <i>both</i> the partition key and the sort key.</p>
                            </li>

        </ul>
                    </li>
                    <li>
                        <p>

        <code>PutRequest</code> - Perform a <code>PutItem</code> operation on the

        specified item. The item to be put is identified by an <code>Item</code>

        subelement:</p>
                        <ul>
                          <li>

        <p>
                                    <code>Item</code> - A map of attributes and
        their values. Each entry in
                                    this map consists of an
        attribute name and an attribute value. Attribute

        values must not be null; string and binary type attributes must have

        lengths greater than zero; and set type attributes must not be empty.

        Requests that contain empty values are rejected with a

        <code>ValidationException</code> exception.</p>
                                <p>If
        you specify any attributes that are part of an index key, then the

        data types for those attributes must match those of the schema in the

        table's attribute definition.</p>
                            </li>

        </ul>
                    </li>
                 </ul>
        :param return_consumed_capacity: <p>Determines the level of detail about either
        provisioned or on-demand throughput
                    consumption that is returned in
        the response:</p>
                <ul>
                    <li>
                        <p>

        <code>INDEXES</code> - The response includes the aggregate

        <code>ConsumedCapacity</code> for the operation, together with

        <code>ConsumedCapacity</code> for each table and secondary index that was

        accessed.</p>
                        <p>Note that some operations, such as
        <code>GetItem</code> and
                                <code>BatchGetItem</code>, do
        not access any indexes at all. In these cases,
                            specifying
        <code>INDEXES</code> will only return <code>ConsumedCapacity</code>

        information for table(s).</p>
                    </li>
                    <li>

        <p>
                            <code>TOTAL</code> - The response includes only the
        aggregate
                                <code>ConsumedCapacity</code> for the
        operation.</p>
                    </li>
                    <li>
                        <p>

        <code>NONE</code> - No <code>ConsumedCapacity</code> details are included in
        the
                            response.</p>
                    </li>
                 </ul>
        :param return_item_collection_metrics: <p>Determines whether item collection
        metrics are returned. If set to <code>SIZE</code>,
                    the response
        includes statistics about item collections, if any, that were modified

        during the operation are returned in the response. If set to <code>NONE</code>
        (the
                    default), no statistics are returned.</p>
        """
        self.request_items = request_items
        self.return_consumed_capacity = return_consumed_capacity
        self.return_item_collection_metrics = return_item_collection_metrics

    def as_dict(self) -> Dict[str, Any]:
        """Converts the BatchWriteItemInput to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        d: Dict[str, Any] = {
            "RequestItems": _batch_write_item_request_map_as_dict(self.request_items),
        }

        if self.return_consumed_capacity is not None:
            d["ReturnConsumedCapacity"] = self.return_consumed_capacity

        if self.return_item_collection_metrics is not None:
            d["ReturnItemCollectionMetrics"] = self.return_item_collection_metrics

        return d

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "BatchWriteItemInput":
        """Creates a BatchWriteItemInput from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {
            "request_items": _batch_write_item_request_map_from_dict(d["RequestItems"]),
        }

        if "ReturnConsumedCapacity" in d:
            kwargs["return_consumed_capacity"] = d["ReturnConsumedCapacity"]

        if "ReturnItemCollectionMetrics" in d:
            kwargs["return_item_collection_metrics"] = d["ReturnItemCollectionMetrics"]

        return BatchWriteItemInput(**kwargs)

    def __repr__(self) -> str:
        result = "BatchWriteItemInput("
        if self.request_items is not None:
            result += f"request_items={repr(self.request_items)}, "

        if self.return_consumed_capacity is not None:
            result += f"return_consumed_capacity={repr(self.return_consumed_capacity)}, "

        if self.return_item_collection_metrics is not None:
            result += f"return_item_collection_metrics={repr(self.return_item_collection_metrics)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, BatchWriteItemInput):
            return False
        attributes: list[str] = ['request_items','return_consumed_capacity','return_item_collection_metrics',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class DeleteItemInput:
    table_name: str
    key: 'dict[str, AttributeValue]'
    expected: Optional['dict[str, ExpectedAttributeValue]']
    conditional_operator: Optional[str]
    return_values: Optional[str]
    return_consumed_capacity: Optional[str]
    return_item_collection_metrics: Optional[str]
    condition_expression: Optional[str]
    expression_attribute_names: Optional[dict[str, str]]
    expression_attribute_values: Optional['dict[str, AttributeValue]']
    def __init__(
        self,
        *,
        table_name: str,
        key: 'dict[str, AttributeValue]',
        expected: Optional['dict[str, ExpectedAttributeValue]'] = None,
        conditional_operator: Optional[str] = None,
        return_values: Optional[str] = None,
        return_consumed_capacity: Optional[str] = None,
        return_item_collection_metrics: Optional[str] = None,
        condition_expression: Optional[str] = None,
        expression_attribute_names: Optional[dict[str, str]] = None,
        expression_attribute_values: Optional['dict[str, AttributeValue]'] = None,
    ):
        """<p>Represents the input of a <code>DeleteItem</code> operation.</p>

        :param table_name: <p>The name of the table from which to delete the item.</p>
        :param key: <p>A map of attribute names to <code>AttributeValue</code> objects,
        representing the
                    primary key of the item to delete.</p>

        <p>For the primary key, you must provide all of the attributes. For example,
        with a
                    simple primary key, you only need to provide a value for the
        partition key. For a
                    composite primary key, you must provide values
        for both the partition key and the sort
                    key.</p>
        :param expected: <p>This is a legacy parameter. Use
        <code>ConditionExpression</code> instead. For more
                    information, see
        <a
        href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/LegacyConditionalParameters.Expected.html">Expected</a>
        in the <i>Amazon DynamoDB Developer
                    Guide</i>.</p>
        :param conditional_operator: <p>This is a legacy parameter. Use
        <code>ConditionExpression</code> instead. For more
                    information, see
        <a
        href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/LegacyConditionalParameters.ConditionalOperator.html">ConditionalOperator</a>
        in the <i>Amazon DynamoDB Developer
                        Guide</i>.</p>
        :param return_values: <p>Use <code>ReturnValues</code> if you want to get the
        item attributes as they appeared
                    before they were deleted. For
        <code>DeleteItem</code>, the valid values are:</p>
                <ul>

        <li>
                        <p>
                            <code>NONE</code> - If
        <code>ReturnValues</code> is not specified, or if its
                            value
        is <code>NONE</code>, then nothing is returned. (This setting is the

        default for <code>ReturnValues</code>.)</p>
                    </li>
                    <li>

        <p>
                            <code>ALL_OLD</code> - The content of the old item is
        returned.</p>
                    </li>
                 </ul>
                <p>There is no additional
        cost associated with requesting a return value aside from the small

        network and processing overhead of receiving a larger response. No read capacity
        units are
                    consumed.</p>
                <note>
                    <p>The
        <code>ReturnValues</code> parameter is used by several DynamoDB operations;

        however, <code>DeleteItem</code> does not recognize any values other than

        <code>NONE</code> or <code>ALL_OLD</code>.</p>
                </note>
        :param return_consumed_capacity: <p>Determines the level of detail about either
        provisioned or on-demand throughput
                    consumption that is returned in
        the response:</p>
                <ul>
                    <li>
                        <p>

        <code>INDEXES</code> - The response includes the aggregate

        <code>ConsumedCapacity</code> for the operation, together with

        <code>ConsumedCapacity</code> for each table and secondary index that was

        accessed.</p>
                        <p>Note that some operations, such as
        <code>GetItem</code> and
                                <code>BatchGetItem</code>, do
        not access any indexes at all. In these cases,
                            specifying
        <code>INDEXES</code> will only return <code>ConsumedCapacity</code>

        information for table(s).</p>
                    </li>
                    <li>

        <p>
                            <code>TOTAL</code> - The response includes only the
        aggregate
                                <code>ConsumedCapacity</code> for the
        operation.</p>
                    </li>
                    <li>
                        <p>

        <code>NONE</code> - No <code>ConsumedCapacity</code> details are included in
        the
                            response.</p>
                    </li>
                 </ul>
        :param return_item_collection_metrics: <p>Determines whether item collection
        metrics are returned. If set to <code>SIZE</code>,
                    the response
        includes statistics about item collections, if any, that were modified

        during the operation are returned in the response. If set to <code>NONE</code>
        (the
                    default), no statistics are returned.</p>
        :param condition_expression: <p>A condition that must be satisfied in order for
        a conditional <code>DeleteItem</code>
                    to succeed.</p>
                <p>An
        expression can contain any of the following:</p>
                <ul>
                    <li>

        <p>Functions: <code>attribute_exists | attribute_not_exists | attribute_type |

        contains | begins_with | size</code>
                        </p>

        <p>These function names are case-sensitive.</p>
                    </li>

        <li>
                        <p>Comparison operators: <code>= | <> |
                    < | > |
        <= | >= |
                    BETWEEN | IN </code>
                        </p>

        </li>
                    <li>
                        <p> Logical operators: <code>AND | OR |
        NOT</code>
                        </p>
                    </li>
                 </ul>
                <p>For
        more information about condition expressions, see <a
        href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Expressions.SpecifyingConditions.html">Condition
        Expressions</a> in the <i>Amazon DynamoDB Developer

        Guide</i>.</p>
        :param expression_attribute_names: <p>One or more substitution tokens for
        attribute names in an expression. The following
                    are some use cases
        for using <code>ExpressionAttributeNames</code>:</p>
                <ul>

        <li>
                        <p>To access an attribute whose name conflicts with a
        DynamoDB reserved
                            word.</p>
                    </li>

        <li>
                        <p>To create a placeholder for repeating occurrences of an
        attribute name in an
                            expression.</p>
                    </li>

        <li>
                        <p>To prevent special characters in an attribute name from
        being misinterpreted
                            in an expression.</p>

        </li>
                 </ul>
                <p>Use the <b>#</b> character in an expression to
        dereference
                    an attribute name. For example, consider the following
        attribute name:</p>
                <ul>
                    <li>
                        <p>

        <code>Percentile</code>
                        </p>
                    </li>
                 </ul>

        <p>The name of this attribute conflicts with a reserved word, so it cannot be
        used
                    directly in an expression. (For the complete list of reserved
        words, see <a
        href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/ReservedWords.html">Reserved
        Words</a> in the <i>Amazon DynamoDB Developer
                    Guide</i>). To work
        around this, you could specify the following for

        <code>ExpressionAttributeNames</code>:</p>
                <ul>
                    <li>

        <p>
                            <code>{"#P":"Percentile"}</code>
                        </p>

        </li>
                 </ul>
                <p>You could then use this substitution in an
        expression, as in this example:</p>
                <ul>
                    <li>

        <p>
                            <code>#P = :val</code>
                        </p>

        </li>
                 </ul>
                <note>
                    <p>Tokens that begin with the
        <b>:</b> character are
                            <i>expression attribute values</i>,
        which are placeholders for the
                        actual value at runtime.</p>

        </note>
                <p>For more information on expression attribute names, see <a
        href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Expressions.AccessingItemAttributes.html">Specifying
        Item Attributes</a> in the <i>Amazon DynamoDB Developer

        Guide</i>.</p>
        :param expression_attribute_values: <p>One or more values that can be
        substituted in an expression.</p>
                <p>Use the <b>:</b> (colon) character
        in an expression to
                    dereference an attribute value. For example,
        suppose that you wanted to check whether
                    the value of the
        <i>ProductStatus</i> attribute was one of the following: </p>
                <p>

        <code>Available | Backordered | Discontinued</code>
                </p>
                <p>You
        would first need to specify <code>ExpressionAttributeValues</code> as

        follows:</p>
                <p>
                    <code>{ ":avail":{"S":"Available"},
        ":back":{"S":"Backordered"},
                        ":disc":{"S":"Discontinued"}
        }</code>
                </p>
                <p>You could then use these values in an
        expression, such as this:</p>
                <p>
                    <code>ProductStatus IN
        (:avail, :back, :disc)</code>
                </p>
                <p>For more information on
        expression attribute values, see <a
        href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Expressions.SpecifyingConditions.html">Condition
        Expressions</a> in the <i>Amazon DynamoDB Developer

        Guide</i>.</p>
        """
        self.table_name = table_name
        self.key = key
        self.expected = expected
        self.conditional_operator = conditional_operator
        self.return_values = return_values
        self.return_consumed_capacity = return_consumed_capacity
        self.return_item_collection_metrics = return_item_collection_metrics
        self.condition_expression = condition_expression
        self.expression_attribute_names = expression_attribute_names
        self.expression_attribute_values = expression_attribute_values

    def as_dict(self) -> Dict[str, Any]:
        """Converts the DeleteItemInput to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        d: Dict[str, Any] = {
            "TableName": self.table_name,
            "Key": _key_as_dict(self.key),
        }

        if self.expected is not None:
            d["Expected"] = _expected_attribute_map_as_dict(self.expected),

        if self.conditional_operator is not None:
            d["ConditionalOperator"] = self.conditional_operator

        if self.return_values is not None:
            d["ReturnValues"] = self.return_values

        if self.return_consumed_capacity is not None:
            d["ReturnConsumedCapacity"] = self.return_consumed_capacity

        if self.return_item_collection_metrics is not None:
            d["ReturnItemCollectionMetrics"] = self.return_item_collection_metrics

        if self.condition_expression is not None:
            d["ConditionExpression"] = self.condition_expression

        if self.expression_attribute_names is not None:
            d["ExpressionAttributeNames"] = self.expression_attribute_names

        if self.expression_attribute_values is not None:
            d["ExpressionAttributeValues"] = _expression_attribute_value_map_as_dict(self.expression_attribute_values),

        return d

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "DeleteItemInput":
        """Creates a DeleteItemInput from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {
            "table_name": d["TableName"],
            "key": _key_from_dict(d["Key"]),
        }

        if "Expected" in d:
            kwargs["expected"] = _expected_attribute_map_from_dict(d["Expected"]),

        if "ConditionalOperator" in d:
            kwargs["conditional_operator"] = d["ConditionalOperator"]

        if "ReturnValues" in d:
            kwargs["return_values"] = d["ReturnValues"]

        if "ReturnConsumedCapacity" in d:
            kwargs["return_consumed_capacity"] = d["ReturnConsumedCapacity"]

        if "ReturnItemCollectionMetrics" in d:
            kwargs["return_item_collection_metrics"] = d["ReturnItemCollectionMetrics"]

        if "ConditionExpression" in d:
            kwargs["condition_expression"] = d["ConditionExpression"]

        if "ExpressionAttributeNames" in d:
            kwargs["expression_attribute_names"] = d["ExpressionAttributeNames"]

        if "ExpressionAttributeValues" in d:
            kwargs["expression_attribute_values"] = _expression_attribute_value_map_from_dict(d["ExpressionAttributeValues"]),

        return DeleteItemInput(**kwargs)

    def __repr__(self) -> str:
        result = "DeleteItemInput("
        if self.table_name is not None:
            result += f"table_name={repr(self.table_name)}, "

        if self.key is not None:
            result += f"key={repr(self.key)}, "

        if self.expected is not None:
            result += f"expected={repr(self.expected)}, "

        if self.conditional_operator is not None:
            result += f"conditional_operator={repr(self.conditional_operator)}, "

        if self.return_values is not None:
            result += f"return_values={repr(self.return_values)}, "

        if self.return_consumed_capacity is not None:
            result += f"return_consumed_capacity={repr(self.return_consumed_capacity)}, "

        if self.return_item_collection_metrics is not None:
            result += f"return_item_collection_metrics={repr(self.return_item_collection_metrics)}, "

        if self.condition_expression is not None:
            result += f"condition_expression={repr(self.condition_expression)}, "

        if self.expression_attribute_names is not None:
            result += f"expression_attribute_names={repr(self.expression_attribute_names)}, "

        if self.expression_attribute_values is not None:
            result += f"expression_attribute_values={repr(self.expression_attribute_values)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, DeleteItemInput):
            return False
        attributes: list[str] = ['table_name','key','expected','conditional_operator','return_values','return_consumed_capacity','return_item_collection_metrics','condition_expression','expression_attribute_names','expression_attribute_values',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class PutItemInput:
    table_name: str
    item: 'dict[str, AttributeValue]'
    expected: Optional['dict[str, ExpectedAttributeValue]']
    return_values: Optional[str]
    return_consumed_capacity: Optional[str]
    return_item_collection_metrics: Optional[str]
    conditional_operator: Optional[str]
    condition_expression: Optional[str]
    expression_attribute_names: Optional[dict[str, str]]
    expression_attribute_values: Optional['dict[str, AttributeValue]']
    def __init__(
        self,
        *,
        table_name: str,
        item: 'dict[str, AttributeValue]',
        expected: Optional['dict[str, ExpectedAttributeValue]'] = None,
        return_values: Optional[str] = None,
        return_consumed_capacity: Optional[str] = None,
        return_item_collection_metrics: Optional[str] = None,
        conditional_operator: Optional[str] = None,
        condition_expression: Optional[str] = None,
        expression_attribute_names: Optional[dict[str, str]] = None,
        expression_attribute_values: Optional['dict[str, AttributeValue]'] = None,
    ):
        """<p>Represents the input of a <code>PutItem</code> operation.</p>

        :param table_name: <p>The name of the table to contain the item.</p>
        :param item: <p>A map of attribute name/value pairs, one for each attribute.
        Only the primary key
                    attributes are required; you can optionally
        provide other attribute name-value pairs for
                    the item.</p>

        <p>You must provide all of the attributes for the primary key. For example, with
        a simple
                    primary key, you only need to provide a value for the
        partition key. For a composite
                    primary key, you must provide both
        values for both the partition key and the sort
                    key.</p>

        <p>If you specify any attributes that are part of an index key, then the data
        types for
                    those attributes must match those of the schema in the
        table's attribute
                    definition.</p>
                <p>Empty String and Binary
        attribute values are allowed. Attribute values of type String
                    and
        Binary must have a length greater than zero if the attribute is used as a key

        attribute for a table or index.</p>

                <p>For more information about
        primary keys, see <a
        href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/HowItWorks.CoreComponents.html#HowItWorks.CoreComponents.PrimaryKey">Primary
        Key</a> in the <i>Amazon DynamoDB Developer
                    Guide</i>.</p>

        <p>Each element in the <code>Item</code> map is an <code>AttributeValue</code>

        object.</p>
        :param expected: <p>This is a legacy parameter. Use
        <code>ConditionExpression</code> instead. For more
                    information, see
        <a
        href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/LegacyConditionalParameters.Expected.html">Expected</a>
        in the <i>Amazon DynamoDB Developer
                    Guide</i>.</p>
        :param return_values: <p>Use <code>ReturnValues</code> if you want to get the
        item attributes as they appeared
                    before they were updated with the
        <code>PutItem</code> request. For
                    <code>PutItem</code>, the valid
        values are:</p>
                <ul>
                    <li>
                        <p>

        <code>NONE</code> - If <code>ReturnValues</code> is not specified, or if its

        value is <code>NONE</code>, then nothing is returned. (This setting is the

        default for <code>ReturnValues</code>.)</p>
                    </li>
                    <li>

        <p>
                            <code>ALL_OLD</code> - If <code>PutItem</code> overwrote
        an attribute name-value
                            pair, then the content of the old
        item is returned.</p>
                    </li>
                 </ul>
                <p>The values
        returned are strongly consistent.</p>
                <p>There is no additional cost
        associated with requesting a return value aside from the small

        network and processing overhead of receiving a larger response. No read capacity
        units are
                    consumed.</p>
                <note>
                    <p>The
        <code>ReturnValues</code> parameter is used by several DynamoDB operations;

        however, <code>PutItem</code> does not recognize any values other than

        <code>NONE</code> or <code>ALL_OLD</code>.</p>
                </note>
        :param return_consumed_capacity: <p>Determines the level of detail about either
        provisioned or on-demand throughput
                    consumption that is returned in
        the response:</p>
                <ul>
                    <li>
                        <p>

        <code>INDEXES</code> - The response includes the aggregate

        <code>ConsumedCapacity</code> for the operation, together with

        <code>ConsumedCapacity</code> for each table and secondary index that was

        accessed.</p>
                        <p>Note that some operations, such as
        <code>GetItem</code> and
                                <code>BatchGetItem</code>, do
        not access any indexes at all. In these cases,
                            specifying
        <code>INDEXES</code> will only return <code>ConsumedCapacity</code>

        information for table(s).</p>
                    </li>
                    <li>

        <p>
                            <code>TOTAL</code> - The response includes only the
        aggregate
                                <code>ConsumedCapacity</code> for the
        operation.</p>
                    </li>
                    <li>
                        <p>

        <code>NONE</code> - No <code>ConsumedCapacity</code> details are included in
        the
                            response.</p>
                    </li>
                 </ul>
        :param return_item_collection_metrics: <p>Determines whether item collection
        metrics are returned. If set to <code>SIZE</code>,
                    the response
        includes statistics about item collections, if any, that were modified

        during the operation are returned in the response. If set to <code>NONE</code>
        (the
                    default), no statistics are returned.</p>
        :param conditional_operator: <p>This is a legacy parameter. Use
        <code>ConditionExpression</code> instead. For more
                    information, see
        <a
        href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/LegacyConditionalParameters.ConditionalOperator.html">ConditionalOperator</a>
        in the <i>Amazon DynamoDB Developer
                        Guide</i>.</p>
        :param condition_expression: <p>A condition that must be satisfied in order for
        a conditional <code>PutItem</code>
                    operation to succeed.</p>

        <p>An expression can contain any of the following:</p>
                <ul>

        <li>
                        <p>Functions: <code>attribute_exists | attribute_not_exists
        | attribute_type |
                                contains | begins_with | size</code>

        </p>
                        <p>These function names are case-sensitive.</p>

        </li>
                    <li>
                        <p>Comparison operators: <code>= | <> |

        < | > | <= | >= |
                    BETWEEN | IN </code>
                        </p>

        </li>
                    <li>
                        <p> Logical operators: <code>AND | OR |
        NOT</code>
                        </p>
                    </li>
                 </ul>
                <p>For
        more information on condition expressions, see <a
        href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Expressions.SpecifyingConditions.html">Condition
        Expressions</a> in the <i>Amazon DynamoDB Developer

        Guide</i>.</p>
        :param expression_attribute_names: <p>One or more substitution tokens for
        attribute names in an expression. The following
                    are some use cases
        for using <code>ExpressionAttributeNames</code>:</p>
                <ul>

        <li>
                        <p>To access an attribute whose name conflicts with a
        DynamoDB reserved
                            word.</p>
                    </li>

        <li>
                        <p>To create a placeholder for repeating occurrences of an
        attribute name in an
                            expression.</p>
                    </li>

        <li>
                        <p>To prevent special characters in an attribute name from
        being misinterpreted
                            in an expression.</p>

        </li>
                 </ul>
                <p>Use the <b>#</b> character in an expression to
        dereference
                    an attribute name. For example, consider the following
        attribute name:</p>
                <ul>
                    <li>
                        <p>

        <code>Percentile</code>
                        </p>
                    </li>
                 </ul>

        <p>The name of this attribute conflicts with a reserved word, so it cannot be
        used
                    directly in an expression. (For the complete list of reserved
        words, see <a
        href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/ReservedWords.html">Reserved
        Words</a> in the <i>Amazon DynamoDB Developer
                    Guide</i>). To work
        around this, you could specify the following for

        <code>ExpressionAttributeNames</code>:</p>
                <ul>
                    <li>

        <p>
                            <code>{"#P":"Percentile"}</code>
                        </p>

        </li>
                 </ul>
                <p>You could then use this substitution in an
        expression, as in this example:</p>
                <ul>
                    <li>

        <p>
                            <code>#P = :val</code>
                        </p>

        </li>
                 </ul>
                <note>
                    <p>Tokens that begin with the
        <b>:</b> character are
                            <i>expression attribute values</i>,
        which are placeholders for the
                        actual value at runtime.</p>

        </note>
                <p>For more information on expression attribute names, see <a
        href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Expressions.AccessingItemAttributes.html">Specifying
        Item Attributes</a> in the <i>Amazon DynamoDB Developer

        Guide</i>.</p>
        :param expression_attribute_values: <p>One or more values that can be
        substituted in an expression.</p>
                <p>Use the <b>:</b> (colon) character
        in an expression to
                    dereference an attribute value. For example,
        suppose that you wanted to check whether
                    the value of the
        <i>ProductStatus</i> attribute was one of the following: </p>
                <p>

        <code>Available | Backordered | Discontinued</code>
                </p>
                <p>You
        would first need to specify <code>ExpressionAttributeValues</code> as

        follows:</p>
                <p>
                    <code>{ ":avail":{"S":"Available"},
        ":back":{"S":"Backordered"},
                        ":disc":{"S":"Discontinued"}
        }</code>
                </p>
                <p>You could then use these values in an
        expression, such as this:</p>
                <p>
                    <code>ProductStatus IN
        (:avail, :back, :disc)</code>
                </p>
                <p>For more information on
        expression attribute values, see <a
        href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Expressions.SpecifyingConditions.html">Condition
        Expressions</a> in the <i>Amazon DynamoDB Developer

        Guide</i>.</p>
        """
        self.table_name = table_name
        self.item = item
        self.expected = expected
        self.return_values = return_values
        self.return_consumed_capacity = return_consumed_capacity
        self.return_item_collection_metrics = return_item_collection_metrics
        self.conditional_operator = conditional_operator
        self.condition_expression = condition_expression
        self.expression_attribute_names = expression_attribute_names
        self.expression_attribute_values = expression_attribute_values

    def as_dict(self) -> Dict[str, Any]:
        """Converts the PutItemInput to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        d: Dict[str, Any] = {
            "TableName": self.table_name,
            "Item": _put_item_input_attribute_map_as_dict(self.item),
        }

        if self.expected is not None:
            d["Expected"] = _expected_attribute_map_as_dict(self.expected),

        if self.return_values is not None:
            d["ReturnValues"] = self.return_values

        if self.return_consumed_capacity is not None:
            d["ReturnConsumedCapacity"] = self.return_consumed_capacity

        if self.return_item_collection_metrics is not None:
            d["ReturnItemCollectionMetrics"] = self.return_item_collection_metrics

        if self.conditional_operator is not None:
            d["ConditionalOperator"] = self.conditional_operator

        if self.condition_expression is not None:
            d["ConditionExpression"] = self.condition_expression

        if self.expression_attribute_names is not None:
            d["ExpressionAttributeNames"] = self.expression_attribute_names

        if self.expression_attribute_values is not None:
            d["ExpressionAttributeValues"] = _expression_attribute_value_map_as_dict(self.expression_attribute_values),

        return d

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "PutItemInput":
        """Creates a PutItemInput from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {
            "table_name": d["TableName"],
            "item": _put_item_input_attribute_map_from_dict(d["Item"]),
        }

        if "Expected" in d:
            kwargs["expected"] = _expected_attribute_map_from_dict(d["Expected"]),

        if "ReturnValues" in d:
            kwargs["return_values"] = d["ReturnValues"]

        if "ReturnConsumedCapacity" in d:
            kwargs["return_consumed_capacity"] = d["ReturnConsumedCapacity"]

        if "ReturnItemCollectionMetrics" in d:
            kwargs["return_item_collection_metrics"] = d["ReturnItemCollectionMetrics"]

        if "ConditionalOperator" in d:
            kwargs["conditional_operator"] = d["ConditionalOperator"]

        if "ConditionExpression" in d:
            kwargs["condition_expression"] = d["ConditionExpression"]

        if "ExpressionAttributeNames" in d:
            kwargs["expression_attribute_names"] = d["ExpressionAttributeNames"]

        if "ExpressionAttributeValues" in d:
            kwargs["expression_attribute_values"] = _expression_attribute_value_map_from_dict(d["ExpressionAttributeValues"]),

        return PutItemInput(**kwargs)

    def __repr__(self) -> str:
        result = "PutItemInput("
        if self.table_name is not None:
            result += f"table_name={repr(self.table_name)}, "

        if self.item is not None:
            result += f"item={repr(self.item)}, "

        if self.expected is not None:
            result += f"expected={repr(self.expected)}, "

        if self.return_values is not None:
            result += f"return_values={repr(self.return_values)}, "

        if self.return_consumed_capacity is not None:
            result += f"return_consumed_capacity={repr(self.return_consumed_capacity)}, "

        if self.return_item_collection_metrics is not None:
            result += f"return_item_collection_metrics={repr(self.return_item_collection_metrics)}, "

        if self.conditional_operator is not None:
            result += f"conditional_operator={repr(self.conditional_operator)}, "

        if self.condition_expression is not None:
            result += f"condition_expression={repr(self.condition_expression)}, "

        if self.expression_attribute_names is not None:
            result += f"expression_attribute_names={repr(self.expression_attribute_names)}, "

        if self.expression_attribute_values is not None:
            result += f"expression_attribute_values={repr(self.expression_attribute_values)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, PutItemInput):
            return False
        attributes: list[str] = ['table_name','item','expected','return_values','return_consumed_capacity','return_item_collection_metrics','conditional_operator','condition_expression','expression_attribute_names','expression_attribute_values',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class QueryInput:
    table_name: str
    index_name: Optional[str]
    select: Optional[str]
    attributes_to_get: Optional[list[str]]
    limit: Optional[int]
    consistent_read: Optional[bool]
    key_conditions: Optional['dict[str, Condition]']
    query_filter: Optional['dict[str, Condition]']
    conditional_operator: Optional[str]
    scan_index_forward: Optional[bool]
    exclusive_start_key: Optional['dict[str, AttributeValue]']
    return_consumed_capacity: Optional[str]
    projection_expression: Optional[str]
    filter_expression: Optional[str]
    key_condition_expression: Optional[str]
    expression_attribute_names: Optional[dict[str, str]]
    expression_attribute_values: Optional['dict[str, AttributeValue]']
    def __init__(
        self,
        *,
        table_name: str,
        index_name: Optional[str] = None,
        select: Optional[str] = None,
        attributes_to_get: Optional[list[str]] = None,
        limit: Optional[int] = None,
        consistent_read: Optional[bool] = None,
        key_conditions: Optional['dict[str, Condition]'] = None,
        query_filter: Optional['dict[str, Condition]'] = None,
        conditional_operator: Optional[str] = None,
        scan_index_forward: Optional[bool] = None,
        exclusive_start_key: Optional['dict[str, AttributeValue]'] = None,
        return_consumed_capacity: Optional[str] = None,
        projection_expression: Optional[str] = None,
        filter_expression: Optional[str] = None,
        key_condition_expression: Optional[str] = None,
        expression_attribute_names: Optional[dict[str, str]] = None,
        expression_attribute_values: Optional['dict[str, AttributeValue]'] = None,
    ):
        """<p>Represents the input of a <code>Query</code> operation.</p>

        :param table_name: <p>The name of the table containing the requested items.</p>
        :param index_name: <p>The name of an index to query. This index can be any local
        secondary index or global
                    secondary index on the table. Note that if
        you use the <code>IndexName</code> parameter,
                    you must also provide
        <code>TableName.</code>
                </p>
        :param select: <p>The attributes to be returned in the result. You can retrieve
        all item attributes,
                    specific item attributes, the count of matching
        items, or in the case of an index, some
                    or all of the attributes
        projected into the index.</p>
                <ul>
                    <li>
                        <p>

        <code>ALL_ATTRIBUTES</code> - Returns all of the item attributes from the

        specified table or index. If you query a local secondary index, then for each

        matching item in the index, DynamoDB fetches the entire item from the parent

        table. If the index is configured to project all item attributes, then all of

        the data can be obtained from the local secondary index, and no fetching is

        required.</p>
                    </li>
                    <li>
                        <p>

        <code>ALL_PROJECTED_ATTRIBUTES</code> - Allowed only when querying an index.

        Retrieves all attributes that have been projected into the index. If the index

        is configured to project all attributes, this return value is equivalent to

        specifying <code>ALL_ATTRIBUTES</code>.</p>
                    </li>
                    <li>

        <p>
                            <code>COUNT</code> - Returns the number of matching
        items, rather than the
                            matching items themselves.</p>

        </li>
                    <li>
                        <p>

        <code>SPECIFIC_ATTRIBUTES</code> - Returns only the attributes listed in

        <code>ProjectionExpression</code>. This return value is equivalent to

        specifying <code>ProjectionExpression</code> without specifying any value for

        <code>Select</code>.</p>
                        <p>If you query or scan a local
        secondary index and request only attributes that
                            are
        projected into that index, the operation will read only the index and not

        the table. If any of the requested attributes are not projected into the local

        secondary index, DynamoDB fetches each of these attributes from the parent

        table. This extra fetching incurs additional throughput cost and latency.</p>

        <p>If you query or scan a global secondary index, you can only request
        attributes
                            that are projected into the index. Global
        secondary index queries cannot fetch
                            attributes from the
        parent table.</p>
                    </li>
                 </ul>
                <p>If neither
        <code>Select</code> nor <code>ProjectionExpression</code> are specified,

        DynamoDB defaults to <code>ALL_ATTRIBUTES</code> when accessing a table, and

        <code>ALL_PROJECTED_ATTRIBUTES</code> when accessing an index. You cannot use
        both
                        <code>Select</code> and <code>ProjectionExpression</code>
        together in a single
                    request, unless the value for
        <code>Select</code> is <code>SPECIFIC_ATTRIBUTES</code>.
                    (This usage
        is equivalent to specifying <code>ProjectionExpression</code> without any

        value for <code>Select</code>.)</p>
                <note>
                    <p>If you use the
        <code>ProjectionExpression</code> parameter, then the value for

        <code>Select</code> can only be <code>SPECIFIC_ATTRIBUTES</code>. Any other

        value for <code>Select</code> will return an error.</p>
                </note>
        :param attributes_to_get: <p>This is a legacy parameter. Use
        <code>ProjectionExpression</code> instead. For more
                    information, see
        <a
        href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/LegacyConditionalParameters.AttributesToGet.html">AttributesToGet</a>
        in the <i>Amazon DynamoDB Developer
                    Guide</i>.</p>
        :param limit: <p>The maximum number of items to evaluate (not necessarily the
        number of matching
                    items). If DynamoDB processes the number of items
        up to the limit while processing the
                    results, it stops the operation
        and returns the matching values up to that point, and a
                    key in
        <code>LastEvaluatedKey</code> to apply in a subsequent operation, so that you
        can
                    pick up where you left off. Also, if the processed dataset size
        exceeds 1 MB before
                    DynamoDB reaches this limit, it stops the
        operation and returns the matching values up
                    to the limit, and a key
        in <code>LastEvaluatedKey</code> to apply in a subsequent
                    operation
        to continue the operation. For more information, see <a
        href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/QueryAndScan.html">Query
        and Scan</a> in the <i>Amazon DynamoDB Developer
                    Guide</i>.</p>
        :param consistent_read: <p>Determines the read consistency model: If set to
        <code>true</code>, then the operation
                    uses strongly consistent
        reads; otherwise, the operation uses eventually consistent

        reads.</p>
                <p>Strongly consistent reads are not supported on global
        secondary indexes. If you query
                    a global secondary index with
        <code>ConsistentRead</code> set to <code>true</code>, you
                    will
        receive a <code>ValidationException</code>.</p>
        :param key_conditions: <p>This is a legacy parameter. Use
        <code>KeyConditionExpression</code> instead. For more
                    information,
        see <a
        href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/LegacyConditionalParameters.KeyConditions.html">KeyConditions</a>
        in the <i>Amazon DynamoDB Developer
                    Guide</i>.</p>
        :param query_filter: <p>This is a legacy parameter. Use
        <code>FilterExpression</code> instead. For more
                    information, see <a
        href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/LegacyConditionalParameters.QueryFilter.html">QueryFilter</a>
        in the <i>Amazon DynamoDB Developer
                    Guide</i>.</p>
        :param conditional_operator: <p>This is a legacy parameter. Use
        <code>FilterExpression</code> instead. For more
                    information, see <a
        href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/LegacyConditionalParameters.ConditionalOperator.html">ConditionalOperator</a>
        in the <i>Amazon DynamoDB Developer
                        Guide</i>.</p>
        :param scan_index_forward: <p>Specifies the order for index traversal: If
        <code>true</code> (default), the traversal
                    is performed in ascending
        order; if <code>false</code>, the traversal is performed in

        descending order. </p>
                <p>Items with the same partition key value are
        stored in sorted order by sort key. If the
                    sort key data type is
        Number, the results are stored in numeric order. For type String,

        the results are stored in order of UTF-8 bytes. For type Binary, DynamoDB treats
        each
                    byte of the binary data as unsigned.</p>
                <p>If
        <code>ScanIndexForward</code> is <code>true</code>, DynamoDB returns the results
        in
                    the order in which they are stored (by sort key value). This is
        the default behavior. If
                        <code>ScanIndexForward</code> is
        <code>false</code>, DynamoDB reads the results in
                    reverse order by
        sort key value, and then returns the results to the client.</p>
        :param exclusive_start_key: <p>The primary key of the first item that this
        operation will evaluate. Use the value
                    that was returned for
        <code>LastEvaluatedKey</code> in the previous operation.</p>
                <p>The data
        type for <code>ExclusiveStartKey</code> must be String, Number, or Binary. No

        set data types are allowed.</p>
        :param return_consumed_capacity: <p>Determines the level of detail about either
        provisioned or on-demand throughput
                    consumption that is returned in
        the response:</p>
                <ul>
                    <li>
                        <p>

        <code>INDEXES</code> - The response includes the aggregate

        <code>ConsumedCapacity</code> for the operation, together with

        <code>ConsumedCapacity</code> for each table and secondary index that was

        accessed.</p>
                        <p>Note that some operations, such as
        <code>GetItem</code> and
                                <code>BatchGetItem</code>, do
        not access any indexes at all. In these cases,
                            specifying
        <code>INDEXES</code> will only return <code>ConsumedCapacity</code>

        information for table(s).</p>
                    </li>
                    <li>

        <p>
                            <code>TOTAL</code> - The response includes only the
        aggregate
                                <code>ConsumedCapacity</code> for the
        operation.</p>
                    </li>
                    <li>
                        <p>

        <code>NONE</code> - No <code>ConsumedCapacity</code> details are included in
        the
                            response.</p>
                    </li>
                 </ul>
        :param projection_expression: <p>A string that identifies one or more attributes
        to retrieve from the table. These
                    attributes can include scalars,
        sets, or elements of a JSON document. The attributes in
                    the
        expression must be separated by commas.</p>
                <p>If no attribute names are
        specified, then all attributes will be returned. If any of
                    the
        requested attributes are not found, they will not appear in the result.</p>

        <p>For more information, see <a
        href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Expressions.AccessingItemAttributes.html">Accessing
        Item Attributes</a> in the <i>Amazon DynamoDB Developer

        Guide</i>.</p>
        :param filter_expression: <p>A string that contains conditions that DynamoDB
        applies after the <code>Query</code>
                    operation, but before the data
        is returned to you. Items that do not satisfy the

        <code>FilterExpression</code> criteria are not returned.</p>
                <p>A
        <code>FilterExpression</code> does not allow key attributes. You cannot define
        a
                    filter expression based on a partition key or a sort key.</p>

        <note>
                    <p>A <code>FilterExpression</code> is applied after the items
        have already been read;
                        the process of filtering does not
        consume any additional read capacity units.</p>
                </note>
                <p>For
        more information, see <a
        href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/QueryAndScan.html#Query.FilterExpression">Filter
        Expressions</a> in the <i>Amazon DynamoDB Developer

        Guide</i>.</p>
        :param key_condition_expression: <p>The condition that specifies the key values
        for items to be retrieved by the
                        <code>Query</code>
        action.</p>

                <p>The condition must perform an equality test on a single
        partition key value.</p>
                <p>The condition can optionally perform one of
        several comparison tests on a single sort
                    key value. This allows
        <code>Query</code> to retrieve one item with a given partition
                    key
        value and sort key value, or several items that have the same partition key
        value
                    but different sort key values.</p>

                <p>The partition
        key equality test is required, and must be specified in the following

        format:</p>

                <p>
                    <code>partitionKeyName</code>

        <i>=</i>
                    <code>:partitionkeyval</code>
                </p>

                <p>If
        you also want to provide a condition for the sort key, it must be combined
        using
                        <code>AND</code> with the condition for the sort key.
        Following is an example, using
                    the <b>=</b> comparison operator for
        the sort key:</p>

                <p>
                    <code>partitionKeyName</code>

        <code>=</code>
                    <code>:partitionkeyval</code>

        <code>AND</code>
                    <code>sortKeyName</code>

        <code>=</code>
                    <code>:sortkeyval</code>
                </p>

        <p>Valid comparisons for the sort key condition are as follows:</p>

        <ul>
                    <li>
                        <p>

        <code>sortKeyName</code>
                            <code>=</code>

        <code>:sortkeyval</code> - true if the sort key value is equal to

        <code>:sortkeyval</code>.</p>
                    </li>
                    <li>

        <p>
                            <code>sortKeyName</code>

        <code><</code>
                            <code>:sortkeyval</code> - true if the sort
        key value is less than
                                <code>:sortkeyval</code>.</p>

        </li>
                    <li>
                        <p>

        <code>sortKeyName</code>
                            <code><=</code>

        <code>:sortkeyval</code> - true if the sort key value is less than or equal to

        <code>:sortkeyval</code>.</p>
                    </li>
                    <li>

        <p>
                            <code>sortKeyName</code>

        <code>></code>
                            <code>:sortkeyval</code> - true if the sort
        key value is greater than
                                <code>:sortkeyval</code>.</p>

        </li>
                    <li>
                        <p>

        <code>sortKeyName</code>
                            <code>>= </code>

        <code>:sortkeyval</code> - true if the sort key value is greater than or equal

        to <code>:sortkeyval</code>.</p>
                    </li>
                    <li>

        <p>
                            <code>sortKeyName</code>

        <code>BETWEEN</code>
                            <code>:sortkeyval1</code>

        <code>AND</code>
                            <code>:sortkeyval2</code> - true if the
        sort key value is greater than or equal
                            to
        <code>:sortkeyval1</code>, and less than or equal to

        <code>:sortkeyval2</code>.</p>
                    </li>
                    <li>

        <p>
                            <code>begins_with (</code>

        <code>sortKeyName</code>, <code>:sortkeyval</code>

        <code>)</code> - true if the sort key value begins with a particular operand.

        (You cannot use this function with a sort key that is of type Number.) Note
        that
                            the function name <code>begins_with</code> is
        case-sensitive.</p>

                    </li>
                 </ul>

                <p>Use the
        <code>ExpressionAttributeValues</code> parameter to replace tokens such as

        <code>:partitionval</code> and <code>:sortval</code> with actual values at

        runtime.</p>

                <p>You can optionally use the
        <code>ExpressionAttributeNames</code> parameter to replace
                    the names
        of the partition key and sort key with placeholder tokens. This option might

        be necessary if an attribute name conflicts with a DynamoDB reserved word. For
        example,
                    the following <code>KeyConditionExpression</code> parameter
        causes an error because
                        <i>Size</i> is a reserved word:</p>

        <ul>
                    <li>
                        <p>
                            <code>Size =
        :myval</code>
                        </p>
                    </li>
                 </ul>

        <p>To work around this, define a placeholder (such a <code>#S</code>) to
        represent the
                    attribute name <i>Size</i>.
        <code>KeyConditionExpression</code> then is as
                    follows:</p>

        <ul>
                    <li>
                        <p>
                            <code>#S =
        :myval</code>
                        </p>
                    </li>
                 </ul>

        <p>For a list of reserved words, see <a
        href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/ReservedWords.html">Reserved
        Words</a>
                    in the <i>Amazon DynamoDB Developer Guide</i>.</p>

        <p>For more information on <code>ExpressionAttributeNames</code> and

        <code>ExpressionAttributeValues</code>, see <a
        href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/ExpressionPlaceholders.html">Using

        Placeholders for Attribute Names and Values</a> in the <i>Amazon DynamoDB

        Developer Guide</i>.</p>
        :param expression_attribute_names: <p>One or more substitution tokens for
        attribute names in an expression. The following
                    are some use cases
        for using <code>ExpressionAttributeNames</code>:</p>
                <ul>

        <li>
                        <p>To access an attribute whose name conflicts with a
        DynamoDB reserved
                            word.</p>
                    </li>

        <li>
                        <p>To create a placeholder for repeating occurrences of an
        attribute name in an
                            expression.</p>
                    </li>

        <li>
                        <p>To prevent special characters in an attribute name from
        being misinterpreted
                            in an expression.</p>

        </li>
                 </ul>
                <p>Use the <b>#</b> character in an expression to
        dereference
                    an attribute name. For example, consider the following
        attribute name:</p>
                <ul>
                    <li>
                        <p>

        <code>Percentile</code>
                        </p>
                    </li>
                 </ul>

        <p>The name of this attribute conflicts with a reserved word, so it cannot be
        used
                    directly in an expression. (For the complete list of reserved
        words, see <a
        href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/ReservedWords.html">Reserved
        Words</a> in the <i>Amazon DynamoDB Developer
                    Guide</i>). To work
        around this, you could specify the following for

        <code>ExpressionAttributeNames</code>:</p>
                <ul>
                    <li>

        <p>
                            <code>{"#P":"Percentile"}</code>
                        </p>

        </li>
                 </ul>
                <p>You could then use this substitution in an
        expression, as in this example:</p>
                <ul>
                    <li>

        <p>
                            <code>#P = :val</code>
                        </p>

        </li>
                 </ul>
                <note>
                    <p>Tokens that begin with the
        <b>:</b> character are
                            <i>expression attribute values</i>,
        which are placeholders for the
                        actual value at runtime.</p>

        </note>
                <p>For more information on expression attribute names, see <a
        href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Expressions.AccessingItemAttributes.html">Specifying
        Item Attributes</a> in the <i>Amazon DynamoDB Developer

        Guide</i>.</p>
        :param expression_attribute_values: <p>One or more values that can be
        substituted in an expression.</p>
                <p>Use the <b>:</b> (colon) character
        in an expression to
                    dereference an attribute value. For example,
        suppose that you wanted to check whether
                    the value of the
        <i>ProductStatus</i> attribute was one of the following: </p>
                <p>

        <code>Available | Backordered | Discontinued</code>
                </p>
                <p>You
        would first need to specify <code>ExpressionAttributeValues</code> as

        follows:</p>
                <p>
                    <code>{ ":avail":{"S":"Available"},
        ":back":{"S":"Backordered"},
                        ":disc":{"S":"Discontinued"}
        }</code>
                </p>
                <p>You could then use these values in an
        expression, such as this:</p>
                <p>
                    <code>ProductStatus IN
        (:avail, :back, :disc)</code>
                </p>
                <p>For more information on
        expression attribute values, see <a
        href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Expressions.SpecifyingConditions.html">Specifying
        Conditions</a> in the <i>Amazon DynamoDB Developer

        Guide</i>.</p>
        """
        self.table_name = table_name
        self.index_name = index_name
        self.select = select
        self.attributes_to_get = attributes_to_get
        self.limit = limit
        self.consistent_read = consistent_read
        self.key_conditions = key_conditions
        self.query_filter = query_filter
        self.conditional_operator = conditional_operator
        self.scan_index_forward = scan_index_forward
        self.exclusive_start_key = exclusive_start_key
        self.return_consumed_capacity = return_consumed_capacity
        self.projection_expression = projection_expression
        self.filter_expression = filter_expression
        self.key_condition_expression = key_condition_expression
        self.expression_attribute_names = expression_attribute_names
        self.expression_attribute_values = expression_attribute_values

    def as_dict(self) -> Dict[str, Any]:
        """Converts the QueryInput to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        d: Dict[str, Any] = {
            "TableName": self.table_name,
        }

        if self.index_name is not None:
            d["IndexName"] = self.index_name

        if self.select is not None:
            d["Select"] = self.select

        if self.attributes_to_get is not None:
            d["AttributesToGet"] = self.attributes_to_get

        if self.limit is not None:
            d["Limit"] = self.limit

        if self.consistent_read is not None:
            d["ConsistentRead"] = self.consistent_read

        if self.key_conditions is not None:
            d["KeyConditions"] = _key_conditions_as_dict(self.key_conditions),

        if self.query_filter is not None:
            d["QueryFilter"] = _filter_condition_map_as_dict(self.query_filter),

        if self.conditional_operator is not None:
            d["ConditionalOperator"] = self.conditional_operator

        if self.scan_index_forward is not None:
            d["ScanIndexForward"] = self.scan_index_forward

        if self.exclusive_start_key is not None:
            d["ExclusiveStartKey"] = _key_as_dict(self.exclusive_start_key),

        if self.return_consumed_capacity is not None:
            d["ReturnConsumedCapacity"] = self.return_consumed_capacity

        if self.projection_expression is not None:
            d["ProjectionExpression"] = self.projection_expression

        if self.filter_expression is not None:
            d["FilterExpression"] = self.filter_expression

        if self.key_condition_expression is not None:
            d["KeyConditionExpression"] = self.key_condition_expression

        if self.expression_attribute_names is not None:
            d["ExpressionAttributeNames"] = self.expression_attribute_names

        if self.expression_attribute_values is not None:
            d["ExpressionAttributeValues"] = _expression_attribute_value_map_as_dict(self.expression_attribute_values),

        return d

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "QueryInput":
        """Creates a QueryInput from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {
            "table_name": d["TableName"],
        }

        if "IndexName" in d:
            kwargs["index_name"] = d["IndexName"]

        if "Select" in d:
            kwargs["select"] = d["Select"]

        if "AttributesToGet" in d:
            kwargs["attributes_to_get"] = d["AttributesToGet"]

        if "Limit" in d:
            kwargs["limit"] = d["Limit"]

        if "ConsistentRead" in d:
            kwargs["consistent_read"] = d["ConsistentRead"]

        if "KeyConditions" in d:
            kwargs["key_conditions"] = _key_conditions_from_dict(d["KeyConditions"]),

        if "QueryFilter" in d:
            kwargs["query_filter"] = _filter_condition_map_from_dict(d["QueryFilter"]),

        if "ConditionalOperator" in d:
            kwargs["conditional_operator"] = d["ConditionalOperator"]

        if "ScanIndexForward" in d:
            kwargs["scan_index_forward"] = d["ScanIndexForward"]

        if "ExclusiveStartKey" in d:
            kwargs["exclusive_start_key"] = _key_from_dict(d["ExclusiveStartKey"]),

        if "ReturnConsumedCapacity" in d:
            kwargs["return_consumed_capacity"] = d["ReturnConsumedCapacity"]

        if "ProjectionExpression" in d:
            kwargs["projection_expression"] = d["ProjectionExpression"]

        if "FilterExpression" in d:
            kwargs["filter_expression"] = d["FilterExpression"]

        if "KeyConditionExpression" in d:
            kwargs["key_condition_expression"] = d["KeyConditionExpression"]

        if "ExpressionAttributeNames" in d:
            kwargs["expression_attribute_names"] = d["ExpressionAttributeNames"]

        if "ExpressionAttributeValues" in d:
            kwargs["expression_attribute_values"] = _expression_attribute_value_map_from_dict(d["ExpressionAttributeValues"]),

        return QueryInput(**kwargs)

    def __repr__(self) -> str:
        result = "QueryInput("
        if self.table_name is not None:
            result += f"table_name={repr(self.table_name)}, "

        if self.index_name is not None:
            result += f"index_name={repr(self.index_name)}, "

        if self.select is not None:
            result += f"select={repr(self.select)}, "

        if self.attributes_to_get is not None:
            result += f"attributes_to_get={repr(self.attributes_to_get)}, "

        if self.limit is not None:
            result += f"limit={repr(self.limit)}, "

        if self.consistent_read is not None:
            result += f"consistent_read={repr(self.consistent_read)}, "

        if self.key_conditions is not None:
            result += f"key_conditions={repr(self.key_conditions)}, "

        if self.query_filter is not None:
            result += f"query_filter={repr(self.query_filter)}, "

        if self.conditional_operator is not None:
            result += f"conditional_operator={repr(self.conditional_operator)}, "

        if self.scan_index_forward is not None:
            result += f"scan_index_forward={repr(self.scan_index_forward)}, "

        if self.exclusive_start_key is not None:
            result += f"exclusive_start_key={repr(self.exclusive_start_key)}, "

        if self.return_consumed_capacity is not None:
            result += f"return_consumed_capacity={repr(self.return_consumed_capacity)}, "

        if self.projection_expression is not None:
            result += f"projection_expression={repr(self.projection_expression)}, "

        if self.filter_expression is not None:
            result += f"filter_expression={repr(self.filter_expression)}, "

        if self.key_condition_expression is not None:
            result += f"key_condition_expression={repr(self.key_condition_expression)}, "

        if self.expression_attribute_names is not None:
            result += f"expression_attribute_names={repr(self.expression_attribute_names)}, "

        if self.expression_attribute_values is not None:
            result += f"expression_attribute_values={repr(self.expression_attribute_values)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, QueryInput):
            return False
        attributes: list[str] = ['table_name','index_name','select','attributes_to_get','limit','consistent_read','key_conditions','query_filter','conditional_operator','scan_index_forward','exclusive_start_key','return_consumed_capacity','projection_expression','filter_expression','key_condition_expression','expression_attribute_names','expression_attribute_values',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class BatchWriteItemOutput:
    unprocessed_items: Optional['dict[str, list[WriteRequest]]']
    item_collection_metrics: Optional['dict[str, list[ItemCollectionMetrics]]']
    consumed_capacity: Optional[list[ConsumedCapacity]]
    def __init__(
        self,
        *,
        unprocessed_items: Optional['dict[str, list[WriteRequest]]'] = None,
        item_collection_metrics: Optional['dict[str, list[ItemCollectionMetrics]]'] = None,
        consumed_capacity: Optional[list[ConsumedCapacity]] = None,
    ):
        """<p>Represents the output of a <code>BatchWriteItem</code> operation.</p>

        :param unprocessed_items: <p>A map of tables and requests against those tables
        that were not processed. The
                        <code>UnprocessedItems</code> value
        is in the same form as
                    <code>RequestItems</code>, so you can provide
        this value directly to a subsequent
                        <code>BatchGetItem</code>
        operation. For more information, see
                        <code>RequestItems</code>
        in the Request Parameters section.</p>
                <p>Each
        <code>UnprocessedItems</code> entry consists of a table name and, for that
        table,
                    a list of operations to perform (<code>DeleteRequest</code>
        or
                    <code>PutRequest</code>).</p>
                <ul>
                    <li>

        <p>
                            <code>DeleteRequest</code> - Perform a
        <code>DeleteItem</code> operation on the
                            specified item. The
        item to be deleted is identified by a <code>Key</code>

        subelement:</p>
                        <ul>
                          <li>

        <p>
                                    <code>Key</code> - A map of primary key
        attribute values that uniquely
                                    identify the item.
        Each entry in this map consists of an attribute name

        and an attribute value.</p>
                            </li>
                       </ul>

        </li>
                    <li>
                        <p>

        <code>PutRequest</code> - Perform a <code>PutItem</code> operation on the

        specified item. The item to be put is identified by an <code>Item</code>

        subelement:</p>
                        <ul>
                          <li>

        <p>
                                    <code>Item</code> - A map of attributes and
        their values. Each entry in
                                    this map consists of an
        attribute name and an attribute value. Attribute

        values must not be null; string and binary type attributes must have

        lengths greater than zero; and set type attributes must not be empty.

        Requests that contain empty values will be rejected with a

        <code>ValidationException</code> exception.</p>
                                <p>If
        you specify any attributes that are part of an index key, then the

        data types for those attributes must match those of the schema in the

        table's attribute definition.</p>
                            </li>

        </ul>
                    </li>
                 </ul>
                <p>If there are no unprocessed
        items remaining, the response contains an empty

        <code>UnprocessedItems</code> map.</p>
        :param item_collection_metrics: <p>A list of tables that were processed by
        <code>BatchWriteItem</code> and, for each
                    table, information about
        any item collections that were affected by individual

        <code>DeleteItem</code> or <code>PutItem</code> operations.</p>
                <p>Each
        entry consists of the following subelements:</p>
                <ul>
                    <li>

        <p>
                            <code>ItemCollectionKey</code> - The partition key value
        of the item collection.
                            This is the same as the partition
        key value of the item.</p>
                    </li>
                    <li>

        <p>
                            <code>SizeEstimateRangeGB</code> - An estimate of item
        collection size,
                            expressed in GB. This is a two-element
        array containing a lower bound and an
                            upper bound for the
        estimate. The estimate includes the size of all the items in

        the table, plus the size of all attributes projected into all of the local

        secondary indexes on the table. Use this estimate to measure whether a local

        secondary index is approaching its size limit.</p>
                        <p>The
        estimate is subject to change over time; therefore, do not rely on the

        precision or accuracy of the estimate.</p>
                    </li>
                 </ul>
        :param consumed_capacity: <p>The capacity units consumed by the entire
        <code>BatchWriteItem</code>
                    operation.</p>
                <p>Each element
        consists of:</p>
                <ul>
                    <li>
                        <p>

        <code>TableName</code> - The table that consumed the provisioned

        throughput.</p>
                    </li>
                    <li>
                        <p>

        <code>CapacityUnits</code> - The total number of capacity units consumed.</p>

        </li>
                 </ul>
        """
        self.unprocessed_items = unprocessed_items
        self.item_collection_metrics = item_collection_metrics
        self.consumed_capacity = consumed_capacity

    def as_dict(self) -> Dict[str, Any]:
        """Converts the BatchWriteItemOutput to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        d: Dict[str, Any] = {}

        if self.unprocessed_items is not None:
            d["UnprocessedItems"] = _batch_write_item_request_map_as_dict(self.unprocessed_items),

        if self.item_collection_metrics is not None:
            d["ItemCollectionMetrics"] = _item_collection_metrics_per_table_as_dict(self.item_collection_metrics),

        if self.consumed_capacity is not None:
            d["ConsumedCapacity"] = _consumed_capacity_multiple_as_dict(self.consumed_capacity),

        return d

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "BatchWriteItemOutput":
        """Creates a BatchWriteItemOutput from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {}

        if "UnprocessedItems" in d:
            kwargs["unprocessed_items"] = _batch_write_item_request_map_from_dict(d["UnprocessedItems"]),

        if "ItemCollectionMetrics" in d:
            kwargs["item_collection_metrics"] = _item_collection_metrics_per_table_from_dict(d["ItemCollectionMetrics"]),

        if "ConsumedCapacity" in d:
            kwargs["consumed_capacity"] = _consumed_capacity_multiple_from_dict(d["ConsumedCapacity"]),

        return BatchWriteItemOutput(**kwargs)

    def __repr__(self) -> str:
        result = "BatchWriteItemOutput("
        if self.unprocessed_items is not None:
            result += f"unprocessed_items={repr(self.unprocessed_items)}, "

        if self.item_collection_metrics is not None:
            result += f"item_collection_metrics={repr(self.item_collection_metrics)}, "

        if self.consumed_capacity is not None:
            result += f"consumed_capacity={repr(self.consumed_capacity)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, BatchWriteItemOutput):
            return False
        attributes: list[str] = ['unprocessed_items','item_collection_metrics','consumed_capacity',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class UpdateItemInput:
    table_name: str
    key: 'dict[str, AttributeValue]'
    attribute_updates: Optional['dict[str, AttributeValueUpdate]']
    expected: Optional['dict[str, ExpectedAttributeValue]']
    conditional_operator: Optional[str]
    return_values: Optional[str]
    return_consumed_capacity: Optional[str]
    return_item_collection_metrics: Optional[str]
    update_expression: Optional[str]
    condition_expression: Optional[str]
    expression_attribute_names: Optional[dict[str, str]]
    expression_attribute_values: Optional['dict[str, AttributeValue]']
    def __init__(
        self,
        *,
        table_name: str,
        key: 'dict[str, AttributeValue]',
        attribute_updates: Optional['dict[str, AttributeValueUpdate]'] = None,
        expected: Optional['dict[str, ExpectedAttributeValue]'] = None,
        conditional_operator: Optional[str] = None,
        return_values: Optional[str] = None,
        return_consumed_capacity: Optional[str] = None,
        return_item_collection_metrics: Optional[str] = None,
        update_expression: Optional[str] = None,
        condition_expression: Optional[str] = None,
        expression_attribute_names: Optional[dict[str, str]] = None,
        expression_attribute_values: Optional['dict[str, AttributeValue]'] = None,
    ):
        """<p>Represents the input of an <code>UpdateItem</code> operation.</p>

        :param table_name: <p>The name of the table containing the item to update.</p>
        :param key: <p>The primary key of the item to be updated. Each element consists
        of an attribute name
                    and a value for that attribute.</p>

        <p>For the primary key, you must provide all of the attributes. For example,
        with a
                    simple primary key, you only need to provide a value for the
        partition key. For a
                    composite primary key, you must provide values
        for both the partition key and the sort
                    key.</p>
        :param attribute_updates: <p>This is a legacy parameter. Use
        <code>UpdateExpression</code> instead. For more
                    information, see <a
        href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/LegacyConditionalParameters.AttributeUpdates.html">AttributeUpdates</a>
        in the <i>Amazon DynamoDB Developer
                        Guide</i>.</p>
        :param expected: <p>This is a legacy parameter. Use
        <code>ConditionExpression</code> instead. For more
                    information, see
        <a
        href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/LegacyConditionalParameters.Expected.html">Expected</a>
        in the <i>Amazon DynamoDB Developer
                    Guide</i>.</p>
        :param conditional_operator: <p>This is a legacy parameter. Use
        <code>ConditionExpression</code> instead. For more
                    information, see
        <a
        href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/LegacyConditionalParameters.ConditionalOperator.html">ConditionalOperator</a>
        in the <i>Amazon DynamoDB Developer
                        Guide</i>.</p>
        :param return_values: <p>Use <code>ReturnValues</code> if you want to get the
        item attributes as they appear
                    before or after they are updated. For
        <code>UpdateItem</code>, the valid values
                    are:</p>
                <ul>

        <li>
                        <p>
                            <code>NONE</code> - If
        <code>ReturnValues</code> is not specified, or if its
                            value
        is <code>NONE</code>, then nothing is returned. (This setting is the

        default for <code>ReturnValues</code>.)</p>
                    </li>
                    <li>

        <p>
                            <code>ALL_OLD</code> - Returns all of the attributes of
        the item, as they
                            appeared before the UpdateItem
        operation.</p>
                    </li>
                    <li>
                        <p>

        <code>UPDATED_OLD</code> - Returns only the updated attributes, as they
        appeared
                            before the UpdateItem operation.</p>

        </li>
                    <li>
                        <p>

        <code>ALL_NEW</code> - Returns all of the attributes of the item, as they
        appear
                            after the UpdateItem operation.</p>

        </li>
                    <li>
                        <p>

        <code>UPDATED_NEW</code> - Returns only the updated attributes, as they appear

        after the UpdateItem operation.</p>
                    </li>
                 </ul>

        <p>There is no additional cost associated with requesting a return value aside
        from the
                    small network and processing overhead of receiving a larger
        response. No read capacity
                    units are consumed.</p>
                <p>The
        values returned are strongly consistent.</p>
        :param return_consumed_capacity: <p>Determines the level of detail about either
        provisioned or on-demand throughput
                    consumption that is returned in
        the response:</p>
                <ul>
                    <li>
                        <p>

        <code>INDEXES</code> - The response includes the aggregate

        <code>ConsumedCapacity</code> for the operation, together with

        <code>ConsumedCapacity</code> for each table and secondary index that was

        accessed.</p>
                        <p>Note that some operations, such as
        <code>GetItem</code> and
                                <code>BatchGetItem</code>, do
        not access any indexes at all. In these cases,
                            specifying
        <code>INDEXES</code> will only return <code>ConsumedCapacity</code>

        information for table(s).</p>
                    </li>
                    <li>

        <p>
                            <code>TOTAL</code> - The response includes only the
        aggregate
                                <code>ConsumedCapacity</code> for the
        operation.</p>
                    </li>
                    <li>
                        <p>

        <code>NONE</code> - No <code>ConsumedCapacity</code> details are included in
        the
                            response.</p>
                    </li>
                 </ul>
        :param return_item_collection_metrics: <p>Determines whether item collection
        metrics are returned. If set to <code>SIZE</code>,
                    the response
        includes statistics about item collections, if any, that were modified

        during the operation are returned in the response. If set to <code>NONE</code>
        (the
                    default), no statistics are returned.</p>
        :param update_expression: <p>An expression that defines one or more attributes
        to be updated, the action to be
                    performed on them, and new values
        for them.</p>
                <p>The following action values are available for
        <code>UpdateExpression</code>.</p>
                <ul>
                    <li>

        <p>
                            <code>SET</code> - Adds one or more attributes and
        values to an item. If any of
                            these attributes already exist,
        they are replaced by the new values. You can
                            also use
        <code>SET</code> to add or subtract from an attribute that is of type

        Number. For example: <code>SET myNum = myNum + :val</code>
                        </p>

        <p>
                            <code>SET</code> supports the following functions:</p>

        <ul>
                          <li>
                                <p>

        <code>if_not_exists (path, operand)</code> - if the item does not

        contain an attribute at the specified path, then

        <code>if_not_exists</code> evaluates to operand; otherwise, it

        evaluates to path. You can use this function to avoid overwriting an

        attribute that may already be present in the item.</p>

        </li>
                          <li>
                                <p>

        <code>list_append (operand, operand)</code> - evaluates to a list with a

        new element added to it. You can append the new element to the start or

        the end of the list by reversing the order of the operands.</p>

        </li>
                       </ul>
                        <p>These function names are
        case-sensitive.</p>
                    </li>
                    <li>
                        <p>

        <code>REMOVE</code> - Removes one or more attributes from an item.</p>

        </li>
                    <li>
                        <p>
                            <code>ADD</code>
        - Adds the specified value to the item, if the attribute does

        not already exist. If the attribute does exist, then the behavior of

        <code>ADD</code> depends on the data type of the attribute:</p>

        <ul>
                          <li>
                                <p>If the existing attribute
        is a number, and if <code>Value</code> is
                                    also a
        number, then <code>Value</code> is mathematically added to the

        existing attribute. If <code>Value</code> is a negative number, then it

        is subtracted from the existing attribute.</p>
                                <note>

        <p>If you use <code>ADD</code> to increment or decrement a number

        value for an item that doesn't exist before the update, DynamoDB

        uses <code>0</code> as the initial value.</p>

        <p>Similarly, if you use <code>ADD</code> for an existing item to

        increment or decrement an attribute value that doesn't exist before

        the update, DynamoDB uses <code>0</code> as the initial value. For

        example, suppose that the item you want to update doesn't have an

        attribute named <code>itemcount</code>, but you decide to

        <code>ADD</code> the number <code>3</code> to this attribute

        anyway. DynamoDB will create the <code>itemcount</code> attribute,

        set its initial value to <code>0</code>, and finally add

        <code>3</code> to it. The result will be a new

        <code>itemcount</code> attribute in the item, with a value of

        <code>3</code>.</p>
                                </note>
                            </li>

        <li>
                                <p>If the existing data type is a set and if
        <code>Value</code> is also a
                                    set, then
        <code>Value</code> is added to the existing set. For example,

        if the attribute value is the set <code>[1,2]</code>, and the

        <code>ADD</code> action specified <code>[3]</code>, then the final

        attribute value is <code>[1,2,3]</code>. An error occurs if an

        <code>ADD</code> action is specified for a set attribute and the

        attribute type specified does not match the existing set type. </p>

        <p>Both sets must have the same primitive data type. For example, if the

        existing data type is a set of strings, the <code>Value</code> must also

        be a set of strings.</p>
                            </li>
                       </ul>

        <important>
                            <p>The <code>ADD</code> action only supports
        Number and set data types. In
                                addition, <code>ADD</code>
        can only be used on top-level attributes, not
                                nested
        attributes.</p>
                        </important>
                    </li>
                    <li>

        <p>
                            <code>DELETE</code> - Deletes an element from a
        set.</p>
                        <p>If a set of values is specified, then those values
        are subtracted from the old
                            set. For example, if the
        attribute value was the set <code>[a,b,c]</code> and
                            the
        <code>DELETE</code> action specifies <code>[a,c]</code>, then the final

        attribute value is <code>[b]</code>. Specifying an empty set is an error.</p>

        <important>
                            <p>The <code>DELETE</code> action only supports
        set data types. In addition,
                                    <code>DELETE</code> can
        only be used on top-level attributes, not nested

        attributes.</p>
                        </important>

                    </li>
                 </ul>

        <p>You can have many actions in a single expression, such as the following:
        <code>SET
                        a=:value1, b=:value2 DELETE :value3, :value4,
        :value5</code>
                </p>
                <p>For more information on update
        expressions, see <a
        href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Expressions.Modifying.html">Modifying

        Items and Attributes</a> in the <i>Amazon DynamoDB Developer

        Guide</i>.</p>
        :param condition_expression: <p>A condition that must be satisfied in order for
        a conditional update to
                    succeed.</p>
                <p>An expression can
        contain any of the following:</p>
                <ul>
                    <li>

        <p>Functions: <code>attribute_exists | attribute_not_exists | attribute_type |

        contains | begins_with | size</code>
                        </p>

        <p>These function names are case-sensitive.</p>
                    </li>

        <li>
                        <p>Comparison operators: <code>= | <> |
                    < | > |
        <= | >= |
                    BETWEEN | IN </code>
                        </p>

        </li>
                    <li>
                        <p> Logical operators: <code>AND | OR |
        NOT</code>
                        </p>
                    </li>
                 </ul>
                <p>For
        more information about condition expressions, see <a
        href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Expressions.SpecifyingConditions.html">Specifying
        Conditions</a> in the <i>Amazon DynamoDB Developer

        Guide</i>.</p>
        :param expression_attribute_names: <p>One or more substitution tokens for
        attribute names in an expression. The following
                    are some use cases
        for using <code>ExpressionAttributeNames</code>:</p>
                <ul>

        <li>
                        <p>To access an attribute whose name conflicts with a
        DynamoDB reserved
                            word.</p>
                    </li>

        <li>
                        <p>To create a placeholder for repeating occurrences of an
        attribute name in an
                            expression.</p>
                    </li>

        <li>
                        <p>To prevent special characters in an attribute name from
        being misinterpreted
                            in an expression.</p>

        </li>
                 </ul>
                <p>Use the <b>#</b> character in an expression to
        dereference
                    an attribute name. For example, consider the following
        attribute name:</p>
                <ul>
                    <li>
                        <p>

        <code>Percentile</code>
                        </p>
                    </li>
                 </ul>

        <p>The name of this attribute conflicts with a reserved word, so it cannot be
        used
                    directly in an expression. (For the complete list of reserved
        words, see <a
        href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/ReservedWords.html">Reserved
        Words</a> in the <i>Amazon DynamoDB Developer
                    Guide</i>.) To work
        around this, you could specify the following for

        <code>ExpressionAttributeNames</code>:</p>
                <ul>
                    <li>

        <p>
                            <code>{"#P":"Percentile"}</code>
                        </p>

        </li>
                 </ul>
                <p>You could then use this substitution in an
        expression, as in this example:</p>
                <ul>
                    <li>

        <p>
                            <code>#P = :val</code>
                        </p>

        </li>
                 </ul>
                <note>
                    <p>Tokens that begin with the
        <b>:</b> character are
                            <i>expression attribute values</i>,
        which are placeholders for the
                        actual value at runtime.</p>

        </note>
                <p>For more information about expression attribute names, see <a
        href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Expressions.AccessingItemAttributes.html">Specifying
        Item Attributes</a> in the <i>Amazon DynamoDB Developer

        Guide</i>.</p>
        :param expression_attribute_values: <p>One or more values that can be
        substituted in an expression.</p>
                <p>Use the <b>:</b> (colon) character
        in an expression to
                    dereference an attribute value. For example,
        suppose that you wanted to check whether
                    the value of the
        <code>ProductStatus</code> attribute was one of the following: </p>
                <p>

        <code>Available | Backordered | Discontinued</code>
                </p>
                <p>You
        would first need to specify <code>ExpressionAttributeValues</code> as

        follows:</p>
                <p>
                    <code>{ ":avail":{"S":"Available"},
        ":back":{"S":"Backordered"},
                        ":disc":{"S":"Discontinued"}
        }</code>
                </p>
                <p>You could then use these values in an
        expression, such as this:</p>
                <p>
                    <code>ProductStatus IN
        (:avail, :back, :disc)</code>
                </p>
                <p>For more information on
        expression attribute values, see <a
        href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Expressions.SpecifyingConditions.html">Condition
        Expressions</a> in the <i>Amazon DynamoDB Developer

        Guide</i>.</p>
        """
        self.table_name = table_name
        self.key = key
        self.attribute_updates = attribute_updates
        self.expected = expected
        self.conditional_operator = conditional_operator
        self.return_values = return_values
        self.return_consumed_capacity = return_consumed_capacity
        self.return_item_collection_metrics = return_item_collection_metrics
        self.update_expression = update_expression
        self.condition_expression = condition_expression
        self.expression_attribute_names = expression_attribute_names
        self.expression_attribute_values = expression_attribute_values

    def as_dict(self) -> Dict[str, Any]:
        """Converts the UpdateItemInput to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        d: Dict[str, Any] = {
            "TableName": self.table_name,
            "Key": _key_as_dict(self.key),
        }

        if self.attribute_updates is not None:
            d["AttributeUpdates"] = _attribute_updates_as_dict(self.attribute_updates),

        if self.expected is not None:
            d["Expected"] = _expected_attribute_map_as_dict(self.expected),

        if self.conditional_operator is not None:
            d["ConditionalOperator"] = self.conditional_operator

        if self.return_values is not None:
            d["ReturnValues"] = self.return_values

        if self.return_consumed_capacity is not None:
            d["ReturnConsumedCapacity"] = self.return_consumed_capacity

        if self.return_item_collection_metrics is not None:
            d["ReturnItemCollectionMetrics"] = self.return_item_collection_metrics

        if self.update_expression is not None:
            d["UpdateExpression"] = self.update_expression

        if self.condition_expression is not None:
            d["ConditionExpression"] = self.condition_expression

        if self.expression_attribute_names is not None:
            d["ExpressionAttributeNames"] = self.expression_attribute_names

        if self.expression_attribute_values is not None:
            d["ExpressionAttributeValues"] = _expression_attribute_value_map_as_dict(self.expression_attribute_values),

        return d

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "UpdateItemInput":
        """Creates a UpdateItemInput from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {
            "table_name": d["TableName"],
            "key": _key_from_dict(d["Key"]),
        }

        if "AttributeUpdates" in d:
            kwargs["attribute_updates"] = _attribute_updates_from_dict(d["AttributeUpdates"]),

        if "Expected" in d:
            kwargs["expected"] = _expected_attribute_map_from_dict(d["Expected"]),

        if "ConditionalOperator" in d:
            kwargs["conditional_operator"] = d["ConditionalOperator"]

        if "ReturnValues" in d:
            kwargs["return_values"] = d["ReturnValues"]

        if "ReturnConsumedCapacity" in d:
            kwargs["return_consumed_capacity"] = d["ReturnConsumedCapacity"]

        if "ReturnItemCollectionMetrics" in d:
            kwargs["return_item_collection_metrics"] = d["ReturnItemCollectionMetrics"]

        if "UpdateExpression" in d:
            kwargs["update_expression"] = d["UpdateExpression"]

        if "ConditionExpression" in d:
            kwargs["condition_expression"] = d["ConditionExpression"]

        if "ExpressionAttributeNames" in d:
            kwargs["expression_attribute_names"] = d["ExpressionAttributeNames"]

        if "ExpressionAttributeValues" in d:
            kwargs["expression_attribute_values"] = _expression_attribute_value_map_from_dict(d["ExpressionAttributeValues"]),

        return UpdateItemInput(**kwargs)

    def __repr__(self) -> str:
        result = "UpdateItemInput("
        if self.table_name is not None:
            result += f"table_name={repr(self.table_name)}, "

        if self.key is not None:
            result += f"key={repr(self.key)}, "

        if self.attribute_updates is not None:
            result += f"attribute_updates={repr(self.attribute_updates)}, "

        if self.expected is not None:
            result += f"expected={repr(self.expected)}, "

        if self.conditional_operator is not None:
            result += f"conditional_operator={repr(self.conditional_operator)}, "

        if self.return_values is not None:
            result += f"return_values={repr(self.return_values)}, "

        if self.return_consumed_capacity is not None:
            result += f"return_consumed_capacity={repr(self.return_consumed_capacity)}, "

        if self.return_item_collection_metrics is not None:
            result += f"return_item_collection_metrics={repr(self.return_item_collection_metrics)}, "

        if self.update_expression is not None:
            result += f"update_expression={repr(self.update_expression)}, "

        if self.condition_expression is not None:
            result += f"condition_expression={repr(self.condition_expression)}, "

        if self.expression_attribute_names is not None:
            result += f"expression_attribute_names={repr(self.expression_attribute_names)}, "

        if self.expression_attribute_values is not None:
            result += f"expression_attribute_values={repr(self.expression_attribute_values)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, UpdateItemInput):
            return False
        attributes: list[str] = ['table_name','key','attribute_updates','expected','conditional_operator','return_values','return_consumed_capacity','return_item_collection_metrics','update_expression','condition_expression','expression_attribute_names','expression_attribute_values',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class TransactWriteItem:
    condition_check: Optional['ConditionCheck']
    put: Optional['Put']
    delete: Optional['Delete']
    update: Optional['Update']
    def __init__(
        self,
        *,
        condition_check: Optional['ConditionCheck'] = None,
        put: Optional['Put'] = None,
        delete: Optional['Delete'] = None,
        update: Optional['Update'] = None,
    ):
        """<p>A list of requests that can perform update, put, delete, or check operations
        on
                    multiple items in one or more tables atomically.</p>

        :param condition_check: <p>A request to perform a check item operation.</p>
        :param put: <p>A request to perform a <code>PutItem</code> operation.</p>
        :param delete: <p>A request to perform a <code>DeleteItem</code> operation.</p>
        :param update: <p>A request to perform an <code>UpdateItem</code> operation.</p>
        """
        self.condition_check = condition_check
        self.put = put
        self.delete = delete
        self.update = update

    def as_dict(self) -> Dict[str, Any]:
        """Converts the TransactWriteItem to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        d: Dict[str, Any] = {}

        if self.condition_check is not None:
            d["ConditionCheck"] = self.condition_check.as_dict()

        if self.put is not None:
            d["Put"] = self.put.as_dict()

        if self.delete is not None:
            d["Delete"] = self.delete.as_dict()

        if self.update is not None:
            d["Update"] = self.update.as_dict()

        return d

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "TransactWriteItem":
        """Creates a TransactWriteItem from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {}

        if "ConditionCheck" in d:
            kwargs["condition_check"] = ConditionCheck.from_dict(d["ConditionCheck"])

        if "Put" in d:
            kwargs["put"] = Put.from_dict(d["Put"])

        if "Delete" in d:
            kwargs["delete"] = Delete.from_dict(d["Delete"])

        if "Update" in d:
            kwargs["update"] = Update.from_dict(d["Update"])

        return TransactWriteItem(**kwargs)

    def __repr__(self) -> str:
        result = "TransactWriteItem("
        if self.condition_check is not None:
            result += f"condition_check={repr(self.condition_check)}, "

        if self.put is not None:
            result += f"put={repr(self.put)}, "

        if self.delete is not None:
            result += f"delete={repr(self.delete)}, "

        if self.update is not None:
            result += f"update={repr(self.update)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, TransactWriteItem):
            return False
        attributes: list[str] = ['condition_check','put','delete','update',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class TransactWriteItemsInput:
    transact_items: 'list[TransactWriteItem]'
    return_consumed_capacity: Optional[str]
    return_item_collection_metrics: Optional[str]
    client_request_token: Optional[str]
    def __init__(
        self,
        *,
        transact_items: 'list[TransactWriteItem]',
        return_consumed_capacity: Optional[str] = None,
        return_item_collection_metrics: Optional[str] = None,
        client_request_token: Optional[str] = None,
    ):
        """
        :param transact_items: <p>An ordered array of up to 25
        <code>TransactWriteItem</code> objects, each of which
                    contains a
        <code>ConditionCheck</code>, <code>Put</code>, <code>Update</code>, or

        <code>Delete</code> object. These can operate on items in different tables, but
        the
                    tables must reside in the same Amazon Web Services account and
        Region, and no two of them
                    can operate on the same item. </p>
        :param return_consumed_capacity: <p>Determines the level of detail about either
        provisioned or on-demand throughput
                    consumption that is returned in
        the response:</p>
                <ul>
                    <li>
                        <p>

        <code>INDEXES</code> - The response includes the aggregate

        <code>ConsumedCapacity</code> for the operation, together with

        <code>ConsumedCapacity</code> for each table and secondary index that was

        accessed.</p>
                        <p>Note that some operations, such as
        <code>GetItem</code> and
                                <code>BatchGetItem</code>, do
        not access any indexes at all. In these cases,
                            specifying
        <code>INDEXES</code> will only return <code>ConsumedCapacity</code>

        information for table(s).</p>
                    </li>
                    <li>

        <p>
                            <code>TOTAL</code> - The response includes only the
        aggregate
                                <code>ConsumedCapacity</code> for the
        operation.</p>
                    </li>
                    <li>
                        <p>

        <code>NONE</code> - No <code>ConsumedCapacity</code> details are included in
        the
                            response.</p>
                    </li>
                 </ul>
        :param return_item_collection_metrics: <p>Determines whether item collection
        metrics are returned. If set to <code>SIZE</code>,
                    the response
        includes statistics about item collections (if any), that were modified

        during the operation and are returned in the response. If set to
        <code>NONE</code> (the
                    default), no statistics are returned. </p>
        :param client_request_token: <p>Providing a <code>ClientRequestToken</code>
        makes the call to
                        <code>TransactWriteItems</code> idempotent,
        meaning that multiple identical calls
                    have the same effect as one
        single call.</p>
                <p>Although multiple identical calls using the same
        client request token produce the same
                    result on the server (no side
        effects), the responses to the calls might not be the
                    same. If the
        <code>ReturnConsumedCapacity></code> parameter is set, then the initial

        <code>TransactWriteItems</code> call returns the amount of write capacity units

        consumed in making the changes. Subsequent <code>TransactWriteItems</code> calls
        with
                    the same client token return the number of read capacity units
        consumed in reading the
                    item.</p>
                <p>A client request token
        is valid for 10 minutes after the first request that uses it is

        completed. After 10 minutes, any request with the same client token is treated
        as a new
                    request. Do not resubmit the same request with the same
        client token for more than 10
                    minutes, or the result might not be
        idempotent.</p>
                <p>If you submit a request with the same client token
        but a change in other parameters
                    within the 10-minute idempotency
        window, DynamoDB returns an

        <code>IdempotentParameterMismatch</code> exception.</p>
        """
        self.transact_items = transact_items
        self.return_consumed_capacity = return_consumed_capacity
        self.return_item_collection_metrics = return_item_collection_metrics
        self.client_request_token = client_request_token

    def as_dict(self) -> Dict[str, Any]:
        """Converts the TransactWriteItemsInput to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        d: Dict[str, Any] = {
            "TransactItems": _transact_write_item_list_as_dict(self.transact_items),
        }

        if self.return_consumed_capacity is not None:
            d["ReturnConsumedCapacity"] = self.return_consumed_capacity

        if self.return_item_collection_metrics is not None:
            d["ReturnItemCollectionMetrics"] = self.return_item_collection_metrics

        if self.client_request_token is not None:
            d["ClientRequestToken"] = self.client_request_token

        return d

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "TransactWriteItemsInput":
        """Creates a TransactWriteItemsInput from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {
            "transact_items": _transact_write_item_list_from_dict(d["TransactItems"]),
        }

        if "ReturnConsumedCapacity" in d:
            kwargs["return_consumed_capacity"] = d["ReturnConsumedCapacity"]

        if "ReturnItemCollectionMetrics" in d:
            kwargs["return_item_collection_metrics"] = d["ReturnItemCollectionMetrics"]

        if "ClientRequestToken" in d:
            kwargs["client_request_token"] = d["ClientRequestToken"]

        return TransactWriteItemsInput(**kwargs)

    def __repr__(self) -> str:
        result = "TransactWriteItemsInput("
        if self.transact_items is not None:
            result += f"transact_items={repr(self.transact_items)}, "

        if self.return_consumed_capacity is not None:
            result += f"return_consumed_capacity={repr(self.return_consumed_capacity)}, "

        if self.return_item_collection_metrics is not None:
            result += f"return_item_collection_metrics={repr(self.return_item_collection_metrics)}, "

        if self.client_request_token is not None:
            result += f"client_request_token={repr(self.client_request_token)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, TransactWriteItemsInput):
            return False
        attributes: list[str] = ['transact_items','return_consumed_capacity','return_item_collection_metrics','client_request_token',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

def _replica_auto_scaling_description_list_as_dict(given: list[ReplicaAutoScalingDescription]) -> List[Any]:
    return [v.as_dict() for v in given]

def _replica_auto_scaling_description_list_from_dict(given: List[Any]) -> list[ReplicaAutoScalingDescription]:
    return [ReplicaAutoScalingDescription.from_dict(v) for v in given]

def _auto_scaling_policy_description_list_as_dict(given: list[AutoScalingPolicyDescription]) -> List[Any]:
    return [v.as_dict() for v in given]

def _auto_scaling_policy_description_list_from_dict(given: List[Any]) -> list[AutoScalingPolicyDescription]:
    return [AutoScalingPolicyDescription.from_dict(v) for v in given]

def _replica_global_secondary_index_auto_scaling_description_list_as_dict(given: list[ReplicaGlobalSecondaryIndexAutoScalingDescription]) -> List[Any]:
    return [v.as_dict() for v in given]

def _replica_global_secondary_index_auto_scaling_description_list_from_dict(given: List[Any]) -> list[ReplicaGlobalSecondaryIndexAutoScalingDescription]:
    return [ReplicaGlobalSecondaryIndexAutoScalingDescription.from_dict(v) for v in given]

def _replica_auto_scaling_update_list_as_dict(given: list[ReplicaAutoScalingUpdate]) -> List[Any]:
    return [v.as_dict() for v in given]

def _replica_auto_scaling_update_list_from_dict(given: List[Any]) -> list[ReplicaAutoScalingUpdate]:
    return [ReplicaAutoScalingUpdate.from_dict(v) for v in given]

def _replica_global_secondary_index_auto_scaling_update_list_as_dict(given: list[ReplicaGlobalSecondaryIndexAutoScalingUpdate]) -> List[Any]:
    return [v.as_dict() for v in given]

def _replica_global_secondary_index_auto_scaling_update_list_from_dict(given: List[Any]) -> list[ReplicaGlobalSecondaryIndexAutoScalingUpdate]:
    return [ReplicaGlobalSecondaryIndexAutoScalingUpdate.from_dict(v) for v in given]

def _global_secondary_index_auto_scaling_update_list_as_dict(given: list[GlobalSecondaryIndexAutoScalingUpdate]) -> List[Any]:
    return [v.as_dict() for v in given]

def _global_secondary_index_auto_scaling_update_list_from_dict(given: List[Any]) -> list[GlobalSecondaryIndexAutoScalingUpdate]:
    return [GlobalSecondaryIndexAutoScalingUpdate.from_dict(v) for v in given]

def _replica_description_list_as_dict(given: list[ReplicaDescription]) -> List[Any]:
    return [v.as_dict() for v in given]

def _replica_description_list_from_dict(given: List[Any]) -> list[ReplicaDescription]:
    return [ReplicaDescription.from_dict(v) for v in given]

def _replica_global_secondary_index_description_list_as_dict(given: list[ReplicaGlobalSecondaryIndexDescription]) -> List[Any]:
    return [v.as_dict() for v in given]

def _replica_global_secondary_index_description_list_from_dict(given: List[Any]) -> list[ReplicaGlobalSecondaryIndexDescription]:
    return [ReplicaGlobalSecondaryIndexDescription.from_dict(v) for v in given]

def _global_secondary_index_description_list_as_dict(given: list[GlobalSecondaryIndexDescription]) -> List[Any]:
    return [v.as_dict() for v in given]

def _global_secondary_index_description_list_from_dict(given: List[Any]) -> list[GlobalSecondaryIndexDescription]:
    return [GlobalSecondaryIndexDescription.from_dict(v) for v in given]

def _key_schema_as_dict(given: list[KeySchemaElement]) -> List[Any]:
    return [v.as_dict() for v in given]

def _key_schema_from_dict(given: List[Any]) -> list[KeySchemaElement]:
    return [KeySchemaElement.from_dict(v) for v in given]

def _local_secondary_index_description_list_as_dict(given: list[LocalSecondaryIndexDescription]) -> List[Any]:
    return [v.as_dict() for v in given]

def _local_secondary_index_description_list_from_dict(given: List[Any]) -> list[LocalSecondaryIndexDescription]:
    return [LocalSecondaryIndexDescription.from_dict(v) for v in given]

def _attribute_definitions_as_dict(given: list[AttributeDefinition]) -> List[Any]:
    return [v.as_dict() for v in given]

def _attribute_definitions_from_dict(given: List[Any]) -> list[AttributeDefinition]:
    return [AttributeDefinition.from_dict(v) for v in given]

def _replication_group_update_list_as_dict(given: list[ReplicationGroupUpdate]) -> List[Any]:
    return [v.as_dict() for v in given]

def _replication_group_update_list_from_dict(given: List[Any]) -> list[ReplicationGroupUpdate]:
    return [ReplicationGroupUpdate.from_dict(v) for v in given]

def _replica_global_secondary_index_list_as_dict(given: list[ReplicaGlobalSecondaryIndex]) -> List[Any]:
    return [v.as_dict() for v in given]

def _replica_global_secondary_index_list_from_dict(given: List[Any]) -> list[ReplicaGlobalSecondaryIndex]:
    return [ReplicaGlobalSecondaryIndex.from_dict(v) for v in given]

def _global_secondary_index_update_list_as_dict(given: list[GlobalSecondaryIndexUpdate]) -> List[Any]:
    return [v.as_dict() for v in given]

def _global_secondary_index_update_list_from_dict(given: List[Any]) -> list[GlobalSecondaryIndexUpdate]:
    return [GlobalSecondaryIndexUpdate.from_dict(v) for v in given]

def _item_collection_key_attribute_map_as_dict(given: dict[str, AttributeValue]) -> Dict[str, Any]:
    return {k: v.as_dict() for k, v in given.items()}

def _item_collection_key_attribute_map_from_dict(given: Dict[str, Any]) -> dict[str, AttributeValue]:
    return {k: AttributeValue.from_dict(v) for k, v in given.items()}

def _list_attribute_value_as_dict(given: list[AttributeValue]) -> List[Any]:
    return [v.as_dict() for v in given]

def _list_attribute_value_from_dict(given: List[Any]) -> list[AttributeValue]:
    return [AttributeValue.from_dict(v) for v in given]

def _map_attribute_value_as_dict(given: dict[str, AttributeValue]) -> Dict[str, Any]:
    return {k: v.as_dict() for k, v in given.items()}

def _map_attribute_value_from_dict(given: Dict[str, Any]) -> dict[str, AttributeValue]:
    return {k: AttributeValue.from_dict(v) for k, v in given.items()}

def _secondary_indexes_capacity_map_as_dict(given: dict[str, Capacity]) -> Dict[str, Any]:
    return {k: v.as_dict() for k, v in given.items()}

def _secondary_indexes_capacity_map_from_dict(given: Dict[str, Any]) -> dict[str, Capacity]:
    return {k: Capacity.from_dict(v) for k, v in given.items()}

def _attribute_map_as_dict(given: dict[str, AttributeValue]) -> Dict[str, Any]:
    return {k: v.as_dict() for k, v in given.items()}

def _attribute_map_from_dict(given: Dict[str, Any]) -> dict[str, AttributeValue]:
    return {k: AttributeValue.from_dict(v) for k, v in given.items()}

def _expression_attribute_value_map_as_dict(given: dict[str, AttributeValue]) -> Dict[str, Any]:
    return {k: v.as_dict() for k, v in given.items()}

def _expression_attribute_value_map_from_dict(given: Dict[str, Any]) -> dict[str, AttributeValue]:
    return {k: AttributeValue.from_dict(v) for k, v in given.items()}

def _expected_attribute_map_as_dict(given: dict[str, ExpectedAttributeValue]) -> Dict[str, Any]:
    return {k: v.as_dict() for k, v in given.items()}

def _expected_attribute_map_from_dict(given: Dict[str, Any]) -> dict[str, ExpectedAttributeValue]:
    return {k: ExpectedAttributeValue.from_dict(v) for k, v in given.items()}

def _attribute_value_list_as_dict(given: list[AttributeValue]) -> List[Any]:
    return [v.as_dict() for v in given]

def _attribute_value_list_from_dict(given: List[Any]) -> list[AttributeValue]:
    return [AttributeValue.from_dict(v) for v in given]

def _attribute_updates_as_dict(given: dict[str, AttributeValueUpdate]) -> Dict[str, Any]:
    return {k: v.as_dict() for k, v in given.items()}

def _attribute_updates_from_dict(given: Dict[str, Any]) -> dict[str, AttributeValueUpdate]:
    return {k: AttributeValueUpdate.from_dict(v) for k, v in given.items()}

def _key_as_dict(given: dict[str, AttributeValue]) -> Dict[str, Any]:
    return {k: v.as_dict() for k, v in given.items()}

def _key_from_dict(given: Dict[str, Any]) -> dict[str, AttributeValue]:
    return {k: AttributeValue.from_dict(v) for k, v in given.items()}

def _replica_settings_description_list_as_dict(given: list[ReplicaSettingsDescription]) -> List[Any]:
    return [v.as_dict() for v in given]

def _replica_settings_description_list_from_dict(given: List[Any]) -> list[ReplicaSettingsDescription]:
    return [ReplicaSettingsDescription.from_dict(v) for v in given]

def _replica_global_secondary_index_settings_description_list_as_dict(given: list[ReplicaGlobalSecondaryIndexSettingsDescription]) -> List[Any]:
    return [v.as_dict() for v in given]

def _replica_global_secondary_index_settings_description_list_from_dict(given: List[Any]) -> list[ReplicaGlobalSecondaryIndexSettingsDescription]:
    return [ReplicaGlobalSecondaryIndexSettingsDescription.from_dict(v) for v in given]

def _replica_settings_update_list_as_dict(given: list[ReplicaSettingsUpdate]) -> List[Any]:
    return [v.as_dict() for v in given]

def _replica_settings_update_list_from_dict(given: List[Any]) -> list[ReplicaSettingsUpdate]:
    return [ReplicaSettingsUpdate.from_dict(v) for v in given]

def _replica_global_secondary_index_settings_update_list_as_dict(given: list[ReplicaGlobalSecondaryIndexSettingsUpdate]) -> List[Any]:
    return [v.as_dict() for v in given]

def _replica_global_secondary_index_settings_update_list_from_dict(given: List[Any]) -> list[ReplicaGlobalSecondaryIndexSettingsUpdate]:
    return [ReplicaGlobalSecondaryIndexSettingsUpdate.from_dict(v) for v in given]

def _global_table_global_secondary_index_settings_update_list_as_dict(given: list[GlobalTableGlobalSecondaryIndexSettingsUpdate]) -> List[Any]:
    return [v.as_dict() for v in given]

def _global_table_global_secondary_index_settings_update_list_from_dict(given: List[Any]) -> list[GlobalTableGlobalSecondaryIndexSettingsUpdate]:
    return [GlobalTableGlobalSecondaryIndexSettingsUpdate.from_dict(v) for v in given]

def _replica_update_list_as_dict(given: list[ReplicaUpdate]) -> List[Any]:
    return [v.as_dict() for v in given]

def _replica_update_list_from_dict(given: List[Any]) -> list[ReplicaUpdate]:
    return [ReplicaUpdate.from_dict(v) for v in given]

def _cancellation_reason_list_as_dict(given: list[CancellationReason]) -> List[Any]:
    return [v.as_dict() for v in given]

def _cancellation_reason_list_from_dict(given: List[Any]) -> list[CancellationReason]:
    return [CancellationReason.from_dict(v) for v in given]

def _item_collection_metrics_per_table_as_dict(given: dict[str, list[ItemCollectionMetrics]]) -> Dict[str, Any]:
    return {k: _item_collection_metrics_multiple_as_dict(v) for k, v in given.items()}

def _item_collection_metrics_per_table_from_dict(given: Dict[str, Any]) -> dict[str, list[ItemCollectionMetrics]]:
    return {k: _item_collection_metrics_multiple_from_dict(v) for k, v in given.items()}

def _item_collection_metrics_multiple_as_dict(given: list[ItemCollectionMetrics]) -> List[Any]:
    return [v.as_dict() for v in given]

def _item_collection_metrics_multiple_from_dict(given: List[Any]) -> list[ItemCollectionMetrics]:
    return [ItemCollectionMetrics.from_dict(v) for v in given]

def _consumed_capacity_multiple_as_dict(given: list[ConsumedCapacity]) -> List[Any]:
    return [v.as_dict() for v in given]

def _consumed_capacity_multiple_from_dict(given: List[Any]) -> list[ConsumedCapacity]:
    return [ConsumedCapacity.from_dict(v) for v in given]

def _transact_write_item_list_as_dict(given: list[TransactWriteItem]) -> List[Any]:
    return [v.as_dict() for v in given]

def _transact_write_item_list_from_dict(given: List[Any]) -> list[TransactWriteItem]:
    return [TransactWriteItem.from_dict(v) for v in given]

def _put_item_input_attribute_map_as_dict(given: dict[str, AttributeValue]) -> Dict[str, Any]:
    return {k: v.as_dict() for k, v in given.items()}

def _put_item_input_attribute_map_from_dict(given: Dict[str, Any]) -> dict[str, AttributeValue]:
    return {k: AttributeValue.from_dict(v) for k, v in given.items()}

def _item_response_list_as_dict(given: list[ItemResponse]) -> List[Any]:
    return [v.as_dict() for v in given]

def _item_response_list_from_dict(given: List[Any]) -> list[ItemResponse]:
    return [ItemResponse.from_dict(v) for v in given]

def _transact_get_item_list_as_dict(given: list[TransactGetItem]) -> List[Any]:
    return [v.as_dict() for v in given]

def _transact_get_item_list_from_dict(given: List[Any]) -> list[TransactGetItem]:
    return [TransactGetItem.from_dict(v) for v in given]

def _tag_list_as_dict(given: list[Tag]) -> List[Any]:
    return [v.as_dict() for v in given]

def _tag_list_from_dict(given: List[Any]) -> list[Tag]:
    return [Tag.from_dict(v) for v in given]

def _item_list_as_dict(given: list[dict[str, AttributeValue]]) -> List[Any]:
    return [_attribute_map_as_dict(v) for v in given]

def _item_list_from_dict(given: List[Any]) -> list[dict[str, AttributeValue]]:
    return [_attribute_map_from_dict(v) for v in given]

def _filter_condition_map_as_dict(given: dict[str, Condition]) -> Dict[str, Any]:
    return {k: v.as_dict() for k, v in given.items()}

def _filter_condition_map_from_dict(given: Dict[str, Any]) -> dict[str, Condition]:
    return {k: Condition.from_dict(v) for k, v in given.items()}

def _local_secondary_index_list_as_dict(given: list[LocalSecondaryIndex]) -> List[Any]:
    return [v.as_dict() for v in given]

def _local_secondary_index_list_from_dict(given: List[Any]) -> list[LocalSecondaryIndex]:
    return [LocalSecondaryIndex.from_dict(v) for v in given]

def _global_secondary_index_list_as_dict(given: list[GlobalSecondaryIndex]) -> List[Any]:
    return [v.as_dict() for v in given]

def _global_secondary_index_list_from_dict(given: List[Any]) -> list[GlobalSecondaryIndex]:
    return [GlobalSecondaryIndex.from_dict(v) for v in given]

def _key_conditions_as_dict(given: dict[str, Condition]) -> Dict[str, Any]:
    return {k: v.as_dict() for k, v in given.items()}

def _key_conditions_from_dict(given: Dict[str, Any]) -> dict[str, Condition]:
    return {k: Condition.from_dict(v) for k, v in given.items()}

def _import_summary_list_as_dict(given: list[ImportSummary]) -> List[Any]:
    return [v.as_dict() for v in given]

def _import_summary_list_from_dict(given: List[Any]) -> list[ImportSummary]:
    return [ImportSummary.from_dict(v) for v in given]

def _global_table_list_as_dict(given: list[GlobalTable]) -> List[Any]:
    return [v.as_dict() for v in given]

def _global_table_list_from_dict(given: List[Any]) -> list[GlobalTable]:
    return [GlobalTable.from_dict(v) for v in given]

def _replica_list_as_dict(given: list[Replica]) -> List[Any]:
    return [v.as_dict() for v in given]

def _replica_list_from_dict(given: List[Any]) -> list[Replica]:
    return [Replica.from_dict(v) for v in given]

def _export_summaries_as_dict(given: list[ExportSummary]) -> List[Any]:
    return [v.as_dict() for v in given]

def _export_summaries_from_dict(given: List[Any]) -> list[ExportSummary]:
    return [ExportSummary.from_dict(v) for v in given]

def _contributor_insights_summaries_as_dict(given: list[ContributorInsightsSummary]) -> List[Any]:
    return [v.as_dict() for v in given]

def _contributor_insights_summaries_from_dict(given: List[Any]) -> list[ContributorInsightsSummary]:
    return [ContributorInsightsSummary.from_dict(v) for v in given]

def _backup_summaries_as_dict(given: list[BackupSummary]) -> List[Any]:
    return [v.as_dict() for v in given]

def _backup_summaries_from_dict(given: List[Any]) -> list[BackupSummary]:
    return [BackupSummary.from_dict(v) for v in given]

def _parameterized_statements_as_dict(given: list[ParameterizedStatement]) -> List[Any]:
    return [v.as_dict() for v in given]

def _parameterized_statements_from_dict(given: List[Any]) -> list[ParameterizedStatement]:
    return [ParameterizedStatement.from_dict(v) for v in given]

def _prepared_statement_parameters_as_dict(given: list[AttributeValue]) -> List[Any]:
    return [v.as_dict() for v in given]

def _prepared_statement_parameters_from_dict(given: List[Any]) -> list[AttributeValue]:
    return [AttributeValue.from_dict(v) for v in given]

def _kinesis_data_stream_destinations_as_dict(given: list[KinesisDataStreamDestination]) -> List[Any]:
    return [v.as_dict() for v in given]

def _kinesis_data_stream_destinations_from_dict(given: List[Any]) -> list[KinesisDataStreamDestination]:
    return [KinesisDataStreamDestination.from_dict(v) for v in given]

def _endpoints_as_dict(given: list[Endpoint]) -> List[Any]:
    return [v.as_dict() for v in given]

def _endpoints_from_dict(given: List[Any]) -> list[Endpoint]:
    return [Endpoint.from_dict(v) for v in given]

def _global_secondary_indexes_as_dict(given: list[GlobalSecondaryIndexInfo]) -> List[Any]:
    return [v.as_dict() for v in given]

def _global_secondary_indexes_from_dict(given: List[Any]) -> list[GlobalSecondaryIndexInfo]:
    return [GlobalSecondaryIndexInfo.from_dict(v) for v in given]

def _local_secondary_indexes_as_dict(given: list[LocalSecondaryIndexInfo]) -> List[Any]:
    return [v.as_dict() for v in given]

def _local_secondary_indexes_from_dict(given: List[Any]) -> list[LocalSecondaryIndexInfo]:
    return [LocalSecondaryIndexInfo.from_dict(v) for v in given]

def _batch_write_item_request_map_as_dict(given: dict[str, list[WriteRequest]]) -> Dict[str, Any]:
    return {k: _write_requests_as_dict(v) for k, v in given.items()}

def _batch_write_item_request_map_from_dict(given: Dict[str, Any]) -> dict[str, list[WriteRequest]]:
    return {k: _write_requests_from_dict(v) for k, v in given.items()}

def _write_requests_as_dict(given: list[WriteRequest]) -> List[Any]:
    return [v.as_dict() for v in given]

def _write_requests_from_dict(given: List[Any]) -> list[WriteRequest]:
    return [WriteRequest.from_dict(v) for v in given]

def _batch_get_request_map_as_dict(given: dict[str, KeysAndAttributes]) -> Dict[str, Any]:
    return {k: v.as_dict() for k, v in given.items()}

def _batch_get_request_map_from_dict(given: Dict[str, Any]) -> dict[str, KeysAndAttributes]:
    return {k: KeysAndAttributes.from_dict(v) for k, v in given.items()}

def _key_list_as_dict(given: list[dict[str, AttributeValue]]) -> List[Any]:
    return [_key_as_dict(v) for v in given]

def _key_list_from_dict(given: List[Any]) -> list[dict[str, AttributeValue]]:
    return [_key_from_dict(v) for v in given]

def _batch_get_response_map_as_dict(given: dict[str, list[dict[str, AttributeValue]]]) -> Dict[str, Any]:
    return {k: _item_list_as_dict(v) for k, v in given.items()}

def _batch_get_response_map_from_dict(given: Dict[str, Any]) -> dict[str, list[dict[str, AttributeValue]]]:
    return {k: _item_list_from_dict(v) for k, v in given.items()}

def _parti_ql_batch_response_as_dict(given: list[BatchStatementResponse]) -> List[Any]:
    return [v.as_dict() for v in given]

def _parti_ql_batch_response_from_dict(given: List[Any]) -> list[BatchStatementResponse]:
    return [BatchStatementResponse.from_dict(v) for v in given]

def _parti_ql_batch_request_as_dict(given: list[BatchStatementRequest]) -> List[Any]:
    return [v.as_dict() for v in given]

def _parti_ql_batch_request_from_dict(given: List[Any]) -> list[BatchStatementRequest]:
    return [BatchStatementRequest.from_dict(v) for v in given]
