# Code generated by smithy-python-codegen DO NOT EDIT.

from typing import Any, Dict, Generic, Literal, Optional, TypeVar

from .models import (
    CancellationReason,
    _cancellation_reason_list_as_dict,
    _cancellation_reason_list_from_dict,
)


class ServiceError(Exception):
    """Base error for all errors in the service.
    """
    pass

T = TypeVar('T')
class ApiError(ServiceError, Generic[T]):
    """Base error for all api errors in the service.
    """
    code: T
    def __init__(self, message: str):
        super().__init__(message)
        self.message = message

class UnknownApiError(ApiError[Literal['Unknown']]):
    """Error representing any unknown api errors
    """
    code: Literal['Unknown'] = 'Unknown'

class BackupInUseException(ApiError[Literal["BackupInUseException"]]):
    code: Literal["BackupInUseException"] = "BackupInUseException"
    message: str
    def __init__(
        self,
        *,
        message: str,
    ):
        """<p>There is another ongoing conflicting backup control plane operation on the
        table.
                    The backup is either being created, deleted or restored to a
        table.</p>
        :param message: A message associated with the specific error.

        """
        super().__init__(message)

    def as_dict(self) -> Dict[str, Any]:
        """Converts the BackupInUseException to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        return {
            'message': self.message,
            'code': self.code,
        }

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "BackupInUseException":
        """Creates a BackupInUseException from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {
            'message': d['message'],
        }

        return BackupInUseException(**kwargs)

    def __repr__(self) -> str:
        result = "BackupInUseException("
        result += f'message={self.message},'
        if self.message is not None:
            result += f"message={repr(self.message)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, BackupInUseException):
            return False
        attributes: list[str] = ['message','message',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class BackupNotFoundException(ApiError[Literal["BackupNotFoundException"]]):
    code: Literal["BackupNotFoundException"] = "BackupNotFoundException"
    message: str
    def __init__(
        self,
        *,
        message: str,
    ):
        """<p>Backup not found for the given BackupARN. </p>
        :param message: A message associated with the specific error.

        """
        super().__init__(message)

    def as_dict(self) -> Dict[str, Any]:
        """Converts the BackupNotFoundException to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        return {
            'message': self.message,
            'code': self.code,
        }

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "BackupNotFoundException":
        """Creates a BackupNotFoundException from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {
            'message': d['message'],
        }

        return BackupNotFoundException(**kwargs)

    def __repr__(self) -> str:
        result = "BackupNotFoundException("
        result += f'message={self.message},'
        if self.message is not None:
            result += f"message={repr(self.message)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, BackupNotFoundException):
            return False
        attributes: list[str] = ['message','message',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class InternalServerError(ApiError[Literal["InternalServerError"]]):
    code: Literal["InternalServerError"] = "InternalServerError"
    message: str
    def __init__(
        self,
        *,
        message: str,
    ):
        """<p>An error occurred on the server side.</p>
        :param message: A message associated with the specific error.

        """
        super().__init__(message)

    def as_dict(self) -> Dict[str, Any]:
        """Converts the InternalServerError to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        return {
            'message': self.message,
            'code': self.code,
        }

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "InternalServerError":
        """Creates a InternalServerError from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {
            'message': d['message'],
        }

        return InternalServerError(**kwargs)

    def __repr__(self) -> str:
        result = "InternalServerError("
        result += f'message={self.message},'
        if self.message is not None:
            result += f"message={repr(self.message)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, InternalServerError):
            return False
        attributes: list[str] = ['message','message',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class RequestLimitExceeded(ApiError[Literal["RequestLimitExceeded"]]):
    code: Literal["RequestLimitExceeded"] = "RequestLimitExceeded"
    message: str
    def __init__(
        self,
        *,
        message: str,
    ):
        """<p>Throughput exceeds the current throughput quota for your account. Please
        contact
                        <a href="https://aws.amazon.com/support">Amazon Web
        Services Support</a> to request a
                    quota increase.</p>
        :param message: A message associated with the specific error.

        """
        super().__init__(message)

    def as_dict(self) -> Dict[str, Any]:
        """Converts the RequestLimitExceeded to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        return {
            'message': self.message,
            'code': self.code,
        }

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "RequestLimitExceeded":
        """Creates a RequestLimitExceeded from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {
            'message': d['message'],
        }

        return RequestLimitExceeded(**kwargs)

    def __repr__(self) -> str:
        result = "RequestLimitExceeded("
        result += f'message={self.message},'
        if self.message is not None:
            result += f"message={repr(self.message)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, RequestLimitExceeded):
            return False
        attributes: list[str] = ['message','message',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class InvalidEndpointException(ApiError[Literal["InvalidEndpointException"]]):
    code: Literal["InvalidEndpointException"] = "InvalidEndpointException"
    message: str
    def __init__(
        self,
        *,
        message: str,
    ):
        super().__init__(message)

    def as_dict(self) -> Dict[str, Any]:
        """Converts the InvalidEndpointException to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        return {
            'message': self.message,
            'code': self.code,
        }

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "InvalidEndpointException":
        """Creates a InvalidEndpointException from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {
            'message': d['message'],
        }

        return InvalidEndpointException(**kwargs)

    def __repr__(self) -> str:
        result = "InvalidEndpointException("
        result += f'message={self.message},'
        if self.message is not None:
            result += f"message={repr(self.message)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, InvalidEndpointException):
            return False
        attributes: list[str] = ['message','message',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class ProvisionedThroughputExceededException(ApiError[Literal["ProvisionedThroughputExceededException"]]):
    code: Literal["ProvisionedThroughputExceededException"] = "ProvisionedThroughputExceededException"
    message: str
    def __init__(
        self,
        *,
        message: str,
    ):
        """<p>Your request rate is too high. The Amazon Web Services SDKs for DynamoDB

        automatically retry requests that receive this exception. Your request is
        eventually
                    successful, unless your retry queue is too large to
        finish. Reduce the frequency of
                    requests and use exponential
        backoff. For more information, go to <a
        href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Programming.Errors.html#Programming.Errors.RetryAndBackoff">Error
        Retries and Exponential Backoff</a> in the <i>Amazon DynamoDB Developer
        Guide</i>.</p>
        :param message: A message associated with the specific error.

        """
        super().__init__(message)

    def as_dict(self) -> Dict[str, Any]:
        """Converts the ProvisionedThroughputExceededException to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        return {
            'message': self.message,
            'code': self.code,
        }

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "ProvisionedThroughputExceededException":
        """Creates a ProvisionedThroughputExceededException from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {
            'message': d['message'],
        }

        return ProvisionedThroughputExceededException(**kwargs)

    def __repr__(self) -> str:
        result = "ProvisionedThroughputExceededException("
        result += f'message={self.message},'
        if self.message is not None:
            result += f"message={repr(self.message)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, ProvisionedThroughputExceededException):
            return False
        attributes: list[str] = ['message','message',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class ResourceNotFoundException(ApiError[Literal["ResourceNotFoundException"]]):
    code: Literal["ResourceNotFoundException"] = "ResourceNotFoundException"
    message: str
    def __init__(
        self,
        *,
        message: str,
    ):
        """<p>The operation tried to access a nonexistent table or index. The resource
        might not
                    be specified correctly, or its status might not be
        <code>ACTIVE</code>.</p>
        :param message: A message associated with the specific error.

        """
        super().__init__(message)

    def as_dict(self) -> Dict[str, Any]:
        """Converts the ResourceNotFoundException to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        return {
            'message': self.message,
            'code': self.code,
        }

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "ResourceNotFoundException":
        """Creates a ResourceNotFoundException from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {
            'message': d['message'],
        }

        return ResourceNotFoundException(**kwargs)

    def __repr__(self) -> str:
        result = "ResourceNotFoundException("
        result += f'message={self.message},'
        if self.message is not None:
            result += f"message={repr(self.message)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, ResourceNotFoundException):
            return False
        attributes: list[str] = ['message','message',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class ItemCollectionSizeLimitExceededException(ApiError[Literal["ItemCollectionSizeLimitExceededException"]]):
    code: Literal["ItemCollectionSizeLimitExceededException"] = "ItemCollectionSizeLimitExceededException"
    message: str
    def __init__(
        self,
        *,
        message: str,
    ):
        """<p>An item collection is too large. This exception is only returned for tables
        that
                    have one or more local secondary indexes.</p>
        :param message: A message associated with the specific error.

        """
        super().__init__(message)

    def as_dict(self) -> Dict[str, Any]:
        """Converts the ItemCollectionSizeLimitExceededException to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        return {
            'message': self.message,
            'code': self.code,
        }

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "ItemCollectionSizeLimitExceededException":
        """Creates a ItemCollectionSizeLimitExceededException from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {
            'message': d['message'],
        }

        return ItemCollectionSizeLimitExceededException(**kwargs)

    def __repr__(self) -> str:
        result = "ItemCollectionSizeLimitExceededException("
        result += f'message={self.message},'
        if self.message is not None:
            result += f"message={repr(self.message)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, ItemCollectionSizeLimitExceededException):
            return False
        attributes: list[str] = ['message','message',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class ConditionalCheckFailedException(ApiError[Literal["ConditionalCheckFailedException"]]):
    code: Literal["ConditionalCheckFailedException"] = "ConditionalCheckFailedException"
    message: str
    def __init__(
        self,
        *,
        message: str,
    ):
        """<p>A condition specified in the operation could not be evaluated.</p>
        :param message: A message associated with the specific error.

        """
        super().__init__(message)

    def as_dict(self) -> Dict[str, Any]:
        """Converts the ConditionalCheckFailedException to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        return {
            'message': self.message,
            'code': self.code,
        }

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "ConditionalCheckFailedException":
        """Creates a ConditionalCheckFailedException from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {
            'message': d['message'],
        }

        return ConditionalCheckFailedException(**kwargs)

    def __repr__(self) -> str:
        result = "ConditionalCheckFailedException("
        result += f'message={self.message},'
        if self.message is not None:
            result += f"message={repr(self.message)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, ConditionalCheckFailedException):
            return False
        attributes: list[str] = ['message','message',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class ContinuousBackupsUnavailableException(ApiError[Literal["ContinuousBackupsUnavailableException"]]):
    code: Literal["ContinuousBackupsUnavailableException"] = "ContinuousBackupsUnavailableException"
    message: str
    def __init__(
        self,
        *,
        message: str,
    ):
        """<p>Backups have not yet been enabled for this table.</p>
        :param message: A message associated with the specific error.

        """
        super().__init__(message)

    def as_dict(self) -> Dict[str, Any]:
        """Converts the ContinuousBackupsUnavailableException to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        return {
            'message': self.message,
            'code': self.code,
        }

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "ContinuousBackupsUnavailableException":
        """Creates a ContinuousBackupsUnavailableException from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {
            'message': d['message'],
        }

        return ContinuousBackupsUnavailableException(**kwargs)

    def __repr__(self) -> str:
        result = "ContinuousBackupsUnavailableException("
        result += f'message={self.message},'
        if self.message is not None:
            result += f"message={repr(self.message)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, ContinuousBackupsUnavailableException):
            return False
        attributes: list[str] = ['message','message',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class LimitExceededException(ApiError[Literal["LimitExceededException"]]):
    code: Literal["LimitExceededException"] = "LimitExceededException"
    message: str
    def __init__(
        self,
        *,
        message: str,
    ):
        """<p>There is no limit to the number of daily on-demand backups that can be taken.
        </p>
                <p>Up to 500 simultaneous table operations are allowed per account.
        These operations
                    include <code>CreateTable</code>,
        <code>UpdateTable</code>,

        <code>DeleteTable</code>,<code>UpdateTimeToLive</code>,

        <code>RestoreTableFromBackup</code>, and <code>RestoreTableToPointInTime</code>.
        </p>
                <p>The only exception is when you are creating a table with one or
        more secondary
                    indexes. You can have up to 250 such requests running
        at a time; however, if the table or
                    index specifications are
        complex, DynamoDB might temporarily reduce the number
                    of concurrent
        operations.</p>
                <p>There is a soft account quota of 2,500 tables.</p>
        :param message: A message associated with the specific error.

        """
        super().__init__(message)

    def as_dict(self) -> Dict[str, Any]:
        """Converts the LimitExceededException to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        return {
            'message': self.message,
            'code': self.code,
        }

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "LimitExceededException":
        """Creates a LimitExceededException from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {
            'message': d['message'],
        }

        return LimitExceededException(**kwargs)

    def __repr__(self) -> str:
        result = "LimitExceededException("
        result += f'message={self.message},'
        if self.message is not None:
            result += f"message={repr(self.message)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, LimitExceededException):
            return False
        attributes: list[str] = ['message','message',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class TableInUseException(ApiError[Literal["TableInUseException"]]):
    code: Literal["TableInUseException"] = "TableInUseException"
    message: str
    def __init__(
        self,
        *,
        message: str,
    ):
        """<p>A target table with the specified name is either being created or deleted.

        </p>
        :param message: A message associated with the specific error.

        """
        super().__init__(message)

    def as_dict(self) -> Dict[str, Any]:
        """Converts the TableInUseException to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        return {
            'message': self.message,
            'code': self.code,
        }

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "TableInUseException":
        """Creates a TableInUseException from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {
            'message': d['message'],
        }

        return TableInUseException(**kwargs)

    def __repr__(self) -> str:
        result = "TableInUseException("
        result += f'message={self.message},'
        if self.message is not None:
            result += f"message={repr(self.message)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, TableInUseException):
            return False
        attributes: list[str] = ['message','message',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class TableNotFoundException(ApiError[Literal["TableNotFoundException"]]):
    code: Literal["TableNotFoundException"] = "TableNotFoundException"
    message: str
    def __init__(
        self,
        *,
        message: str,
    ):
        """<p>A source table with the name <code>TableName</code> does not currently exist
        within
                    the subscriber's account or the subscriber is operating in
        the wrong Amazon Web Services Region.</p>
        :param message: A message associated with the specific error.

        """
        super().__init__(message)

    def as_dict(self) -> Dict[str, Any]:
        """Converts the TableNotFoundException to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        return {
            'message': self.message,
            'code': self.code,
        }

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "TableNotFoundException":
        """Creates a TableNotFoundException from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {
            'message': d['message'],
        }

        return TableNotFoundException(**kwargs)

    def __repr__(self) -> str:
        result = "TableNotFoundException("
        result += f'message={self.message},'
        if self.message is not None:
            result += f"message={repr(self.message)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, TableNotFoundException):
            return False
        attributes: list[str] = ['message','message',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class GlobalTableAlreadyExistsException(ApiError[Literal["GlobalTableAlreadyExistsException"]]):
    code: Literal["GlobalTableAlreadyExistsException"] = "GlobalTableAlreadyExistsException"
    message: str
    def __init__(
        self,
        *,
        message: str,
    ):
        """<p>The specified global table already exists.</p>
        :param message: A message associated with the specific error.

        """
        super().__init__(message)

    def as_dict(self) -> Dict[str, Any]:
        """Converts the GlobalTableAlreadyExistsException to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        return {
            'message': self.message,
            'code': self.code,
        }

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "GlobalTableAlreadyExistsException":
        """Creates a GlobalTableAlreadyExistsException from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {
            'message': d['message'],
        }

        return GlobalTableAlreadyExistsException(**kwargs)

    def __repr__(self) -> str:
        result = "GlobalTableAlreadyExistsException("
        result += f'message={self.message},'
        if self.message is not None:
            result += f"message={repr(self.message)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, GlobalTableAlreadyExistsException):
            return False
        attributes: list[str] = ['message','message',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class ResourceInUseException(ApiError[Literal["ResourceInUseException"]]):
    code: Literal["ResourceInUseException"] = "ResourceInUseException"
    message: str
    def __init__(
        self,
        *,
        message: str,
    ):
        """<p>The operation conflicts with the resource's availability. For example, you

        attempted to recreate an existing table, or tried to delete a table currently in
        the
                        <code>CREATING</code> state.</p>
        :param message: A message associated with the specific error.

        """
        super().__init__(message)

    def as_dict(self) -> Dict[str, Any]:
        """Converts the ResourceInUseException to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        return {
            'message': self.message,
            'code': self.code,
        }

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "ResourceInUseException":
        """Creates a ResourceInUseException from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {
            'message': d['message'],
        }

        return ResourceInUseException(**kwargs)

    def __repr__(self) -> str:
        result = "ResourceInUseException("
        result += f'message={self.message},'
        if self.message is not None:
            result += f"message={repr(self.message)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, ResourceInUseException):
            return False
        attributes: list[str] = ['message','message',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class TransactionConflictException(ApiError[Literal["TransactionConflictException"]]):
    code: Literal["TransactionConflictException"] = "TransactionConflictException"
    message: str
    def __init__(
        self,
        *,
        message: str,
    ):
        """<p>Operation was rejected because there is an ongoing transaction for the

        item.</p>
        :param message: A message associated with the specific error.

        """
        super().__init__(message)

    def as_dict(self) -> Dict[str, Any]:
        """Converts the TransactionConflictException to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        return {
            'message': self.message,
            'code': self.code,
        }

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "TransactionConflictException":
        """Creates a TransactionConflictException from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {
            'message': d['message'],
        }

        return TransactionConflictException(**kwargs)

    def __repr__(self) -> str:
        result = "TransactionConflictException("
        result += f'message={self.message},'
        if self.message is not None:
            result += f"message={repr(self.message)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, TransactionConflictException):
            return False
        attributes: list[str] = ['message','message',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class ExportNotFoundException(ApiError[Literal["ExportNotFoundException"]]):
    code: Literal["ExportNotFoundException"] = "ExportNotFoundException"
    message: str
    def __init__(
        self,
        *,
        message: str,
    ):
        """<p>The specified export was not found.</p>
        :param message: A message associated with the specific error.

        """
        super().__init__(message)

    def as_dict(self) -> Dict[str, Any]:
        """Converts the ExportNotFoundException to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        return {
            'message': self.message,
            'code': self.code,
        }

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "ExportNotFoundException":
        """Creates a ExportNotFoundException from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {
            'message': d['message'],
        }

        return ExportNotFoundException(**kwargs)

    def __repr__(self) -> str:
        result = "ExportNotFoundException("
        result += f'message={self.message},'
        if self.message is not None:
            result += f"message={repr(self.message)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, ExportNotFoundException):
            return False
        attributes: list[str] = ['message','message',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class GlobalTableNotFoundException(ApiError[Literal["GlobalTableNotFoundException"]]):
    code: Literal["GlobalTableNotFoundException"] = "GlobalTableNotFoundException"
    message: str
    def __init__(
        self,
        *,
        message: str,
    ):
        """<p>The specified global table does not exist.</p>
        :param message: A message associated with the specific error.

        """
        super().__init__(message)

    def as_dict(self) -> Dict[str, Any]:
        """Converts the GlobalTableNotFoundException to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        return {
            'message': self.message,
            'code': self.code,
        }

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "GlobalTableNotFoundException":
        """Creates a GlobalTableNotFoundException from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {
            'message': d['message'],
        }

        return GlobalTableNotFoundException(**kwargs)

    def __repr__(self) -> str:
        result = "GlobalTableNotFoundException("
        result += f'message={self.message},'
        if self.message is not None:
            result += f"message={repr(self.message)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, GlobalTableNotFoundException):
            return False
        attributes: list[str] = ['message','message',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class ImportNotFoundException(ApiError[Literal["ImportNotFoundException"]]):
    code: Literal["ImportNotFoundException"] = "ImportNotFoundException"
    message: str
    def __init__(
        self,
        *,
        message: str,
    ):
        """<p>
                    The specified import was not found.
                    </p>
        :param message: A message associated with the specific error.

        """
        super().__init__(message)

    def as_dict(self) -> Dict[str, Any]:
        """Converts the ImportNotFoundException to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        return {
            'message': self.message,
            'code': self.code,
        }

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "ImportNotFoundException":
        """Creates a ImportNotFoundException from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {
            'message': d['message'],
        }

        return ImportNotFoundException(**kwargs)

    def __repr__(self) -> str:
        result = "ImportNotFoundException("
        result += f'message={self.message},'
        if self.message is not None:
            result += f"message={repr(self.message)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, ImportNotFoundException):
            return False
        attributes: list[str] = ['message','message',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class DuplicateItemException(ApiError[Literal["DuplicateItemException"]]):
    code: Literal["DuplicateItemException"] = "DuplicateItemException"
    message: str
    def __init__(
        self,
        *,
        message: str,
    ):
        """<p> There was an attempt to insert an item with the same primary key as an item
        that
                    already exists in the DynamoDB table.</p>
        :param message: A message associated with the specific error.

        """
        super().__init__(message)

    def as_dict(self) -> Dict[str, Any]:
        """Converts the DuplicateItemException to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        return {
            'message': self.message,
            'code': self.code,
        }

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "DuplicateItemException":
        """Creates a DuplicateItemException from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {
            'message': d['message'],
        }

        return DuplicateItemException(**kwargs)

    def __repr__(self) -> str:
        result = "DuplicateItemException("
        result += f'message={self.message},'
        if self.message is not None:
            result += f"message={repr(self.message)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, DuplicateItemException):
            return False
        attributes: list[str] = ['message','message',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class IdempotentParameterMismatchException(ApiError[Literal["IdempotentParameterMismatchException"]]):
    code: Literal["IdempotentParameterMismatchException"] = "IdempotentParameterMismatchException"
    message: str
    def __init__(
        self,
        *,
        message: str,
    ):
        """<p>DynamoDB rejected the request because you retried a request with a

        different payload but with an idempotent token that was already used.</p>
        :param message: A message associated with the specific error.

        """
        super().__init__(message)

    def as_dict(self) -> Dict[str, Any]:
        """Converts the IdempotentParameterMismatchException to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        return {
            'message': self.message,
            'code': self.code,
        }

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "IdempotentParameterMismatchException":
        """Creates a IdempotentParameterMismatchException from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {
            'message': d['message'],
        }

        return IdempotentParameterMismatchException(**kwargs)

    def __repr__(self) -> str:
        result = "IdempotentParameterMismatchException("
        result += f'message={self.message},'
        if self.message is not None:
            result += f"message={repr(self.message)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, IdempotentParameterMismatchException):
            return False
        attributes: list[str] = ['message','message',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class TransactionInProgressException(ApiError[Literal["TransactionInProgressException"]]):
    code: Literal["TransactionInProgressException"] = "TransactionInProgressException"
    message: str
    def __init__(
        self,
        *,
        message: str,
    ):
        """<p>The transaction with the given request token is already in progress.</p>
        :param message: A message associated with the specific error.

        """
        super().__init__(message)

    def as_dict(self) -> Dict[str, Any]:
        """Converts the TransactionInProgressException to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        return {
            'message': self.message,
            'code': self.code,
        }

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "TransactionInProgressException":
        """Creates a TransactionInProgressException from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {
            'message': d['message'],
        }

        return TransactionInProgressException(**kwargs)

    def __repr__(self) -> str:
        result = "TransactionInProgressException("
        result += f'message={self.message},'
        if self.message is not None:
            result += f"message={repr(self.message)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, TransactionInProgressException):
            return False
        attributes: list[str] = ['message','message',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class ExportConflictException(ApiError[Literal["ExportConflictException"]]):
    code: Literal["ExportConflictException"] = "ExportConflictException"
    message: str
    def __init__(
        self,
        *,
        message: str,
    ):
        """<p>There was a conflict when writing to the specified S3 bucket.</p>
        :param message: A message associated with the specific error.

        """
        super().__init__(message)

    def as_dict(self) -> Dict[str, Any]:
        """Converts the ExportConflictException to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        return {
            'message': self.message,
            'code': self.code,
        }

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "ExportConflictException":
        """Creates a ExportConflictException from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {
            'message': d['message'],
        }

        return ExportConflictException(**kwargs)

    def __repr__(self) -> str:
        result = "ExportConflictException("
        result += f'message={self.message},'
        if self.message is not None:
            result += f"message={repr(self.message)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, ExportConflictException):
            return False
        attributes: list[str] = ['message','message',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class InvalidExportTimeException(ApiError[Literal["InvalidExportTimeException"]]):
    code: Literal["InvalidExportTimeException"] = "InvalidExportTimeException"
    message: str
    def __init__(
        self,
        *,
        message: str,
    ):
        """<p>The specified <code>ExportTime</code> is outside of the point in time
        recovery
                    window.</p>
        :param message: A message associated with the specific error.

        """
        super().__init__(message)

    def as_dict(self) -> Dict[str, Any]:
        """Converts the InvalidExportTimeException to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        return {
            'message': self.message,
            'code': self.code,
        }

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "InvalidExportTimeException":
        """Creates a InvalidExportTimeException from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {
            'message': d['message'],
        }

        return InvalidExportTimeException(**kwargs)

    def __repr__(self) -> str:
        result = "InvalidExportTimeException("
        result += f'message={self.message},'
        if self.message is not None:
            result += f"message={repr(self.message)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, InvalidExportTimeException):
            return False
        attributes: list[str] = ['message','message',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class PointInTimeRecoveryUnavailableException(ApiError[Literal["PointInTimeRecoveryUnavailableException"]]):
    code: Literal["PointInTimeRecoveryUnavailableException"] = "PointInTimeRecoveryUnavailableException"
    message: str
    def __init__(
        self,
        *,
        message: str,
    ):
        """<p>Point in time recovery has not yet been enabled for this source table.</p>
        :param message: A message associated with the specific error.

        """
        super().__init__(message)

    def as_dict(self) -> Dict[str, Any]:
        """Converts the PointInTimeRecoveryUnavailableException to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        return {
            'message': self.message,
            'code': self.code,
        }

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "PointInTimeRecoveryUnavailableException":
        """Creates a PointInTimeRecoveryUnavailableException from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {
            'message': d['message'],
        }

        return PointInTimeRecoveryUnavailableException(**kwargs)

    def __repr__(self) -> str:
        result = "PointInTimeRecoveryUnavailableException("
        result += f'message={self.message},'
        if self.message is not None:
            result += f"message={repr(self.message)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, PointInTimeRecoveryUnavailableException):
            return False
        attributes: list[str] = ['message','message',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class ImportConflictException(ApiError[Literal["ImportConflictException"]]):
    code: Literal["ImportConflictException"] = "ImportConflictException"
    message: str
    def __init__(
        self,
        *,
        message: str,
    ):
        """<p>
                    There was a conflict when importing from the specified S3
        source.
                    This can occur when the current import conflicts with a
        previous import request
                    that had the same client token.

        </p>
        :param message: A message associated with the specific error.

        """
        super().__init__(message)

    def as_dict(self) -> Dict[str, Any]:
        """Converts the ImportConflictException to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        return {
            'message': self.message,
            'code': self.code,
        }

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "ImportConflictException":
        """Creates a ImportConflictException from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {
            'message': d['message'],
        }

        return ImportConflictException(**kwargs)

    def __repr__(self) -> str:
        result = "ImportConflictException("
        result += f'message={self.message},'
        if self.message is not None:
            result += f"message={repr(self.message)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, ImportConflictException):
            return False
        attributes: list[str] = ['message','message',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class TableAlreadyExistsException(ApiError[Literal["TableAlreadyExistsException"]]):
    code: Literal["TableAlreadyExistsException"] = "TableAlreadyExistsException"
    message: str
    def __init__(
        self,
        *,
        message: str,
    ):
        """<p>A target table with the specified name already exists. </p>
        :param message: A message associated with the specific error.

        """
        super().__init__(message)

    def as_dict(self) -> Dict[str, Any]:
        """Converts the TableAlreadyExistsException to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        return {
            'message': self.message,
            'code': self.code,
        }

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "TableAlreadyExistsException":
        """Creates a TableAlreadyExistsException from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {
            'message': d['message'],
        }

        return TableAlreadyExistsException(**kwargs)

    def __repr__(self) -> str:
        result = "TableAlreadyExistsException("
        result += f'message={self.message},'
        if self.message is not None:
            result += f"message={repr(self.message)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, TableAlreadyExistsException):
            return False
        attributes: list[str] = ['message','message',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class InvalidRestoreTimeException(ApiError[Literal["InvalidRestoreTimeException"]]):
    code: Literal["InvalidRestoreTimeException"] = "InvalidRestoreTimeException"
    message: str
    def __init__(
        self,
        *,
        message: str,
    ):
        """<p>An invalid restore time was specified. RestoreDateTime must be between

        EarliestRestorableDateTime and LatestRestorableDateTime.</p>
        :param message: A message associated with the specific error.

        """
        super().__init__(message)

    def as_dict(self) -> Dict[str, Any]:
        """Converts the InvalidRestoreTimeException to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        return {
            'message': self.message,
            'code': self.code,
        }

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "InvalidRestoreTimeException":
        """Creates a InvalidRestoreTimeException from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {
            'message': d['message'],
        }

        return InvalidRestoreTimeException(**kwargs)

    def __repr__(self) -> str:
        result = "InvalidRestoreTimeException("
        result += f'message={self.message},'
        if self.message is not None:
            result += f"message={repr(self.message)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, InvalidRestoreTimeException):
            return False
        attributes: list[str] = ['message','message',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class ReplicaAlreadyExistsException(ApiError[Literal["ReplicaAlreadyExistsException"]]):
    code: Literal["ReplicaAlreadyExistsException"] = "ReplicaAlreadyExistsException"
    message: str
    def __init__(
        self,
        *,
        message: str,
    ):
        """<p>The specified replica is already part of the global table.</p>
        :param message: A message associated with the specific error.

        """
        super().__init__(message)

    def as_dict(self) -> Dict[str, Any]:
        """Converts the ReplicaAlreadyExistsException to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        return {
            'message': self.message,
            'code': self.code,
        }

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "ReplicaAlreadyExistsException":
        """Creates a ReplicaAlreadyExistsException from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {
            'message': d['message'],
        }

        return ReplicaAlreadyExistsException(**kwargs)

    def __repr__(self) -> str:
        result = "ReplicaAlreadyExistsException("
        result += f'message={self.message},'
        if self.message is not None:
            result += f"message={repr(self.message)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, ReplicaAlreadyExistsException):
            return False
        attributes: list[str] = ['message','message',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class ReplicaNotFoundException(ApiError[Literal["ReplicaNotFoundException"]]):
    code: Literal["ReplicaNotFoundException"] = "ReplicaNotFoundException"
    message: str
    def __init__(
        self,
        *,
        message: str,
    ):
        """<p>The specified replica is no longer part of the global table.</p>
        :param message: A message associated with the specific error.

        """
        super().__init__(message)

    def as_dict(self) -> Dict[str, Any]:
        """Converts the ReplicaNotFoundException to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        return {
            'message': self.message,
            'code': self.code,
        }

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "ReplicaNotFoundException":
        """Creates a ReplicaNotFoundException from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {
            'message': d['message'],
        }

        return ReplicaNotFoundException(**kwargs)

    def __repr__(self) -> str:
        result = "ReplicaNotFoundException("
        result += f'message={self.message},'
        if self.message is not None:
            result += f"message={repr(self.message)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, ReplicaNotFoundException):
            return False
        attributes: list[str] = ['message','message',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class IndexNotFoundException(ApiError[Literal["IndexNotFoundException"]]):
    code: Literal["IndexNotFoundException"] = "IndexNotFoundException"
    message: str
    def __init__(
        self,
        *,
        message: str,
    ):
        """<p>The operation tried to access a nonexistent index.</p>
        :param message: A message associated with the specific error.

        """
        super().__init__(message)

    def as_dict(self) -> Dict[str, Any]:
        """Converts the IndexNotFoundException to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        return {
            'message': self.message,
            'code': self.code,
        }

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "IndexNotFoundException":
        """Creates a IndexNotFoundException from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {
            'message': d['message'],
        }

        return IndexNotFoundException(**kwargs)

    def __repr__(self) -> str:
        result = "IndexNotFoundException("
        result += f'message={self.message},'
        if self.message is not None:
            result += f"message={repr(self.message)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, IndexNotFoundException):
            return False
        attributes: list[str] = ['message','message',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class TransactionCanceledException(ApiError[Literal["TransactionCanceledException"]]):
    code: Literal["TransactionCanceledException"] = "TransactionCanceledException"
    message: str
    cancellation_reasons: Optional['list[CancellationReason]']
    def __init__(
        self,
        *,
        message: str,
        cancellation_reasons: Optional['list[CancellationReason]'] = None,
    ):
        """<p>The entire transaction request was canceled.</p>
                <p>DynamoDB cancels
        a <code>TransactWriteItems</code> request under the following

        circumstances:</p>
                <ul>
                    <li>
                        <p>A condition
        in one of the condition expressions is not met.</p>
                    </li>

        <li>
                        <p>A table in the <code>TransactWriteItems</code> request
        is in a different
                            account or region.</p>
                    </li>

        <li>
                        <p>More than one action in the
        <code>TransactWriteItems</code> operation
                            targets the same
        item.</p>
                    </li>
                    <li>
                        <p>There is
        insufficient provisioned capacity for the transaction to be

        completed.</p>
                    </li>
                    <li>
                        <p>An item
        size becomes too large (larger than 400 KB), or a local secondary

        index (LSI) becomes too large, or a similar validation error occurs because of

        changes made by the transaction.</p>
                    </li>
                    <li>

        <p>There is a user error, such as an invalid data format.</p>
                    </li>

        </ul>

                <p>DynamoDB cancels a <code>TransactGetItems</code> request under
        the
                    following circumstances:</p>
                <ul>
                    <li>

        <p>There is an ongoing <code>TransactGetItems</code> operation that conflicts

        with a concurrent <code>PutItem</code>, <code>UpdateItem</code>,

        <code>DeleteItem</code> or <code>TransactWriteItems</code> request. In this

        case the <code>TransactGetItems</code> operation fails with a

        <code>TransactionCanceledException</code>.</p>
                    </li>

        <li>
                        <p>A table in the <code>TransactGetItems</code> request is
        in a different
                            account or region.</p>
                    </li>

        <li>
                        <p>There is insufficient provisioned capacity for the
        transaction to be
                            completed.</p>
                    </li>

        <li>
                        <p>There is a user error, such as an invalid data
        format.</p>
                    </li>
                 </ul>

                <note>
                    <p>If
        using Java, DynamoDB lists the cancellation reasons on the

        <code>CancellationReasons</code> property. This property is not set for other

        languages. Transaction cancellation reasons are ordered in the order of
        requested
                        items, if an item has no error it will have
        <code>None</code> code and
                            <code>Null</code> message.</p>

        </note>
                <p>Cancellation reason codes and possible error messages:</p>

        <ul>
                    <li>
                        <p>No Errors:</p>
                        <ul>

        <li>
                                <p>Code: <code>None</code>

        </p>
                            </li>
                          <li>

        <p>Message: <code>null</code>
                                </p>

        </li>
                       </ul>
                    </li>
                    <li>

        <p>Conditional Check Failed:</p>
                        <ul>
                          <li>

        <p>Code: <code>ConditionalCheckFailed</code>
                                </p>

        </li>
                          <li>
                                <p>Message: The conditional
        request failed. </p>
                            </li>
                       </ul>

        </li>
                    <li>
                        <p>Item Collection Size Limit
        Exceeded:</p>
                        <ul>
                          <li>

        <p>Code: <code>ItemCollectionSizeLimitExceeded</code>

        </p>
                            </li>
                          <li>

        <p>Message: Collection size exceeded.</p>
                            </li>

        </ul>
                    </li>
                    <li>
                        <p>Transaction
        Conflict:</p>
                        <ul>
                          <li>

        <p>Code: <code>TransactionConflict</code>
                                </p>

        </li>
                          <li>
                                <p>Message: Transaction is
        ongoing for the item.</p>
                            </li>
                       </ul>

        </li>
                    <li>
                        <p>Provisioned Throughput Exceeded:</p>

        <ul>
                          <li>
                                <p>Code:
        <code>ProvisionedThroughputExceeded</code>
                                </p>

        </li>
                          <li>
                                <p>Messages:</p>

        <ul>
                                <li>
                                        <p>The level
        of configured provisioned throughput for the

        table was exceeded. Consider increasing your provisioning level

        with the UpdateTable API.</p>
                                        <note>

        <p>This Message is received when provisioned throughput is

        exceeded is on a provisioned DynamoDB

        table.</p>
                                        </note>

        </li>
                                <li>
                                        <p>The level
        of configured provisioned throughput for one or

        more global secondary indexes of the table was exceeded.

        Consider increasing your provisioning level for the

        under-provisioned global secondary indexes with the UpdateTable

        API.</p>
                                        <note>

        <p>This message is returned when provisioned throughput is

        exceeded is on a provisioned GSI.</p>
                                        </note>

        </li>
                             </ul>

                            </li>

        </ul>
                    </li>
                    <li>
                        <p>Throttling
        Error:</p>
                        <ul>
                          <li>

        <p>Code: <code>ThrottlingError</code>
                                </p>

        </li>
                          <li>
                                <p>Messages: </p>

        <ul>
                                <li>
                                        <p>Throughput
        exceeds the current capacity of your table or

        index. DynamoDB is automatically scaling your table or

        index so please try again shortly. If exceptions persist, check

        if you have a hot key:

        https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/bp-partition-key-design.html.</p>

        <note>
                                            <p>This message is returned when
        writes get throttled on an
                                                On-Demand
        table as DynamoDB is automatically

        scaling the table.</p>
                                        </note>

        </li>
                                <li>
                                        <p>Throughput
        exceeds the current capacity for one or more

        global secondary indexes. DynamoDB is automatically

        scaling your index so please try again shortly.</p>

        <note>
                                            <p>This message is returned when when
        writes get throttled on
                                                an On-Demand GSI
        as DynamoDB is automatically
                                                scaling the
        GSI.</p>
                                        </note>

        </li>
                             </ul>

                            </li>

        </ul>
                    </li>
                    <li>
                        <p>Validation
        Error:</p>
                        <ul>
                          <li>

        <p>Code: <code>ValidationError</code>
                                </p>

        </li>
                          <li>
                                <p>Messages: </p>

        <ul>
                                <li>
                                        <p>One or more
        parameter values were invalid.</p>
                                    </li>

        <li>
                                        <p>The update expression attempted to
        update the secondary
                                            index key beyond
        allowed size limits.</p>
                                    </li>

        <li>
                                        <p>The update expression attempted to
        update the secondary
                                            index key to
        unsupported type.</p>
                                    </li>

        <li>
                                        <p>An operand in the update expression has
        an incorrect data
                                            type.</p>

        </li>
                                <li>
                                        <p>Item size
        to update has exceeded the maximum allowed

        size.</p>
                                    </li>
                                <li>

        <p>Number overflow. Attempting to store a number with

        magnitude larger than supported range.</p>
                                    </li>

        <li>
                                        <p>Type mismatch for attribute to
        update.</p>
                                    </li>
                                <li>

        <p>Nesting Levels have exceeded supported limits.</p>

        </li>
                                <li>
                                        <p>The
        document path provided in the update expression is

        invalid for update.</p>
                                    </li>

        <li>
                                        <p>The provided expression refers to an
        attribute that does
                                            not exist in the
        item.</p>
                                    </li>
                             </ul>

        </li>
                       </ul>
                    </li>
                 </ul>
        :param message: A message associated with the specific error.

        :param cancellation_reasons: <p>A list of cancellation reasons.</p>
        """
        super().__init__(message)
        self.cancellation_reasons = cancellation_reasons

    def as_dict(self) -> Dict[str, Any]:
        """Converts the TransactionCanceledException to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        d: Dict[str, Any] = {
            'message': self.message,
            'code': self.code,
        }

        if self.cancellation_reasons is not None:
            d["CancellationReasons"] = _cancellation_reason_list_as_dict(self.cancellation_reasons),

        return d

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "TransactionCanceledException":
        """Creates a TransactionCanceledException from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {
            'message': d['message'],
        }

        if "CancellationReasons" in d:
            kwargs["cancellation_reasons"] = _cancellation_reason_list_from_dict(d["CancellationReasons"]),

        return TransactionCanceledException(**kwargs)

    def __repr__(self) -> str:
        result = "TransactionCanceledException("
        result += f'message={self.message},'
        if self.message is not None:
            result += f"message={repr(self.message)}, "

        if self.cancellation_reasons is not None:
            result += f"cancellation_reasons={repr(self.cancellation_reasons)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, TransactionCanceledException):
            return False
        attributes: list[str] = ['message','message','cancellation_reasons',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )
