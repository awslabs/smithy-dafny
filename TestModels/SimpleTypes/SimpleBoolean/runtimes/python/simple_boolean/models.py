# Code generated by smithy-python-codegen DO NOT EDIT.

from typing import Any, Dict, Optional, TypeVar, cast


class _DEFAULT:
    def __init__(self, wrapped: Any):
        """Wraps a value to signal it was provided by default.

        These values will be immediately unwrapped in the associated
        initializers so the values can be used as normal, the defaultedness
        will then be tracked separately.
        """
        self._wrapped = wrapped

    @property
    def value(self) -> Any:
        # Prevent mutations from leaking by simply returning copies of mutable
        # defaults. We could also just make immutable subclasses.
        if isinstance(self._wrapped, list):
            return list(self._wrapped)
        if isinstance(self._wrapped, dict):
            return dict(self._wrapped)
        return self._wrapped

    def __repr__(self) -> str:
        return f"_DEFAULT({repr(self._wrapped)})"

    def __str__(self) -> str:
        return str(self._wrapped)

_D = TypeVar("_D")

def _default(value: _D) -> _D:
    """Wraps a value to signal it was provided by default.

    These values will be immediately unwrapped in the associated
    initializers so the values can be used as normal, the defaultedness
    will then be tracked separately.

    We use this wrapper function for brevity, but also because many completion
    tools will show the code of the default rather than the result, and
    `_default(7)` is a bit more clear than `cast(int, _DEFAULT(7))`.
    """
    return cast(_D, _DEFAULT(value))

class GetBooleanInput:
    value: Optional[bool]
    def __init__(
        self,
        *,
        value: Optional[bool] = None,
    ):
        self._has: dict[str, bool] = {}
        self.value = value

    def _set_default_attr(self, name: str, value: Any) -> None:
        if isinstance(value, _DEFAULT):
            object.__setattr__(self, name, value.value)
            self._has[name] = False
        else:
            setattr(self, name, value)

    def __setattr__(self, name: str, value: Any) -> None:
        object.__setattr__(self, name, value)
        self._has[name] = True

    def _hasattr(self, name: str) -> bool:
        if self._has.get(name, False):
            return True
        # Lists and dicts are mutable. We could make immutable variants, but
        # that's kind of a bad experience. Instead we can just check to see if
        # the value is empty.
        if isinstance((v := getattr(self, name, None)), (dict, list)) and len(v) != 0:
            self._has[name] = True
            return True
        return False

    def as_dict(self) -> Dict[str, Any]:
        """Converts the GetBooleanInput to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        d: Dict[str, Any] = {}

        if self._hasattr("value") and self.value is not None:
            d["value"] = self.value

        return d

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "GetBooleanInput":
        """Creates a GetBooleanInput from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {}

        if "value" in d:
            kwargs["value"] = d["value"]

        return GetBooleanInput(**kwargs)

    def __repr__(self) -> str:
        result = "GetBooleanInput("
        if self._has["value"]:
            result += f"value={repr(self.value)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, GetBooleanInput):
            return False
        attributes: list[str] = ['value',]
        return all(
            self._hasattr(a) == other._hasattr(a) and getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class GetBooleanOutput:
    value: Optional[bool]
    def __init__(
        self,
        *,
        value: Optional[bool] = None,
    ):
        self._has: dict[str, bool] = {}
        self.value = value

    def _set_default_attr(self, name: str, value: Any) -> None:
        if isinstance(value, _DEFAULT):
            object.__setattr__(self, name, value.value)
            self._has[name] = False
        else:
            setattr(self, name, value)

    def __setattr__(self, name: str, value: Any) -> None:
        object.__setattr__(self, name, value)
        self._has[name] = True

    def _hasattr(self, name: str) -> bool:
        if self._has.get(name, False):
            return True
        # Lists and dicts are mutable. We could make immutable variants, but
        # that's kind of a bad experience. Instead we can just check to see if
        # the value is empty.
        if isinstance((v := getattr(self, name, None)), (dict, list)) and len(v) != 0:
            self._has[name] = True
            return True
        return False

    def as_dict(self) -> Dict[str, Any]:
        """Converts the GetBooleanOutput to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        d: Dict[str, Any] = {}

        if self._hasattr("value") and self.value is not None:
            d["value"] = self.value

        return d

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "GetBooleanOutput":
        """Creates a GetBooleanOutput from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {}

        if "value" in d:
            kwargs["value"] = d["value"]

        return GetBooleanOutput(**kwargs)

    def __repr__(self) -> str:
        result = "GetBooleanOutput("
        if self._has["value"]:
            result += f"value={repr(self.value)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, GetBooleanOutput):
            return False
        attributes: list[str] = ['value',]
        return all(
            self._hasattr(a) == other._hasattr(a) and getattr(self, a) == getattr(other, a)
            for a in attributes
        )
