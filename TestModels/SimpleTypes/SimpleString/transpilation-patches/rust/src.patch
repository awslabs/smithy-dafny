diff --git b/TestModels/SimpleTypes/SimpleString/runtimes/rust/Cargo.lock a/TestModels/SimpleTypes/SimpleString/runtimes/rust/Cargo.lock
new file mode 100644
index 00000000..9b476ce2
--- /dev/null
+++ a/TestModels/SimpleTypes/SimpleString/runtimes/rust/Cargo.lock
@@ -0,0 +1,894 @@
+# This file is automatically @generated by Cargo.
+# It is not intended for manual editing.
+version = 3
+
+[[package]]
+name = "addr2line"
+version = "0.21.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "8a30b2e23b9e17a9f90641c7ab1549cd9b44f296d3ccbf309d2863cfe398a0cb"
+dependencies = [
+ "gimli",
+]
+
+[[package]]
+name = "adler"
+version = "1.0.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "f26201604c87b1e01bd3d98f8d5d9a8fcbb815e8cedb41ffccbeb4bf593a35fe"
+
+[[package]]
+name = "as-any"
+version = "0.3.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "5b8a30a44e99a1c83ccb2a6298c563c888952a1c9134953db26876528f84c93a"
+
+[[package]]
+name = "autocfg"
+version = "1.2.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "f1fdabc7756949593fe60f30ec81974b613357de856987752631dea1e3394c80"
+
+[[package]]
+name = "aws-smithy-async"
+version = "1.2.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "62220bc6e97f946ddd51b5f1361f78996e704677afc518a4ff66b7a72ea1378c"
+dependencies = [
+ "futures-util",
+ "pin-project-lite",
+ "tokio",
+]
+
+[[package]]
+name = "aws-smithy-http"
+version = "0.60.7"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "3f10fa66956f01540051b0aa7ad54574640f748f9839e843442d99b970d3aff9"
+dependencies = [
+ "aws-smithy-runtime-api",
+ "aws-smithy-types",
+ "bytes",
+ "bytes-utils",
+ "futures-core",
+ "http 0.2.12",
+ "http-body 0.4.6",
+ "once_cell",
+ "percent-encoding",
+ "pin-project-lite",
+ "pin-utils",
+ "tracing",
+]
+
+[[package]]
+name = "aws-smithy-runtime"
+version = "1.2.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "c53572b4cd934ee5e8461ad53caa36e9d246aaef42166e3ac539e206a925d330"
+dependencies = [
+ "aws-smithy-async",
+ "aws-smithy-http",
+ "aws-smithy-runtime-api",
+ "aws-smithy-types",
+ "bytes",
+ "fastrand",
+ "http 0.2.12",
+ "http-body 0.4.6",
+ "http-body 1.0.0",
+ "once_cell",
+ "pin-project-lite",
+ "pin-utils",
+ "tokio",
+ "tracing",
+]
+
+[[package]]
+name = "aws-smithy-runtime-api"
+version = "1.3.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "ccb2b3a7030dc9a3c9a08ce0b25decea5130e9db19619d4dffbbff34f75fe850"
+dependencies = [
+ "aws-smithy-async",
+ "aws-smithy-types",
+ "bytes",
+ "http 0.2.12",
+ "http 1.1.0",
+ "pin-project-lite",
+ "tokio",
+ "tracing",
+]
+
+[[package]]
+name = "aws-smithy-types"
+version = "1.1.8"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "abe14dceea1e70101d38fbf2a99e6a34159477c0fb95e68e05c66bd7ae4c3729"
+dependencies = [
+ "base64-simd",
+ "bytes",
+ "bytes-utils",
+ "http 0.2.12",
+ "http 1.1.0",
+ "http-body 0.4.6",
+ "http-body 1.0.0",
+ "http-body-util",
+ "itoa",
+ "num-integer",
+ "pin-project-lite",
+ "pin-utils",
+ "ryu",
+ "serde",
+ "time",
+]
+
+[[package]]
+name = "backtrace"
+version = "0.3.71"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "26b05800d2e817c8b3b4b54abd461726265fa9789ae34330622f2db9ee696f9d"
+dependencies = [
+ "addr2line",
+ "cc",
+ "cfg-if",
+ "libc",
+ "miniz_oxide",
+ "object",
+ "rustc-demangle",
+]
+
+[[package]]
+name = "base64-simd"
+version = "0.8.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "339abbe78e73178762e23bea9dfd08e697eb3f3301cd4be981c0f78ba5859195"
+dependencies = [
+ "outref",
+ "vsimd",
+]
+
+[[package]]
+name = "bitflags"
+version = "1.3.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "bef38d45163c2f1dde094a7dfd33ccf595c92905c8f8f4fdc18d06fb1037718a"
+
+[[package]]
+name = "bytes"
+version = "1.6.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "514de17de45fdb8dc022b1a7975556c53c86f9f0aa5f534b98977b171857c2c9"
+
+[[package]]
+name = "bytes-utils"
+version = "0.1.4"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "7dafe3a8757b027e2be6e4e5601ed563c55989fcf1546e933c66c8eb3a058d35"
+dependencies = [
+ "bytes",
+ "either",
+]
+
+[[package]]
+name = "cc"
+version = "1.0.90"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "8cd6604a82acf3039f1144f54b8eb34e91ffba622051189e71b781822d5ee1f5"
+
+[[package]]
+name = "cfg-if"
+version = "1.0.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "baf1de4339761588bc0619e3cbc0120ee582ebb74b53b4efbf79117bd2da40fd"
+
+[[package]]
+name = "dafny_runtime"
+version = "0.1.0"
+dependencies = [
+ "as-any",
+ "itertools",
+ "num",
+ "once_cell",
+ "paste",
+]
+
+[[package]]
+name = "dafny_standard_library"
+version = "0.1.0"
+dependencies = [
+ "dafny_runtime",
+]
+
+[[package]]
+name = "deranged"
+version = "0.3.11"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "b42b6fa04a440b495c8b04d0e71b707c585f83cb9cb28cf8cd0d976c315e31b4"
+dependencies = [
+ "powerfmt",
+]
+
+[[package]]
+name = "either"
+version = "1.10.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "11157ac094ffbdde99aa67b23417ebdd801842852b500e395a45a9c0aac03e4a"
+
+[[package]]
+name = "fastrand"
+version = "2.0.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "658bd65b1cf4c852a3cc96f18a8ce7b5640f6b703f905c7d74532294c2a63984"
+
+[[package]]
+name = "fnv"
+version = "1.0.7"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "3f9eec918d3f24069decb9af1554cad7c880e2da24a9afd88aca000531ab82c1"
+
+[[package]]
+name = "futures-core"
+version = "0.3.30"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "dfc6580bb841c5a68e9ef15c77ccc837b40a7504914d52e47b8b0e9bbda25a1d"
+
+[[package]]
+name = "futures-task"
+version = "0.3.30"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "38d84fa142264698cdce1a9f9172cf383a0c82de1bddcf3092901442c4097004"
+
+[[package]]
+name = "futures-util"
+version = "0.3.30"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "3d6401deb83407ab3da39eba7e33987a73c3df0c82b4bb5813ee871c19c41d48"
+dependencies = [
+ "futures-core",
+ "futures-task",
+ "pin-project-lite",
+ "pin-utils",
+]
+
+[[package]]
+name = "gimli"
+version = "0.28.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "4271d37baee1b8c7e4b708028c57d816cf9d2434acb33a549475f78c181f6253"
+
+[[package]]
+name = "hermit-abi"
+version = "0.3.9"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "d231dfb89cfffdbc30e7fc41579ed6066ad03abda9e567ccafae602b97ec5024"
+
+[[package]]
+name = "http"
+version = "0.2.12"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "601cbb57e577e2f5ef5be8e7b83f0f63994f25aa94d673e54a92d5c516d101f1"
+dependencies = [
+ "bytes",
+ "fnv",
+ "itoa",
+]
+
+[[package]]
+name = "http"
+version = "1.1.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "21b9ddb458710bc376481b842f5da65cdf31522de232c1ca8146abce2a358258"
+dependencies = [
+ "bytes",
+ "fnv",
+ "itoa",
+]
+
+[[package]]
+name = "http-body"
+version = "0.4.6"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "7ceab25649e9960c0311ea418d17bee82c0dcec1bd053b5f9a66e265a693bed2"
+dependencies = [
+ "bytes",
+ "http 0.2.12",
+ "pin-project-lite",
+]
+
+[[package]]
+name = "http-body"
+version = "1.0.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "1cac85db508abc24a2e48553ba12a996e87244a0395ce011e62b37158745d643"
+dependencies = [
+ "bytes",
+ "http 1.1.0",
+]
+
+[[package]]
+name = "http-body-util"
+version = "0.1.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "0475f8b2ac86659c21b64320d5d653f9efe42acd2a4e560073ec61a155a34f1d"
+dependencies = [
+ "bytes",
+ "futures-core",
+ "http 1.1.0",
+ "http-body 1.0.0",
+ "pin-project-lite",
+]
+
+[[package]]
+name = "itertools"
+version = "0.11.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "b1c173a5686ce8bfa551b3563d0c2170bf24ca44da99c7ca4bfdab5418c3fe57"
+dependencies = [
+ "either",
+]
+
+[[package]]
+name = "itoa"
+version = "1.0.11"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "49f1f14873335454500d59611f1cf4a4b0f786f9ac11f4312a78e4cf2566695b"
+
+[[package]]
+name = "libc"
+version = "0.2.153"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "9c198f91728a82281a64e1f4f9eeb25d82cb32a5de251c6bd1b5154d63a8e7bd"
+
+[[package]]
+name = "lock_api"
+version = "0.4.11"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "3c168f8615b12bc01f9c17e2eb0cc07dcae1940121185446edc3744920e8ef45"
+dependencies = [
+ "autocfg",
+ "scopeguard",
+]
+
+[[package]]
+name = "memchr"
+version = "2.7.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "6c8640c5d730cb13ebd907d8d04b52f55ac9a2eec55b440c8892f40d56c76c1d"
+
+[[package]]
+name = "miniz_oxide"
+version = "0.7.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "9d811f3e15f28568be3407c8e7fdb6514c1cda3cb30683f15b6a1a1dc4ea14a7"
+dependencies = [
+ "adler",
+]
+
+[[package]]
+name = "mio"
+version = "0.8.11"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "a4a650543ca06a924e8b371db273b2756685faae30f8487da1b56505a8f78b0c"
+dependencies = [
+ "libc",
+ "wasi",
+ "windows-sys 0.48.0",
+]
+
+[[package]]
+name = "num"
+version = "0.4.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "b05180d69e3da0e530ba2a1dae5110317e49e3b7f3d41be227dc5f92e49ee7af"
+dependencies = [
+ "num-bigint",
+ "num-complex",
+ "num-integer",
+ "num-iter",
+ "num-rational",
+ "num-traits",
+]
+
+[[package]]
+name = "num-bigint"
+version = "0.4.4"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "608e7659b5c3d7cba262d894801b9ec9d00de989e8a82bd4bef91d08da45cdc0"
+dependencies = [
+ "autocfg",
+ "num-integer",
+ "num-traits",
+]
+
+[[package]]
+name = "num-complex"
+version = "0.4.5"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "23c6602fda94a57c990fe0df199a035d83576b496aa29f4e634a8ac6004e68a6"
+dependencies = [
+ "num-traits",
+]
+
+[[package]]
+name = "num-conv"
+version = "0.1.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "51d515d32fb182ee37cda2ccdcb92950d6a3c2893aa280e540671c2cd0f3b1d9"
+
+[[package]]
+name = "num-integer"
+version = "0.1.46"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "7969661fd2958a5cb096e56c8e1ad0444ac2bbcd0061bd28660485a44879858f"
+dependencies = [
+ "num-traits",
+]
+
+[[package]]
+name = "num-iter"
+version = "0.1.44"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "d869c01cc0c455284163fd0092f1f93835385ccab5a98a0dcc497b2f8bf055a9"
+dependencies = [
+ "autocfg",
+ "num-integer",
+ "num-traits",
+]
+
+[[package]]
+name = "num-rational"
+version = "0.4.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "0638a1c9d0a3c0914158145bc76cff373a75a627e6ecbfb71cbe6f453a5a19b0"
+dependencies = [
+ "autocfg",
+ "num-bigint",
+ "num-integer",
+ "num-traits",
+]
+
+[[package]]
+name = "num-traits"
+version = "0.2.18"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "da0df0e5185db44f69b44f26786fe401b6c293d1907744beaa7fa62b2e5a517a"
+dependencies = [
+ "autocfg",
+]
+
+[[package]]
+name = "num_cpus"
+version = "1.16.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "4161fcb6d602d4d2081af7c3a45852d875a03dd337a6bfdd6e06407b61342a43"
+dependencies = [
+ "hermit-abi",
+ "libc",
+]
+
+[[package]]
+name = "object"
+version = "0.32.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "a6a622008b6e321afc04970976f62ee297fdbaa6f95318ca343e3eebb9648441"
+dependencies = [
+ "memchr",
+]
+
+[[package]]
+name = "once_cell"
+version = "1.19.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "3fdb12b2476b595f9358c5161aa467c2438859caa136dec86c26fdd2efe17b92"
+
+[[package]]
+name = "outref"
+version = "0.5.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "4030760ffd992bef45b0ae3f10ce1aba99e33464c90d14dd7c039884963ddc7a"
+
+[[package]]
+name = "parking_lot"
+version = "0.12.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "3742b2c103b9f06bc9fff0a37ff4912935851bee6d36f3c02bcc755bcfec228f"
+dependencies = [
+ "lock_api",
+ "parking_lot_core",
+]
+
+[[package]]
+name = "parking_lot_core"
+version = "0.9.9"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "4c42a9226546d68acdd9c0a280d17ce19bfe27a46bf68784e4066115788d008e"
+dependencies = [
+ "cfg-if",
+ "libc",
+ "redox_syscall",
+ "smallvec",
+ "windows-targets 0.48.5",
+]
+
+[[package]]
+name = "paste"
+version = "1.0.14"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "de3145af08024dea9fa9914f381a17b8fc6034dfb00f3a84013f7ff43f29ed4c"
+
+[[package]]
+name = "percent-encoding"
+version = "2.3.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "e3148f5046208a5d56bcfc03053e3ca6334e51da8dfb19b6cdc8b306fae3283e"
+
+[[package]]
+name = "pin-project-lite"
+version = "0.2.14"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "bda66fc9667c18cb2758a2ac84d1167245054bcf85d5d1aaa6923f45801bdd02"
+
+[[package]]
+name = "pin-utils"
+version = "0.1.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "8b870d8c151b6f2fb93e84a13146138f05d02ed11c7e7c54f8826aaaf7c9f184"
+
+[[package]]
+name = "powerfmt"
+version = "0.2.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "439ee305def115ba05938db6eb1644ff94165c5ab5e9420d1c1bcedbba909391"
+
+[[package]]
+name = "proc-macro2"
+version = "1.0.79"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "e835ff2298f5721608eb1a980ecaee1aef2c132bf95ecc026a11b7bf3c01c02e"
+dependencies = [
+ "unicode-ident",
+]
+
+[[package]]
+name = "quote"
+version = "1.0.35"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "291ec9ab5efd934aaf503a6466c5d5251535d108ee747472c3977cc5acc868ef"
+dependencies = [
+ "proc-macro2",
+]
+
+[[package]]
+name = "redox_syscall"
+version = "0.4.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "4722d768eff46b75989dd134e5c353f0d6296e5aaa3132e776cbdb56be7731aa"
+dependencies = [
+ "bitflags",
+]
+
+[[package]]
+name = "rustc-demangle"
+version = "0.1.23"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "d626bb9dae77e28219937af045c257c28bfd3f69333c512553507f5f9798cb76"
+
+[[package]]
+name = "ryu"
+version = "1.0.17"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "e86697c916019a8588c99b5fac3cead74ec0b4b819707a682fd4d23fa0ce1ba1"
+
+[[package]]
+name = "scopeguard"
+version = "1.2.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "94143f37725109f92c262ed2cf5e59bce7498c01bcc1502d7b9afe439a4e9f49"
+
+[[package]]
+name = "serde"
+version = "1.0.197"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "3fb1c873e1b9b056a4dc4c0c198b24c3ffa059243875552b2bd0933b1aee4ce2"
+dependencies = [
+ "serde_derive",
+]
+
+[[package]]
+name = "serde_derive"
+version = "1.0.197"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "7eb0b34b42edc17f6b7cac84a52a1c5f0e1bb2227e997ca9011ea3dd34e8610b"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "syn",
+]
+
+[[package]]
+name = "signal-hook-registry"
+version = "1.4.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "d8229b473baa5980ac72ef434c4415e70c4b5e71b423043adb4ba059f89c99a1"
+dependencies = [
+ "libc",
+]
+
+[[package]]
+name = "simple_string"
+version = "0.1.0"
+dependencies = [
+ "aws-smithy-runtime",
+ "aws-smithy-runtime-api",
+ "aws-smithy-types",
+ "dafny_runtime",
+ "dafny_standard_library",
+ "tokio",
+]
+
+[[package]]
+name = "smallvec"
+version = "1.13.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "3c5e1a9a646d36c3599cd173a41282daf47c44583ad367b8e6837255952e5c67"
+
+[[package]]
+name = "socket2"
+version = "0.5.6"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "05ffd9c0a93b7543e062e759284fcf5f5e3b098501104bfbdde4d404db792871"
+dependencies = [
+ "libc",
+ "windows-sys 0.52.0",
+]
+
+[[package]]
+name = "syn"
+version = "2.0.57"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "11a6ae1e52eb25aab8f3fb9fca13be982a373b8f1157ca14b897a825ba4a2d35"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "unicode-ident",
+]
+
+[[package]]
+name = "time"
+version = "0.3.34"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "c8248b6521bb14bc45b4067159b9b6ad792e2d6d754d6c41fb50e29fefe38749"
+dependencies = [
+ "deranged",
+ "num-conv",
+ "powerfmt",
+ "serde",
+ "time-core",
+ "time-macros",
+]
+
+[[package]]
+name = "time-core"
+version = "0.1.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "ef927ca75afb808a4d64dd374f00a2adf8d0fcff8e7b184af886c3c87ec4a3f3"
+
+[[package]]
+name = "time-macros"
+version = "0.2.17"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "7ba3a3ef41e6672a2f0f001392bb5dcd3ff0a9992d618ca761a11c3121547774"
+dependencies = [
+ "num-conv",
+ "time-core",
+]
+
+[[package]]
+name = "tokio"
+version = "1.37.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "1adbebffeca75fcfd058afa480fb6c0b81e165a0323f9c9d39c9697e37c46787"
+dependencies = [
+ "backtrace",
+ "bytes",
+ "libc",
+ "mio",
+ "num_cpus",
+ "parking_lot",
+ "pin-project-lite",
+ "signal-hook-registry",
+ "socket2",
+ "tokio-macros",
+ "windows-sys 0.48.0",
+]
+
+[[package]]
+name = "tokio-macros"
+version = "2.2.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "5b8a1e28f2deaa14e508979454cb3a223b10b938b45af148bc0986de36f1923b"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "syn",
+]
+
+[[package]]
+name = "tracing"
+version = "0.1.40"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "c3523ab5a71916ccf420eebdf5521fcef02141234bbc0b8a49f2fdc4544364ef"
+dependencies = [
+ "pin-project-lite",
+ "tracing-attributes",
+ "tracing-core",
+]
+
+[[package]]
+name = "tracing-attributes"
+version = "0.1.27"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "34704c8d6ebcbc939824180af020566b01a7c01f80641264eba0999f6c2b6be7"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "syn",
+]
+
+[[package]]
+name = "tracing-core"
+version = "0.1.32"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "c06d3da6113f116aaee68e4d601191614c9053067f9ab7f6edbcb161237daa54"
+dependencies = [
+ "once_cell",
+]
+
+[[package]]
+name = "unicode-ident"
+version = "1.0.12"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "3354b9ac3fae1ff6755cb6db53683adb661634f67557942dea4facebec0fee4b"
+
+[[package]]
+name = "vsimd"
+version = "0.8.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "5c3082ca00d5a5ef149bb8b555a72ae84c9c59f7250f013ac822ac2e49b19c64"
+
+[[package]]
+name = "wasi"
+version = "0.11.0+wasi-snapshot-preview1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "9c8d87e72b64a3b4db28d11ce29237c246188f4f51057d65a7eab63b7987e423"
+
+[[package]]
+name = "windows-sys"
+version = "0.48.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "677d2418bec65e3338edb076e806bc1ec15693c5d0104683f2efe857f61056a9"
+dependencies = [
+ "windows-targets 0.48.5",
+]
+
+[[package]]
+name = "windows-sys"
+version = "0.52.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "282be5f36a8ce781fad8c8ae18fa3f9beff57ec1b52cb3de0789201425d9a33d"
+dependencies = [
+ "windows-targets 0.52.4",
+]
+
+[[package]]
+name = "windows-targets"
+version = "0.48.5"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "9a2fa6e2155d7247be68c096456083145c183cbbbc2764150dda45a87197940c"
+dependencies = [
+ "windows_aarch64_gnullvm 0.48.5",
+ "windows_aarch64_msvc 0.48.5",
+ "windows_i686_gnu 0.48.5",
+ "windows_i686_msvc 0.48.5",
+ "windows_x86_64_gnu 0.48.5",
+ "windows_x86_64_gnullvm 0.48.5",
+ "windows_x86_64_msvc 0.48.5",
+]
+
+[[package]]
+name = "windows-targets"
+version = "0.52.4"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "7dd37b7e5ab9018759f893a1952c9420d060016fc19a472b4bb20d1bdd694d1b"
+dependencies = [
+ "windows_aarch64_gnullvm 0.52.4",
+ "windows_aarch64_msvc 0.52.4",
+ "windows_i686_gnu 0.52.4",
+ "windows_i686_msvc 0.52.4",
+ "windows_x86_64_gnu 0.52.4",
+ "windows_x86_64_gnullvm 0.52.4",
+ "windows_x86_64_msvc 0.52.4",
+]
+
+[[package]]
+name = "windows_aarch64_gnullvm"
+version = "0.48.5"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "2b38e32f0abccf9987a4e3079dfb67dcd799fb61361e53e2882c3cbaf0d905d8"
+
+[[package]]
+name = "windows_aarch64_gnullvm"
+version = "0.52.4"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "bcf46cf4c365c6f2d1cc93ce535f2c8b244591df96ceee75d8e83deb70a9cac9"
+
+[[package]]
+name = "windows_aarch64_msvc"
+version = "0.48.5"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "dc35310971f3b2dbbf3f0690a219f40e2d9afcf64f9ab7cc1be722937c26b4bc"
+
+[[package]]
+name = "windows_aarch64_msvc"
+version = "0.52.4"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "da9f259dd3bcf6990b55bffd094c4f7235817ba4ceebde8e6d11cd0c5633b675"
+
+[[package]]
+name = "windows_i686_gnu"
+version = "0.48.5"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "a75915e7def60c94dcef72200b9a8e58e5091744960da64ec734a6c6e9b3743e"
+
+[[package]]
+name = "windows_i686_gnu"
+version = "0.52.4"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "b474d8268f99e0995f25b9f095bc7434632601028cf86590aea5c8a5cb7801d3"
+
+[[package]]
+name = "windows_i686_msvc"
+version = "0.48.5"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "8f55c233f70c4b27f66c523580f78f1004e8b5a8b659e05a4eb49d4166cca406"
+
+[[package]]
+name = "windows_i686_msvc"
+version = "0.52.4"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "1515e9a29e5bed743cb4415a9ecf5dfca648ce85ee42e15873c3cd8610ff8e02"
+
+[[package]]
+name = "windows_x86_64_gnu"
+version = "0.48.5"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "53d40abd2583d23e4718fddf1ebec84dbff8381c07cae67ff7768bbf19c6718e"
+
+[[package]]
+name = "windows_x86_64_gnu"
+version = "0.52.4"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "5eee091590e89cc02ad514ffe3ead9eb6b660aedca2183455434b93546371a03"
+
+[[package]]
+name = "windows_x86_64_gnullvm"
+version = "0.48.5"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "0b7b52767868a23d5bab768e390dc5f5c55825b6d30b86c844ff2dc7414044cc"
+
+[[package]]
+name = "windows_x86_64_gnullvm"
+version = "0.52.4"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "77ca79f2451b49fa9e2af39f0747fe999fcda4f5e241b2898624dca97a1f2177"
+
+[[package]]
+name = "windows_x86_64_msvc"
+version = "0.48.5"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "ed94fce61571a4006852b7389a063ab983c02eb1bb37b47f8272ce92d06d9538"
+
+[[package]]
+name = "windows_x86_64_msvc"
+version = "0.52.4"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "32b752e52a2da0ddfbdbcc6fceadfeede4c939ed16d13e648833a61dfb611ed8"
diff --git b/TestModels/SimpleTypes/SimpleString/runtimes/rust/Cargo.toml a/TestModels/SimpleTypes/SimpleString/runtimes/rust/Cargo.toml
new file mode 100644
index 00000000..b6ed66fb
--- /dev/null
+++ a/TestModels/SimpleTypes/SimpleString/runtimes/rust/Cargo.toml
@@ -0,0 +1,19 @@
+[package]
+name = "simple_string"
+version = "0.1.0"
+edition = "2021"
+
+# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html
+
+[dependencies]
+dafny_runtime = { path = "../../../../dafny-dependencies/dafny_runtime_rust"}
+dafny_standard_library = { path = "../../../../dafny-dependencies/StandardLibrary/runtimes/rust"}
+[dependencies.aws-smithy-runtime]
+features = ["client"]
+[dependencies.aws-smithy-runtime-api]
+features = ["client"]
+[dependencies.aws-smithy-types]
+
+[dev-dependencies.tokio]
+version = "1.26.0"
+features = ["full"]
\ No newline at end of file
diff --git b/TestModels/SimpleTypes/SimpleString/runtimes/rust/README.md a/TestModels/SimpleTypes/SimpleString/runtimes/rust/README.md
new file mode 100644
index 00000000..65d21fde
--- /dev/null
+++ a/TestModels/SimpleTypes/SimpleString/runtimes/rust/README.md
@@ -0,0 +1,31 @@
+
+This directory is the code generation target for the SimpleString model when targetting Rust.
+
+Like the other targets, the crate is a combination of the output of three different components:
+
+1. The output of Dafny code generation for Rust (`src/implementation_from_dafny.rs`)
+2. The output of `smithy-dafny` shim/conversion generation for Rust (the `conversions` module)
+3. The output of `smithy-rs` (all other files)
+
+Most of the `smithy-rs` output is not modified, 
+only trimmed down to cut out components that aren't relevant for Polymorph libraries.
+The main exception is `client.rs` and the operation builders such as `operation/get_string.rs`,
+which instantiate the underlying Dafny client implementation and invoke operations on it, respectively,
+instead of sending the operation value through an orchestrated plugin stack
+that eventually serializes it and sends it to a remote service endpoint.
+
+This crate also includes manually-written Rust tests demonstrating what it's like
+to work with the Rust API we're exposing.
+Although we need to also get the Dafny-generated tests working,
+the manually-written ones are also valuable.
+
+It looks likely that `smithy-rs` is pluggable enough that we can plug our conversion code generation
+into it without having to fork its implementation.
+This means we should be able to get 2. and 3. above out of a single call to `smithy-rs`.
+Hence I've optimistically left the "// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT."
+header on both kinds of files.
+
+Note that even 1. is hand-modified, as the Dafny Rust code generator is not yet complete,
+and rejects some features such as the type paramter variance specifier on `Option<+T>`.
+We are trusting that Dafny will soon generate exactly the content of `implementation_from_dafny.rs`
+and it is a priority to set up CI to assert that ASAP.
diff --git b/TestModels/SimpleTypes/SimpleString/runtimes/rust/src/client.rs a/TestModels/SimpleTypes/SimpleString/runtimes/rust/src/client.rs
new file mode 100644
index 00000000..617b65b9
--- /dev/null
+++ a/TestModels/SimpleTypes/SimpleString/runtimes/rust/src/client.rs
@@ -0,0 +1,57 @@
+// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
+
+use aws_smithy_types::error::operation::BuildError;
+
+#[derive(Debug)]
+pub(crate) struct Handle {
+    pub(crate) conf: crate::Config,
+    pub(crate) inner: *mut dyn crate::implementation_from_dafny::r#_simple_dtypes_dsmithystring_dinternaldafny_dtypes::ISimpleTypesStringClient
+}
+
+#[derive(::std::clone::Clone, ::std::fmt::Debug)]
+pub struct Client {
+    handle: ::std::sync::Arc<Handle>,
+}
+
+impl Client {
+    /// Creates a new client from the service [`Config`](crate::Config).
+    #[track_caller]
+    pub fn from_conf(conf: crate::Config) -> Result<Self, BuildError> {
+        // If this service had any configuration properties,
+        // they would need converting here too.
+        let inner_config = ::std::rc::Rc::new(
+            crate::implementation_from_dafny::_simple_dtypes_dsmithystring_dinternaldafny::_default::DefaultSimpleStringConfig());
+        let inner =
+            crate::implementation_from_dafny::_simple_dtypes_dsmithystring_dinternaldafny::_default::SimpleString(&inner_config);
+        if matches!(inner.as_ref(), crate::implementation_from_dafny::_Wrappers_Compile::Result::Failure { .. }) {
+            // TODO: convert error - the potential types are not modeled!
+            return Err(BuildError::other(::aws_smithy_types::error::metadata::ErrorMetadata::builder().message("Invalid client config").build()));
+        }
+        let handle = Handle {
+            conf: conf.clone(),
+            inner: inner.Extract()
+        };
+        Ok(Self {
+            handle: ::std::sync::Arc::new(handle),
+        })
+    }
+
+    /// Returns the client's configuration.
+    pub fn config(&self) -> &crate::Config {
+        &self.handle.conf
+    }
+}
+
+impl Drop for Handle {
+    fn drop(&mut self) {
+        // Ensure the Dafny values we created by calling SimpleString are deallocated.
+        unsafe { drop(Box::from_raw(self.inner)); }
+    }
+}
+
+mod get_string;
+
+mod get_string_single_value;
+
+mod get_string_utf8;
+
diff --git b/TestModels/SimpleTypes/SimpleString/runtimes/rust/src/client/get_string.rs a/TestModels/SimpleTypes/SimpleString/runtimes/rust/src/client/get_string.rs
new file mode 100644
index 00000000..ad22d270
--- /dev/null
+++ a/TestModels/SimpleTypes/SimpleString/runtimes/rust/src/client/get_string.rs
@@ -0,0 +1,13 @@
+// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
+impl super::Client {
+  /// Constructs a fluent builder for the [`GetString`](crate::operation::get_string::builders::GetStringFluentBuilder) operation.
+  ///
+  /// - The fluent builder is configurable:
+  ///   - [`value(impl Into<Option<String>>)`](crate::operation::get_string::builders::GetStringFluentBuilder::name) / [`set_name(Option<String>)`](crate::operation::get_string::builders::GetStringFluentBuilder::set_name):(undocumented)<br>
+  /// - On success, responds with [`GetStringOutput`](crate::operation::get_string::GetStringOutput) with field(s):
+  ///   - [`value(Option<String>)`](crate::operation::get_string::GetStringOutput::value): (undocumented)
+  /// - On failure, responds with [`SdkError<GetStringError>`](crate::operation::get_string::GetStringError)
+  pub fn get_string(&self) -> crate::operation::get_string::builders::GetStringFluentBuilder {
+      crate::operation::get_string::builders::GetStringFluentBuilder::new(self.handle.clone())
+  }
+}
diff --git b/TestModels/SimpleTypes/SimpleString/runtimes/rust/src/client/get_string_single_value.rs a/TestModels/SimpleTypes/SimpleString/runtimes/rust/src/client/get_string_single_value.rs
new file mode 100644
index 00000000..3c4a6a45
--- /dev/null
+++ a/TestModels/SimpleTypes/SimpleString/runtimes/rust/src/client/get_string_single_value.rs
@@ -0,0 +1,13 @@
+// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
+impl super::Client {
+  /// Constructs a fluent builder for the [`GetStringSingleValue`](crate::operation::get_string_single_value::builders::GetStringSingleValueFluentBuilder) operation.
+  ///
+  /// - The fluent builder is configurable:
+  ///   - [`value(impl Into<Option<String>>)`](crate::operation::get_string_single_value::builders::GetStringSingleValueFluentBuilder::name) / [`set_name(Option<String>)`](crate::operation::get_string_single_value::builders::GetStringSingleValueFluentBuilder::set_name):(undocumented)<br>
+  /// - On success, responds with [`GetStringSingleValueOutput`](crate::operation::get_string_single_value::GetStringSingleValueOutput) with field(s):
+  ///   - [`value(Option<String>)`](crate::operation::get_string_single_value::GetStringSingleValueOutput::value): (undocumented)
+  /// - On failure, responds with [`SdkError<GetStringSingleValueError>`](crate::operation::get_string_single_value::GetStringSingleValueError)
+  pub fn get_string_single_value(&self) -> crate::operation::get_string_single_value::builders::GetStringSingleValueFluentBuilder {
+      crate::operation::get_string_single_value::builders::GetStringSingleValueFluentBuilder::new(self.handle.clone())
+  }
+}
diff --git b/TestModels/SimpleTypes/SimpleString/runtimes/rust/src/client/get_string_utf8.rs a/TestModels/SimpleTypes/SimpleString/runtimes/rust/src/client/get_string_utf8.rs
new file mode 100644
index 00000000..b250b248
--- /dev/null
+++ a/TestModels/SimpleTypes/SimpleString/runtimes/rust/src/client/get_string_utf8.rs
@@ -0,0 +1,13 @@
+// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
+impl super::Client {
+  /// Constructs a fluent builder for the [`GetStringUTF8`](crate::operation::get_string_utf8::builders::GetStringUTF8FluentBuilder) operation.
+  ///
+  /// - The fluent builder is configurable:
+  ///   - [`value(impl Into<Option<String>>)`](crate::operation::get_string_utf8::builders::GetStringUTF8FluentBuilder::name) / [`set_name(Option<String>)`](crate::operation::get_string_utf8::builders::GetStringUTF8FluentBuilder::set_name):(undocumented)<br>
+  /// - On success, responds with [`GetStringUTF8Output`](crate::operation::get_string_utf8::GetStringUTF8Output) with field(s):
+  ///   - [`value(Option<String>)`](crate::operation::get_string_utf8::GetStringUTF8Output::value): (undocumented)
+  /// - On failure, responds with [`SdkError<GetStringUTF8Error>`](crate::operation::get_string_utf8::GetStringUTF8Error)
+  pub fn get_string_utf8(&self) -> crate::operation::get_string_utf8::builders::GetStringUTF8FluentBuilder {
+      crate::operation::get_string_utf8::builders::GetStringUTF8FluentBuilder::new(self.handle.clone())
+  }
+}
diff --git b/TestModels/SimpleTypes/SimpleString/runtimes/rust/src/config.rs a/TestModels/SimpleTypes/SimpleString/runtimes/rust/src/config.rs
new file mode 100644
index 00000000..1cdef04b
--- /dev/null
+++ a/TestModels/SimpleTypes/SimpleString/runtimes/rust/src/config.rs
@@ -0,0 +1,125 @@
+// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
+
+/// Configuration for a simple service client.
+///
+#[derive(::std::clone::Clone, ::std::fmt::Debug)]
+pub struct Config {
+    behavior_version: ::std::option::Option<crate::config::BehaviorVersion>,
+}
+impl Config {
+    /// Constructs a config builder.
+    pub fn builder() -> Builder {
+        Builder::default()
+    }
+    /// Converts this config back into a builder so that it can be tweaked.
+    pub fn to_builder(&self) -> Builder {
+        Builder {
+            behavior_version: self.behavior_version.clone(),
+        }
+    }
+}
+/// Builder for creating a `Config`.
+#[derive(::std::clone::Clone, ::std::fmt::Debug)]
+pub struct Builder {
+    pub(crate) behavior_version: ::std::option::Option<crate::config::BehaviorVersion>,
+}
+impl ::std::default::Default for Builder {
+    fn default() -> Self {
+        Self {
+            behavior_version: ::std::default::Default::default(),
+        }
+    }
+}
+impl Builder {
+    /// Constructs a config builder.
+    pub fn new() -> Self {
+        Self::default()
+    }
+    
+    /// Sets the [`behavior major version`](crate::config::BehaviorVersion).
+    ///
+    /// Over time, new best-practice behaviors are introduced. However, these behaviors might not be backwards
+    /// compatible. For example, a change which introduces new default timeouts or a new retry-mode for
+    /// all operations might be the ideal behavior but could break existing applications.
+    ///
+    /// # Examples
+    ///
+    /// Set the behavior major version to `latest`. This is equivalent to enabling the `behavior-version-latest` cargo feature.
+    /// ```no_run
+    /// use simple_string::config::BehaviorVersion;
+    ///
+    /// let config = simple_string::Config::builder()
+    ///     .behavior_version(BehaviorVersion::latest())
+    ///     // ...
+    ///     .build();
+    /// let client = simple_string::Client::from_conf(config);
+    /// ```
+    ///
+    /// Customizing behavior major version:
+    /// ```no_run
+    /// use simple_string::config::BehaviorVersion;
+    ///
+    /// let config = simple_string::Config::builder()
+    ///     .behavior_version(BehaviorVersion::v2023_11_09())
+    ///     // ...
+    ///     .build();
+    /// let client = simple_string::Client::from_conf(config);
+    /// ```
+
+    pub fn behavior_version(mut self, behavior_version: crate::config::BehaviorVersion) -> Self {
+        self.set_behavior_version(Some(behavior_version));
+        self
+    }
+
+    /// Sets the [`behavior major version`](crate::config::BehaviorVersion).
+    ///
+    /// Over time, new best-practice behaviors are introduced. However, these behaviors might not be backwards
+    /// compatible. For example, a change which introduces new default timeouts or a new retry-mode for
+    /// all operations might be the ideal behavior but could break existing applications.
+    ///
+    /// # Examples
+    ///
+    /// Set the behavior major version to `latest`. This is equivalent to enabling the `behavior-version-latest` cargo feature.
+    /// ```no_run
+    /// use simple_string::config::BehaviorVersion;
+    ///
+    /// let config = simple_string::Config::builder()
+    ///     .behavior_version(BehaviorVersion::latest())
+    ///     // ...
+    ///     .build();
+    /// let client = simple_string::Client::from_conf(config);
+    /// ```
+    ///
+    /// Customizing behavior major version:
+    /// ```no_run
+    /// use simple_string::config::BehaviorVersion;
+    ///
+    /// let config = simple_string::Config::builder()
+    ///     .behavior_version(BehaviorVersion::v2023_11_09())
+    ///     // ...
+    ///     .build();
+    /// let client = simple_string::Client::from_conf(config);
+    /// ```
+
+    pub fn set_behavior_version(&mut self, behavior_version: Option<crate::config::BehaviorVersion>) -> &mut Self {
+        self.behavior_version = behavior_version;
+        self
+    }
+
+    /// Convenience method to set the latest behavior major version
+    ///
+    /// This is equivalent to enabling the `behavior-version-latest` Cargo feature
+    pub fn behavior_version_latest(mut self) -> Self {
+        self.set_behavior_version(Some(crate::config::BehaviorVersion::latest()));
+        self
+    }
+    /// Builds a [`Config`].
+    #[allow(unused_mut)]
+    pub fn build(mut self) -> Config {
+        Config {
+            behavior_version: self.behavior_version,
+        }
+    }
+}
+
+pub use ::aws_smithy_runtime_api::client::behavior_version::BehaviorVersion;
diff --git b/TestModels/SimpleTypes/SimpleString/runtimes/rust/src/conversions.rs a/TestModels/SimpleTypes/SimpleString/runtimes/rust/src/conversions.rs
new file mode 100644
index 00000000..7c4b6dcb
--- /dev/null
+++ a/TestModels/SimpleTypes/SimpleString/runtimes/rust/src/conversions.rs
@@ -0,0 +1,6 @@
+// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
+pub mod get_string;
+
+pub mod get_string_single_value;
+
+pub mod get_string_utf8;
\ No newline at end of file
diff --git b/TestModels/SimpleTypes/SimpleString/runtimes/rust/src/conversions/get_string.rs a/TestModels/SimpleTypes/SimpleString/runtimes/rust/src/conversions/get_string.rs
new file mode 100644
index 00000000..62ba240c
--- /dev/null
+++ a/TestModels/SimpleTypes/SimpleString/runtimes/rust/src/conversions/get_string.rs
@@ -0,0 +1,26 @@
+// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
+
+use std::any::Any;
+
+#[allow(dead_code)]
+pub fn to_dafny_error(value: crate::operation::get_string::GetStringError) -> ::std::rc::Rc<crate::implementation_from_dafny::r#_simple_dtypes_dsmithystring_dinternaldafny_dtypes::Error> {
+  match value {
+    crate::operation::get_string::GetStringError::Unhandled(unhandled) => 
+      ::std::rc::Rc::new(crate::implementation_from_dafny::r#_simple_dtypes_dsmithystring_dinternaldafny_dtypes::Error::Opaque { obj: Box::into_raw(Box::new(unhandled) as Box<dyn Any>) })
+  }
+}
+
+#[allow(dead_code)]
+pub fn from_dafny_error(dafny_value: ::std::rc::Rc<crate::implementation_from_dafny::r#_simple_dtypes_dsmithystring_dinternaldafny_dtypes::Error>) -> crate::operation::get_string::GetStringError {
+  // TODO: Losing information here, but we have to figure out how to wrap an arbitrary Dafny value as std::error::Error
+  if matches!(&dafny_value.as_ref(), crate::implementation_from_dafny::r#_simple_dtypes_dsmithystring_dinternaldafny_dtypes::Error::CollectionOfErrors { .. }) {
+    let error_message = "TODO: can't get message yet";
+    crate::operation::get_string::GetStringError::generic(::aws_smithy_types::error::metadata::ErrorMetadata::builder().message(error_message).build())
+  } else {
+    crate::operation::get_string::GetStringError::generic(::aws_smithy_types::error::metadata::ErrorMetadata::builder().message("Opaque error").build())
+  }
+}
+
+pub mod _get_string_input;
+
+pub mod _get_string_output;
\ No newline at end of file
diff --git b/TestModels/SimpleTypes/SimpleString/runtimes/rust/src/conversions/get_string/_get_string_input.rs a/TestModels/SimpleTypes/SimpleString/runtimes/rust/src/conversions/get_string/_get_string_input.rs
new file mode 100644
index 00000000..4d736127
--- /dev/null
+++ a/TestModels/SimpleTypes/SimpleString/runtimes/rust/src/conversions/get_string/_get_string_input.rs
@@ -0,0 +1,27 @@
+// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
+#[allow(dead_code)]
+pub fn to_dafny(value: crate::operation::get_string::GetStringInput) -> ::std::rc::Rc<crate::implementation_from_dafny::r#_simple_dtypes_dsmithystring_dinternaldafny_dtypes::GetStringInput> {
+  let dafny_value = 
+    match value.value {
+      Some(s) => crate::implementation_from_dafny::_Wrappers_Compile::Option::Some { 
+        value: dafny_runtime::dafny_runtime_conversions::unicode_chars_false::string_to_dafny_string(&s) 
+      },
+      None => crate::implementation_from_dafny::_Wrappers_Compile::Option::None {},
+    };
+  ::std::rc::Rc::new(crate::implementation_from_dafny::r#_simple_dtypes_dsmithystring_dinternaldafny_dtypes::GetStringInput::GetStringInput {
+    value: ::std::rc::Rc::new(dafny_value)
+  })
+}
+
+#[allow(dead_code)]
+pub fn from_dafny(dafny_value: ::std::rc::Rc<crate::implementation_from_dafny::r#_simple_dtypes_dsmithystring_dinternaldafny_dtypes::GetStringInput>) -> crate::operation::get_string::GetStringInput {
+  let value = 
+    if matches!(dafny_value.value().as_ref(), crate::implementation_from_dafny::_Wrappers_Compile::Option::Some { .. }) {
+      Some(dafny_runtime::dafny_runtime_conversions::unicode_chars_false::dafny_string_to_string(&dafny_value.value().Extract()))
+    } else if matches!(dafny_value.value().as_ref(), crate::implementation_from_dafny::_Wrappers_Compile::Option::None { .. }) {
+      None
+    } else {
+      panic!("Unreachable")
+    };
+  crate::operation::get_string::GetStringInput { value }
+}
\ No newline at end of file
diff --git b/TestModels/SimpleTypes/SimpleString/runtimes/rust/src/conversions/get_string/_get_string_output.rs a/TestModels/SimpleTypes/SimpleString/runtimes/rust/src/conversions/get_string/_get_string_output.rs
new file mode 100644
index 00000000..dcb416a9
--- /dev/null
+++ a/TestModels/SimpleTypes/SimpleString/runtimes/rust/src/conversions/get_string/_get_string_output.rs
@@ -0,0 +1,27 @@
+// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
+#[allow(dead_code)]
+pub fn to_dafny(value: crate::operation::get_string::GetStringOutput) -> ::std::rc::Rc<crate::implementation_from_dafny::r#_simple_dtypes_dsmithystring_dinternaldafny_dtypes::GetStringOutput> {
+  let dafny_value = 
+    match value.value {
+      Some(s) => crate::implementation_from_dafny::_Wrappers_Compile::Option::Some { 
+        value: dafny_runtime::dafny_runtime_conversions::unicode_chars_false::string_to_dafny_string(&s) 
+      },
+      None => crate::implementation_from_dafny::_Wrappers_Compile::Option::None {},
+    };
+  ::std::rc::Rc::new(crate::implementation_from_dafny::r#_simple_dtypes_dsmithystring_dinternaldafny_dtypes::GetStringOutput::GetStringOutput {
+    value: ::std::rc::Rc::new(dafny_value)
+  })
+}
+
+#[allow(dead_code)]
+pub fn from_dafny(dafny_value: ::std::rc::Rc<crate::implementation_from_dafny::r#_simple_dtypes_dsmithystring_dinternaldafny_dtypes::GetStringOutput>) -> crate::operation::get_string::GetStringOutput {
+  let value = 
+    if matches!(dafny_value.value().as_ref(), crate::implementation_from_dafny::_Wrappers_Compile::Option::Some { .. }) {
+      Some(dafny_runtime::dafny_runtime_conversions::unicode_chars_false::dafny_string_to_string(&dafny_value.value().Extract()))
+    } else if matches!(dafny_value.value().as_ref(), crate::implementation_from_dafny::_Wrappers_Compile::Option::None { .. }) {
+      None
+    } else {
+      panic!("Unreachable")
+    };
+  crate::operation::get_string::GetStringOutput { value }
+}
\ No newline at end of file
diff --git b/TestModels/SimpleTypes/SimpleString/runtimes/rust/src/conversions/get_string_single_value.rs a/TestModels/SimpleTypes/SimpleString/runtimes/rust/src/conversions/get_string_single_value.rs
new file mode 100644
index 00000000..bdd76a08
--- /dev/null
+++ a/TestModels/SimpleTypes/SimpleString/runtimes/rust/src/conversions/get_string_single_value.rs
@@ -0,0 +1,26 @@
+// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
+
+use std::any::Any;
+
+#[allow(dead_code)]
+pub fn to_dafny_error(value: crate::operation::get_string_single_value::GetStringSingleValueError) -> ::std::rc::Rc<crate::implementation_from_dafny::r#_simple_dtypes_dsmithystring_dinternaldafny_dtypes::Error> {
+  match value {
+    crate::operation::get_string_single_value::GetStringSingleValueError::Unhandled(unhandled) => 
+      ::std::rc::Rc::new(crate::implementation_from_dafny::r#_simple_dtypes_dsmithystring_dinternaldafny_dtypes::Error::Opaque { obj: Box::into_raw(Box::new(unhandled) as Box<dyn Any>) })
+  }
+}
+
+#[allow(dead_code)]
+pub fn from_dafny_error(dafny_value: ::std::rc::Rc<crate::implementation_from_dafny::r#_simple_dtypes_dsmithystring_dinternaldafny_dtypes::Error>) -> crate::operation::get_string_single_value::GetStringSingleValueError {
+  // TODO: Losing information here, but we have to figure out how to wrap an arbitrary Dafny value as std::error::Error
+  if matches!(&dafny_value.as_ref(), crate::implementation_from_dafny::r#_simple_dtypes_dsmithystring_dinternaldafny_dtypes::Error::CollectionOfErrors { .. }) {
+    let error_message = "TODO: can't get message yet";
+    crate::operation::get_string_single_value::GetStringSingleValueError::generic(::aws_smithy_types::error::metadata::ErrorMetadata::builder().message(error_message).build())
+  } else {
+    crate::operation::get_string_single_value::GetStringSingleValueError::generic(::aws_smithy_types::error::metadata::ErrorMetadata::builder().message("Opaque error").build())
+  }
+}
+
+pub mod _get_string_single_value_input;
+
+pub mod _get_string_single_value_output;
\ No newline at end of file
diff --git b/TestModels/SimpleTypes/SimpleString/runtimes/rust/src/conversions/get_string_single_value/_get_string_single_value_input.rs a/TestModels/SimpleTypes/SimpleString/runtimes/rust/src/conversions/get_string_single_value/_get_string_single_value_input.rs
new file mode 100644
index 00000000..1cbf58b0
--- /dev/null
+++ a/TestModels/SimpleTypes/SimpleString/runtimes/rust/src/conversions/get_string_single_value/_get_string_single_value_input.rs
@@ -0,0 +1,27 @@
+// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
+#[allow(dead_code)]
+pub fn to_dafny(value: crate::operation::get_string_single_value::GetStringSingleValueInput) -> ::std::rc::Rc<crate::implementation_from_dafny::r#_simple_dtypes_dsmithystring_dinternaldafny_dtypes::GetStringInput> {
+  let dafny_value = 
+    match value.value {
+      Some(s) => crate::implementation_from_dafny::_Wrappers_Compile::Option::Some { 
+        value: dafny_runtime::dafny_runtime_conversions::unicode_chars_false::string_to_dafny_string(&s) 
+      },
+      None => crate::implementation_from_dafny::_Wrappers_Compile::Option::None {},
+    };
+  ::std::rc::Rc::new(crate::implementation_from_dafny::r#_simple_dtypes_dsmithystring_dinternaldafny_dtypes::GetStringInput::GetStringInput {
+    value: ::std::rc::Rc::new(dafny_value)
+  })
+}
+
+#[allow(dead_code)]
+pub fn from_dafny(dafny_value: ::std::rc::Rc<crate::implementation_from_dafny::r#_simple_dtypes_dsmithystring_dinternaldafny_dtypes::GetStringInput>) -> crate::operation::get_string_single_value::GetStringSingleValueInput {
+  let value = 
+    if matches!(dafny_value.value().as_ref(), crate::implementation_from_dafny::_Wrappers_Compile::Option::Some { .. }) {
+      Some(dafny_runtime::dafny_runtime_conversions::unicode_chars_false::dafny_string_to_string(&dafny_value.value().Extract()))
+    } else if matches!(dafny_value.value().as_ref(), crate::implementation_from_dafny::_Wrappers_Compile::Option::None { .. }) {
+      None
+    } else {
+      panic!("Unreachable")
+    };
+  crate::operation::get_string_single_value::GetStringSingleValueInput { value }
+}
\ No newline at end of file
diff --git b/TestModels/SimpleTypes/SimpleString/runtimes/rust/src/conversions/get_string_single_value/_get_string_single_value_output.rs a/TestModels/SimpleTypes/SimpleString/runtimes/rust/src/conversions/get_string_single_value/_get_string_single_value_output.rs
new file mode 100644
index 00000000..5b18732f
--- /dev/null
+++ a/TestModels/SimpleTypes/SimpleString/runtimes/rust/src/conversions/get_string_single_value/_get_string_single_value_output.rs
@@ -0,0 +1,27 @@
+// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
+#[allow(dead_code)]
+pub fn to_dafny(value: crate::operation::get_string_single_value::GetStringSingleValueOutput) -> ::std::rc::Rc<crate::implementation_from_dafny::r#_simple_dtypes_dsmithystring_dinternaldafny_dtypes::GetStringOutput> {
+  let dafny_value = 
+    match value.value {
+      Some(s) => crate::implementation_from_dafny::_Wrappers_Compile::Option::Some { 
+        value: dafny_runtime::dafny_runtime_conversions::unicode_chars_false::string_to_dafny_string(&s) 
+      },
+      None => crate::implementation_from_dafny::_Wrappers_Compile::Option::None {},
+    };
+  ::std::rc::Rc::new(crate::implementation_from_dafny::r#_simple_dtypes_dsmithystring_dinternaldafny_dtypes::GetStringOutput::GetStringOutput {
+    value: ::std::rc::Rc::new(dafny_value)
+  })
+}
+
+#[allow(dead_code)]
+pub fn from_dafny(dafny_value: ::std::rc::Rc<crate::implementation_from_dafny::r#_simple_dtypes_dsmithystring_dinternaldafny_dtypes::GetStringOutput>) -> crate::operation::get_string_single_value::GetStringSingleValueOutput {
+  let value = 
+    if matches!(dafny_value.value().as_ref(), crate::implementation_from_dafny::_Wrappers_Compile::Option::Some { .. }) {
+      Some(dafny_runtime::dafny_runtime_conversions::unicode_chars_false::dafny_string_to_string(&dafny_value.value().Extract()))
+    } else if matches!(dafny_value.value().as_ref(), crate::implementation_from_dafny::_Wrappers_Compile::Option::None { .. }) {
+      None
+    } else {
+      panic!("Unreachable")
+    };
+  crate::operation::get_string_single_value::GetStringSingleValueOutput { value }
+}
\ No newline at end of file
diff --git b/TestModels/SimpleTypes/SimpleString/runtimes/rust/src/conversions/get_string_utf8.rs a/TestModels/SimpleTypes/SimpleString/runtimes/rust/src/conversions/get_string_utf8.rs
new file mode 100644
index 00000000..f71f2a55
--- /dev/null
+++ a/TestModels/SimpleTypes/SimpleString/runtimes/rust/src/conversions/get_string_utf8.rs
@@ -0,0 +1,26 @@
+// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
+
+use std::any::Any;
+
+#[allow(dead_code)]
+pub fn to_dafny_error(value: crate::operation::get_string_utf8::GetStringUTF8Error) -> ::std::rc::Rc<crate::implementation_from_dafny::r#_simple_dtypes_dsmithystring_dinternaldafny_dtypes::Error> {
+  match value {
+    crate::operation::get_string_utf8::GetStringUTF8Error::Unhandled(unhandled) => 
+      ::std::rc::Rc::new(crate::implementation_from_dafny::r#_simple_dtypes_dsmithystring_dinternaldafny_dtypes::Error::Opaque { obj: Box::into_raw(Box::new(unhandled) as Box<dyn Any>) })
+  }
+}
+
+#[allow(dead_code)]
+pub fn from_dafny_error(dafny_value: ::std::rc::Rc<crate::implementation_from_dafny::r#_simple_dtypes_dsmithystring_dinternaldafny_dtypes::Error>) -> crate::operation::get_string_utf8::GetStringUTF8Error {
+  // TODO: Losing information here, but we have to figure out how to wrap an arbitrary Dafny value as std::error::Error
+  if matches!(&dafny_value.as_ref(), crate::implementation_from_dafny::r#_simple_dtypes_dsmithystring_dinternaldafny_dtypes::Error::CollectionOfErrors { .. }) {
+    let error_message = "TODO: can't get message yet";
+    crate::operation::get_string_utf8::GetStringUTF8Error::generic(::aws_smithy_types::error::metadata::ErrorMetadata::builder().message(error_message).build())
+  } else {
+    crate::operation::get_string_utf8::GetStringUTF8Error::generic(::aws_smithy_types::error::metadata::ErrorMetadata::builder().message("Opaque error").build())
+  }
+}
+
+pub mod _get_string_utf8_input;
+
+pub mod _get_string_utf8_output;
\ No newline at end of file
diff --git b/TestModels/SimpleTypes/SimpleString/runtimes/rust/src/conversions/get_string_utf8/_get_string_utf8_input.rs a/TestModels/SimpleTypes/SimpleString/runtimes/rust/src/conversions/get_string_utf8/_get_string_utf8_input.rs
new file mode 100644
index 00000000..6d4fdfc9
--- /dev/null
+++ a/TestModels/SimpleTypes/SimpleString/runtimes/rust/src/conversions/get_string_utf8/_get_string_utf8_input.rs
@@ -0,0 +1,27 @@
+// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
+#[allow(dead_code)]
+pub fn to_dafny(value: crate::operation::get_string_utf8::GetStringUTF8Input) -> ::std::rc::Rc<crate::implementation_from_dafny::r#_simple_dtypes_dsmithystring_dinternaldafny_dtypes::GetStringInput> {
+  let dafny_value = 
+    match value.value {
+      Some(s) => crate::implementation_from_dafny::_Wrappers_Compile::Option::Some { 
+        value: dafny_runtime::dafny_runtime_conversions::unicode_chars_false::string_to_dafny_string(&s) 
+      },
+      None => crate::implementation_from_dafny::_Wrappers_Compile::Option::None {},
+    };
+  ::std::rc::Rc::new(crate::implementation_from_dafny::r#_simple_dtypes_dsmithystring_dinternaldafny_dtypes::GetStringInput::GetStringInput {
+    value: ::std::rc::Rc::new(dafny_value)
+  })
+}
+
+#[allow(dead_code)]
+pub fn from_dafny(dafny_value: ::std::rc::Rc<crate::implementation_from_dafny::r#_simple_dtypes_dsmithystring_dinternaldafny_dtypes::GetStringInput>) -> crate::operation::get_string_utf8::GetStringUTF8Input {
+  let value = 
+    if matches!(dafny_value.value().as_ref(), crate::implementation_from_dafny::_Wrappers_Compile::Option::Some { .. }) {
+      Some(dafny_runtime::dafny_runtime_conversions::unicode_chars_false::dafny_string_to_string(&dafny_value.value().Extract()))
+    } else if matches!(dafny_value.value().as_ref(), crate::implementation_from_dafny::_Wrappers_Compile::Option::None { .. }) {
+      None
+    } else {
+      panic!("Unreachable")
+    };
+  crate::operation::get_string_utf8::GetStringUTF8Input { value }
+}
\ No newline at end of file
diff --git b/TestModels/SimpleTypes/SimpleString/runtimes/rust/src/conversions/get_string_utf8/_get_string_utf8_output.rs a/TestModels/SimpleTypes/SimpleString/runtimes/rust/src/conversions/get_string_utf8/_get_string_utf8_output.rs
new file mode 100644
index 00000000..6d0f7d17
--- /dev/null
+++ a/TestModels/SimpleTypes/SimpleString/runtimes/rust/src/conversions/get_string_utf8/_get_string_utf8_output.rs
@@ -0,0 +1,27 @@
+// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
+#[allow(dead_code)]
+pub fn to_dafny(value: crate::operation::get_string_utf8::GetStringUTF8Output) -> ::std::rc::Rc<crate::implementation_from_dafny::r#_simple_dtypes_dsmithystring_dinternaldafny_dtypes::GetStringOutput> {
+  let dafny_value = 
+    match value.value {
+      Some(s) => crate::implementation_from_dafny::_Wrappers_Compile::Option::Some { 
+        value: dafny_runtime::dafny_runtime_conversions::unicode_chars_false::string_to_dafny_string(&s) 
+      },
+      None => crate::implementation_from_dafny::_Wrappers_Compile::Option::None {},
+    };
+  ::std::rc::Rc::new(crate::implementation_from_dafny::r#_simple_dtypes_dsmithystring_dinternaldafny_dtypes::GetStringOutput::GetStringOutput {
+    value: ::std::rc::Rc::new(dafny_value)
+  })
+}
+
+#[allow(dead_code)]
+pub fn from_dafny(dafny_value: ::std::rc::Rc<crate::implementation_from_dafny::r#_simple_dtypes_dsmithystring_dinternaldafny_dtypes::GetStringOutput>) -> crate::operation::get_string_utf8::GetStringUTF8Output {
+  let value = 
+    if matches!(dafny_value.value().as_ref(), crate::implementation_from_dafny::_Wrappers_Compile::Option::Some { .. }) {
+      Some(dafny_runtime::dafny_runtime_conversions::unicode_chars_false::dafny_string_to_string(&dafny_value.value().Extract()))
+    } else if matches!(dafny_value.value().as_ref(), crate::implementation_from_dafny::_Wrappers_Compile::Option::None { .. }) {
+      None
+    } else {
+      panic!("Unreachable")
+    };
+  crate::operation::get_string_utf8::GetStringUTF8Output { value }
+}
\ No newline at end of file
diff --git b/TestModels/SimpleTypes/SimpleString/runtimes/rust/src/error.rs a/TestModels/SimpleTypes/SimpleString/runtimes/rust/src/error.rs
new file mode 100644
index 00000000..f2646b97
--- /dev/null
+++ a/TestModels/SimpleTypes/SimpleString/runtimes/rust/src/error.rs
@@ -0,0 +1,13 @@
+// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
+pub use ::aws_smithy_runtime_api::box_error::BoxError;
+
+/// Error type returned by the client.
+pub type SdkError<E, R = ::aws_smithy_runtime_api::client::orchestrator::HttpResponse> = ::aws_smithy_runtime_api::client::result::SdkError<E, R>;
+pub use ::aws_smithy_runtime_api::client::result::ConnectorError;
+pub use ::aws_smithy_types::error::operation::BuildError;
+
+pub use ::aws_smithy_types::error::display::DisplayErrorContext;
+pub use ::aws_smithy_types::error::metadata::ErrorMetadata;
+pub use ::aws_smithy_types::error::metadata::ProvideErrorMetadata;
+
+pub(crate) mod sealed_unhandled;
diff --git b/TestModels/SimpleTypes/SimpleString/runtimes/rust/src/error/sealed_unhandled.rs a/TestModels/SimpleTypes/SimpleString/runtimes/rust/src/error/sealed_unhandled.rs
new file mode 100644
index 00000000..357c3ccc
--- /dev/null
+++ a/TestModels/SimpleTypes/SimpleString/runtimes/rust/src/error/sealed_unhandled.rs
@@ -0,0 +1,20 @@
+// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
+/// This struct is not intended to be used.
+///
+/// This struct holds information about an unhandled error,
+/// but that information should be obtained by using the
+/// [`ProvideErrorMetadata`](::aws_smithy_types::error::metadata::ProvideErrorMetadata) trait
+/// on the error type.
+///
+/// This struct intentionally doesn't yield any useful information itself.
+#[deprecated(note = "Matching `Unhandled` directly is not forwards compatible. Instead, match using a \
+variable wildcard pattern and check `.code()`:
+ \
+&nbsp;&nbsp;&nbsp;`err if err.code() == Some(\"SpecificExceptionCode\") => { /* handle the error */ }`
+ \
+See [`ProvideErrorMetadata`](::aws_smithy_types::error::metadata::ProvideErrorMetadata) for what information is available for the error.")]
+#[derive(Debug)]
+pub struct Unhandled {
+    pub(crate) source: ::aws_smithy_runtime_api::box_error::BoxError,
+    pub(crate) meta: ::aws_smithy_types::error::metadata::ErrorMetadata,
+}
diff --git b/TestModels/SimpleTypes/SimpleString/runtimes/rust/src/implementation_from_dafny.rs a/TestModels/SimpleTypes/SimpleString/runtimes/rust/src/implementation_from_dafny.rs
index b2f40300..00e2106e 100644
--- b/TestModels/SimpleTypes/SimpleString/runtimes/rust/src/implementation_from_dafny.rs
+++ a/TestModels/SimpleTypes/SimpleString/runtimes/rust/src/implementation_from_dafny.rs
@@ -1,114 +1,450 @@
 #![allow(warnings, unconditional_panic)]
-extern crate dafny_runtime;
-mod r#_System {
-#[derive(Clone, PartialEq)]
-#[repr(transparent)]
-pub struct r#nat(pub ::dafny_runtime::BigInt);
-impl  ::dafny_runtime::DafnyErasable for r#nat {
-type Erased = ::dafny_runtime::BigInt;
-}
-impl  ::dafny_runtime::DafnyUnerasable<::dafny_runtime::BigInt> for r#nat {}
-impl  ::dafny_runtime::DafnyUnerasable<r#nat> for r#nat {}
-impl  ::std::default::Default for r#nat {
-fn default() -> Self {
-r#nat(::std::default::Default::default())
-}
-}
-impl  ::dafny_runtime::DafnyPrint for r#nat {
-fn fmt_print(&self, __fmt_print_formatter: &mut ::std::fmt::Formatter, in_seq: bool) -> ::std::fmt::Result {
-::dafny_runtime::DafnyPrint::fmt_print(&self.0, __fmt_print_formatter, in_seq)
-}
-}
-impl  ::std::ops::Deref for r#nat {
-type Target = ::dafny_runtime::BigInt;
-fn deref(&self) -> &Self::Target {
-&self.0
-}
-}
+#![allow(nonstandard_style)]
+pub extern crate dafny_runtime;
+pub extern crate dafny_standard_library;
+pub use dafny_standard_library::implementation_from_dafny::*;
 
-#[derive(PartialEq)]
-pub enum r#Tuple2<r#T0, r#T1, > {
-r#___hMake2 { r#_0: r#T0, r#_1: r#T1, },
-_PhantomVariant(::std::marker::PhantomData::<r#T0>, ::std::marker::PhantomData::<r#T1>)
-}
-impl <r#T0: ::dafny_runtime::DafnyErasable + ::dafny_runtime::DafnyUnerasable<r#T0> + Clone + ::dafny_runtime::DafnyPrint + ::std::default::Default + 'static, r#T1: ::dafny_runtime::DafnyErasable + ::dafny_runtime::DafnyUnerasable<r#T1> + Clone + ::dafny_runtime::DafnyPrint + ::std::default::Default + 'static, > r#Tuple2<r#T0, r#T1, > where <r#T0 as ::dafny_runtime::DafnyErasable>::Erased: ::std::cmp::PartialEq, <r#T1 as ::dafny_runtime::DafnyErasable>::Erased: ::std::cmp::PartialEq,  {
-pub fn r#_0(&self) -> &r#T0 {
-match self {
-r#Tuple2::r#___hMake2 { r#_0, r#_1, } => r#_0,
-r#Tuple2::_PhantomVariant(..) => panic!(),
-}
-}
-pub fn r#_1(&self) -> &r#T1 {
-match self {
-r#Tuple2::r#___hMake2 { r#_0, r#_1, } => r#_1,
-r#Tuple2::_PhantomVariant(..) => panic!(),
-}
-}
+pub mod r#_simple_dtypes_dsmithystring_dinternaldafny_dtypes {
+  /* datatype DafnyCallEvent<I, O> = DafnyCallEvent(input: I, output: O) */
+    #[derive(Clone)]
+    pub struct DafnyCallEvent<I: ::dafny_runtime::DafnyType, O: ::dafny_runtime::DafnyType> {
+      input: I,
+      output: O
+    }
+    impl <I: ::dafny_runtime::DafnyType, O: ::dafny_runtime::DafnyType> ::core::fmt::Debug for
+      DafnyCallEvent<I, O> {
+      fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
+        f.debug_struct("DafnyCallEvent").field("input", &self.input).field("output", &self.output).finish()
+      }
+    }
+    impl <I: ::dafny_runtime::DafnyType, O: ::dafny_runtime::DafnyType> ::dafny_runtime::DafnyPrint for
+      DafnyCallEvent<I, O> {
+      fn fmt_print(&self, f: &mut std::fmt::Formatter<'_>, in_seq: bool) -> std::fmt::Result {
+        write!(f, "simple.types.smithystring.internaldafny.types.DafnyCallEvent(")?;
+        self.input.fmt_print(f, false)?;
+        write!(f, ",")?;
+        self.output.fmt_print(f, false)?;
+        write!(f, ")")
+      }
+    }
+    impl <I: ::dafny_runtime::DafnyTypeEq, O: ::dafny_runtime::DafnyTypeEq>
+      PartialEq<DafnyCallEvent<I, O>> for DafnyCallEvent<I, O> {
+        fn eq(&self, other: &DafnyCallEvent<I, O>) -> bool {
+          self.input == other.input && self.output == other.output
+        }
+    }
+    impl <I: ::dafny_runtime::DafnyTypeEq, O: ::dafny_runtime::DafnyTypeEq> Eq for DafnyCallEvent<I, O> {}
+    impl <I: ::dafny_runtime::DafnyTypeEq, O: ::dafny_runtime::DafnyTypeEq> ::core::hash::Hash for DafnyCallEvent<I, O> {
+      fn hash<H: std::hash::Hasher>(&self, state: &mut H) {
+        self.input.hash(state);
+        self.output.hash(state);
+      }
+    }
 
-}
-impl <r#T0: ::dafny_runtime::DafnyErasable + ::dafny_runtime::DafnyUnerasable<r#T0> + Clone + ::dafny_runtime::DafnyPrint + ::std::default::Default + 'static, r#T1: ::dafny_runtime::DafnyErasable + ::dafny_runtime::DafnyUnerasable<r#T1> + Clone + ::dafny_runtime::DafnyPrint + ::std::default::Default + 'static, > ::dafny_runtime::DafnyErasable for r#Tuple2<r#T0, r#T1, > {
-type Erased = r#Tuple2<r#T0::Erased, r#T1::Erased, >;
-}
-impl <r#T0__Erased, r#T0: ::dafny_runtime::DafnyErasable + ::dafny_runtime::DafnyUnerasable<r#T0> + Clone + ::dafny_runtime::DafnyPrint + ::std::default::Default + ::dafny_runtime::DafnyUnerasable<r#T0__Erased> + 'static, r#T1__Erased, r#T1: ::dafny_runtime::DafnyErasable + ::dafny_runtime::DafnyUnerasable<r#T1> + Clone + ::dafny_runtime::DafnyPrint + ::std::default::Default + ::dafny_runtime::DafnyUnerasable<r#T1__Erased> + 'static, > ::dafny_runtime::DafnyUnerasable<r#Tuple2<r#T0__Erased, r#T1__Erased, >> for r#Tuple2<r#T0, r#T1, > {}
+    /*
+     datatype GetStringInput = | GetStringInput (
+      nameonly value: Option<string> := Option.None
+    )
+    */
+    #[derive(Clone)]
+    pub enum GetStringInput {
+      GetStringInput { value: ::std::rc::Rc<super::r#_Wrappers_Compile::Option<::dafny_runtime::DafnyStringUTF16>> }
+    }
+    impl ::std::convert::AsRef<GetStringInput> for &GetStringInput {
+      fn as_ref(&self) -> Self {
+        self
+      }
+    }
+    impl GetStringInput {
+      pub fn value(&self) -> ::std::rc::Rc<super::r#_Wrappers_Compile::Option<::dafny_runtime::DafnyStringUTF16>> {
+        match self {
+          GetStringInput::GetStringInput { value } => {
+            value.clone()
+          }
+        }
+      }
+    }
+    impl ::core::fmt::Debug for GetStringInput {
+        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
+          ::dafny_runtime::DafnyPrint::fmt_print(self, f, false)
+        }
+    }
+    impl ::dafny_runtime::DafnyPrint for GetStringInput {
+      fn fmt_print(&self, f: &mut std::fmt::Formatter<'_>, in_seq: bool) -> std::fmt::Result {
+        write!(f, "simple.types.smithystring.internaldafny.types.GetStringInput(value := ")?;
+        self.value().fmt_print(f, false)?;
+        write!(f, ")")
+      }
+    }
+    impl PartialEq<GetStringInput> for GetStringInput {
+        fn eq(&self, other: &GetStringInput) -> bool {
+          self.value() == other.value()
+        }
+    }
+    impl Eq for GetStringInput {}
+    impl ::core::hash::Hash for GetStringInput {
+      fn hash<H: std::hash::Hasher>(&self, state: &mut H) {
+        self.value().hash(state);
+      }
+    }
+    
+    /*
+    datatype GetStringOutput = | GetStringOutput (
+    nameonly value: Option<string> := Option.None
+    ) */
+    #[derive(Clone)]
+    pub enum GetStringOutput {
+      GetStringOutput {
+        value: ::std::rc::Rc<super::r#_Wrappers_Compile::Option<::dafny_runtime::DafnyStringUTF16>>
+      }
+    }
+    impl GetStringOutput {
+      pub fn value(&self) -> ::std::rc::Rc<super::r#_Wrappers_Compile::Option<::dafny_runtime::DafnyStringUTF16>> {
+        match self {
+          GetStringOutput::GetStringOutput { value } => {
+            value.clone()
+          }
+        }
+      }
+    }
+    impl ::std::convert::AsRef<GetStringOutput> for &GetStringOutput {
+      fn as_ref(&self) -> Self {
+        self
+      }
+    }
+    impl ::core::fmt::Debug for GetStringOutput {
+        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
+          ::dafny_runtime::DafnyPrint::fmt_print(self, f, false)
+        }
+    }
+    impl ::dafny_runtime::DafnyPrint for GetStringOutput {
+      fn fmt_print(&self, f: &mut std::fmt::Formatter<'_>, in_seq: bool) -> std::fmt::Result {
+        write!(f, "simple.types.smithystring.internaldafny.types.GetStringOutput(value := ")?;
+        self.value().fmt_print(f, false)?;
+        write!(f, ")")
+      }
+    }
+    impl PartialEq<GetStringOutput> for GetStringOutput {
+        fn eq(&self, other: &GetStringOutput) -> bool {
+          self.value() == other.value()
+        }
+    }
+    impl Eq for GetStringOutput {}
+    impl ::core::hash::Hash for GetStringOutput {
+      fn hash<H: std::hash::Hasher>(&self, state: &mut H) {
+        self.value().hash(state);
+      }
+    }
 
-impl <r#T0: ::dafny_runtime::DafnyErasable + ::dafny_runtime::DafnyUnerasable<r#T0> + Clone + ::dafny_runtime::DafnyPrint + ::std::default::Default + 'static, r#T1: ::dafny_runtime::DafnyErasable + ::dafny_runtime::DafnyUnerasable<r#T1> + Clone + ::dafny_runtime::DafnyPrint + ::std::default::Default + 'static, > ::dafny_runtime::DafnyPrint for r#Tuple2<r#T0, r#T1, > {
-fn fmt_print(&self, __fmt_print_formatter: &mut ::std::fmt::Formatter, _in_seq: bool) -> std::fmt::Result {
-match self {
-r#Tuple2::r#___hMake2 { r#_0, r#_1, } => {
-write!(__fmt_print_formatter, "_System.Tuple2.___hMake2(")?;
-::dafny_runtime::DafnyPrint::fmt_print(r#_0, __fmt_print_formatter, false)?;
-write!(__fmt_print_formatter, ", ")?;
-::dafny_runtime::DafnyPrint::fmt_print(r#_1, __fmt_print_formatter, false)?;
-write!(__fmt_print_formatter, ")")?;
-Ok(())
-}
-r#Tuple2::_PhantomVariant(..) => {panic!()
-}
-}
-}
-}
-
-impl <r#T0: ::dafny_runtime::DafnyErasable + ::dafny_runtime::DafnyUnerasable<r#T0> + Clone + ::dafny_runtime::DafnyPrint + ::std::default::Default + 'static, r#T1: ::dafny_runtime::DafnyErasable + ::dafny_runtime::DafnyUnerasable<r#T1> + Clone + ::dafny_runtime::DafnyPrint + ::std::default::Default + 'static, > ::std::default::Default for r#Tuple2<r#T0, r#T1, > {
-fn default() -> Self {
-r#Tuple2::r#___hMake2 {
-r#_0: ::std::default::Default::default(),
-r#_1: ::std::default::Default::default(),
-}
-}
-}
+    
+    /*
+    datatype SimpleStringConfig = | SimpleStringConfig (
+    ) */
+    #[derive(Clone)]
+    pub enum SimpleStringConfig {
+      SimpleStringConfig {}
+    }
+    impl ::std::convert::AsRef<SimpleStringConfig> for &SimpleStringConfig {
+      fn as_ref(&self) -> Self {
+        self
+      }
+    }
+    impl ::core::fmt::Debug for SimpleStringConfig {
+        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
+          f.debug_struct("SimpleStringConfig").finish()
+        }
+    }
+    impl ::dafny_runtime::DafnyPrint for SimpleStringConfig {
+      fn fmt_print(&self, f: &mut std::fmt::Formatter<'_>, in_seq: bool) -> std::fmt::Result {
+        write!(f, "simple.types.smithystring.internaldafny.types.SimpleStringConfig()")
+      }
+    }
+    impl PartialEq<SimpleStringConfig> for SimpleStringConfig {
+        fn eq(&self, other: &SimpleStringConfig) -> bool {
+          true
+        }
+    }
+    impl Eq for SimpleStringConfig {}
+    impl ::core::hash::Hash for SimpleStringConfig {
+      fn hash<H: std::hash::Hasher>(&self, state: &mut H) {
+      }
+    }
 
-#[derive(PartialEq)]
-pub enum r#Tuple0 {
-r#___hMake0 { },
+    pub struct ISimpleTypesStringClientCallHistory {
+    }
+    impl ISimpleTypesStringClientCallHistory {
+      fn ctor(this: *mut ISimpleTypesStringClientCallHistory) {
+      }
+    }
+    pub trait ISimpleTypesStringClient {
+      fn GetString(self: &Self, input: &::std::rc::Rc<super::r#_simple_dtypes_dsmithystring_dinternaldafny_dtypes::GetStringInput>) -> ::std::rc::Rc<super::r#_Wrappers_Compile::Result<::std::rc::Rc<super::r#_simple_dtypes_dsmithystring_dinternaldafny_dtypes::GetStringOutput>, ::std::rc::Rc<super::r#_simple_dtypes_dsmithystring_dinternaldafny_dtypes::Error>>>;
+      fn GetStringSingleValue(self: &Self, input: &::std::rc::Rc<super::r#_simple_dtypes_dsmithystring_dinternaldafny_dtypes::GetStringInput>) -> ::std::rc::Rc<super::r#_Wrappers_Compile::Result<::std::rc::Rc<super::r#_simple_dtypes_dsmithystring_dinternaldafny_dtypes::GetStringOutput>, ::std::rc::Rc<super::r#_simple_dtypes_dsmithystring_dinternaldafny_dtypes::Error>>>;
+      fn GetStringUTF8(self: &Self, input: &::std::rc::Rc<super::r#_simple_dtypes_dsmithystring_dinternaldafny_dtypes::GetStringInput>) -> ::std::rc::Rc<super::r#_Wrappers_Compile::Result<::std::rc::Rc<super::r#_simple_dtypes_dsmithystring_dinternaldafny_dtypes::GetStringOutput>, ::std::rc::Rc<super::r#_simple_dtypes_dsmithystring_dinternaldafny_dtypes::Error>>>;
+    }
+    /*
+    datatype Error =
+    | CollectionOfErrors(list: seq<Error>, nameonly message: string)
+    | Opaque(obj: object)
+    */
+    #[derive(Clone)]
+    pub enum Error {
+      CollectionOfErrors{list: ::dafny_runtime::Sequence<Error>, message: ::dafny_runtime::DafnyStringUTF16},
+      Opaque{obj: *mut dyn ::std::any::Any}
+    }
+    impl ::core::fmt::Debug for Error {
+        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
+          match self {
+            Error::CollectionOfErrors{list, message} => f.debug_struct("Error::CollectionOfErrors").field("list", list).field("message", message).finish(),
+            Error::Opaque{obj} => f.debug_struct("Error::Opaque").field("obj", obj).finish()
+          }
+        }
+    }
+    impl ::dafny_runtime::DafnyPrint for Error {
+      fn fmt_print(&self, f: &mut std::fmt::Formatter<'_>, in_seq: bool) -> std::fmt::Result {
+        match self {
+          Error::CollectionOfErrors{list, message} => {
+            write!(f, "Error::CollectionOfErrors(list := ")?;
+            list.fmt_print(f, false)?;
+            write!(f, ", message := ")?;
+            message.fmt_print(f, false)?;
+            write!(f, ")")
+          },
+          Error::Opaque{obj} => {
+            write!(f, "Error::Opaque(obj := ")?;
+            obj.fmt_print(f, false)?;
+            write!(f, ")")
+          }
+        }
+      }
+    }
+    impl PartialEq<Error> for Error {
+        fn eq(&self, other: &Error) -> bool {
+          match self {
+            Error::CollectionOfErrors{list, message} => match other {
+              Error::CollectionOfErrors{list: other_list, message: other_message} => list == other_list && message == other_message,
+              _ => false
+            },
+            Error::Opaque{obj} => match other {
+              Error::Opaque{obj: other_obj} => obj == other_obj,
+              _ => false
+            }
+          }
+        }
+    }
+    impl Eq for Error {}
+    impl ::core::hash::Hash for Error {
+      fn hash<H: std::hash::Hasher>(&self, state: &mut H) {
+        match self {
+          Error::CollectionOfErrors{list, message} => {
+            list.hash(state);
+            message.hash(state);
+          },
+          Error::Opaque{obj} => obj.hash(state)
+        }
+      }
+    }
 
-}
-impl  r#Tuple0 {
-
-}
-impl  ::dafny_runtime::DafnyErasable for r#Tuple0 {
-type Erased = r#Tuple0;
-}
-impl  ::dafny_runtime::DafnyUnerasable<r#Tuple0> for r#Tuple0 {}
+    pub type OpaqueError = Error;
 
-impl  ::dafny_runtime::DafnyPrint for r#Tuple0 {
-fn fmt_print(&self, __fmt_print_formatter: &mut ::std::fmt::Formatter, _in_seq: bool) -> std::fmt::Result {
-match self {
-r#Tuple0::r#___hMake0 { } => {
-write!(__fmt_print_formatter, "_System.Tuple0.___hMake0")?;
-Ok(())
-}
-}
-}
-}
-
-impl  ::std::default::Default for r#Tuple0 {
-fn default() -> Self {
-r#Tuple0::r#___hMake0 {
-}
-}
-}
 
 }
-mod r#_module {
+mod r#_SimpleStringImpl_Compile {
+  pub struct _default {}
+  impl _default {
+    pub fn new() -> Self {
+      _default {}
+    }
+    pub fn _allocated() -> *mut Self {
+      ::dafny_runtime::allocate::<Self>()
+    }
+    pub fn GetString(config: &::std::rc::Rc<super::r#_SimpleStringImpl_Compile::Config>, input: &::std::rc::Rc<super::r#_simple_dtypes_dsmithystring_dinternaldafny_dtypes::GetStringInput>) -> ::std::rc::Rc<super::r#_Wrappers_Compile::Result<::std::rc::Rc<super::r#_simple_dtypes_dsmithystring_dinternaldafny_dtypes::GetStringOutput>, ::std::rc::Rc<super::r#_simple_dtypes_dsmithystring_dinternaldafny_dtypes::Error>>> {
+      let mut output = ::dafny_runtime::MaybePlacebo::<::std::rc::Rc<super::r#_Wrappers_Compile::Result<::std::rc::Rc<super::r#_simple_dtypes_dsmithystring_dinternaldafny_dtypes::GetStringOutput>, ::std::rc::Rc<super::r#_simple_dtypes_dsmithystring_dinternaldafny_dtypes::Error>>>>::new();
+      let mut res: ::std::rc::Rc<super::r#_simple_dtypes_dsmithystring_dinternaldafny_dtypes::GetStringOutput> = ::std::rc::Rc::new(super::r#_simple_dtypes_dsmithystring_dinternaldafny_dtypes::GetStringOutput::GetStringOutput {
+            value: input.value().clone()
+          });
+      res = ::std::rc::Rc::new(super::r#_simple_dtypes_dsmithystring_dinternaldafny_dtypes::GetStringOutput::GetStringOutput {
+            value: input.value().clone()
+          });
+      output = ::dafny_runtime::MaybePlacebo::from(::std::rc::Rc::new(super::r#_Wrappers_Compile::Result::<::std::rc::Rc<super::r#_simple_dtypes_dsmithystring_dinternaldafny_dtypes::GetStringOutput>, ::std::rc::Rc<super::r#_simple_dtypes_dsmithystring_dinternaldafny_dtypes::Error>>::Success {
+              value: res.clone()
+            }));
+      return output.read();
+      return output.read();
+    }
+    pub fn GetStringSingleValue(config: &::std::rc::Rc<super::r#_SimpleStringImpl_Compile::Config>, input: &::std::rc::Rc<super::r#_simple_dtypes_dsmithystring_dinternaldafny_dtypes::GetStringInput>) -> ::std::rc::Rc<super::r#_Wrappers_Compile::Result<::std::rc::Rc<super::r#_simple_dtypes_dsmithystring_dinternaldafny_dtypes::GetStringOutput>, ::std::rc::Rc<super::r#_simple_dtypes_dsmithystring_dinternaldafny_dtypes::Error>>> {
+      let mut output = ::dafny_runtime::MaybePlacebo::<::std::rc::Rc<super::r#_Wrappers_Compile::Result<::std::rc::Rc<super::r#_simple_dtypes_dsmithystring_dinternaldafny_dtypes::GetStringOutput>, ::std::rc::Rc<super::r#_simple_dtypes_dsmithystring_dinternaldafny_dtypes::Error>>>>::new();
+      if !matches!(input.value().as_ref(), super::r#_Wrappers_Compile::Option::Some{ .. }) {
+        panic!("Halt")
+      };
+      if !(input.value().value().clone() == ::dafny_runtime::string_utf16_of("TEST_SIMPLE_STRING_SINGLE_VALUE")) {
+        panic!("Halt")
+      };
+      let mut res: ::std::rc::Rc<super::r#_simple_dtypes_dsmithystring_dinternaldafny_dtypes::GetStringOutput> = ::std::rc::Rc::new(super::r#_simple_dtypes_dsmithystring_dinternaldafny_dtypes::GetStringOutput::GetStringOutput {
+            value: input.value().clone()
+          });
+      res = ::std::rc::Rc::new(super::r#_simple_dtypes_dsmithystring_dinternaldafny_dtypes::GetStringOutput::GetStringOutput {
+            value: input.value().clone()
+          });
+      output = ::dafny_runtime::MaybePlacebo::from(::std::rc::Rc::new(super::r#_Wrappers_Compile::Result::<::std::rc::Rc<super::r#_simple_dtypes_dsmithystring_dinternaldafny_dtypes::GetStringOutput>, ::std::rc::Rc<super::r#_simple_dtypes_dsmithystring_dinternaldafny_dtypes::Error>>::Success {
+              value: res.clone()
+            }));
+      return output.read();
+      return output.read();
+    }
+    pub fn GetStringUTF8(config: &::std::rc::Rc<super::r#_SimpleStringImpl_Compile::Config>, input: &::std::rc::Rc<super::r#_simple_dtypes_dsmithystring_dinternaldafny_dtypes::GetStringInput>) -> ::std::rc::Rc<super::r#_Wrappers_Compile::Result<::std::rc::Rc<super::r#_simple_dtypes_dsmithystring_dinternaldafny_dtypes::GetStringOutput>, ::std::rc::Rc<super::r#_simple_dtypes_dsmithystring_dinternaldafny_dtypes::Error>>> {
+      let mut output = ::dafny_runtime::MaybePlacebo::<::std::rc::Rc<super::r#_Wrappers_Compile::Result<::std::rc::Rc<super::r#_simple_dtypes_dsmithystring_dinternaldafny_dtypes::GetStringOutput>, ::std::rc::Rc<super::r#_simple_dtypes_dsmithystring_dinternaldafny_dtypes::Error>>>>::new();
+      if !matches!(input.value().as_ref(), super::r#_Wrappers_Compile::Option::Some{ .. }) {
+        panic!("Halt")
+      };
+      let mut res: ::std::rc::Rc<super::r#_simple_dtypes_dsmithystring_dinternaldafny_dtypes::GetStringOutput> = ::std::rc::Rc::new(super::r#_simple_dtypes_dsmithystring_dinternaldafny_dtypes::GetStringOutput::GetStringOutput {
+            value: input.value().clone()
+          });
+      res = ::std::rc::Rc::new(super::r#_simple_dtypes_dsmithystring_dinternaldafny_dtypes::GetStringOutput::GetStringOutput {
+            value: input.value().clone()
+          });
+      output = ::dafny_runtime::MaybePlacebo::from(::std::rc::Rc::new(super::r#_Wrappers_Compile::Result::<::std::rc::Rc<super::r#_simple_dtypes_dsmithystring_dinternaldafny_dtypes::GetStringOutput>, ::std::rc::Rc<super::r#_simple_dtypes_dsmithystring_dinternaldafny_dtypes::Error>>::Success {
+              value: res.clone()
+            }));
+      return output.read();
+      return output.read();
+    }
+  }
+  impl ::std::default::Default for _default {
+    fn default() -> Self {
+      _default::new()
+    }
+  }
+  impl ::dafny_runtime::DafnyPrint for _default {
+    fn fmt_print(&self, _formatter: &mut ::std::fmt::Formatter, _in_seq: bool) -> std::fmt::Result {
+      write!(_formatter, "SimpleStringImpl_Compile.__default")
+    }
+  }
+  impl ::std::cmp::PartialEq for _default {
+    fn eq(&self, other: &Self) -> bool {
+      ::std::ptr::eq(self, other)
+    }
+  }
+  #[derive(PartialEq, Clone)]
+  pub enum Config {
+    Config {}
+  }
+  impl Config {}
+  impl ::dafny_runtime::DafnyPrint for Config {
+    fn fmt_print(&self, _formatter: &mut ::std::fmt::Formatter, _in_seq: bool) -> std::fmt::Result {
+      match self {
+        Config::Config { } => {
+          write!(_formatter, "SimpleStringImpl_Compile.Config.Config")?;
+          Ok(())
+        }
+      }
+    }
+  }
+  impl ::std::default::Default for Config {
+    fn default() -> Config {
+      Config::Config {}
+    }
+  }
+  impl ::std::convert::AsRef<Config> for &Config {
+    fn as_ref(&self) -> Self {
+      self
+    }
+  }
+}
+// SimpleString
+pub mod r#_simple_dtypes_dsmithystring_dinternaldafny {
+  pub struct _default {}
+  impl _default {
+    pub fn new() -> Self {
+      _default {}
+    }
+    pub fn DefaultSimpleStringConfig() -> super::r#_simple_dtypes_dsmithystring_dinternaldafny_dtypes::SimpleStringConfig {
+      super::r#_simple_dtypes_dsmithystring_dinternaldafny_dtypes::SimpleStringConfig::SimpleStringConfig{}
+    }
+    /*method SimpleString(config: SimpleStringConfig)
+    returns (res: Result<ISimpleTypesStringClient, Error>) {
+        var client := new SimpleStringClient(Operations.Config);
+        return Success(client);
+    } */
+    pub fn SimpleString(config: &::std::rc::Rc<super::r#_simple_dtypes_dsmithystring_dinternaldafny_dtypes::SimpleStringConfig>)
+      -> ::std::rc::Rc<super::r#_Wrappers_Compile::Result<*mut dyn super::r#_simple_dtypes_dsmithystring_dinternaldafny_dtypes::ISimpleTypesStringClient, ::std::rc::Rc<super::r#_simple_dtypes_dsmithystring_dinternaldafny_dtypes::Error>>> {
+      let client: *mut SimpleStringClient = ::dafny_runtime::allocate::<SimpleStringClient>();
+      SimpleStringClient::_ctor(client, &::std::rc::Rc::new(super::r#_SimpleStringImpl_Compile::Config::Config{}));
+      let v = client as *mut dyn super::r#_simple_dtypes_dsmithystring_dinternaldafny_dtypes::ISimpleTypesStringClient;
+      // build a success
+      ::std::rc::Rc::new(super::r#_Wrappers_Compile::Result::<*mut dyn super::r#_simple_dtypes_dsmithystring_dinternaldafny_dtypes::ISimpleTypesStringClient, ::std::rc::Rc<super::r#_simple_dtypes_dsmithystring_dinternaldafny_dtypes::Error>>::Success{
+          value: v
+      })
+    }
+  }
+  
+  struct SimpleStringClient {
+    r#_i_config: ::std::rc::Rc<super::r#_SimpleStringImpl_Compile::Config>
+  }
 
+  impl SimpleStringClient {
+    fn _ctor(this: *mut SimpleStringClient, config: &::std::rc::Rc<super::r#_SimpleStringImpl_Compile::Config>) {
+      let mut _i_set_config = false;
+      ::dafny_runtime::update_field_uninit!(this, r#_i_config, _i_set_config, config.clone());
+    }
+    fn config(&self) -> ::std::rc::Rc<super::r#_SimpleStringImpl_Compile::Config> {
+      self.r#_i_config.clone()
+    }
+  }
+  impl super::r#_simple_dtypes_dsmithystring_dinternaldafny_dtypes::ISimpleTypesStringClient for SimpleStringClient {
+    fn GetString(self: &Self, input: &::std::rc::Rc<super::r#_simple_dtypes_dsmithystring_dinternaldafny_dtypes::GetStringInput>) -> ::std::rc::Rc<super::r#_Wrappers_Compile::Result<::std::rc::Rc<super::r#_simple_dtypes_dsmithystring_dinternaldafny_dtypes::GetStringOutput>, ::std::rc::Rc<super::r#_simple_dtypes_dsmithystring_dinternaldafny_dtypes::Error>>> {
+      super::r#_SimpleStringImpl_Compile::_default::GetString(&self.config(), input)
+    }
+    fn GetStringSingleValue(self: &Self, input: &::std::rc::Rc<super::r#_simple_dtypes_dsmithystring_dinternaldafny_dtypes::GetStringInput>) -> ::std::rc::Rc<super::r#_Wrappers_Compile::Result<::std::rc::Rc<super::r#_simple_dtypes_dsmithystring_dinternaldafny_dtypes::GetStringOutput>, ::std::rc::Rc<super::r#_simple_dtypes_dsmithystring_dinternaldafny_dtypes::Error>>> {
+      super::r#_SimpleStringImpl_Compile::_default::GetStringSingleValue(&self.config(), input)
+    }
+    fn GetStringUTF8(self: &Self, input: &::std::rc::Rc<super::r#_simple_dtypes_dsmithystring_dinternaldafny_dtypes::GetStringInput>) -> ::std::rc::Rc<super::r#_Wrappers_Compile::Result<::std::rc::Rc<super::r#_simple_dtypes_dsmithystring_dinternaldafny_dtypes::GetStringOutput>, ::std::rc::Rc<super::r#_simple_dtypes_dsmithystring_dinternaldafny_dtypes::Error>>> {
+      super::r#_SimpleStringImpl_Compile::_default::GetStringUTF8(&self.config(), input)
+    }
+  }
+  ::dafny_runtime::UpcastTo!(SimpleStringClient, dyn super::r#_simple_dtypes_dsmithystring_dinternaldafny_dtypes::ISimpleTypesStringClient);
+}
+mod r#_StandardLibraryInterop_Compile {
+  pub struct WrappersInterop {}
+  impl WrappersInterop {
+    pub fn new() -> Self {
+      WrappersInterop {}
+    }
+    pub fn _allocated() -> *mut Self {
+      ::dafny_runtime::allocate::<Self>()
+    }
+    pub fn CreateStringSome(s: &::dafny_runtime::Sequence<::dafny_runtime::DafnyCharUTF16>) -> ::std::rc::Rc<super::r#_Wrappers_Compile::Option<::dafny_runtime::Sequence<::dafny_runtime::DafnyCharUTF16>>> {
+      ::std::rc::Rc::new(super::r#_Wrappers_Compile::Option::<::dafny_runtime::Sequence<::dafny_runtime::DafnyCharUTF16>>::Some {
+          value: s.clone()
+        })
+    }
+    pub fn CreateStringNone() -> ::std::rc::Rc<super::r#_Wrappers_Compile::Option<::dafny_runtime::Sequence<::dafny_runtime::DafnyCharUTF16>>> {
+      ::std::rc::Rc::new(super::r#_Wrappers_Compile::Option::<::dafny_runtime::Sequence<::dafny_runtime::DafnyCharUTF16>>::None {})
+    }
+    pub fn CreateBooleanSome(b: bool) -> ::std::rc::Rc<super::r#_Wrappers_Compile::Option<bool>> {
+      ::std::rc::Rc::new(super::r#_Wrappers_Compile::Option::<bool>::Some {
+          value: b
+        })
+    }
+    pub fn CreateBooleanNone() -> ::std::rc::Rc<super::r#_Wrappers_Compile::Option<bool>> {
+      ::std::rc::Rc::new(super::r#_Wrappers_Compile::Option::<bool>::None {})
+    }
+  }
+  impl ::std::default::Default for WrappersInterop {
+    fn default() -> Self {
+      WrappersInterop::new()
+    }
+  }
+  impl ::dafny_runtime::DafnyPrint for WrappersInterop {
+    fn fmt_print(&self, _formatter: &mut ::std::fmt::Formatter, _in_seq: bool) -> std::fmt::Result {
+      write!(_formatter, "StandardLibraryInterop_Compile.WrappersInterop")
+    }
+  }
+  impl ::std::cmp::PartialEq for WrappersInterop {
+    fn eq(&self, other: &Self) -> bool {
+      ::std::ptr::eq(self, other)
+    }
+  }
+}
+mod _module {
+  
 }
\ No newline at end of file
diff --git b/TestModels/SimpleTypes/SimpleString/runtimes/rust/src/lib.rs a/TestModels/SimpleTypes/SimpleString/runtimes/rust/src/lib.rs
new file mode 100644
index 00000000..91608d30
--- /dev/null
+++ a/TestModels/SimpleTypes/SimpleString/runtimes/rust/src/lib.rs
@@ -0,0 +1,22 @@
+
+// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
+
+pub mod implementation_from_dafny;
+
+#[doc(inline)]
+pub use config::Config;
+
+pub mod client;
+
+/// Configuration for SimpleString Service.
+pub mod config;
+
+/// Common errors and error handling utilities.
+pub mod error;
+
+/// All operations that this crate can perform.
+pub mod operation;
+
+mod conversions;
+
+pub use client::Client;
diff --git b/TestModels/SimpleTypes/SimpleString/runtimes/rust/src/operation.rs a/TestModels/SimpleTypes/SimpleString/runtimes/rust/src/operation.rs
new file mode 100644
index 00000000..668f909e
--- /dev/null
+++ a/TestModels/SimpleTypes/SimpleString/runtimes/rust/src/operation.rs
@@ -0,0 +1,10 @@
+// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
+
+/// Types for the `GetString` operation.
+pub mod get_string;
+
+/// Types for the `GetStringSingleValue` operation.
+pub mod get_string_single_value;
+
+/// Types for the `GetStringUTF8` operation.
+pub mod get_string_utf8;
diff --git b/TestModels/SimpleTypes/SimpleString/runtimes/rust/src/operation/get_string.rs a/TestModels/SimpleTypes/SimpleString/runtimes/rust/src/operation/get_string.rs
new file mode 100644
index 00000000..60a777c1
--- /dev/null
+++ a/TestModels/SimpleTypes/SimpleString/runtimes/rust/src/operation/get_string.rs
@@ -0,0 +1,127 @@
+// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
+/// Orchestration and serialization glue logic for `GetString`.
+#[derive(::std::clone::Clone, ::std::default::Default, ::std::fmt::Debug)]
+#[non_exhaustive]
+pub struct GetString;
+impl GetString {
+    /// Creates a new `GetString`
+    pub fn new() -> Self {
+        Self
+    }
+    pub(crate) async fn send(
+        handle: &crate::client::Handle,
+        input: crate::operation::get_string::GetStringInput,
+    ) -> ::std::result::Result<
+        crate::operation::get_string::GetStringOutput,
+        crate::operation::get_string::GetStringError
+    > {
+        let inner_input = crate::conversions::get_string::_get_string_input::to_dafny(input);
+        let inner_result = crate::implementation_from_dafny::dafny_runtime::read!(handle.inner).GetString(&inner_input);
+        if matches!(inner_result.as_ref(), crate::implementation_from_dafny::r#_Wrappers_Compile::Result::Success{ .. }) {
+            Ok(crate::conversions::get_string::_get_string_output::from_dafny(inner_result.value().clone()))
+        } else {
+            Err(crate::conversions::get_string::from_dafny_error(inner_result.error().clone()))
+        }
+    }
+}
+
+/// Error type for the `GetString` operation.
+#[non_exhaustive]
+#[derive(::std::fmt::Debug)]
+pub enum GetStringError {
+    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
+    #[deprecated(note = "Matching `Unhandled` directly is not forwards compatible. Instead, match using a \
+    variable wildcard pattern and check `.code()`:
+     \
+    &nbsp;&nbsp;&nbsp;`err if err.code() == Some(\"SpecificExceptionCode\") => { /* handle the error */ }`
+     \
+    See [`ProvideErrorMetadata`](#impl-ProvideErrorMetadata-for-GetStringError) for what information is available for the error.")]
+    Unhandled(crate::error::sealed_unhandled::Unhandled),
+}
+impl GetStringError {
+    /// Creates the `GetStringError::Unhandled` variant from any error type.
+    pub fn unhandled(
+        err: impl ::std::convert::Into<::std::boxed::Box<dyn ::std::error::Error + ::std::marker::Send + ::std::marker::Sync + 'static>>,
+    ) -> Self {
+        Self::Unhandled(crate::error::sealed_unhandled::Unhandled {
+            source: err.into(),
+            meta: ::std::default::Default::default(),
+        })
+    }
+
+    /// Creates the `GetStringError::Unhandled` variant from an [`ErrorMetadata`](::aws_smithy_types::error::ErrorMetadata).
+    pub fn generic(err: ::aws_smithy_types::error::ErrorMetadata) -> Self {
+        Self::Unhandled(crate::error::sealed_unhandled::Unhandled {
+            source: err.clone().into(),
+            meta: err,
+        })
+    }
+    ///
+    /// Returns error metadata, which includes the error code, message,
+    /// request ID, and potentially additional information.
+    ///
+    pub fn meta(&self) -> &::aws_smithy_types::error::ErrorMetadata {
+        match self {
+            Self::Unhandled(e) => &e.meta,
+        }
+    }
+}
+impl ::std::error::Error for GetStringError {
+    fn source(&self) -> ::std::option::Option<&(dyn ::std::error::Error + 'static)> {
+        match self {
+            Self::Unhandled(_inner) => ::std::option::Option::Some(&*_inner.source),
+        }
+    }
+}
+impl ::std::fmt::Display for GetStringError {
+    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
+        match self {
+            Self::Unhandled(_inner) => {
+                if let ::std::option::Option::Some(code) = ::aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self) {
+                    write!(f, "unhandled error ({code})")
+                } else {
+                    f.write_str("unhandled error")
+                }
+            }
+        }
+    }
+}
+impl ::aws_smithy_types::retry::ProvideErrorKind for GetStringError {
+    fn code(&self) -> ::std::option::Option<&str> {
+        ::aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
+    }
+    fn retryable_error_kind(&self) -> ::std::option::Option<::aws_smithy_types::retry::ErrorKind> {
+        ::std::option::Option::None
+    }
+}
+impl ::aws_smithy_types::error::metadata::ProvideErrorMetadata for GetStringError {
+    fn meta(&self) -> &::aws_smithy_types::error::ErrorMetadata {
+        match self {
+            Self::Unhandled(_inner) => &_inner.meta,
+        }
+    }
+}
+impl ::aws_smithy_runtime_api::client::result::CreateUnhandledError for GetStringError {
+    fn create_unhandled_error(
+        source: ::std::boxed::Box<dyn ::std::error::Error + ::std::marker::Send + ::std::marker::Sync + 'static>,
+        meta: ::std::option::Option<::aws_smithy_types::error::ErrorMetadata>,
+    ) -> Self {
+        Self::Unhandled(crate::error::sealed_unhandled::Unhandled {
+            source,
+            meta: meta.unwrap_or_default(),
+        })
+    }
+}
+
+use core::panic;
+
+pub use crate::operation::get_string::_get_string_output::GetStringOutput;
+
+pub use crate::operation::get_string::_get_string_input::GetStringInput;
+
+mod _get_string_input;
+
+mod _get_string_output;
+
+/// Builders
+pub mod builders;
diff --git b/TestModels/SimpleTypes/SimpleString/runtimes/rust/src/operation/get_string/_get_string_input.rs a/TestModels/SimpleTypes/SimpleString/runtimes/rust/src/operation/get_string/_get_string_input.rs
new file mode 100644
index 00000000..6b6defd1
--- /dev/null
+++ a/TestModels/SimpleTypes/SimpleString/runtimes/rust/src/operation/get_string/_get_string_input.rs
@@ -0,0 +1,47 @@
+// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
+#[allow(missing_docs)] // documentation missing in model
+#[non_exhaustive]
+#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
+pub struct GetStringInput {
+    #[allow(missing_docs)] // documentation missing in model
+    pub value: ::std::option::Option<::std::string::String>,
+}
+impl GetStringInput {
+    #[allow(missing_docs)] // documentation missing in model
+    pub fn message(&self) -> ::std::option::Option<&str> {
+        self.value.as_deref()
+    }
+}
+impl GetStringInput {
+    /// Creates a new builder-style object to manufacture [`GetStringInput`](crate::operation::operation::GetStringInput).
+    pub fn builder() -> crate::operation::get_string::builders::GetStringInputBuilder {
+        crate::operation::get_string::builders::GetStringInputBuilder::default()
+    }
+}
+
+/// A builder for [`GetStringInput`](crate::operation::operation::GetStringInput).
+#[non_exhaustive]
+#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::default::Default, ::std::fmt::Debug)]
+pub struct GetStringInputBuilder {
+    pub(crate) value: ::std::option::Option<::std::string::String>,
+}
+impl GetStringInputBuilder {
+    #[allow(missing_docs)] // documentation missing in model
+    pub fn value(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
+        self.value = ::std::option::Option::Some(input.into());
+        self
+    }
+    #[allow(missing_docs)] // documentation missing in model
+    pub fn set_value(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
+        self.value = input;
+        self
+    }
+    #[allow(missing_docs)] // documentation missing in model
+    pub fn get_value(&self) -> &::std::option::Option<::std::string::String> {
+        &self.value
+    }
+    /// Consumes the builder and constructs a [`GetStringInput`](crate::operation::operation::GetStringInput).
+    pub fn build(self) -> ::std::result::Result<crate::operation::get_string::GetStringInput, ::aws_smithy_types::error::operation::BuildError> {
+        ::std::result::Result::Ok(crate::operation::get_string::GetStringInput { value: self.value })
+    }
+}
diff --git b/TestModels/SimpleTypes/SimpleString/runtimes/rust/src/operation/get_string/_get_string_output.rs a/TestModels/SimpleTypes/SimpleString/runtimes/rust/src/operation/get_string/_get_string_output.rs
new file mode 100644
index 00000000..6bcd74c0
--- /dev/null
+++ a/TestModels/SimpleTypes/SimpleString/runtimes/rust/src/operation/get_string/_get_string_output.rs
@@ -0,0 +1,47 @@
+// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
+#[allow(missing_docs)] // documentation missing in model
+#[non_exhaustive]
+#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
+pub struct GetStringOutput {
+    #[allow(missing_docs)] // documentation missing in model
+    pub value: ::std::option::Option<::std::string::String>,
+}
+impl GetStringOutput {
+    #[allow(missing_docs)] // documentation missing in model
+    pub fn value(&self) -> ::std::option::Option<&str> {
+        self.value.as_deref()
+    }
+}
+impl GetStringOutput {
+    /// Creates a new builder-style object to manufacture [`GetStringOutput`](crate::operation::operation::GetStringOutput).
+    pub fn builder() -> crate::operation::get_string::builders::GetStringOutputBuilder {
+        crate::operation::get_string::builders::GetStringOutputBuilder::default()
+    }
+}
+
+/// A builder for [`GetStringOutput`](crate::operation::operation::GetStringOutput).
+#[non_exhaustive]
+#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::default::Default, ::std::fmt::Debug)]
+pub struct GetStringOutputBuilder {
+    pub(crate) value: ::std::option::Option<::std::string::String>,
+}
+impl GetStringOutputBuilder {
+    #[allow(missing_docs)] // documentation missing in model
+    pub fn value(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
+        self.value = ::std::option::Option::Some(input.into());
+        self
+    }
+    #[allow(missing_docs)] // documentation missing in model
+    pub fn set_value(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
+        self.value = input;
+        self
+    }
+    #[allow(missing_docs)] // documentation missing in model
+    pub fn get_value(&self) -> &::std::option::Option<::std::string::String> {
+        &self.value
+    }
+    /// Consumes the builder and constructs a [`GetStringOutput`](crate::operation::operation::GetStringOutput).
+    pub fn build(self) -> ::std::result::Result<crate::operation::get_string::GetStringOutput, ::aws_smithy_types::error::operation::BuildError> {
+        ::std::result::Result::Ok(crate::operation::get_string::GetStringOutput { value: self.value })
+    }
+}
diff --git b/TestModels/SimpleTypes/SimpleString/runtimes/rust/src/operation/get_string/builders.rs a/TestModels/SimpleTypes/SimpleString/runtimes/rust/src/operation/get_string/builders.rs
new file mode 100644
index 00000000..691f2645
--- /dev/null
+++ a/TestModels/SimpleTypes/SimpleString/runtimes/rust/src/operation/get_string/builders.rs
@@ -0,0 +1,83 @@
+// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
+pub use crate::operation::get_string::_get_string_output::GetStringOutputBuilder;
+
+pub use crate::operation::get_string::_get_string_input::GetStringInputBuilder;
+
+impl GetStringInputBuilder {
+    /// Sends a request with this input using the given client.
+    pub async fn send_with(
+        self,
+        client: &crate::Client,
+    ) -> ::std::result::Result<
+        crate::operation::get_string::GetStringOutput,
+        crate::operation::get_string::GetStringError
+    > {
+        let mut fluent_builder = client.get_string();
+        fluent_builder.inner = self;
+        fluent_builder.send().await
+    }
+}
+/// Fluent builder constructing a request to `GetString`.
+///
+#[derive(::std::clone::Clone, ::std::fmt::Debug)]
+pub struct GetStringFluentBuilder {
+    handle: ::std::sync::Arc<crate::client::Handle>,
+    inner: crate::operation::get_string::builders::GetStringInputBuilder,
+    config_override: ::std::option::Option<crate::config::Builder>,
+}
+impl GetStringFluentBuilder {
+    /// Creates a new `GetString`.
+    pub(crate) fn new(handle: ::std::sync::Arc<crate::client::Handle>) -> Self {
+        Self {
+            handle,
+            inner: ::std::default::Default::default(),
+            config_override: ::std::option::Option::None,
+        }
+    }
+    /// Access the GetString as a reference.
+    pub fn as_input(&self) -> &crate::operation::get_string::builders::GetStringInputBuilder {
+        &self.inner
+    }
+    /// Sends the request and returns the response.
+    pub async fn send(
+        self,
+    ) -> ::std::result::Result<
+        crate::operation::get_string::GetStringOutput,
+        crate::operation::get_string::GetStringError
+    > {
+        let input = self
+            .inner
+            .build()
+            // Using unhandled since GetString doesn't declare any validation,
+            // and smithy-rs seems to not generate a ValidationError case unless there is
+            // (but isn't that a backwards compatibility problem for output structures?)
+            // Vanilla smithy-rs uses SdkError::construction_failure,
+            // but we aren't using SdkError.
+            .map_err(crate::operation::get_string::GetStringError::unhandled)?;
+        crate::operation::get_string::GetString::send(&self.handle, input).await
+    }
+
+    pub(crate) fn config_override(mut self, config_override: impl Into<crate::config::Builder>) -> Self {
+        self.set_config_override(Some(config_override.into()));
+        self
+    }
+
+    pub(crate) fn set_config_override(&mut self, config_override: Option<crate::config::Builder>) -> &mut Self {
+        self.config_override = config_override;
+        self
+    }
+    #[allow(missing_docs)] // documentation missing in model
+    pub fn value(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
+        self.inner = self.inner.value(input.into());
+        self
+    }
+    #[allow(missing_docs)] // documentation missing in model
+    pub fn set_value(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
+        self.inner = self.inner.set_value(input);
+        self
+    }
+    #[allow(missing_docs)] // documentation missing in model
+    pub fn get_value(&self) -> &::std::option::Option<::std::string::String> {
+        self.inner.get_value()
+    }
+}
diff --git b/TestModels/SimpleTypes/SimpleString/runtimes/rust/src/operation/get_string_single_value.rs a/TestModels/SimpleTypes/SimpleString/runtimes/rust/src/operation/get_string_single_value.rs
new file mode 100644
index 00000000..f8f76b17
--- /dev/null
+++ a/TestModels/SimpleTypes/SimpleString/runtimes/rust/src/operation/get_string_single_value.rs
@@ -0,0 +1,127 @@
+// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
+/// Orchestration and serialization glue logic for `GetStringSingleValue`.
+#[derive(::std::clone::Clone, ::std::default::Default, ::std::fmt::Debug)]
+#[non_exhaustive]
+pub struct GetStringSingleValue;
+impl GetStringSingleValue {
+    /// Creates a new `GetStringSingleValue`
+    pub fn new() -> Self {
+        Self
+    }
+    pub(crate) async fn send(
+        handle: &crate::client::Handle,
+        input: crate::operation::get_string_single_value::GetStringSingleValueInput,
+    ) -> ::std::result::Result<
+        crate::operation::get_string_single_value::GetStringSingleValueOutput,
+        crate::operation::get_string_single_value::GetStringSingleValueError
+    > {
+        let inner_input = crate::conversions::get_string_single_value::_get_string_single_value_input::to_dafny(input);
+        let inner_result = crate::implementation_from_dafny::dafny_runtime::read!(handle.inner).GetStringUTF8(&inner_input);
+        if matches!(inner_result.as_ref(), crate::implementation_from_dafny::r#_Wrappers_Compile::Result::Success{ .. }) {
+            Ok(crate::conversions::get_string_single_value::_get_string_single_value_output::from_dafny(inner_result.value().clone()))
+        } else {
+            Err(crate::conversions::get_string_single_value::from_dafny_error(inner_result.error().clone()))
+        }
+    }
+}
+
+/// Error type for the `GetStringSingleValue` operation.
+#[non_exhaustive]
+#[derive(::std::fmt::Debug)]
+pub enum GetStringSingleValueError {
+    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
+    #[deprecated(note = "Matching `Unhandled` directly is not forwards compatible. Instead, match using a \
+    variable wildcard pattern and check `.code()`:
+     \
+    &nbsp;&nbsp;&nbsp;`err if err.code() == Some(\"SpecificExceptionCode\") => { /* handle the error */ }`
+     \
+    See [`ProvideErrorMetadata`](#impl-ProvideErrorMetadata-for-GetStringSingleValueError) for what information is available for the error.")]
+    Unhandled(crate::error::sealed_unhandled::Unhandled),
+}
+impl GetStringSingleValueError {
+    /// Creates the `GetStringSingleValueError::Unhandled` variant from any error type.
+    pub fn unhandled(
+        err: impl ::std::convert::Into<::std::boxed::Box<dyn ::std::error::Error + ::std::marker::Send + ::std::marker::Sync + 'static>>,
+    ) -> Self {
+        Self::Unhandled(crate::error::sealed_unhandled::Unhandled {
+            source: err.into(),
+            meta: ::std::default::Default::default(),
+        })
+    }
+
+    /// Creates the `GetStringSingleValueError::Unhandled` variant from an [`ErrorMetadata`](::aws_smithy_types::error::ErrorMetadata).
+    pub fn generic(err: ::aws_smithy_types::error::ErrorMetadata) -> Self {
+        Self::Unhandled(crate::error::sealed_unhandled::Unhandled {
+            source: err.clone().into(),
+            meta: err,
+        })
+    }
+    ///
+    /// Returns error metadata, which includes the error code, message,
+    /// request ID, and potentially additional information.
+    ///
+    pub fn meta(&self) -> &::aws_smithy_types::error::ErrorMetadata {
+        match self {
+            Self::Unhandled(e) => &e.meta,
+        }
+    }
+}
+impl ::std::error::Error for GetStringSingleValueError {
+    fn source(&self) -> ::std::option::Option<&(dyn ::std::error::Error + 'static)> {
+        match self {
+            Self::Unhandled(_inner) => ::std::option::Option::Some(&*_inner.source),
+        }
+    }
+}
+impl ::std::fmt::Display for GetStringSingleValueError {
+    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
+        match self {
+            Self::Unhandled(_inner) => {
+                if let ::std::option::Option::Some(code) = ::aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self) {
+                    write!(f, "unhandled error ({code})")
+                } else {
+                    f.write_str("unhandled error")
+                }
+            }
+        }
+    }
+}
+impl ::aws_smithy_types::retry::ProvideErrorKind for GetStringSingleValueError {
+    fn code(&self) -> ::std::option::Option<&str> {
+        ::aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
+    }
+    fn retryable_error_kind(&self) -> ::std::option::Option<::aws_smithy_types::retry::ErrorKind> {
+        ::std::option::Option::None
+    }
+}
+impl ::aws_smithy_types::error::metadata::ProvideErrorMetadata for GetStringSingleValueError {
+    fn meta(&self) -> &::aws_smithy_types::error::ErrorMetadata {
+        match self {
+            Self::Unhandled(_inner) => &_inner.meta,
+        }
+    }
+}
+impl ::aws_smithy_runtime_api::client::result::CreateUnhandledError for GetStringSingleValueError {
+    fn create_unhandled_error(
+        source: ::std::boxed::Box<dyn ::std::error::Error + ::std::marker::Send + ::std::marker::Sync + 'static>,
+        meta: ::std::option::Option<::aws_smithy_types::error::ErrorMetadata>,
+    ) -> Self {
+        Self::Unhandled(crate::error::sealed_unhandled::Unhandled {
+            source,
+            meta: meta.unwrap_or_default(),
+        })
+    }
+}
+
+use core::panic;
+
+pub use crate::operation::get_string_single_value::_get_string_single_value_output::GetStringSingleValueOutput;
+
+pub use crate::operation::get_string_single_value::_get_string_single_value_input::GetStringSingleValueInput;
+
+mod _get_string_single_value_input;
+
+mod _get_string_single_value_output;
+
+/// Builders
+pub mod builders;
diff --git b/TestModels/SimpleTypes/SimpleString/runtimes/rust/src/operation/get_string_single_value/_get_string_single_value_input.rs a/TestModels/SimpleTypes/SimpleString/runtimes/rust/src/operation/get_string_single_value/_get_string_single_value_input.rs
new file mode 100644
index 00000000..39a3dbf7
--- /dev/null
+++ a/TestModels/SimpleTypes/SimpleString/runtimes/rust/src/operation/get_string_single_value/_get_string_single_value_input.rs
@@ -0,0 +1,47 @@
+// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
+#[allow(missing_docs)] // documentation missing in model
+#[non_exhaustive]
+#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
+pub struct GetStringSingleValueInput {
+    #[allow(missing_docs)] // documentation missing in model
+    pub value: ::std::option::Option<::std::string::String>,
+}
+impl GetStringSingleValueInput {
+    #[allow(missing_docs)] // documentation missing in model
+    pub fn value(&self) -> ::std::option::Option<&str> {
+        self.value.as_deref()
+    }
+}
+impl GetStringSingleValueInput {
+    /// Creates a new builder-style object to manufacture [`GetStringSingleValueInput`](crate::operation::operation::GetStringSingleValueInput).
+    pub fn builder() -> crate::operation::get_string_single_value::builders::GetStringSingleValueInputBuilder {
+        crate::operation::get_string_single_value::builders::GetStringSingleValueInputBuilder::default()
+    }
+}
+
+/// A builder for [`GetStringSingleValueInput`](crate::operation::operation::GetStringSingleValueInput).
+#[non_exhaustive]
+#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::default::Default, ::std::fmt::Debug)]
+pub struct GetStringSingleValueInputBuilder {
+    pub(crate) value: ::std::option::Option<::std::string::String>,
+}
+impl GetStringSingleValueInputBuilder {
+    #[allow(missing_docs)] // documentation missing in model
+    pub fn value(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
+        self.value = ::std::option::Option::Some(input.into());
+        self
+    }
+    #[allow(missing_docs)] // documentation missing in model
+    pub fn set_value(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
+        self.value = input;
+        self
+    }
+    #[allow(missing_docs)] // documentation missing in model
+    pub fn get_value(&self) -> &::std::option::Option<::std::string::String> {
+        &self.value
+    }
+    /// Consumes the builder and constructs a [`GetStringSingleValueInput`](crate::operation::operation::GetStringSingleValueInput).
+    pub fn build(self) -> ::std::result::Result<crate::operation::get_string_single_value::GetStringSingleValueInput, ::aws_smithy_types::error::operation::BuildError> {
+        ::std::result::Result::Ok(crate::operation::get_string_single_value::GetStringSingleValueInput { value: self.value })
+    }
+}
diff --git b/TestModels/SimpleTypes/SimpleString/runtimes/rust/src/operation/get_string_single_value/_get_string_single_value_output.rs a/TestModels/SimpleTypes/SimpleString/runtimes/rust/src/operation/get_string_single_value/_get_string_single_value_output.rs
new file mode 100644
index 00000000..c6139f5b
--- /dev/null
+++ a/TestModels/SimpleTypes/SimpleString/runtimes/rust/src/operation/get_string_single_value/_get_string_single_value_output.rs
@@ -0,0 +1,47 @@
+// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
+#[allow(missing_docs)] // documentation missing in model
+#[non_exhaustive]
+#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
+pub struct GetStringSingleValueOutput {
+    #[allow(missing_docs)] // documentation missing in model
+    pub value: ::std::option::Option<::std::string::String>,
+}
+impl GetStringSingleValueOutput {
+    #[allow(missing_docs)] // documentation missing in model
+    pub fn value(&self) -> ::std::option::Option<&str> {
+        self.value.as_deref()
+    }
+}
+impl GetStringSingleValueOutput {
+    /// Creates a new builder-style object to manufacture [`GetStringSingleValueOutput`](crate::operation::operation::GetStringSingleValueOutput).
+    pub fn builder() -> crate::operation::get_string_single_value::builders::GetStringSingleValueOutputBuilder {
+        crate::operation::get_string_single_value::builders::GetStringSingleValueOutputBuilder::default()
+    }
+}
+
+/// A builder for [`GetStringSingleValueOutput`](crate::operation::operation::GetStringSingleValueOutput).
+#[non_exhaustive]
+#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::default::Default, ::std::fmt::Debug)]
+pub struct GetStringSingleValueOutputBuilder {
+    pub(crate) value: ::std::option::Option<::std::string::String>,
+}
+impl GetStringSingleValueOutputBuilder {
+    #[allow(missing_docs)] // documentation missing in model
+    pub fn value(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
+        self.value = ::std::option::Option::Some(input.into());
+        self
+    }
+    #[allow(missing_docs)] // documentation missing in model
+    pub fn set_value(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
+        self.value = input;
+        self
+    }
+    #[allow(missing_docs)] // documentation missing in model
+    pub fn get_value(&self) -> &::std::option::Option<::std::string::String> {
+        &self.value
+    }
+    /// Consumes the builder and constructs a [`GetStringSingleValueOutput`](crate::operation::operation::GetStringSingleValueOutput).
+    pub fn build(self) -> ::std::result::Result<crate::operation::get_string_single_value::GetStringSingleValueOutput, ::aws_smithy_types::error::operation::BuildError> {
+        ::std::result::Result::Ok(crate::operation::get_string_single_value::GetStringSingleValueOutput { value: self.value })
+    }
+}
diff --git b/TestModels/SimpleTypes/SimpleString/runtimes/rust/src/operation/get_string_single_value/builders.rs a/TestModels/SimpleTypes/SimpleString/runtimes/rust/src/operation/get_string_single_value/builders.rs
new file mode 100644
index 00000000..03c86742
--- /dev/null
+++ a/TestModels/SimpleTypes/SimpleString/runtimes/rust/src/operation/get_string_single_value/builders.rs
@@ -0,0 +1,83 @@
+// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
+pub use crate::operation::get_string_single_value::_get_string_single_value_output::GetStringSingleValueOutputBuilder;
+
+pub use crate::operation::get_string_single_value::_get_string_single_value_input::GetStringSingleValueInputBuilder;
+
+impl GetStringSingleValueInputBuilder {
+    /// Sends a request with this input using the given client.
+    pub async fn send_with(
+        self,
+        client: &crate::Client,
+    ) -> ::std::result::Result<
+        crate::operation::get_string_single_value::GetStringSingleValueOutput,
+        crate::operation::get_string_single_value::GetStringSingleValueError
+    > {
+        let mut fluent_builder = client.get_string_single_value();
+        fluent_builder.inner = self;
+        fluent_builder.send().await
+    }
+}
+/// Fluent builder constructing a request to `GetStringSingleValue`.
+///
+#[derive(::std::clone::Clone, ::std::fmt::Debug)]
+pub struct GetStringSingleValueFluentBuilder {
+    handle: ::std::sync::Arc<crate::client::Handle>,
+    inner: crate::operation::get_string_single_value::builders::GetStringSingleValueInputBuilder,
+    config_override: ::std::option::Option<crate::config::Builder>,
+}
+impl GetStringSingleValueFluentBuilder {
+    /// Creates a new `GetStringSingleValue`.
+    pub(crate) fn new(handle: ::std::sync::Arc<crate::client::Handle>) -> Self {
+        Self {
+            handle,
+            inner: ::std::default::Default::default(),
+            config_override: ::std::option::Option::None,
+        }
+    }
+    /// Access the GetStringSingleValue as a reference.
+    pub fn as_input(&self) -> &crate::operation::get_string_single_value::builders::GetStringSingleValueInputBuilder {
+        &self.inner
+    }
+    /// Sends the request and returns the response.
+    pub async fn send(
+        self,
+    ) -> ::std::result::Result<
+        crate::operation::get_string_single_value::GetStringSingleValueOutput,
+        crate::operation::get_string_single_value::GetStringSingleValueError
+    > {
+        let input = self
+            .inner
+            .build()
+            // Using unhandled since GetString doesn't declare any validation,
+            // and smithy-rs seems to not generate a ValidationError case unless there is
+            // (but isn't that a backwards compatibility problem for output structures?)
+            // Vanilla smithy-rs uses SdkError::construction_failure,
+            // but we aren't using SdkError.
+            .map_err(crate::operation::get_string_single_value::GetStringSingleValueError::unhandled)?;
+        crate::operation::get_string_single_value::GetStringSingleValue::send(&self.handle, input).await
+    }
+
+    pub(crate) fn config_override(mut self, config_override: impl Into<crate::config::Builder>) -> Self {
+        self.set_config_override(Some(config_override.into()));
+        self
+    }
+
+    pub(crate) fn set_config_override(&mut self, config_override: Option<crate::config::Builder>) -> &mut Self {
+        self.config_override = config_override;
+        self
+    }
+    #[allow(missing_docs)] // documentation missing in model
+    pub fn value(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
+        self.inner = self.inner.value(input.into());
+        self
+    }
+    #[allow(missing_docs)] // documentation missing in model
+    pub fn set_value(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
+        self.inner = self.inner.set_value(input);
+        self
+    }
+    #[allow(missing_docs)] // documentation missing in model
+    pub fn get_value(&self) -> &::std::option::Option<::std::string::String> {
+        self.inner.get_value()
+    }
+}
diff --git b/TestModels/SimpleTypes/SimpleString/runtimes/rust/src/operation/get_string_utf8.rs a/TestModels/SimpleTypes/SimpleString/runtimes/rust/src/operation/get_string_utf8.rs
new file mode 100644
index 00000000..8f3c14f2
--- /dev/null
+++ a/TestModels/SimpleTypes/SimpleString/runtimes/rust/src/operation/get_string_utf8.rs
@@ -0,0 +1,127 @@
+// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
+/// Orchestration and serialization glue logic for `GetStringUTF8`.
+#[derive(::std::clone::Clone, ::std::default::Default, ::std::fmt::Debug)]
+#[non_exhaustive]
+pub struct GetStringUTF8;
+impl GetStringUTF8 {
+    /// Creates a new `GetStringUTF8`
+    pub fn new() -> Self {
+        Self
+    }
+    pub(crate) async fn send(
+        handle: &crate::client::Handle,
+        input: crate::operation::get_string_utf8::GetStringUTF8Input,
+    ) -> ::std::result::Result<
+        crate::operation::get_string_utf8::GetStringUTF8Output,
+        crate::operation::get_string_utf8::GetStringUTF8Error
+    > {
+        let inner_input = crate::conversions::get_string_utf8::_get_string_utf8_input::to_dafny(input);
+        let inner_result = crate::implementation_from_dafny::dafny_runtime::read!(handle.inner).GetStringUTF8(&inner_input);
+        if matches!(inner_result.as_ref(), crate::implementation_from_dafny::r#_Wrappers_Compile::Result::Success{ .. }) {
+            Ok(crate::conversions::get_string_utf8::_get_string_utf8_output::from_dafny(inner_result.value().clone()))
+        } else {
+            Err(crate::conversions::get_string_utf8::from_dafny_error(inner_result.error().clone()))
+        }
+    }
+}
+
+/// Error type for the `GetStringUTF8` operation.
+#[non_exhaustive]
+#[derive(::std::fmt::Debug)]
+pub enum GetStringUTF8Error {
+    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
+    #[deprecated(note = "Matching `Unhandled` directly is not forwards compatible. Instead, match using a \
+    variable wildcard pattern and check `.code()`:
+     \
+    &nbsp;&nbsp;&nbsp;`err if err.code() == Some(\"SpecificExceptionCode\") => { /* handle the error */ }`
+     \
+    See [`ProvideErrorMetadata`](#impl-ProvideErrorMetadata-for-GetStringUTF8Error) for what information is available for the error.")]
+    Unhandled(crate::error::sealed_unhandled::Unhandled),
+}
+impl GetStringUTF8Error {
+    /// Creates the `GetStringUTF8Error::Unhandled` variant from any error type.
+    pub fn unhandled(
+        err: impl ::std::convert::Into<::std::boxed::Box<dyn ::std::error::Error + ::std::marker::Send + ::std::marker::Sync + 'static>>,
+    ) -> Self {
+        Self::Unhandled(crate::error::sealed_unhandled::Unhandled {
+            source: err.into(),
+            meta: ::std::default::Default::default(),
+        })
+    }
+
+    /// Creates the `GetStringUTF8Error::Unhandled` variant from an [`ErrorMetadata`](::aws_smithy_types::error::ErrorMetadata).
+    pub fn generic(err: ::aws_smithy_types::error::ErrorMetadata) -> Self {
+        Self::Unhandled(crate::error::sealed_unhandled::Unhandled {
+            source: err.clone().into(),
+            meta: err,
+        })
+    }
+    ///
+    /// Returns error metadata, which includes the error code, message,
+    /// request ID, and potentially additional information.
+    ///
+    pub fn meta(&self) -> &::aws_smithy_types::error::ErrorMetadata {
+        match self {
+            Self::Unhandled(e) => &e.meta,
+        }
+    }
+}
+impl ::std::error::Error for GetStringUTF8Error {
+    fn source(&self) -> ::std::option::Option<&(dyn ::std::error::Error + 'static)> {
+        match self {
+            Self::Unhandled(_inner) => ::std::option::Option::Some(&*_inner.source),
+        }
+    }
+}
+impl ::std::fmt::Display for GetStringUTF8Error {
+    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
+        match self {
+            Self::Unhandled(_inner) => {
+                if let ::std::option::Option::Some(code) = ::aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self) {
+                    write!(f, "unhandled error ({code})")
+                } else {
+                    f.write_str("unhandled error")
+                }
+            }
+        }
+    }
+}
+impl ::aws_smithy_types::retry::ProvideErrorKind for GetStringUTF8Error {
+    fn code(&self) -> ::std::option::Option<&str> {
+        ::aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
+    }
+    fn retryable_error_kind(&self) -> ::std::option::Option<::aws_smithy_types::retry::ErrorKind> {
+        ::std::option::Option::None
+    }
+}
+impl ::aws_smithy_types::error::metadata::ProvideErrorMetadata for GetStringUTF8Error {
+    fn meta(&self) -> &::aws_smithy_types::error::ErrorMetadata {
+        match self {
+            Self::Unhandled(_inner) => &_inner.meta,
+        }
+    }
+}
+impl ::aws_smithy_runtime_api::client::result::CreateUnhandledError for GetStringUTF8Error {
+    fn create_unhandled_error(
+        source: ::std::boxed::Box<dyn ::std::error::Error + ::std::marker::Send + ::std::marker::Sync + 'static>,
+        meta: ::std::option::Option<::aws_smithy_types::error::ErrorMetadata>,
+    ) -> Self {
+        Self::Unhandled(crate::error::sealed_unhandled::Unhandled {
+            source,
+            meta: meta.unwrap_or_default(),
+        })
+    }
+}
+
+use core::panic;
+
+pub use crate::operation::get_string_utf8::_get_string_utf8_output::GetStringUTF8Output;
+
+pub use crate::operation::get_string_utf8::_get_string_utf8_input::GetStringUTF8Input;
+
+mod _get_string_utf8_input;
+
+mod _get_string_utf8_output;
+
+/// Builders
+pub mod builders;
diff --git b/TestModels/SimpleTypes/SimpleString/runtimes/rust/src/operation/get_string_utf8/_get_string_utf8_input.rs a/TestModels/SimpleTypes/SimpleString/runtimes/rust/src/operation/get_string_utf8/_get_string_utf8_input.rs
new file mode 100644
index 00000000..508b4e80
--- /dev/null
+++ a/TestModels/SimpleTypes/SimpleString/runtimes/rust/src/operation/get_string_utf8/_get_string_utf8_input.rs
@@ -0,0 +1,47 @@
+// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
+#[allow(missing_docs)] // documentation missing in model
+#[non_exhaustive]
+#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
+pub struct GetStringUTF8Input {
+    #[allow(missing_docs)] // documentation missing in model
+    pub value: ::std::option::Option<::std::string::String>,
+}
+impl GetStringUTF8Input {
+    #[allow(missing_docs)] // documentation missing in model
+    pub fn value(&self) -> ::std::option::Option<&str> {
+        self.value.as_deref()
+    }
+}
+impl GetStringUTF8Input {
+    /// Creates a new builder-style object to manufacture [`GetStringUTF8Input`](crate::operation::operation::GetStringUTF8Input).
+    pub fn builder() -> crate::operation::get_string_utf8::builders::GetStringUTF8InputBuilder {
+        crate::operation::get_string_utf8::builders::GetStringUTF8InputBuilder::default()
+    }
+}
+
+/// A builder for [`GetStringUTF8Input`](crate::operation::operation::GetStringUTF8Input).
+#[non_exhaustive]
+#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::default::Default, ::std::fmt::Debug)]
+pub struct GetStringUTF8InputBuilder {
+    pub(crate) value: ::std::option::Option<::std::string::String>,
+}
+impl GetStringUTF8InputBuilder {
+    #[allow(missing_docs)] // documentation missing in model
+    pub fn value(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
+        self.value = ::std::option::Option::Some(input.into());
+        self
+    }
+    #[allow(missing_docs)] // documentation missing in model
+    pub fn set_value(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
+        self.value = input;
+        self
+    }
+    #[allow(missing_docs)] // documentation missing in model
+    pub fn get_value(&self) -> &::std::option::Option<::std::string::String> {
+        &self.value
+    }
+    /// Consumes the builder and constructs a [`GetStringUTF8Input`](crate::operation::operation::GetStringUTF8Input).
+    pub fn build(self) -> ::std::result::Result<crate::operation::get_string_utf8::GetStringUTF8Input, ::aws_smithy_types::error::operation::BuildError> {
+        ::std::result::Result::Ok(crate::operation::get_string_utf8::GetStringUTF8Input { value: self.value })
+    }
+}
diff --git b/TestModels/SimpleTypes/SimpleString/runtimes/rust/src/operation/get_string_utf8/_get_string_utf8_output.rs a/TestModels/SimpleTypes/SimpleString/runtimes/rust/src/operation/get_string_utf8/_get_string_utf8_output.rs
new file mode 100644
index 00000000..fe91d670
--- /dev/null
+++ a/TestModels/SimpleTypes/SimpleString/runtimes/rust/src/operation/get_string_utf8/_get_string_utf8_output.rs
@@ -0,0 +1,47 @@
+// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
+#[allow(missing_docs)] // documentation missing in model
+#[non_exhaustive]
+#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
+pub struct GetStringUTF8Output {
+    #[allow(missing_docs)] // documentation missing in model
+    pub value: ::std::option::Option<::std::string::String>,
+}
+impl GetStringUTF8Output {
+    #[allow(missing_docs)] // documentation missing in model
+    pub fn value(&self) -> ::std::option::Option<&str> {
+        self.value.as_deref()
+    }
+}
+impl GetStringUTF8Output {
+    /// Creates a new builder-style object to manufacture [`GetStringUTF8Output`](crate::operation::operation::GetStringUTF8Output).
+    pub fn builder() -> crate::operation::get_string_utf8::builders::GetStringUTF8OutputBuilder {
+        crate::operation::get_string_utf8::builders::GetStringUTF8OutputBuilder::default()
+    }
+}
+
+/// A builder for [`GetStringUTF8Output`](crate::operation::operation::GetStringUTF8Output).
+#[non_exhaustive]
+#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::default::Default, ::std::fmt::Debug)]
+pub struct GetStringUTF8OutputBuilder {
+    pub(crate) value: ::std::option::Option<::std::string::String>,
+}
+impl GetStringUTF8OutputBuilder {
+    #[allow(missing_docs)] // documentation missing in model
+    pub fn value(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
+        self.value = ::std::option::Option::Some(input.into());
+        self
+    }
+    #[allow(missing_docs)] // documentation missing in model
+    pub fn set_value(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
+        self.value = input;
+        self
+    }
+    #[allow(missing_docs)] // documentation missing in model
+    pub fn get_value(&self) -> &::std::option::Option<::std::string::String> {
+        &self.value
+    }
+    /// Consumes the builder and constructs a [`GetStringUTF8Output`](crate::operation::operation::GetStringUTF8Output).
+    pub fn build(self) -> ::std::result::Result<crate::operation::get_string_utf8::GetStringUTF8Output, ::aws_smithy_types::error::operation::BuildError> {
+        ::std::result::Result::Ok(crate::operation::get_string_utf8::GetStringUTF8Output { value: self.value })
+    }
+}
diff --git b/TestModels/SimpleTypes/SimpleString/runtimes/rust/src/operation/get_string_utf8/builders.rs a/TestModels/SimpleTypes/SimpleString/runtimes/rust/src/operation/get_string_utf8/builders.rs
new file mode 100644
index 00000000..56bbc83d
--- /dev/null
+++ a/TestModels/SimpleTypes/SimpleString/runtimes/rust/src/operation/get_string_utf8/builders.rs
@@ -0,0 +1,83 @@
+// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
+pub use crate::operation::get_string_utf8::_get_string_utf8_output::GetStringUTF8OutputBuilder;
+
+pub use crate::operation::get_string_utf8::_get_string_utf8_input::GetStringUTF8InputBuilder;
+
+impl GetStringUTF8InputBuilder {
+    /// Sends a request with this input using the given client.
+    pub async fn send_with(
+        self,
+        client: &crate::Client,
+    ) -> ::std::result::Result<
+        crate::operation::get_string_utf8::GetStringUTF8Output,
+        crate::operation::get_string_utf8::GetStringUTF8Error
+    > {
+        let mut fluent_builder = client.get_string_utf8();
+        fluent_builder.inner = self;
+        fluent_builder.send().await
+    }
+}
+/// Fluent builder constructing a request to `GetStringUTF8`.
+///
+#[derive(::std::clone::Clone, ::std::fmt::Debug)]
+pub struct GetStringUTF8FluentBuilder {
+    handle: ::std::sync::Arc<crate::client::Handle>,
+    inner: crate::operation::get_string_utf8::builders::GetStringUTF8InputBuilder,
+    config_override: ::std::option::Option<crate::config::Builder>,
+}
+impl GetStringUTF8FluentBuilder {
+    /// Creates a new `GetStringUTF8`.
+    pub(crate) fn new(handle: ::std::sync::Arc<crate::client::Handle>) -> Self {
+        Self {
+            handle,
+            inner: ::std::default::Default::default(),
+            config_override: ::std::option::Option::None,
+        }
+    }
+    /// Access the GetStringUTF8 as a reference.
+    pub fn as_input(&self) -> &crate::operation::get_string_utf8::builders::GetStringUTF8InputBuilder {
+        &self.inner
+    }
+    /// Sends the request and returns the response.
+    pub async fn send(
+        self,
+    ) -> ::std::result::Result<
+        crate::operation::get_string_utf8::GetStringUTF8Output,
+        crate::operation::get_string_utf8::GetStringUTF8Error
+    > {
+        let input = self
+            .inner
+            .build()
+            // Using unhandled since GetString doesn't declare any validation,
+            // and smithy-rs seems to not generate a ValidationError case unless there is
+            // (but isn't that a backwards compatibility problem for output structures?)
+            // Vanilla smithy-rs uses SdkError::construction_failure,
+            // but we aren't using SdkError.
+            .map_err(crate::operation::get_string_utf8::GetStringUTF8Error::unhandled)?;
+        crate::operation::get_string_utf8::GetStringUTF8::send(&self.handle, input).await
+    }
+
+    pub(crate) fn config_override(mut self, config_override: impl Into<crate::config::Builder>) -> Self {
+        self.set_config_override(Some(config_override.into()));
+        self
+    }
+
+    pub(crate) fn set_config_override(&mut self, config_override: Option<crate::config::Builder>) -> &mut Self {
+        self.config_override = config_override;
+        self
+    }
+    #[allow(missing_docs)] // documentation missing in model
+    pub fn value(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
+        self.inner = self.inner.value(input.into());
+        self
+    }
+    #[allow(missing_docs)] // documentation missing in model
+    pub fn set_value(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
+        self.inner = self.inner.set_value(input);
+        self
+    }
+    #[allow(missing_docs)] // documentation missing in model
+    pub fn get_value(&self) -> &::std::option::Option<::std::string::String> {
+        self.inner.get_value()
+    }
+}
diff --git b/TestModels/SimpleTypes/SimpleString/runtimes/rust/tests/simple_string_test.rs a/TestModels/SimpleTypes/SimpleString/runtimes/rust/tests/simple_string_test.rs
new file mode 100644
index 00000000..4f669d42
--- /dev/null
+++ a/TestModels/SimpleTypes/SimpleString/runtimes/rust/tests/simple_string_test.rs
@@ -0,0 +1,57 @@
+extern crate simple_string;
+
+mod simple_string_test {
+  use simple_string::*;
+  /*
+  method{:test} GetString(){
+        var client :- expect SimpleString.SimpleString();
+        TestGetString(client);
+        TestGetStringSingleValue(client);
+        TestGetStringUTF8(client);
+    }
+  */
+
+  /*method TestGetString(client: ISimpleTypesStringClient)
+    {
+        var ret :- expect client.GetString(SimpleString.Types.GetStringInput(value:= Some("TEST_SIMPLE_STRING_VALUE")));
+        expect ret.value.UnwrapOr("") == "TEST_SIMPLE_STRING_VALUE";
+        print ret;
+    } */
+  #[tokio::test]
+  async fn test_get_string() {
+    let result = client().get_string().value("TEST_SIMPLE_STRING_VALUE").send().await;
+    let output = result.unwrap();
+    let value = output.value().unwrap();
+    assert_eq!(value, "TEST_SIMPLE_STRING_VALUE");
+  }
+
+  #[tokio::test]
+  async fn test_get_string_single_value() {
+    let result = client().get_string_single_value().value("TEST_SIMPLE_STRING_SINGLE_VALUE").send().await;
+    let output = result.unwrap();
+    let value = output.value().unwrap();
+    assert_eq!(value, "TEST_SIMPLE_STRING_SINGLE_VALUE");
+  }
+
+   /*method TestGetStringUTF8(client: ISimpleTypesStringClient)
+    {
+        // utf8EncodedString holds a value of UTF-8 encoded Hindi word "Anar" (pomegranate, similar to A -> Apple) in it's native script
+        var utf8EncodedString := "\u0905\u0928\u093e\u0930";
+        var ret :- expect client.GetStringUTF8(SimpleString.Types.GetStringInput(value:= Some(utf8EncodedString)));
+        expect ret.value.UnwrapOr("") == utf8EncodedString;
+        print ret;
+    }*/
+  #[tokio::test]
+  async fn test_get_string_utf8() {
+    let utf8_encoded_string = "\u{0905}\u{0928}\u{093e}\u{0930}";
+    let result = client().get_string_utf8().value(utf8_encoded_string).send().await;
+    let output = result.unwrap();
+    let value = output.value().unwrap();
+    assert_eq!(value, utf8_encoded_string);
+  }
+
+  pub fn client() -> Client {
+    let config = Config::builder().build();
+    Client::from_conf(config).unwrap()
+  }
+}
\ No newline at end of file
diff --git b/TestModels/dafny-dependencies/StandardLibrary/runtimes/rust/Cargo.lock a/TestModels/dafny-dependencies/StandardLibrary/runtimes/rust/Cargo.lock
new file mode 100644
index 00000000..0b3c6129
--- /dev/null
+++ a/TestModels/dafny-dependencies/StandardLibrary/runtimes/rust/Cargo.lock
@@ -0,0 +1,135 @@
+# This file is automatically @generated by Cargo.
+# It is not intended for manual editing.
+version = 3
+
+[[package]]
+name = "as-any"
+version = "0.3.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "5b8a30a44e99a1c83ccb2a6298c563c888952a1c9134953db26876528f84c93a"
+
+[[package]]
+name = "autocfg"
+version = "1.1.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "d468802bab17cbc0cc575e9b053f41e72aa36bfa6b7f55e3529ffa43161b97fa"
+
+[[package]]
+name = "dafny_runtime"
+version = "0.1.0"
+dependencies = [
+ "as-any",
+ "itertools",
+ "num",
+ "once_cell",
+ "paste",
+]
+
+[[package]]
+name = "dafny_standard_library"
+version = "0.1.0"
+dependencies = [
+ "dafny_runtime",
+]
+
+[[package]]
+name = "either"
+version = "1.10.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "11157ac094ffbdde99aa67b23417ebdd801842852b500e395a45a9c0aac03e4a"
+
+[[package]]
+name = "itertools"
+version = "0.11.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "b1c173a5686ce8bfa551b3563d0c2170bf24ca44da99c7ca4bfdab5418c3fe57"
+dependencies = [
+ "either",
+]
+
+[[package]]
+name = "num"
+version = "0.4.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "b05180d69e3da0e530ba2a1dae5110317e49e3b7f3d41be227dc5f92e49ee7af"
+dependencies = [
+ "num-bigint",
+ "num-complex",
+ "num-integer",
+ "num-iter",
+ "num-rational",
+ "num-traits",
+]
+
+[[package]]
+name = "num-bigint"
+version = "0.4.4"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "608e7659b5c3d7cba262d894801b9ec9d00de989e8a82bd4bef91d08da45cdc0"
+dependencies = [
+ "autocfg",
+ "num-integer",
+ "num-traits",
+]
+
+[[package]]
+name = "num-complex"
+version = "0.4.5"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "23c6602fda94a57c990fe0df199a035d83576b496aa29f4e634a8ac6004e68a6"
+dependencies = [
+ "num-traits",
+]
+
+[[package]]
+name = "num-integer"
+version = "0.1.46"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "7969661fd2958a5cb096e56c8e1ad0444ac2bbcd0061bd28660485a44879858f"
+dependencies = [
+ "num-traits",
+]
+
+[[package]]
+name = "num-iter"
+version = "0.1.44"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "d869c01cc0c455284163fd0092f1f93835385ccab5a98a0dcc497b2f8bf055a9"
+dependencies = [
+ "autocfg",
+ "num-integer",
+ "num-traits",
+]
+
+[[package]]
+name = "num-rational"
+version = "0.4.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "0638a1c9d0a3c0914158145bc76cff373a75a627e6ecbfb71cbe6f453a5a19b0"
+dependencies = [
+ "autocfg",
+ "num-bigint",
+ "num-integer",
+ "num-traits",
+]
+
+[[package]]
+name = "num-traits"
+version = "0.2.18"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "da0df0e5185db44f69b44f26786fe401b6c293d1907744beaa7fa62b2e5a517a"
+dependencies = [
+ "autocfg",
+]
+
+[[package]]
+name = "once_cell"
+version = "1.19.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "3fdb12b2476b595f9358c5161aa467c2438859caa136dec86c26fdd2efe17b92"
+
+[[package]]
+name = "paste"
+version = "1.0.14"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "de3145af08024dea9fa9914f381a17b8fc6034dfb00f3a84013f7ff43f29ed4c"
diff --git b/TestModels/dafny-dependencies/StandardLibrary/runtimes/rust/Cargo.toml a/TestModels/dafny-dependencies/StandardLibrary/runtimes/rust/Cargo.toml
new file mode 100644
index 00000000..4e7b7b91
--- /dev/null
+++ a/TestModels/dafny-dependencies/StandardLibrary/runtimes/rust/Cargo.toml
@@ -0,0 +1,9 @@
+[package]
+name = "dafny_standard_library"
+version = "0.1.0"
+edition = "2021"
+
+# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html
+
+[dependencies]
+dafny_runtime = { path = "../../../dafny_runtime_rust"}
diff --git b/TestModels/dafny-dependencies/StandardLibrary/runtimes/rust/src/UTF8.rs a/TestModels/dafny-dependencies/StandardLibrary/runtimes/rust/src/UTF8.rs
new file mode 100644
index 00000000..1b9158e9
--- /dev/null
+++ a/TestModels/dafny-dependencies/StandardLibrary/runtimes/rust/src/UTF8.rs
@@ -0,0 +1,64 @@
+
+// Annotation to ignore the case of this module
+#[allow(non_snake_case)]
+pub mod UTF8 {
+  use crate::implementation_from_dafny::r#_Wrappers_Compile;
+  use crate::implementation_from_dafny::r#_UTF8_Compile;
+
+  pub fn Encode(s: &::dafny_runtime::Sequence<::dafny_runtime::DafnyCharUTF16>) -> ::std::rc::Rc<r#_Wrappers_Compile::Result<r#_UTF8_Compile::ValidUTF8Bytes, ::dafny_runtime::Sequence<::dafny_runtime::DafnyCharUTF16>>> {
+    let v = s.to_array();
+    let mut _accumulator: Vec<u8> = vec![];
+    // Use of .encode_utf8 method.
+    let mut surrogate: Option<u16> = None;
+    for c in v.iter() {
+      let s = 
+        if let Some(s) = surrogate {
+          String::from_utf16(&[s, c.0])
+        } else {
+          String::from_utf16(&[c.0])
+        };
+      surrogate = None;
+      match s {
+        Ok(value) => {
+          _accumulator.extend(value.as_bytes());
+          continue;
+        },
+        Err(e) => {
+          if 0xD800 <= c.0 && c.0 <= 0xDFFF {
+            surrogate = Some(c.0);
+            continue;
+          } 
+          return ::std::rc::Rc::new(r#_Wrappers_Compile::Result::<r#_UTF8_Compile::ValidUTF8Bytes, ::dafny_runtime::Sequence<::dafny_runtime::DafnyCharUTF16>>::Failure {
+            error: ::dafny_runtime::dafny_runtime_conversions::unicode_chars_false::string_to_dafny_string(
+              &e.to_string())
+          });
+        }
+      }
+    }
+    if let Some(s) = surrogate {
+      return ::std::rc::Rc::new(r#_Wrappers_Compile::Result::<r#_UTF8_Compile::ValidUTF8Bytes, ::dafny_runtime::Sequence<::dafny_runtime::DafnyCharUTF16>>::Failure {
+        error: ::dafny_runtime::dafny_runtime_conversions::unicode_chars_false::string_to_dafny_string(
+          &format!("Surrogate pair missing: 0x{:04x}", s))
+      });
+    }
+    ::std::rc::Rc::new(r#_Wrappers_Compile::Result::<r#_UTF8_Compile::ValidUTF8Bytes, ::dafny_runtime::Sequence<::dafny_runtime::DafnyCharUTF16>>::Success { value: ::dafny_runtime::Sequence::from_array_owned(_accumulator) })
+  }
+  pub fn Decode(b: &::dafny_runtime::Sequence<u8>) -> ::std::rc::Rc<r#_Wrappers_Compile::Result<::dafny_runtime::Sequence<::dafny_runtime::DafnyCharUTF16>, ::dafny_runtime::Sequence<::dafny_runtime::DafnyCharUTF16>>> {
+    let b = String::from_utf8(b.to_array().as_ref().clone());
+    match b {
+      Ok(s) => {
+        ::std::rc::Rc::new(r#_Wrappers_Compile::Result::<::dafny_runtime::Sequence<::dafny_runtime::DafnyCharUTF16>,
+          ::dafny_runtime::Sequence<::dafny_runtime::DafnyCharUTF16>>::Success {
+            value: ::dafny_runtime::dafny_runtime_conversions::unicode_chars_false::string_to_dafny_string(&s)
+        })
+      },
+      Err(e) => {
+        return ::std::rc::Rc::new(r#_Wrappers_Compile::Result::<::dafny_runtime::Sequence<::dafny_runtime::DafnyCharUTF16>,
+          ::dafny_runtime::Sequence<::dafny_runtime::DafnyCharUTF16>>::Failure {
+            error: ::dafny_runtime::dafny_runtime_conversions::unicode_chars_false::string_to_dafny_string(
+              &e.to_string())
+          })
+      }
+    }
+  }
+}
\ No newline at end of file
diff --git b/TestModels/dafny-dependencies/StandardLibrary/runtimes/rust/src/implementation_from_dafny.rs a/TestModels/dafny-dependencies/StandardLibrary/runtimes/rust/src/implementation_from_dafny.rs
index d2318ad3..a67da67c 100644
--- b/TestModels/dafny-dependencies/StandardLibrary/runtimes/rust/src/implementation_from_dafny.rs
+++ a/TestModels/dafny-dependencies/StandardLibrary/runtimes/rust/src/implementation_from_dafny.rs
@@ -1,497 +1,1071 @@
 #![allow(warnings, unconditional_panic)]
+#![allow(nonstandard_style)]
 extern crate dafny_runtime;
-mod r#_System {
-#[derive(Clone, PartialEq)]
-#[repr(transparent)]
-pub struct r#nat(pub ::dafny_runtime::BigInt);
-impl  ::dafny_runtime::DafnyErasable for r#nat {
-type Erased = ::dafny_runtime::BigInt;
+pub mod _System {
+  pub type nat = ::dafny_runtime::DafnyInt;
+  #[derive(PartialEq, Clone)]
+  pub enum Tuple2<T0: ::dafny_runtime::DafnyType, T1: ::dafny_runtime::DafnyType> {
+    _T2 { _0: T0, _1: T1 },
+    _PhantomVariant(::std::marker::PhantomData<T0>, ::std::marker::PhantomData<T1>)
+  }
+  impl <T0: ::dafny_runtime::DafnyType, T1: ::dafny_runtime::DafnyType>Tuple2<T0, T1> {
+    pub fn _0(&self) -> &T0 {
+      match self {
+        Tuple2::_T2 { _0, _1, } => _0,
+        Tuple2::_PhantomVariant(..) => panic!()
+      }
+    }
+    pub fn _1(&self) -> &T1 {
+      match self {
+        Tuple2::_T2 { _0, _1, } => _1,
+        Tuple2::_PhantomVariant(..) => panic!()
+      }
+    }
+  }
+  impl <T0: ::dafny_runtime::DafnyType, T1: ::dafny_runtime::DafnyType>::std::fmt::Debug for Tuple2<T0, T1> {
+    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> std::fmt::Result {
+      ::dafny_runtime::DafnyPrint::fmt_print(self, f, true)
+    }
+  }
+  impl <T0: ::dafny_runtime::DafnyType, T1: ::dafny_runtime::DafnyType>::dafny_runtime::DafnyPrint for Tuple2<T0, T1> {
+    fn fmt_print(&self, _formatter: &mut ::std::fmt::Formatter, _in_seq: bool) -> std::fmt::Result {
+      match self {
+        Tuple2::_T2 { _0, _1, } => {
+          write!(_formatter, "_System.Tuple2._T2(")?;
+          ::dafny_runtime::DafnyPrint::fmt_print(_0, _formatter, false)?;
+          write!(_formatter, ", ")?;
+          ::dafny_runtime::DafnyPrint::fmt_print(_1, _formatter, false)?;
+          write!(_formatter, ")")?;
+          Ok(())
+        },
+        Tuple2::_PhantomVariant(..) => {panic!()}
+      }
+    }
+  }
+  impl <T0: ::dafny_runtime::DafnyType + Eq, T1: ::dafny_runtime::DafnyType + Eq>Eq for Tuple2<T0, T1> {}
+  impl <T0: ::dafny_runtime::DafnyType + ::std::hash::Hash, T1: ::dafny_runtime::DafnyType + ::std::hash::Hash>::std::hash::Hash for Tuple2<T0, T1> {
+    fn hash<_H: ::std::hash::Hasher>(&self, _state: &mut _H) {
+      match self {
+        Tuple2::_T2 { _0, _1, } => {
+          _0.hash(_state);
+          _1.hash(_state)
+        },
+        Tuple2::_PhantomVariant(..) => {panic!()}
+      }
+    }
+  }
+  impl <T0: ::dafny_runtime::DafnyType + ::std::default::Default, T1: ::dafny_runtime::DafnyType + ::std::default::Default>::std::default::Default for Tuple2<T0, T1> {
+    fn default() -> Tuple2<T0, T1> {
+      Tuple2::_T2 {
+        _0: ::std::default::Default::default(),
+        _1: ::std::default::Default::default()
+      }
+    }
+  }
+  impl <T0: ::dafny_runtime::DafnyType + ::std::default::Default, T1: ::dafny_runtime::DafnyType + ::std::default::Default>::std::convert::AsRef<Tuple2<T0, T1>> for &Tuple2<T0, T1> {
+    fn as_ref(&self) -> Self {
+      self
+    }
+  }
+  #[derive(PartialEq, Clone)]
+  pub enum Tuple0 {
+    _T0 {}
+  }
+  impl Tuple0 {}
+  impl ::std::fmt::Debug for Tuple0 {
+    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> std::fmt::Result {
+      ::dafny_runtime::DafnyPrint::fmt_print(self, f, true)
+    }
+  }
+  impl ::dafny_runtime::DafnyPrint for Tuple0 {
+    fn fmt_print(&self, _formatter: &mut ::std::fmt::Formatter, _in_seq: bool) -> std::fmt::Result {
+      match self {
+        Tuple0::_T0 { } => {
+          write!(_formatter, "_System.Tuple0._T0")?;
+          Ok(())
+        }
+      }
+    }
+  }
+  impl Eq for Tuple0 {}
+  impl ::std::hash::Hash for Tuple0 {
+    fn hash<_H: ::std::hash::Hasher>(&self, _state: &mut _H) {
+      match self {
+        Tuple0::_T0 { } => {
+          
+        }
+      }
+    }
+  }
+  impl ::std::default::Default for Tuple0 {
+    fn default() -> Tuple0 {
+      Tuple0::_T0 {}
+    }
+  }
+  impl ::std::convert::AsRef<Tuple0> for &Tuple0 {
+    fn as_ref(&self) -> Self {
+      self
+    }
+  }
+}
+pub mod r#_Wrappers_Compile {
+  pub struct _default {}
+  impl _default {
+    pub fn new() -> Self {
+      _default {}
+    }
+    pub fn _allocated() -> *mut Self {
+      ::dafny_runtime::allocate::<Self>()
+    }
+    pub fn Need<_E: ::dafny_runtime::DafnyType>(condition: bool, error: &_E) -> ::std::rc::Rc<super::r#_Wrappers_Compile::Outcome<_E>> {
+      if condition {
+        ::std::rc::Rc::new(super::r#_Wrappers_Compile::Outcome::<_E>::Pass {})
+      } else {
+        ::std::rc::Rc::new(super::r#_Wrappers_Compile::Outcome::<_E>::Fail {
+            error: error.clone()
+          })
+      }
+    }
+  }
+  impl ::std::default::Default for _default {
+    fn default() -> Self {
+      _default::new()
+    }
+  }
+  impl ::dafny_runtime::DafnyPrint for _default {
+    fn fmt_print(&self, _formatter: &mut ::std::fmt::Formatter, _in_seq: bool) -> std::fmt::Result {
+      write!(_formatter, "Wrappers_Compile.__default")
+    }
+  }
+  impl ::std::cmp::PartialEq for _default {
+    fn eq(&self, other: &Self) -> bool {
+      ::std::ptr::eq(self, other)
+    }
+  }
+  #[derive(PartialEq, Clone)]
+  pub enum Option<T: ::dafny_runtime::DafnyType> {
+    None {},
+    Some { value: T },
+    _PhantomVariant(::std::marker::PhantomData<T>)
+  }
+  impl <T: ::dafny_runtime::DafnyType>Option<T> {
+    pub fn ToResult(self: &::std::rc::Rc<Self>) -> ::std::rc::Rc<super::r#_Wrappers_Compile::Result<T, ::dafny_runtime::Sequence<::dafny_runtime::DafnyCharUTF16>>> {
+      let mut _source0: ::std::rc::Rc<super::r#_Wrappers_Compile::Option<T>> = self.clone();
+      if matches!((&_source0).as_ref(), super::r#_Wrappers_Compile::Option::None{ .. }) {
+        ::std::rc::Rc::new(super::r#_Wrappers_Compile::Result::<T, ::dafny_runtime::Sequence<::dafny_runtime::DafnyCharUTF16>>::Failure {
+            error: ::dafny_runtime::string_utf16_of("Option is None")
+          })
+      } else {
+        let mut r#___mcc_h0: T = _source0.value().clone();
+        let mut v: T = r#___mcc_h0.clone();
+        ::std::rc::Rc::new(super::r#_Wrappers_Compile::Result::<T, ::dafny_runtime::Sequence<::dafny_runtime::DafnyCharUTF16>>::Success {
+            value: v.clone()
+          })
+      }
+    }
+    pub fn UnwrapOr(self: &::std::rc::Rc<Self>, default: &T) -> T {
+      let mut _source1: ::std::rc::Rc<super::r#_Wrappers_Compile::Option<T>> = self.clone();
+      if matches!((&_source1).as_ref(), super::r#_Wrappers_Compile::Option::None{ .. }) {
+        default.clone()
+      } else {
+        let mut r#___mcc_h0: T = _source1.value().clone();
+        let mut v: T = r#___mcc_h0.clone();
+        v.clone()
+      }
+    }
+    pub fn IsFailure(self: &::std::rc::Rc<Self>) -> bool {
+      matches!(self.as_ref(), super::r#_Wrappers_Compile::Option::None{ .. })
+    }
+    pub fn PropagateFailure<_U: ::dafny_runtime::DafnyType>(self: &::std::rc::Rc<Self>) -> ::std::rc::Rc<super::r#_Wrappers_Compile::Option<_U>> {
+      ::std::rc::Rc::new(super::r#_Wrappers_Compile::Option::<_U>::None {})
+    }
+    pub fn Extract(self: &::std::rc::Rc<Self>) -> T {
+      self.value().clone()
+    }
+    pub fn value(&self) -> &T {
+      match self {
+        Option::None { } => panic!("field does not exist on this variant"),
+        Option::Some { value, } => value,
+        Option::_PhantomVariant(..) => panic!()
+      }
+    }
+  }
+  impl <T: ::dafny_runtime::DafnyType>::std::fmt::Debug for Option<T> {
+    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> std::fmt::Result {
+      ::dafny_runtime::DafnyPrint::fmt_print(self, f, true)
+    }
+  }
+  impl <T: ::dafny_runtime::DafnyType>::dafny_runtime::DafnyPrint for Option<T> {
+    fn fmt_print(&self, _formatter: &mut ::std::fmt::Formatter, _in_seq: bool) -> std::fmt::Result {
+      match self {
+        Option::None { } => {
+          write!(_formatter, "Wrappers_Compile.Option.None")?;
+          Ok(())
+        },
+        Option::Some { value, } => {
+          write!(_formatter, "Wrappers_Compile.Option.Some(")?;
+          ::dafny_runtime::DafnyPrint::fmt_print(value, _formatter, false)?;
+          write!(_formatter, ")")?;
+          Ok(())
+        },
+        Option::_PhantomVariant(..) => {panic!()}
+      }
+    }
+  }
+  impl <T: ::dafny_runtime::DafnyType + Eq>Eq for Option<T> {}
+  impl <T: ::dafny_runtime::DafnyType + ::std::hash::Hash>::std::hash::Hash for Option<T> {
+    fn hash<_H: ::std::hash::Hasher>(&self, _state: &mut _H) {
+      match self {
+        Option::None { } => {
+          
+        },
+        Option::Some { value, } => {
+          value.hash(_state)
+        },
+        Option::_PhantomVariant(..) => {panic!()}
+      }
+    }
+  }
+  impl <T: ::dafny_runtime::DafnyType + ::std::default::Default>::std::default::Default for Option<T> {
+    fn default() -> Option<T> {
+      Option::None {}
+    }
+  }
+  impl <T: ::dafny_runtime::DafnyType + ::std::default::Default>::std::convert::AsRef<Option<T>> for &Option<T> {
+    fn as_ref(&self) -> Self {
+      self
+    }
+  }
+  #[derive(PartialEq, Clone)]
+  pub enum Result<T: ::dafny_runtime::DafnyType, R: ::dafny_runtime::DafnyType> {
+    Success { value: T },
+    Failure { error: R },
+    _PhantomVariant(::std::marker::PhantomData<T>, ::std::marker::PhantomData<R>)
+  }
+  impl <T: ::dafny_runtime::DafnyType, R: ::dafny_runtime::DafnyType>Result<T, R> {
+    pub fn ToOption(self: &::std::rc::Rc<Self>) -> ::std::rc::Rc<super::r#_Wrappers_Compile::Option<T>> {
+      let mut _source2: ::std::rc::Rc<super::r#_Wrappers_Compile::Result<T, R>> = self.clone();
+      if matches!((&_source2).as_ref(), super::r#_Wrappers_Compile::Result::Success{ .. }) {
+        let mut r#___mcc_h0: T = _source2.value().clone();
+        let mut s: T = r#___mcc_h0.clone();
+        ::std::rc::Rc::new(super::r#_Wrappers_Compile::Option::<T>::Some {
+            value: s.clone()
+          })
+      } else {
+        let mut r#___mcc_h1: R = _source2.error().clone();
+        let mut e: R = r#___mcc_h1.clone();
+        ::std::rc::Rc::new(super::r#_Wrappers_Compile::Option::<T>::None {})
+      }
+    }
+    pub fn UnwrapOr(self: &::std::rc::Rc<Self>, default: &T) -> T {
+      let mut _source3: ::std::rc::Rc<super::r#_Wrappers_Compile::Result<T, R>> = self.clone();
+      if matches!((&_source3).as_ref(), super::r#_Wrappers_Compile::Result::Success{ .. }) {
+        let mut r#___mcc_h0: T = _source3.value().clone();
+        let mut s: T = r#___mcc_h0.clone();
+        s.clone()
+      } else {
+        let mut r#___mcc_h1: R = _source3.error().clone();
+        let mut e: R = r#___mcc_h1.clone();
+        default.clone()
+      }
+    }
+    pub fn IsFailure(self: &::std::rc::Rc<Self>) -> bool {
+      matches!(self.as_ref(), super::r#_Wrappers_Compile::Result::Failure{ .. })
+    }
+    pub fn PropagateFailure<_U: ::dafny_runtime::DafnyType>(self: &::std::rc::Rc<Self>) -> ::std::rc::Rc<super::r#_Wrappers_Compile::Result<_U, R>> {
+      ::std::rc::Rc::new(super::r#_Wrappers_Compile::Result::<_U, R>::Failure {
+          error: self.error().clone()
+        })
+    }
+    pub fn MapFailure<_NewR: ::dafny_runtime::DafnyType>(self: &::std::rc::Rc<Self>, reWrap: &::std::rc::Rc<dyn ::std::ops::Fn(&R) -> _NewR>) -> ::std::rc::Rc<super::r#_Wrappers_Compile::Result<T, _NewR>> {
+      let mut _source4: ::std::rc::Rc<super::r#_Wrappers_Compile::Result<T, R>> = self.clone();
+      if matches!((&_source4).as_ref(), super::r#_Wrappers_Compile::Result::Success{ .. }) {
+        let mut r#___mcc_h0: T = _source4.value().clone();
+        let mut s: T = r#___mcc_h0.clone();
+        ::std::rc::Rc::new(super::r#_Wrappers_Compile::Result::<T, _NewR>::Success {
+            value: s.clone()
+          })
+      } else {
+        let mut r#___mcc_h1: R = _source4.error().clone();
+        let mut e: R = r#___mcc_h1.clone();
+        ::std::rc::Rc::new(super::r#_Wrappers_Compile::Result::<T, _NewR>::Failure {
+            error: reWrap(&e)
+          })
+      }
+    }
+    pub fn Extract(self: &::std::rc::Rc<Self>) -> T {
+      self.value().clone()
+    }
+    pub fn value(&self) -> &T {
+      match self {
+        Result::Success { value, } => value,
+        Result::Failure { error, } => panic!("field does not exist on this variant"),
+        Result::_PhantomVariant(..) => panic!()
+      }
+    }
+    pub fn error(&self) -> &R {
+      match self {
+        Result::Success { value, } => panic!("field does not exist on this variant"),
+        Result::Failure { error, } => error,
+        Result::_PhantomVariant(..) => panic!()
+      }
+    }
+  }
+  impl <T: ::dafny_runtime::DafnyType, R: ::dafny_runtime::DafnyType>::std::fmt::Debug for Result<T, R> {
+    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> std::fmt::Result {
+      ::dafny_runtime::DafnyPrint::fmt_print(self, f, true)
+    }
+  }
+  impl <T: ::dafny_runtime::DafnyType, R: ::dafny_runtime::DafnyType>::dafny_runtime::DafnyPrint for Result<T, R> {
+    fn fmt_print(&self, _formatter: &mut ::std::fmt::Formatter, _in_seq: bool) -> std::fmt::Result {
+      match self {
+        Result::Success { value, } => {
+          write!(_formatter, "Wrappers_Compile.Result.Success(")?;
+          ::dafny_runtime::DafnyPrint::fmt_print(value, _formatter, false)?;
+          write!(_formatter, ")")?;
+          Ok(())
+        },
+        Result::Failure { error, } => {
+          write!(_formatter, "Wrappers_Compile.Result.Failure(")?;
+          ::dafny_runtime::DafnyPrint::fmt_print(error, _formatter, false)?;
+          write!(_formatter, ")")?;
+          Ok(())
+        },
+        Result::_PhantomVariant(..) => {panic!()}
+      }
+    }
+  }
+  impl <T: ::dafny_runtime::DafnyType + Eq, R: ::dafny_runtime::DafnyType + Eq>Eq for Result<T, R> {}
+  impl <T: ::dafny_runtime::DafnyType + ::std::hash::Hash, R: ::dafny_runtime::DafnyType + ::std::hash::Hash>::std::hash::Hash for Result<T, R> {
+    fn hash<_H: ::std::hash::Hasher>(&self, _state: &mut _H) {
+      match self {
+        Result::Success { value, } => {
+          value.hash(_state)
+        },
+        Result::Failure { error, } => {
+          error.hash(_state)
+        },
+        Result::_PhantomVariant(..) => {panic!()}
+      }
+    }
+  }
+  impl <T: ::dafny_runtime::DafnyType + ::std::default::Default, R: ::dafny_runtime::DafnyType + ::std::default::Default>::std::default::Default for Result<T, R> {
+    fn default() -> Result<T, R> {
+      Result::Success {
+        value: ::std::default::Default::default()
+      }
+    }
+  }
+  impl <T: ::dafny_runtime::DafnyType + ::std::default::Default, R: ::dafny_runtime::DafnyType + ::std::default::Default>::std::convert::AsRef<Result<T, R>> for &Result<T, R> {
+    fn as_ref(&self) -> Self {
+      self
+    }
+  }
+  #[derive(PartialEq, Clone)]
+  pub enum Outcome<E: ::dafny_runtime::DafnyType> {
+    Pass {},
+    Fail { error: E },
+    _PhantomVariant(::std::marker::PhantomData<E>)
+  }
+  impl <E: ::dafny_runtime::DafnyType>Outcome<E> {
+    pub fn IsFailure(self: &::std::rc::Rc<Self>) -> bool {
+      matches!(self.as_ref(), super::r#_Wrappers_Compile::Outcome::Fail{ .. })
+    }
+    pub fn PropagateFailure<_U: ::dafny_runtime::DafnyType>(self: &::std::rc::Rc<Self>) -> ::std::rc::Rc<super::r#_Wrappers_Compile::Result<_U, E>> {
+      ::std::rc::Rc::new(super::r#_Wrappers_Compile::Result::<_U, E>::Failure {
+          error: self.error().clone()
+        })
+    }
+    pub fn error(&self) -> &E {
+      match self {
+        Outcome::Pass { } => panic!("field does not exist on this variant"),
+        Outcome::Fail { error, } => error,
+        Outcome::_PhantomVariant(..) => panic!()
+      }
+    }
+  }
+  impl <E: ::dafny_runtime::DafnyType>::std::fmt::Debug for Outcome<E> {
+    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> std::fmt::Result {
+      ::dafny_runtime::DafnyPrint::fmt_print(self, f, true)
+    }
+  }
+  impl <E: ::dafny_runtime::DafnyType>::dafny_runtime::DafnyPrint for Outcome<E> {
+    fn fmt_print(&self, _formatter: &mut ::std::fmt::Formatter, _in_seq: bool) -> std::fmt::Result {
+      match self {
+        Outcome::Pass { } => {
+          write!(_formatter, "Wrappers_Compile.Outcome.Pass")?;
+          Ok(())
+        },
+        Outcome::Fail { error, } => {
+          write!(_formatter, "Wrappers_Compile.Outcome.Fail(")?;
+          ::dafny_runtime::DafnyPrint::fmt_print(error, _formatter, false)?;
+          write!(_formatter, ")")?;
+          Ok(())
+        },
+        Outcome::_PhantomVariant(..) => {panic!()}
+      }
+    }
+  }
+  impl <E: ::dafny_runtime::DafnyType + Eq>Eq for Outcome<E> {}
+  impl <E: ::dafny_runtime::DafnyType + ::std::hash::Hash>::std::hash::Hash for Outcome<E> {
+    fn hash<_H: ::std::hash::Hasher>(&self, _state: &mut _H) {
+      match self {
+        Outcome::Pass { } => {
+          
+        },
+        Outcome::Fail { error, } => {
+          error.hash(_state)
+        },
+        Outcome::_PhantomVariant(..) => {panic!()}
+      }
+    }
+  }
+  impl <E: ::dafny_runtime::DafnyType + ::std::default::Default>::std::default::Default for Outcome<E> {
+    fn default() -> Outcome<E> {
+      Outcome::Pass {}
+    }
+  }
+  impl <E: ::dafny_runtime::DafnyType + ::std::default::Default>::std::convert::AsRef<Outcome<E>> for &Outcome<E> {
+    fn as_ref(&self) -> Self {
+      self
+    }
+  }
+}
+pub mod r#_StandardLibrary_Compile_dUInt_Compile {
+  pub struct _default {}
+  impl _default {
+    pub fn new() -> Self {
+      _default {}
+    }
+    pub fn _allocated() -> *mut Self {
+      ::dafny_runtime::allocate::<Self>()
+    }
+    pub fn UInt8Less(a: u8, b: u8) -> bool {
+      a < b
+    }
+    pub fn HasUint16Len<_T: ::dafny_runtime::DafnyType>(s: &::dafny_runtime::Sequence<_T>) -> bool {
+      s.cardinality() < super::r#_StandardLibrary_Compile_dUInt_Compile::_default::UINT16_LIMIT()
+    }
+    pub fn HasUint32Len<_T: ::dafny_runtime::DafnyType>(s: &::dafny_runtime::Sequence<_T>) -> bool {
+      s.cardinality() < super::r#_StandardLibrary_Compile_dUInt_Compile::_default::UINT32_LIMIT()
+    }
+    pub fn HasUint64Len<_T: ::dafny_runtime::DafnyType>(s: &::dafny_runtime::Sequence<_T>) -> bool {
+      s.cardinality() < super::r#_StandardLibrary_Compile_dUInt_Compile::_default::UINT64_LIMIT()
+    }
+    pub fn UInt16ToSeq(x: u16) -> ::dafny_runtime::Sequence<u8> {
+      let mut b0: u8 = (x / 256) as u8;
+      let mut b1: u8 = (x % 256) as u8;
+      ::dafny_runtime::seq![b0, b1]
+    }
+    pub fn SeqToUInt16(s: &::dafny_runtime::Sequence<u8>) -> u16 {
+      let mut x0: u16 = s.get(&::dafny_runtime::int!(0)) as u16 * 256;
+      x0 + s.get(&::dafny_runtime::int!(1)) as u16
+    }
+    pub fn UInt32ToSeq(x: u32) -> ::dafny_runtime::Sequence<u8> {
+      let mut b0: u8 = (x / 16777216) as u8;
+      let mut x0: u32 = x - b0 as u32 * 16777216;
+      let mut b1: u8 = (x0 / 65536) as u8;
+      let mut x1: u32 = x0 - b1 as u32 * 65536;
+      let mut b2: u8 = (x1 / 256) as u8;
+      let mut b3: u8 = (x1 % 256) as u8;
+      ::dafny_runtime::seq![b0, b1, b2, b3]
+    }
+    pub fn SeqToUInt32(s: &::dafny_runtime::Sequence<u8>) -> u32 {
+      let mut x0: u32 = s.get(&::dafny_runtime::int!(0)) as u32 * 16777216;
+      let mut x1: u32 = x0 + s.get(&::dafny_runtime::int!(1)) as u32 * 65536;
+      let mut x2: u32 = x1 + s.get(&::dafny_runtime::int!(2)) as u32 * 256;
+      x2 + s.get(&::dafny_runtime::int!(3)) as u32
+    }
+    pub fn UInt64ToSeq(x: u64) -> ::dafny_runtime::Sequence<u8> {
+      let mut b0: u8 = (x / 72057594037927936) as u8;
+      let mut x0: u64 = x - b0 as u64 * 72057594037927936;
+      let mut b1: u8 = (x0 / 281474976710656) as u8;
+      let mut x1: u64 = x0 - b1 as u64 * 281474976710656;
+      let mut b2: u8 = (x1 / 1099511627776) as u8;
+      let mut x2: u64 = x1 - b2 as u64 * 1099511627776;
+      let mut b3: u8 = (x2 / 4294967296) as u8;
+      let mut x3: u64 = x2 - b3 as u64 * 4294967296;
+      let mut b4: u8 = (x3 / 16777216) as u8;
+      let mut x4: u64 = x3 - b4 as u64 * 16777216;
+      let mut b5: u8 = (x4 / 65536) as u8;
+      let mut x5: u64 = x4 - b5 as u64 * 65536;
+      let mut b6: u8 = (x5 / 256) as u8;
+      let mut b7: u8 = (x5 % 256) as u8;
+      ::dafny_runtime::seq![b0, b1, b2, b3, b4, b5, b6, b7]
+    }
+    pub fn SeqToUInt64(s: &::dafny_runtime::Sequence<u8>) -> u64 {
+      let mut x0: u64 = s.get(&::dafny_runtime::int!(0)) as u64 * 72057594037927936;
+      let mut x1: u64 = x0 + s.get(&::dafny_runtime::int!(1)) as u64 * 281474976710656;
+      let mut x2: u64 = x1 + s.get(&::dafny_runtime::int!(2)) as u64 * 1099511627776;
+      let mut x3: u64 = x2 + s.get(&::dafny_runtime::int!(3)) as u64 * 4294967296;
+      let mut x4: u64 = x3 + s.get(&::dafny_runtime::int!(4)) as u64 * 16777216;
+      let mut x5: u64 = x4 + s.get(&::dafny_runtime::int!(5)) as u64 * 65536;
+      let mut x6: u64 = x5 + s.get(&::dafny_runtime::int!(6)) as u64 * 256;
+      let mut x: u64 = x6 + s.get(&::dafny_runtime::int!(7)) as u64;
+      x
+    }
+    pub fn UINT16_LIMIT() -> ::dafny_runtime::DafnyInt {
+      ::dafny_runtime::int!(b"65536")
+    }
+    pub fn UINT32_LIMIT() -> ::dafny_runtime::DafnyInt {
+      ::dafny_runtime::int!(b"4294967296")
+    }
+    pub fn UINT64_LIMIT() -> ::dafny_runtime::DafnyInt {
+      ::dafny_runtime::int!(b"18446744073709551616")
+    }
+    pub fn INT32_MAX_LIMIT() -> ::dafny_runtime::DafnyInt {
+      ::dafny_runtime::int!(b"2147483648")
+    }
+    pub fn INT64_MAX_LIMIT() -> ::dafny_runtime::DafnyInt {
+      ::dafny_runtime::int!(b"9223372036854775808")
+    }
+  }
+  impl ::std::default::Default for _default {
+    fn default() -> Self {
+      _default::new()
+    }
+  }
+  impl ::dafny_runtime::DafnyPrint for _default {
+    fn fmt_print(&self, _formatter: &mut ::std::fmt::Formatter, _in_seq: bool) -> std::fmt::Result {
+      write!(_formatter, "StandardLibrary_Compile.UInt_Compile.__default")
+    }
+  }
+  impl ::std::cmp::PartialEq for _default {
+    fn eq(&self, other: &Self) -> bool {
+      ::std::ptr::eq(self, other)
+    }
+  }
+  #[derive(Clone, PartialEq)]
+  #[repr(transparent)]
+  pub struct uint8(pub u8);
+  impl ::std::default::Default for uint8 {
+    fn default() -> Self {
+      uint8(::std::default::Default::default())
+    }
+  }
+  impl ::dafny_runtime::DafnyPrint for uint8 {
+    fn fmt_print(&self, _formatter: &mut ::std::fmt::Formatter, in_seq: bool) -> ::std::fmt::Result {
+      ::dafny_runtime::DafnyPrint::fmt_print(&self.0, _formatter, in_seq)
+    }
+  }
+  impl ::std::ops::Deref for uint8 {
+    type Target = u8;
+    fn deref(&self) -> &Self::Target {
+      &self.0
+    }
+  }
+  #[derive(Clone, PartialEq)]
+  #[repr(transparent)]
+  pub struct uint16(pub u16);
+  impl ::std::default::Default for uint16 {
+    fn default() -> Self {
+      uint16(::std::default::Default::default())
+    }
+  }
+  impl ::dafny_runtime::DafnyPrint for uint16 {
+    fn fmt_print(&self, _formatter: &mut ::std::fmt::Formatter, in_seq: bool) -> ::std::fmt::Result {
+      ::dafny_runtime::DafnyPrint::fmt_print(&self.0, _formatter, in_seq)
+    }
+  }
+  impl ::std::ops::Deref for uint16 {
+    type Target = u16;
+    fn deref(&self) -> &Self::Target {
+      &self.0
+    }
+  }
+  #[derive(Clone, PartialEq)]
+  #[repr(transparent)]
+  pub struct uint32(pub u32);
+  impl ::std::default::Default for uint32 {
+    fn default() -> Self {
+      uint32(::std::default::Default::default())
+    }
+  }
+  impl ::dafny_runtime::DafnyPrint for uint32 {
+    fn fmt_print(&self, _formatter: &mut ::std::fmt::Formatter, in_seq: bool) -> ::std::fmt::Result {
+      ::dafny_runtime::DafnyPrint::fmt_print(&self.0, _formatter, in_seq)
+    }
+  }
+  impl ::std::ops::Deref for uint32 {
+    type Target = u32;
+    fn deref(&self) -> &Self::Target {
+      &self.0
+    }
+  }
+  #[derive(Clone, PartialEq)]
+  #[repr(transparent)]
+  pub struct uint64(pub u64);
+  impl ::std::default::Default for uint64 {
+    fn default() -> Self {
+      uint64(::std::default::Default::default())
+    }
+  }
+  impl ::dafny_runtime::DafnyPrint for uint64 {
+    fn fmt_print(&self, _formatter: &mut ::std::fmt::Formatter, in_seq: bool) -> ::std::fmt::Result {
+      ::dafny_runtime::DafnyPrint::fmt_print(&self.0, _formatter, in_seq)
+    }
+  }
+  impl ::std::ops::Deref for uint64 {
+    type Target = u64;
+    fn deref(&self) -> &Self::Target {
+      &self.0
+    }
+  }
+  #[derive(Clone, PartialEq)]
+  #[repr(transparent)]
+  pub struct int32(pub i32);
+  impl ::std::default::Default for int32 {
+    fn default() -> Self {
+      int32(::std::default::Default::default())
+    }
+  }
+  impl ::dafny_runtime::DafnyPrint for int32 {
+    fn fmt_print(&self, _formatter: &mut ::std::fmt::Formatter, in_seq: bool) -> ::std::fmt::Result {
+      ::dafny_runtime::DafnyPrint::fmt_print(&self.0, _formatter, in_seq)
+    }
+  }
+  impl ::std::ops::Deref for int32 {
+    type Target = i32;
+    fn deref(&self) -> &Self::Target {
+      &self.0
+    }
+  }
+  #[derive(Clone, PartialEq)]
+  #[repr(transparent)]
+  pub struct int64(pub i64);
+  impl ::std::default::Default for int64 {
+    fn default() -> Self {
+      int64(::std::default::Default::default())
+    }
+  }
+  impl ::dafny_runtime::DafnyPrint for int64 {
+    fn fmt_print(&self, _formatter: &mut ::std::fmt::Formatter, in_seq: bool) -> ::std::fmt::Result {
+      ::dafny_runtime::DafnyPrint::fmt_print(&self.0, _formatter, in_seq)
+    }
+  }
+  impl ::std::ops::Deref for int64 {
+    type Target = i64;
+    fn deref(&self) -> &Self::Target {
+      &self.0
+    }
+  }
+  #[derive(Clone, PartialEq)]
+  #[repr(transparent)]
+  pub struct posInt64(pub u64);
+  impl ::std::default::Default for posInt64 {
+    fn default() -> Self {
+      posInt64(1)
+    }
+  }
+  impl ::dafny_runtime::DafnyPrint for posInt64 {
+    fn fmt_print(&self, _formatter: &mut ::std::fmt::Formatter, in_seq: bool) -> ::std::fmt::Result {
+      ::dafny_runtime::DafnyPrint::fmt_print(&self.0, _formatter, in_seq)
+    }
+  }
+  impl ::std::ops::Deref for posInt64 {
+    type Target = u64;
+    fn deref(&self) -> &Self::Target {
+      &self.0
+    }
+  }
+  pub type seq16<T: ::dafny_runtime::DafnyType> = ::dafny_runtime::Sequence<T>;
+  pub type seq32<T: ::dafny_runtime::DafnyType> = ::dafny_runtime::Sequence<T>;
+  pub type seq64<T: ::dafny_runtime::DafnyType> = ::dafny_runtime::Sequence<T>;
+}
+pub mod r#_StandardLibrary_Compile {
+  pub struct _default {}
+  impl _default {
+    pub fn new() -> Self {
+      _default {}
+    }
+    pub fn _allocated() -> *mut Self {
+      ::dafny_runtime::allocate::<Self>()
+    }
+    pub fn Join<_T: ::dafny_runtime::DafnyType>(ss: &::dafny_runtime::Sequence<::dafny_runtime::Sequence<_T>>, joiner: &::dafny_runtime::Sequence<_T>) -> ::dafny_runtime::Sequence<_T> {
+      let mut _accumulator: ::dafny_runtime::Sequence<_T> = ::dafny_runtime::seq![] as ::dafny_runtime::Sequence<_T>;
+      let mut ss = ss.clone();
+      let mut joiner = joiner.clone();
+      let mut _accumulator = _accumulator.clone();
+      'TAIL_CALL_START: loop {
+        if ss.cardinality() == ::dafny_runtime::int!(1) {
+          return _accumulator.concat(&ss.get(&::dafny_runtime::int!(0)));
+        } else {
+          _accumulator = _accumulator.concat(&ss.get(&::dafny_runtime::int!(0)).concat(&joiner));
+          let mut _in0: ::dafny_runtime::Sequence<::dafny_runtime::Sequence<_T>> = ss.drop(&::dafny_runtime::int!(1));
+          let mut _in1: ::dafny_runtime::Sequence<_T> = joiner.clone();
+          ss = _in0.clone();
+          joiner = _in1.clone();
+          continue 'TAIL_CALL_START;
+        }
+      }
+    }
+    pub fn Split<_T: ::dafny_runtime::DafnyTypeEq>(s: &::dafny_runtime::Sequence<_T>, delim: &_T) -> ::dafny_runtime::Sequence<::dafny_runtime::Sequence<_T>> {
+      let mut _accumulator: ::dafny_runtime::Sequence<::dafny_runtime::Sequence<_T>> = ::dafny_runtime::seq![] as ::dafny_runtime::Sequence<::dafny_runtime::Sequence<_T>>;
+      let mut s = s.clone();
+      let mut delim = delim.clone();
+      let mut _accumulator = _accumulator.clone();
+      'TAIL_CALL_START: loop {
+        let mut i: ::std::rc::Rc<super::r#_Wrappers_Compile::Option<super::_System::nat>> = super::r#_StandardLibrary_Compile::_default::FindIndexMatching::<_T>(&s, &delim, &::dafny_runtime::int!(0));
+        if matches!((&i).as_ref(), super::r#_Wrappers_Compile::Option::Some{ .. }) {
+          _accumulator = _accumulator.concat(&::dafny_runtime::seq![s.take(i.value())]);
+          let mut _in2: ::dafny_runtime::Sequence<_T> = s.drop(&(i.value().clone() + ::dafny_runtime::int!(1)));
+          let mut _in3: _T = delim.clone();
+          s = _in2.clone();
+          delim = _in3.clone();
+          continue 'TAIL_CALL_START;
+        } else {
+          return _accumulator.concat(&::dafny_runtime::seq![s.clone()]);
+        }
+      }
+    }
+    pub fn SplitOnce<_T: ::dafny_runtime::DafnyTypeEq>(s: &::dafny_runtime::Sequence<_T>, delim: &_T) -> (::dafny_runtime::Sequence<_T>, ::dafny_runtime::Sequence<_T>) {
+      let mut i: ::std::rc::Rc<super::r#_Wrappers_Compile::Option<super::_System::nat>> = super::r#_StandardLibrary_Compile::_default::FindIndexMatching::<_T>(s, delim, &::dafny_runtime::int!(0));
+      (s.take(i.value()), s.drop(&(i.value().clone() + ::dafny_runtime::int!(1))),)
+    }
+    pub fn r#_SplitOnce_q<_T: ::dafny_runtime::DafnyTypeEq>(s: &::dafny_runtime::Sequence<_T>, delim: &_T) -> ::std::rc::Rc<super::r#_Wrappers_Compile::Option<(::dafny_runtime::Sequence<_T>, ::dafny_runtime::Sequence<_T>)>> {
+      let mut valueOrError0: ::std::rc::Rc<super::r#_Wrappers_Compile::Option<super::_System::nat>> = super::r#_StandardLibrary_Compile::_default::FindIndexMatching::<_T>(s, delim, &::dafny_runtime::int!(0));
+      if valueOrError0.IsFailure() {
+        (valueOrError0.PropagateFailure::<(::dafny_runtime::Sequence<_T>, ::dafny_runtime::Sequence<_T>)>()/* <i>Coercion from ::std::rc::Rc<super::r#_Wrappers_Compile::Option<_U>> to ::std::rc::Rc<super::r#_Wrappers_Compile::Option<(::dafny_runtime::Sequence<_T>, ::dafny_runtime::Sequence<_T>)>></i> not yet implemented */)
+      } else {
+        let mut i: super::_System::nat = (valueOrError0.Extract()/* <i>Coercion from T to ::dafny_runtime::DafnyInt</i> not yet implemented */);
+        ::std::rc::Rc::new(super::r#_Wrappers_Compile::Option::<(::dafny_runtime::Sequence<_T>, ::dafny_runtime::Sequence<_T>)>::Some {
+            value: (s.take(&i), s.drop(&(i.clone() + ::dafny_runtime::int!(1))),)
+          })
+      }
+    }
+    pub fn FindIndexMatching<_T: ::dafny_runtime::DafnyTypeEq>(s: &::dafny_runtime::Sequence<_T>, c: &_T, i: &super::_System::nat) -> ::std::rc::Rc<super::r#_Wrappers_Compile::Option<super::_System::nat>> {
+      super::r#_StandardLibrary_Compile::_default::FindIndex::<_T>(s, {
+          let c: _T = c.clone();
+          &({
+                  let mut c = c.clone();
+                  ::std::rc::Rc::new(move |x: &_T| -> bool {
+                          x.clone() == c.clone()
+                        })
+                })
+          }, i)
+    }
+    pub fn FindIndex<_T: ::dafny_runtime::DafnyType>(s: &::dafny_runtime::Sequence<_T>, f: &::std::rc::Rc<dyn ::std::ops::Fn(&_T) -> bool>, i: &super::_System::nat) -> ::std::rc::Rc<super::r#_Wrappers_Compile::Option<super::_System::nat>> {
+      let mut s = s.clone();
+      let mut f = f.clone();
+      let mut i = i.clone();
+      'TAIL_CALL_START: loop {
+        if i.clone() == s.cardinality() {
+          return ::std::rc::Rc::new(super::r#_Wrappers_Compile::Option::<super::_System::nat>::None {});
+        } else {
+          if (&f)(&s.get(&i)) {
+            return ::std::rc::Rc::new(super::r#_Wrappers_Compile::Option::<super::_System::nat>::Some {
+                  value: i.clone()
+                });
+          } else {
+            let mut _in4: ::dafny_runtime::Sequence<_T> = s.clone();
+            let mut _in5: ::std::rc::Rc<dyn ::std::ops::Fn(&_T) -> bool> = f.clone();
+            let mut _in6: ::dafny_runtime::DafnyInt = i.clone() + ::dafny_runtime::int!(1);
+            s = _in4.clone();
+            f = _in5.clone();
+            i = _in6.clone();
+            continue 'TAIL_CALL_START;
+          }
+        }
+      }
+    }
+    pub fn Filter<_T: ::dafny_runtime::DafnyType>(s: &::dafny_runtime::Sequence<_T>, f: &::std::rc::Rc<dyn ::std::ops::Fn(&_T) -> bool>) -> ::dafny_runtime::Sequence<_T> {
+      let mut _accumulator: ::dafny_runtime::Sequence<_T> = ::dafny_runtime::seq![] as ::dafny_runtime::Sequence<_T>;
+      let mut s = s.clone();
+      let mut f = f.clone();
+      let mut _accumulator = _accumulator.clone();
+      'TAIL_CALL_START: loop {
+        if s.cardinality() == ::dafny_runtime::int!(0) {
+          return _accumulator.concat(&(::dafny_runtime::seq![] as ::dafny_runtime::Sequence<_T>));
+        } else {
+          if (&f)(&s.get(&::dafny_runtime::int!(0))) {
+            _accumulator = _accumulator.concat(&::dafny_runtime::seq![s.get(&::dafny_runtime::int!(0))]);
+            let mut _in7: ::dafny_runtime::Sequence<_T> = s.drop(&::dafny_runtime::int!(1));
+            let mut _in8: ::std::rc::Rc<dyn ::std::ops::Fn(&_T) -> bool> = f.clone();
+            s = _in7.clone();
+            f = _in8.clone();
+            continue 'TAIL_CALL_START;
+          } else {
+            let mut _in9: ::dafny_runtime::Sequence<_T> = s.drop(&::dafny_runtime::int!(1));
+            let mut _in10: ::std::rc::Rc<dyn ::std::ops::Fn(&_T) -> bool> = f.clone();
+            s = _in9.clone();
+            f = _in10.clone();
+            continue 'TAIL_CALL_START;
+          }
+        }
+      }
+    }
+    pub fn Min(a: &::dafny_runtime::DafnyInt, b: &::dafny_runtime::DafnyInt) -> ::dafny_runtime::DafnyInt {
+      if a.clone() < b.clone() {
+        a.clone()
+      } else {
+        b.clone()
+      }
+    }
+    pub fn Fill<_T: ::dafny_runtime::DafnyType>(value: &_T, n: &super::_System::nat) -> ::dafny_runtime::Sequence<_T> {
+      {
+        let _initializer = {
+              let value: _T = value.clone();
+              {
+                      let mut value = value.clone();
+                      ::std::rc::Rc::new(move |_v0: &::dafny_runtime::DafnyInt| -> _T {
+                                  value.clone()
+                                })
+                    }
+              };
+        ::dafny_runtime::integer_range(::dafny_runtime::Zero::zero(), n.clone()).map(|i| _initializer(&i)).collect::<::dafny_runtime::Sequence<_>>()
+        }
+    }
+    pub fn SeqToArray<_T: ::dafny_runtime::DafnyType>(s: &::dafny_runtime::Sequence<_T>) -> *mut [_T] {
+      let mut _init0: ::std::rc::Rc<dyn ::std::ops::Fn(&::dafny_runtime::DafnyInt) -> _T> = {
+          let s: ::dafny_runtime::Sequence<_T> = s.clone();
+          ({
+                    let s = s.clone();
+                    ::std::rc::Rc::new(move |i: &::dafny_runtime::DafnyInt| -> _T {
+                            s.get(i)
+                            })})
+          };
+      ::dafny_runtime::array::initialize(&s.cardinality(), _init0)
+    }
+    pub fn LexicographicLessOrEqual<_T: ::dafny_runtime::DafnyTypeEq>(a: &::dafny_runtime::Sequence<_T>, b: &::dafny_runtime::Sequence<_T>, less: &::std::rc::Rc<dyn ::std::ops::Fn(&_T, &_T) -> bool>) -> bool {
+      Self::LexicographicLessOrEqualAux(a, b, less, &::dafny_runtime::int!(0))
+    }
+    pub fn LexicographicLessOrEqualAux<_T: ::dafny_runtime::DafnyTypeEq>(a: &::dafny_runtime::Sequence<_T>, b: &::dafny_runtime::Sequence<_T>, less: &::std::rc::Rc<dyn ::std::ops::Fn(&_T, &_T) -> bool>, lengthOfCommonPrefix: &super::_System::nat) -> bool {
+      lengthOfCommonPrefix.clone() <= b.cardinality() && ::dafny_runtime::Forall::forall(&::dafny_runtime::Range(::dafny_runtime::int!(0), lengthOfCommonPrefix.clone()), {
+        let a = a.clone();
+        let b = b.clone();
+        ::std::rc::Rc::new(move |i| a.get(i) == b.get(i))}) && (lengthOfCommonPrefix.clone() == a.cardinality() || lengthOfCommonPrefix.clone() < b.cardinality() && ((less(&a.get(lengthOfCommonPrefix), &b.get(lengthOfCommonPrefix)))))
+    }
+    pub fn SetToOrderedSequence<_T: ::dafny_runtime::DafnyTypeEq>(s: &::dafny_runtime::Set<::dafny_runtime::Sequence<_T>>, less: &::std::rc::Rc<dyn ::std::ops::Fn(&_T, &_T) -> bool>) -> ::dafny_runtime::Sequence<::dafny_runtime::Sequence<_T>> {
+      let mut _accumulator: ::dafny_runtime::Sequence<::dafny_runtime::Sequence<_T>> = ::dafny_runtime::seq![] as ::dafny_runtime::Sequence<::dafny_runtime::Sequence<_T>>;
+      let mut s = s.clone();
+      let mut less = less.clone();
+      let mut _accumulator = _accumulator.clone();
+      'TAIL_CALL_START: loop {
+        if s.clone() == ::dafny_runtime::set!{} {
+          return _accumulator.concat(&(::dafny_runtime::seq![] as ::dafny_runtime::Sequence<::dafny_runtime::Sequence<_T>>));
+        } else {
+          return (&({
+              let mut s = s.clone();
+              let mut less = less.clone();
+              ::std::rc::Rc::new(move |r#__let_dummy_0: &::dafny_runtime::DafnyInt| -> ::dafny_runtime::Sequence<::dafny_runtime::Sequence<_T>> {
+                  let mut a = ::dafny_runtime::MaybePlacebo::<::dafny_runtime::Sequence<_T>>::new();
+                  'label_goto__ASSIGN_SUCH_THAT_0: loop {
+                    for r#__assign_such_that_0 in (&s).iter() {
+                      a = ::dafny_runtime::MaybePlacebo::from(r#__assign_such_that_0.clone());
+                      if s.contains(&a.read()) && super::r#_StandardLibrary_Compile::_default::IsMinimum::<_T>(&a.read(), &s, &less) {
+                        break 'label_goto__ASSIGN_SUCH_THAT_0;
+                      }
+                    };
+                    panic!("Halt");
+                    break;
+                  };
+                  ::dafny_runtime::seq![a.read()].concat(&super::r#_StandardLibrary_Compile::_default::SetToOrderedSequence::<_T>(&s.subtract(&::dafny_runtime::set!{a.read()}), &less))
+                })
+            }))(&::dafny_runtime::int!(0));
+        }
+      }
+    }
+    pub fn IsMinimum<_T: ::dafny_runtime::DafnyTypeEq>(a: &::dafny_runtime::Sequence<_T>, s: &::dafny_runtime::Set<::dafny_runtime::Sequence<_T>>, less: &::std::rc::Rc<dyn ::std::ops::Fn(&_T, &_T) -> bool>) -> bool {
+      s.contains(a) && 
+      ::dafny_runtime::Forall::forall(s, {
+        let a = a.clone();
+        let less = less.clone();
+        ::std::rc::Rc::new(move |z| Self::LexicographicLessOrEqual(&a, z, &less))
+      })
+    }
+  }
+  impl ::std::default::Default for _default {
+    fn default() -> Self {
+      _default::new()
+    }
+  }
+  impl ::dafny_runtime::DafnyPrint for _default {
+    fn fmt_print(&self, _formatter: &mut ::std::fmt::Formatter, _in_seq: bool) -> std::fmt::Result {
+      write!(_formatter, "StandardLibrary_Compile.__default")
+    }
+  }
+  impl ::std::cmp::PartialEq for _default {
+    fn eq(&self, other: &Self) -> bool {
+      ::std::ptr::eq(self, other)
+    }
+  }
 }
-impl  ::dafny_runtime::DafnyUnerasable<::dafny_runtime::BigInt> for r#nat {}
-impl  ::dafny_runtime::DafnyUnerasable<r#nat> for r#nat {}
-impl  ::std::default::Default for r#nat {
-fn default() -> Self {
-r#nat(::std::default::Default::default())
-}
-}
-impl  ::dafny_runtime::DafnyPrint for r#nat {
-fn fmt_print(&self, __fmt_print_formatter: &mut ::std::fmt::Formatter, in_seq: bool) -> ::std::fmt::Result {
-::dafny_runtime::DafnyPrint::fmt_print(&self.0, __fmt_print_formatter, in_seq)
-}
-}
-impl  ::std::ops::Deref for r#nat {
-type Target = ::dafny_runtime::BigInt;
-fn deref(&self) -> &Self::Target {
-&self.0
-}
-}
-
-#[derive(PartialEq)]
-pub enum r#Tuple2<r#T0, r#T1, > {
-r#___hMake2 { r#_0: r#T0, r#_1: r#T1, },
-_PhantomVariant(::std::marker::PhantomData::<r#T0>, ::std::marker::PhantomData::<r#T1>)
-}
-impl <r#T0: ::dafny_runtime::DafnyErasable + ::dafny_runtime::DafnyUnerasable<r#T0> + Clone + ::dafny_runtime::DafnyPrint + ::std::default::Default + 'static, r#T1: ::dafny_runtime::DafnyErasable + ::dafny_runtime::DafnyUnerasable<r#T1> + Clone + ::dafny_runtime::DafnyPrint + ::std::default::Default + 'static, > r#Tuple2<r#T0, r#T1, > where <r#T0 as ::dafny_runtime::DafnyErasable>::Erased: ::std::cmp::PartialEq, <r#T1 as ::dafny_runtime::DafnyErasable>::Erased: ::std::cmp::PartialEq,  {
-pub fn r#_0(&self) -> &r#T0 {
-match self {
-r#Tuple2::r#___hMake2 { r#_0, r#_1, } => r#_0,
-r#Tuple2::_PhantomVariant(..) => panic!(),
-}
-}
-pub fn r#_1(&self) -> &r#T1 {
-match self {
-r#Tuple2::r#___hMake2 { r#_0, r#_1, } => r#_1,
-r#Tuple2::_PhantomVariant(..) => panic!(),
-}
-}
-
-}
-impl <r#T0: ::dafny_runtime::DafnyErasable + ::dafny_runtime::DafnyUnerasable<r#T0> + Clone + ::dafny_runtime::DafnyPrint + ::std::default::Default + 'static, r#T1: ::dafny_runtime::DafnyErasable + ::dafny_runtime::DafnyUnerasable<r#T1> + Clone + ::dafny_runtime::DafnyPrint + ::std::default::Default + 'static, > ::dafny_runtime::DafnyErasable for r#Tuple2<r#T0, r#T1, > {
-type Erased = r#Tuple2<r#T0::Erased, r#T1::Erased, >;
-}
-impl <r#T0__Erased, r#T0: ::dafny_runtime::DafnyErasable + ::dafny_runtime::DafnyUnerasable<r#T0> + Clone + ::dafny_runtime::DafnyPrint + ::std::default::Default + ::dafny_runtime::DafnyUnerasable<r#T0__Erased> + 'static, r#T1__Erased, r#T1: ::dafny_runtime::DafnyErasable + ::dafny_runtime::DafnyUnerasable<r#T1> + Clone + ::dafny_runtime::DafnyPrint + ::std::default::Default + ::dafny_runtime::DafnyUnerasable<r#T1__Erased> + 'static, > ::dafny_runtime::DafnyUnerasable<r#Tuple2<r#T0__Erased, r#T1__Erased, >> for r#Tuple2<r#T0, r#T1, > {}
-
-impl <r#T0: ::dafny_runtime::DafnyErasable + ::dafny_runtime::DafnyUnerasable<r#T0> + Clone + ::dafny_runtime::DafnyPrint + ::std::default::Default + 'static, r#T1: ::dafny_runtime::DafnyErasable + ::dafny_runtime::DafnyUnerasable<r#T1> + Clone + ::dafny_runtime::DafnyPrint + ::std::default::Default + 'static, > ::dafny_runtime::DafnyPrint for r#Tuple2<r#T0, r#T1, > {
-fn fmt_print(&self, __fmt_print_formatter: &mut ::std::fmt::Formatter, _in_seq: bool) -> std::fmt::Result {
-match self {
-r#Tuple2::r#___hMake2 { r#_0, r#_1, } => {
-write!(__fmt_print_formatter, "_System.Tuple2.___hMake2(")?;
-::dafny_runtime::DafnyPrint::fmt_print(r#_0, __fmt_print_formatter, false)?;
-write!(__fmt_print_formatter, ", ")?;
-::dafny_runtime::DafnyPrint::fmt_print(r#_1, __fmt_print_formatter, false)?;
-write!(__fmt_print_formatter, ")")?;
-Ok(())
-}
-r#Tuple2::_PhantomVariant(..) => {panic!()
-}
-}
-}
-}
-
-impl <r#T0: ::dafny_runtime::DafnyErasable + ::dafny_runtime::DafnyUnerasable<r#T0> + Clone + ::dafny_runtime::DafnyPrint + ::std::default::Default + 'static, r#T1: ::dafny_runtime::DafnyErasable + ::dafny_runtime::DafnyUnerasable<r#T1> + Clone + ::dafny_runtime::DafnyPrint + ::std::default::Default + 'static, > ::std::default::Default for r#Tuple2<r#T0, r#T1, > {
-fn default() -> Self {
-r#Tuple2::r#___hMake2 {
-r#_0: ::std::default::Default::default(),
-r#_1: ::std::default::Default::default(),
-}
-}
-}
-
-#[derive(PartialEq)]
-pub enum r#Tuple0 {
-r#___hMake0 { },
-
-}
-impl  r#Tuple0 {
-
-}
-impl  ::dafny_runtime::DafnyErasable for r#Tuple0 {
-type Erased = r#Tuple0;
-}
-impl  ::dafny_runtime::DafnyUnerasable<r#Tuple0> for r#Tuple0 {}
-
-impl  ::dafny_runtime::DafnyPrint for r#Tuple0 {
-fn fmt_print(&self, __fmt_print_formatter: &mut ::std::fmt::Formatter, _in_seq: bool) -> std::fmt::Result {
-match self {
-r#Tuple0::r#___hMake0 { } => {
-write!(__fmt_print_formatter, "_System.Tuple0.___hMake0")?;
-Ok(())
-}
-}
-}
-}
-
-impl  ::std::default::Default for r#Tuple0 {
-fn default() -> Self {
-r#Tuple0::r#___hMake0 {
-}
-}
-}
-
-}
-mod r#StandardLibrary_Compile_UInt_Compile {
-pub struct r#__default {
-
-}
-impl  r#__default {
-pub fn new() -> Self {
-r#__default {
-
-}
-}
-pub fn r#UInt8Less(r#a: &super::r#StandardLibrary_Compile_UInt_Compile::r#uint8, r#b: &super::r#StandardLibrary_Compile_UInt_Compile::r#uint8) -> bool {
-::dafny_runtime::DafnyUnerasable::<_>::unerase_owned(::dafny_runtime::DafnyErasable::erase_owned((::dafny_runtime::DafnyErasable::erase_owned(r#a.clone()) < ::dafny_runtime::DafnyErasable::erase_owned(r#b.clone()))))
-}
-
-pub fn r#HasUint16Len<r#__T: ::dafny_runtime::DafnyErasable + ::dafny_runtime::DafnyUnerasable<r#__T> + Clone + ::dafny_runtime::DafnyPrint + ::std::default::Default + 'static>(r#s: &::std::vec::Vec<r#__T>) -> bool where <r#__T as ::dafny_runtime::DafnyErasable>::Erased: ::std::cmp::PartialEq {
-::dafny_runtime::DafnyUnerasable::<_>::unerase_owned(::dafny_runtime::DafnyErasable::erase_owned((::dafny_runtime::BigInt::from((::dafny_runtime::DafnyErasable::erase(r#s)).len()) < ::dafny_runtime::DafnyErasable::erase_owned(super::r#StandardLibrary_Compile_UInt_Compile::r#__default::r#UINT16__LIMIT()))))
-}
-
-pub fn r#HasUint32Len<r#__T: ::dafny_runtime::DafnyErasable + ::dafny_runtime::DafnyUnerasable<r#__T> + Clone + ::dafny_runtime::DafnyPrint + ::std::default::Default + 'static>(r#s: &::std::vec::Vec<r#__T>) -> bool where <r#__T as ::dafny_runtime::DafnyErasable>::Erased: ::std::cmp::PartialEq {
-::dafny_runtime::DafnyUnerasable::<_>::unerase_owned(::dafny_runtime::DafnyErasable::erase_owned((::dafny_runtime::BigInt::from((::dafny_runtime::DafnyErasable::erase(r#s)).len()) < ::dafny_runtime::DafnyErasable::erase_owned(super::r#StandardLibrary_Compile_UInt_Compile::r#__default::r#UINT32__LIMIT()))))
-}
-
-pub fn r#HasUint64Len<r#__T: ::dafny_runtime::DafnyErasable + ::dafny_runtime::DafnyUnerasable<r#__T> + Clone + ::dafny_runtime::DafnyPrint + ::std::default::Default + 'static>(r#s: &::std::vec::Vec<r#__T>) -> bool where <r#__T as ::dafny_runtime::DafnyErasable>::Erased: ::std::cmp::PartialEq {
-::dafny_runtime::DafnyUnerasable::<_>::unerase_owned(::dafny_runtime::DafnyErasable::erase_owned((::dafny_runtime::BigInt::from((::dafny_runtime::DafnyErasable::erase(r#s)).len()) < ::dafny_runtime::DafnyErasable::erase_owned(super::r#StandardLibrary_Compile_UInt_Compile::r#__default::r#UINT64__LIMIT()))))
-}
-
-pub fn r#UInt16ToSeq(r#x: &super::r#StandardLibrary_Compile_UInt_Compile::r#uint16) -> ::std::vec::Vec<super::r#StandardLibrary_Compile_UInt_Compile::r#uint8> {
-let mut r#_0_b0: super::r#StandardLibrary_Compile_UInt_Compile::r#uint8 = <super::r#StandardLibrary_Compile_UInt_Compile::r#uint8 as ::dafny_runtime::DafnyUnerasable<_>>::unerase_owned(::dafny_runtime::DafnyErasable::erase_owned(<super::r#StandardLibrary_Compile_UInt_Compile::r#uint8 as ::dafny_runtime::DafnyUnerasable<_>>::unerase_owned(::dafny_runtime::DafnyErasable::erase_owned((::dafny_runtime::DafnyErasable::erase_owned(r#x.clone())) / (::dafny_runtime::DafnyErasable::erase_owned(<super::r#StandardLibrary_Compile_UInt_Compile::r#uint16 as ::dafny_runtime::DafnyUnerasable<_>>::unerase_owned(::dafny_runtime::BigInt::parse_bytes(b"256", 10).unwrap())))))));
-let mut r#_1_b1: super::r#StandardLibrary_Compile_UInt_Compile::r#uint8 = <super::r#StandardLibrary_Compile_UInt_Compile::r#uint8 as ::dafny_runtime::DafnyUnerasable<_>>::unerase_owned(::dafny_runtime::DafnyErasable::erase_owned(<super::r#StandardLibrary_Compile_UInt_Compile::r#uint8 as ::dafny_runtime::DafnyUnerasable<_>>::unerase_owned(::dafny_runtime::DafnyErasable::erase_owned((::dafny_runtime::DafnyErasable::erase_owned(r#x.clone())) % (::dafny_runtime::DafnyErasable::erase_owned(<super::r#StandardLibrary_Compile_UInt_Compile::r#uint16 as ::dafny_runtime::DafnyUnerasable<_>>::unerase_owned(::dafny_runtime::BigInt::parse_bytes(b"256", 10).unwrap())))))));
-::dafny_runtime::DafnyUnerasable::<_>::unerase_owned(::dafny_runtime::DafnyErasable::erase_owned((vec![(&r#_0_b0).clone(), (&r#_1_b1).clone()] as Vec<super::r#StandardLibrary_Compile_UInt_Compile::r#uint8>)))
-}
-
-pub fn r#SeqToUInt16(r#s: &::std::vec::Vec<super::r#StandardLibrary_Compile_UInt_Compile::r#uint8>) -> super::r#StandardLibrary_Compile_UInt_Compile::r#uint16 {
-let mut r#_2_x0: super::r#StandardLibrary_Compile_UInt_Compile::r#uint16 = <super::r#StandardLibrary_Compile_UInt_Compile::r#uint16 as ::dafny_runtime::DafnyUnerasable<_>>::unerase_owned((::dafny_runtime::DafnyErasable::erase_owned(<super::r#StandardLibrary_Compile_UInt_Compile::r#uint16 as ::dafny_runtime::DafnyUnerasable<_>>::unerase_owned(::dafny_runtime::DafnyErasable::erase_owned(((r#s)[<usize as ::dafny_runtime::NumCast>::from(::dafny_runtime::DafnyErasable::erase_owned(::dafny_runtime::BigInt::parse_bytes(b"0", 10).unwrap())).unwrap()]).clone()))) * ::dafny_runtime::DafnyErasable::erase_owned(<super::r#StandardLibrary_Compile_UInt_Compile::r#uint16 as ::dafny_runtime::DafnyUnerasable<_>>::unerase_owned(::dafny_runtime::BigInt::parse_bytes(b"256", 10).unwrap()))));
-::dafny_runtime::DafnyUnerasable::<_>::unerase_owned(::dafny_runtime::DafnyErasable::erase_owned((::dafny_runtime::DafnyErasable::erase_owned((&r#_2_x0).clone()) + ::dafny_runtime::DafnyErasable::erase_owned(<super::r#StandardLibrary_Compile_UInt_Compile::r#uint16 as ::dafny_runtime::DafnyUnerasable<_>>::unerase_owned(::dafny_runtime::DafnyErasable::erase_owned(((r#s)[<usize as ::dafny_runtime::NumCast>::from(::dafny_runtime::DafnyErasable::erase_owned(::dafny_runtime::BigInt::parse_bytes(b"1", 10).unwrap())).unwrap()]).clone()))))))
-}
-
-pub fn r#UInt32ToSeq(r#x: &super::r#StandardLibrary_Compile_UInt_Compile::r#uint32) -> ::std::vec::Vec<super::r#StandardLibrary_Compile_UInt_Compile::r#uint8> {
-let mut r#_3_b0: super::r#StandardLibrary_Compile_UInt_Compile::r#uint8 = <super::r#StandardLibrary_Compile_UInt_Compile::r#uint8 as ::dafny_runtime::DafnyUnerasable<_>>::unerase_owned(::dafny_runtime::DafnyErasable::erase_owned(<super::r#StandardLibrary_Compile_UInt_Compile::r#uint8 as ::dafny_runtime::DafnyUnerasable<_>>::unerase_owned(::dafny_runtime::DafnyErasable::erase_owned((::dafny_runtime::DafnyErasable::erase_owned(r#x.clone())) / (::dafny_runtime::DafnyErasable::erase_owned(<super::r#StandardLibrary_Compile_UInt_Compile::r#uint32 as ::dafny_runtime::DafnyUnerasable<_>>::unerase_owned(::dafny_runtime::BigInt::parse_bytes(b"16777216", 10).unwrap())))))));
-let mut r#_4_x0: super::r#StandardLibrary_Compile_UInt_Compile::r#uint32 = <super::r#StandardLibrary_Compile_UInt_Compile::r#uint32 as ::dafny_runtime::DafnyUnerasable<_>>::unerase_owned((::dafny_runtime::DafnyErasable::erase_owned(r#x.clone()) - (::dafny_runtime::DafnyErasable::erase_owned(<super::r#StandardLibrary_Compile_UInt_Compile::r#uint32 as ::dafny_runtime::DafnyUnerasable<_>>::unerase_owned(::dafny_runtime::DafnyErasable::erase_owned((&r#_3_b0).clone()))) * ::dafny_runtime::DafnyErasable::erase_owned(<super::r#StandardLibrary_Compile_UInt_Compile::r#uint32 as ::dafny_runtime::DafnyUnerasable<_>>::unerase_owned(::dafny_runtime::BigInt::parse_bytes(b"16777216", 10).unwrap())))));
-let mut r#_5_b1: super::r#StandardLibrary_Compile_UInt_Compile::r#uint8 = <super::r#StandardLibrary_Compile_UInt_Compile::r#uint8 as ::dafny_runtime::DafnyUnerasable<_>>::unerase_owned(::dafny_runtime::DafnyErasable::erase_owned(<super::r#StandardLibrary_Compile_UInt_Compile::r#uint8 as ::dafny_runtime::DafnyUnerasable<_>>::unerase_owned(::dafny_runtime::DafnyErasable::erase_owned((::dafny_runtime::DafnyErasable::erase_owned((&r#_4_x0).clone())) / (::dafny_runtime::DafnyErasable::erase_owned(<super::r#StandardLibrary_Compile_UInt_Compile::r#uint32 as ::dafny_runtime::DafnyUnerasable<_>>::unerase_owned(::dafny_runtime::BigInt::parse_bytes(b"65536", 10).unwrap())))))));
-let mut r#_6_x1: super::r#StandardLibrary_Compile_UInt_Compile::r#uint32 = <super::r#StandardLibrary_Compile_UInt_Compile::r#uint32 as ::dafny_runtime::DafnyUnerasable<_>>::unerase_owned((::dafny_runtime::DafnyErasable::erase_owned((&r#_4_x0).clone()) - (::dafny_runtime::DafnyErasable::erase_owned(<super::r#StandardLibrary_Compile_UInt_Compile::r#uint32 as ::dafny_runtime::DafnyUnerasable<_>>::unerase_owned(::dafny_runtime::DafnyErasable::erase_owned((&r#_5_b1).clone()))) * ::dafny_runtime::DafnyErasable::erase_owned(<super::r#StandardLibrary_Compile_UInt_Compile::r#uint32 as ::dafny_runtime::DafnyUnerasable<_>>::unerase_owned(::dafny_runtime::BigInt::parse_bytes(b"65536", 10).unwrap())))));
-let mut r#_7_b2: super::r#StandardLibrary_Compile_UInt_Compile::r#uint8 = <super::r#StandardLibrary_Compile_UInt_Compile::r#uint8 as ::dafny_runtime::DafnyUnerasable<_>>::unerase_owned(::dafny_runtime::DafnyErasable::erase_owned(<super::r#StandardLibrary_Compile_UInt_Compile::r#uint8 as ::dafny_runtime::DafnyUnerasable<_>>::unerase_owned(::dafny_runtime::DafnyErasable::erase_owned((::dafny_runtime::DafnyErasable::erase_owned((&r#_6_x1).clone())) / (::dafny_runtime::DafnyErasable::erase_owned(<super::r#StandardLibrary_Compile_UInt_Compile::r#uint32 as ::dafny_runtime::DafnyUnerasable<_>>::unerase_owned(::dafny_runtime::BigInt::parse_bytes(b"256", 10).unwrap())))))));
-let mut r#_8_b3: super::r#StandardLibrary_Compile_UInt_Compile::r#uint8 = <super::r#StandardLibrary_Compile_UInt_Compile::r#uint8 as ::dafny_runtime::DafnyUnerasable<_>>::unerase_owned(::dafny_runtime::DafnyErasable::erase_owned(<super::r#StandardLibrary_Compile_UInt_Compile::r#uint8 as ::dafny_runtime::DafnyUnerasable<_>>::unerase_owned(::dafny_runtime::DafnyErasable::erase_owned((::dafny_runtime::DafnyErasable::erase_owned((&r#_6_x1).clone())) % (::dafny_runtime::DafnyErasable::erase_owned(<super::r#StandardLibrary_Compile_UInt_Compile::r#uint32 as ::dafny_runtime::DafnyUnerasable<_>>::unerase_owned(::dafny_runtime::BigInt::parse_bytes(b"256", 10).unwrap())))))));
-::dafny_runtime::DafnyUnerasable::<_>::unerase_owned(::dafny_runtime::DafnyErasable::erase_owned((vec![(&r#_3_b0).clone(), (&r#_5_b1).clone(), (&r#_7_b2).clone(), (&r#_8_b3).clone()] as Vec<super::r#StandardLibrary_Compile_UInt_Compile::r#uint8>)))
-}
-
-pub fn r#SeqToUInt32(r#s: &::std::vec::Vec<super::r#StandardLibrary_Compile_UInt_Compile::r#uint8>) -> super::r#StandardLibrary_Compile_UInt_Compile::r#uint32 {
-let mut r#_9_x0: super::r#StandardLibrary_Compile_UInt_Compile::r#uint32 = <super::r#StandardLibrary_Compile_UInt_Compile::r#uint32 as ::dafny_runtime::DafnyUnerasable<_>>::unerase_owned((::dafny_runtime::DafnyErasable::erase_owned(<super::r#StandardLibrary_Compile_UInt_Compile::r#uint32 as ::dafny_runtime::DafnyUnerasable<_>>::unerase_owned(::dafny_runtime::DafnyErasable::erase_owned(((r#s)[<usize as ::dafny_runtime::NumCast>::from(::dafny_runtime::DafnyErasable::erase_owned(::dafny_runtime::BigInt::parse_bytes(b"0", 10).unwrap())).unwrap()]).clone()))) * ::dafny_runtime::DafnyErasable::erase_owned(<super::r#StandardLibrary_Compile_UInt_Compile::r#uint32 as ::dafny_runtime::DafnyUnerasable<_>>::unerase_owned(::dafny_runtime::BigInt::parse_bytes(b"16777216", 10).unwrap()))));
-let mut r#_10_x1: super::r#StandardLibrary_Compile_UInt_Compile::r#uint32 = <super::r#StandardLibrary_Compile_UInt_Compile::r#uint32 as ::dafny_runtime::DafnyUnerasable<_>>::unerase_owned((::dafny_runtime::DafnyErasable::erase_owned((&r#_9_x0).clone()) + (::dafny_runtime::DafnyErasable::erase_owned(<super::r#StandardLibrary_Compile_UInt_Compile::r#uint32 as ::dafny_runtime::DafnyUnerasable<_>>::unerase_owned(::dafny_runtime::DafnyErasable::erase_owned(((r#s)[<usize as ::dafny_runtime::NumCast>::from(::dafny_runtime::DafnyErasable::erase_owned(::dafny_runtime::BigInt::parse_bytes(b"1", 10).unwrap())).unwrap()]).clone()))) * ::dafny_runtime::DafnyErasable::erase_owned(<super::r#StandardLibrary_Compile_UInt_Compile::r#uint32 as ::dafny_runtime::DafnyUnerasable<_>>::unerase_owned(::dafny_runtime::BigInt::parse_bytes(b"65536", 10).unwrap())))));
-let mut r#_11_x2: super::r#StandardLibrary_Compile_UInt_Compile::r#uint32 = <super::r#StandardLibrary_Compile_UInt_Compile::r#uint32 as ::dafny_runtime::DafnyUnerasable<_>>::unerase_owned((::dafny_runtime::DafnyErasable::erase_owned((&r#_10_x1).clone()) + (::dafny_runtime::DafnyErasable::erase_owned(<super::r#StandardLibrary_Compile_UInt_Compile::r#uint32 as ::dafny_runtime::DafnyUnerasable<_>>::unerase_owned(::dafny_runtime::DafnyErasable::erase_owned(((r#s)[<usize as ::dafny_runtime::NumCast>::from(::dafny_runtime::DafnyErasable::erase_owned(::dafny_runtime::BigInt::parse_bytes(b"2", 10).unwrap())).unwrap()]).clone()))) * ::dafny_runtime::DafnyErasable::erase_owned(<super::r#StandardLibrary_Compile_UInt_Compile::r#uint32 as ::dafny_runtime::DafnyUnerasable<_>>::unerase_owned(::dafny_runtime::BigInt::parse_bytes(b"256", 10).unwrap())))));
-::dafny_runtime::DafnyUnerasable::<_>::unerase_owned(::dafny_runtime::DafnyErasable::erase_owned((::dafny_runtime::DafnyErasable::erase_owned((&r#_11_x2).clone()) + ::dafny_runtime::DafnyErasable::erase_owned(<super::r#StandardLibrary_Compile_UInt_Compile::r#uint32 as ::dafny_runtime::DafnyUnerasable<_>>::unerase_owned(::dafny_runtime::DafnyErasable::erase_owned(((r#s)[<usize as ::dafny_runtime::NumCast>::from(::dafny_runtime::DafnyErasable::erase_owned(::dafny_runtime::BigInt::parse_bytes(b"3", 10).unwrap())).unwrap()]).clone()))))))
-}
-
-pub fn r#UInt64ToSeq(r#x: &super::r#StandardLibrary_Compile_UInt_Compile::r#uint64) -> ::std::vec::Vec<super::r#StandardLibrary_Compile_UInt_Compile::r#uint8> {
-let mut r#_12_b0: super::r#StandardLibrary_Compile_UInt_Compile::r#uint8 = <super::r#StandardLibrary_Compile_UInt_Compile::r#uint8 as ::dafny_runtime::DafnyUnerasable<_>>::unerase_owned(::dafny_runtime::DafnyErasable::erase_owned(<super::r#StandardLibrary_Compile_UInt_Compile::r#uint8 as ::dafny_runtime::DafnyUnerasable<_>>::unerase_owned(::dafny_runtime::DafnyErasable::erase_owned((::dafny_runtime::DafnyErasable::erase_owned(r#x.clone())) / (::dafny_runtime::DafnyErasable::erase_owned(<super::r#StandardLibrary_Compile_UInt_Compile::r#uint64 as ::dafny_runtime::DafnyUnerasable<_>>::unerase_owned(::dafny_runtime::BigInt::parse_bytes(b"72057594037927936", 10).unwrap())))))));
-let mut r#_13_x0: super::r#StandardLibrary_Compile_UInt_Compile::r#uint64 = <super::r#StandardLibrary_Compile_UInt_Compile::r#uint64 as ::dafny_runtime::DafnyUnerasable<_>>::unerase_owned((::dafny_runtime::DafnyErasable::erase_owned(r#x.clone()) - (::dafny_runtime::DafnyErasable::erase_owned(<super::r#StandardLibrary_Compile_UInt_Compile::r#uint64 as ::dafny_runtime::DafnyUnerasable<_>>::unerase_owned(::dafny_runtime::DafnyErasable::erase_owned((&r#_12_b0).clone()))) * ::dafny_runtime::DafnyErasable::erase_owned(<super::r#StandardLibrary_Compile_UInt_Compile::r#uint64 as ::dafny_runtime::DafnyUnerasable<_>>::unerase_owned(::dafny_runtime::BigInt::parse_bytes(b"72057594037927936", 10).unwrap())))));
-let mut r#_14_b1: super::r#StandardLibrary_Compile_UInt_Compile::r#uint8 = <super::r#StandardLibrary_Compile_UInt_Compile::r#uint8 as ::dafny_runtime::DafnyUnerasable<_>>::unerase_owned(::dafny_runtime::DafnyErasable::erase_owned(<super::r#StandardLibrary_Compile_UInt_Compile::r#uint8 as ::dafny_runtime::DafnyUnerasable<_>>::unerase_owned(::dafny_runtime::DafnyErasable::erase_owned((::dafny_runtime::DafnyErasable::erase_owned((&r#_13_x0).clone())) / (::dafny_runtime::DafnyErasable::erase_owned(<super::r#StandardLibrary_Compile_UInt_Compile::r#uint64 as ::dafny_runtime::DafnyUnerasable<_>>::unerase_owned(::dafny_runtime::BigInt::parse_bytes(b"281474976710656", 10).unwrap())))))));
-let mut r#_15_x1: super::r#StandardLibrary_Compile_UInt_Compile::r#uint64 = <super::r#StandardLibrary_Compile_UInt_Compile::r#uint64 as ::dafny_runtime::DafnyUnerasable<_>>::unerase_owned((::dafny_runtime::DafnyErasable::erase_owned((&r#_13_x0).clone()) - (::dafny_runtime::DafnyErasable::erase_owned(<super::r#StandardLibrary_Compile_UInt_Compile::r#uint64 as ::dafny_runtime::DafnyUnerasable<_>>::unerase_owned(::dafny_runtime::DafnyErasable::erase_owned((&r#_14_b1).clone()))) * ::dafny_runtime::DafnyErasable::erase_owned(<super::r#StandardLibrary_Compile_UInt_Compile::r#uint64 as ::dafny_runtime::DafnyUnerasable<_>>::unerase_owned(::dafny_runtime::BigInt::parse_bytes(b"281474976710656", 10).unwrap())))));
-let mut r#_16_b2: super::r#StandardLibrary_Compile_UInt_Compile::r#uint8 = <super::r#StandardLibrary_Compile_UInt_Compile::r#uint8 as ::dafny_runtime::DafnyUnerasable<_>>::unerase_owned(::dafny_runtime::DafnyErasable::erase_owned(<super::r#StandardLibrary_Compile_UInt_Compile::r#uint8 as ::dafny_runtime::DafnyUnerasable<_>>::unerase_owned(::dafny_runtime::DafnyErasable::erase_owned((::dafny_runtime::DafnyErasable::erase_owned((&r#_15_x1).clone())) / (::dafny_runtime::DafnyErasable::erase_owned(<super::r#StandardLibrary_Compile_UInt_Compile::r#uint64 as ::dafny_runtime::DafnyUnerasable<_>>::unerase_owned(::dafny_runtime::BigInt::parse_bytes(b"1099511627776", 10).unwrap())))))));
-let mut r#_17_x2: super::r#StandardLibrary_Compile_UInt_Compile::r#uint64 = <super::r#StandardLibrary_Compile_UInt_Compile::r#uint64 as ::dafny_runtime::DafnyUnerasable<_>>::unerase_owned((::dafny_runtime::DafnyErasable::erase_owned((&r#_15_x1).clone()) - (::dafny_runtime::DafnyErasable::erase_owned(<super::r#StandardLibrary_Compile_UInt_Compile::r#uint64 as ::dafny_runtime::DafnyUnerasable<_>>::unerase_owned(::dafny_runtime::DafnyErasable::erase_owned((&r#_16_b2).clone()))) * ::dafny_runtime::DafnyErasable::erase_owned(<super::r#StandardLibrary_Compile_UInt_Compile::r#uint64 as ::dafny_runtime::DafnyUnerasable<_>>::unerase_owned(::dafny_runtime::BigInt::parse_bytes(b"1099511627776", 10).unwrap())))));
-let mut r#_18_b3: super::r#StandardLibrary_Compile_UInt_Compile::r#uint8 = <super::r#StandardLibrary_Compile_UInt_Compile::r#uint8 as ::dafny_runtime::DafnyUnerasable<_>>::unerase_owned(::dafny_runtime::DafnyErasable::erase_owned(<super::r#StandardLibrary_Compile_UInt_Compile::r#uint8 as ::dafny_runtime::DafnyUnerasable<_>>::unerase_owned(::dafny_runtime::DafnyErasable::erase_owned((::dafny_runtime::DafnyErasable::erase_owned((&r#_17_x2).clone())) / (::dafny_runtime::DafnyErasable::erase_owned(<super::r#StandardLibrary_Compile_UInt_Compile::r#uint64 as ::dafny_runtime::DafnyUnerasable<_>>::unerase_owned(::dafny_runtime::BigInt::parse_bytes(b"4294967296", 10).unwrap())))))));
-let mut r#_19_x3: super::r#StandardLibrary_Compile_UInt_Compile::r#uint64 = <super::r#StandardLibrary_Compile_UInt_Compile::r#uint64 as ::dafny_runtime::DafnyUnerasable<_>>::unerase_owned((::dafny_runtime::DafnyErasable::erase_owned((&r#_17_x2).clone()) - (::dafny_runtime::DafnyErasable::erase_owned(<super::r#StandardLibrary_Compile_UInt_Compile::r#uint64 as ::dafny_runtime::DafnyUnerasable<_>>::unerase_owned(::dafny_runtime::DafnyErasable::erase_owned((&r#_18_b3).clone()))) * ::dafny_runtime::DafnyErasable::erase_owned(<super::r#StandardLibrary_Compile_UInt_Compile::r#uint64 as ::dafny_runtime::DafnyUnerasable<_>>::unerase_owned(::dafny_runtime::BigInt::parse_bytes(b"4294967296", 10).unwrap())))));
-let mut r#_20_b4: super::r#StandardLibrary_Compile_UInt_Compile::r#uint8 = <super::r#StandardLibrary_Compile_UInt_Compile::r#uint8 as ::dafny_runtime::DafnyUnerasable<_>>::unerase_owned(::dafny_runtime::DafnyErasable::erase_owned(<super::r#StandardLibrary_Compile_UInt_Compile::r#uint8 as ::dafny_runtime::DafnyUnerasable<_>>::unerase_owned(::dafny_runtime::DafnyErasable::erase_owned((::dafny_runtime::DafnyErasable::erase_owned((&r#_19_x3).clone())) / (::dafny_runtime::DafnyErasable::erase_owned(<super::r#StandardLibrary_Compile_UInt_Compile::r#uint64 as ::dafny_runtime::DafnyUnerasable<_>>::unerase_owned(::dafny_runtime::BigInt::parse_bytes(b"16777216", 10).unwrap())))))));
-let mut r#_21_x4: super::r#StandardLibrary_Compile_UInt_Compile::r#uint64 = <super::r#StandardLibrary_Compile_UInt_Compile::r#uint64 as ::dafny_runtime::DafnyUnerasable<_>>::unerase_owned((::dafny_runtime::DafnyErasable::erase_owned((&r#_19_x3).clone()) - (::dafny_runtime::DafnyErasable::erase_owned(<super::r#StandardLibrary_Compile_UInt_Compile::r#uint64 as ::dafny_runtime::DafnyUnerasable<_>>::unerase_owned(::dafny_runtime::DafnyErasable::erase_owned((&r#_20_b4).clone()))) * ::dafny_runtime::DafnyErasable::erase_owned(<super::r#StandardLibrary_Compile_UInt_Compile::r#uint64 as ::dafny_runtime::DafnyUnerasable<_>>::unerase_owned(::dafny_runtime::BigInt::parse_bytes(b"16777216", 10).unwrap())))));
-let mut r#_22_b5: super::r#StandardLibrary_Compile_UInt_Compile::r#uint8 = <super::r#StandardLibrary_Compile_UInt_Compile::r#uint8 as ::dafny_runtime::DafnyUnerasable<_>>::unerase_owned(::dafny_runtime::DafnyErasable::erase_owned(<super::r#StandardLibrary_Compile_UInt_Compile::r#uint8 as ::dafny_runtime::DafnyUnerasable<_>>::unerase_owned(::dafny_runtime::DafnyErasable::erase_owned((::dafny_runtime::DafnyErasable::erase_owned((&r#_21_x4).clone())) / (::dafny_runtime::DafnyErasable::erase_owned(<super::r#StandardLibrary_Compile_UInt_Compile::r#uint64 as ::dafny_runtime::DafnyUnerasable<_>>::unerase_owned(::dafny_runtime::BigInt::parse_bytes(b"65536", 10).unwrap())))))));
-let mut r#_23_x5: super::r#StandardLibrary_Compile_UInt_Compile::r#uint64 = <super::r#StandardLibrary_Compile_UInt_Compile::r#uint64 as ::dafny_runtime::DafnyUnerasable<_>>::unerase_owned((::dafny_runtime::DafnyErasable::erase_owned((&r#_21_x4).clone()) - (::dafny_runtime::DafnyErasable::erase_owned(<super::r#StandardLibrary_Compile_UInt_Compile::r#uint64 as ::dafny_runtime::DafnyUnerasable<_>>::unerase_owned(::dafny_runtime::DafnyErasable::erase_owned((&r#_22_b5).clone()))) * ::dafny_runtime::DafnyErasable::erase_owned(<super::r#StandardLibrary_Compile_UInt_Compile::r#uint64 as ::dafny_runtime::DafnyUnerasable<_>>::unerase_owned(::dafny_runtime::BigInt::parse_bytes(b"65536", 10).unwrap())))));
-let mut r#_24_b6: super::r#StandardLibrary_Compile_UInt_Compile::r#uint8 = <super::r#StandardLibrary_Compile_UInt_Compile::r#uint8 as ::dafny_runtime::DafnyUnerasable<_>>::unerase_owned(::dafny_runtime::DafnyErasable::erase_owned(<super::r#StandardLibrary_Compile_UInt_Compile::r#uint8 as ::dafny_runtime::DafnyUnerasable<_>>::unerase_owned(::dafny_runtime::DafnyErasable::erase_owned((::dafny_runtime::DafnyErasable::erase_owned((&r#_23_x5).clone())) / (::dafny_runtime::DafnyErasable::erase_owned(<super::r#StandardLibrary_Compile_UInt_Compile::r#uint64 as ::dafny_runtime::DafnyUnerasable<_>>::unerase_owned(::dafny_runtime::BigInt::parse_bytes(b"256", 10).unwrap())))))));
-let mut r#_25_b7: super::r#StandardLibrary_Compile_UInt_Compile::r#uint8 = <super::r#StandardLibrary_Compile_UInt_Compile::r#uint8 as ::dafny_runtime::DafnyUnerasable<_>>::unerase_owned(::dafny_runtime::DafnyErasable::erase_owned(<super::r#StandardLibrary_Compile_UInt_Compile::r#uint8 as ::dafny_runtime::DafnyUnerasable<_>>::unerase_owned(::dafny_runtime::DafnyErasable::erase_owned((::dafny_runtime::DafnyErasable::erase_owned((&r#_23_x5).clone())) % (::dafny_runtime::DafnyErasable::erase_owned(<super::r#StandardLibrary_Compile_UInt_Compile::r#uint64 as ::dafny_runtime::DafnyUnerasable<_>>::unerase_owned(::dafny_runtime::BigInt::parse_bytes(b"256", 10).unwrap())))))));
-::dafny_runtime::DafnyUnerasable::<_>::unerase_owned(::dafny_runtime::DafnyErasable::erase_owned((vec![(&r#_12_b0).clone(), (&r#_14_b1).clone(), (&r#_16_b2).clone(), (&r#_18_b3).clone(), (&r#_20_b4).clone(), (&r#_22_b5).clone(), (&r#_24_b6).clone(), (&r#_25_b7).clone()] as Vec<super::r#StandardLibrary_Compile_UInt_Compile::r#uint8>)))
-}
-
-pub fn r#SeqToUInt64(r#s: &::std::vec::Vec<super::r#StandardLibrary_Compile_UInt_Compile::r#uint8>) -> super::r#StandardLibrary_Compile_UInt_Compile::r#uint64 {
-let mut r#_26_x0: super::r#StandardLibrary_Compile_UInt_Compile::r#uint64 = <super::r#StandardLibrary_Compile_UInt_Compile::r#uint64 as ::dafny_runtime::DafnyUnerasable<_>>::unerase_owned((::dafny_runtime::DafnyErasable::erase_owned(<super::r#StandardLibrary_Compile_UInt_Compile::r#uint64 as ::dafny_runtime::DafnyUnerasable<_>>::unerase_owned(::dafny_runtime::DafnyErasable::erase_owned(((r#s)[<usize as ::dafny_runtime::NumCast>::from(::dafny_runtime::DafnyErasable::erase_owned(::dafny_runtime::BigInt::parse_bytes(b"0", 10).unwrap())).unwrap()]).clone()))) * ::dafny_runtime::DafnyErasable::erase_owned(<super::r#StandardLibrary_Compile_UInt_Compile::r#uint64 as ::dafny_runtime::DafnyUnerasable<_>>::unerase_owned(::dafny_runtime::BigInt::parse_bytes(b"72057594037927936", 10).unwrap()))));
-let mut r#_27_x1: super::r#StandardLibrary_Compile_UInt_Compile::r#uint64 = <super::r#StandardLibrary_Compile_UInt_Compile::r#uint64 as ::dafny_runtime::DafnyUnerasable<_>>::unerase_owned((::dafny_runtime::DafnyErasable::erase_owned((&r#_26_x0).clone()) + (::dafny_runtime::DafnyErasable::erase_owned(<super::r#StandardLibrary_Compile_UInt_Compile::r#uint64 as ::dafny_runtime::DafnyUnerasable<_>>::unerase_owned(::dafny_runtime::DafnyErasable::erase_owned(((r#s)[<usize as ::dafny_runtime::NumCast>::from(::dafny_runtime::DafnyErasable::erase_owned(::dafny_runtime::BigInt::parse_bytes(b"1", 10).unwrap())).unwrap()]).clone()))) * ::dafny_runtime::DafnyErasable::erase_owned(<super::r#StandardLibrary_Compile_UInt_Compile::r#uint64 as ::dafny_runtime::DafnyUnerasable<_>>::unerase_owned(::dafny_runtime::BigInt::parse_bytes(b"281474976710656", 10).unwrap())))));
-let mut r#_28_x2: super::r#StandardLibrary_Compile_UInt_Compile::r#uint64 = <super::r#StandardLibrary_Compile_UInt_Compile::r#uint64 as ::dafny_runtime::DafnyUnerasable<_>>::unerase_owned((::dafny_runtime::DafnyErasable::erase_owned((&r#_27_x1).clone()) + (::dafny_runtime::DafnyErasable::erase_owned(<super::r#StandardLibrary_Compile_UInt_Compile::r#uint64 as ::dafny_runtime::DafnyUnerasable<_>>::unerase_owned(::dafny_runtime::DafnyErasable::erase_owned(((r#s)[<usize as ::dafny_runtime::NumCast>::from(::dafny_runtime::DafnyErasable::erase_owned(::dafny_runtime::BigInt::parse_bytes(b"2", 10).unwrap())).unwrap()]).clone()))) * ::dafny_runtime::DafnyErasable::erase_owned(<super::r#StandardLibrary_Compile_UInt_Compile::r#uint64 as ::dafny_runtime::DafnyUnerasable<_>>::unerase_owned(::dafny_runtime::BigInt::parse_bytes(b"1099511627776", 10).unwrap())))));
-let mut r#_29_x3: super::r#StandardLibrary_Compile_UInt_Compile::r#uint64 = <super::r#StandardLibrary_Compile_UInt_Compile::r#uint64 as ::dafny_runtime::DafnyUnerasable<_>>::unerase_owned((::dafny_runtime::DafnyErasable::erase_owned((&r#_28_x2).clone()) + (::dafny_runtime::DafnyErasable::erase_owned(<super::r#StandardLibrary_Compile_UInt_Compile::r#uint64 as ::dafny_runtime::DafnyUnerasable<_>>::unerase_owned(::dafny_runtime::DafnyErasable::erase_owned(((r#s)[<usize as ::dafny_runtime::NumCast>::from(::dafny_runtime::DafnyErasable::erase_owned(::dafny_runtime::BigInt::parse_bytes(b"3", 10).unwrap())).unwrap()]).clone()))) * ::dafny_runtime::DafnyErasable::erase_owned(<super::r#StandardLibrary_Compile_UInt_Compile::r#uint64 as ::dafny_runtime::DafnyUnerasable<_>>::unerase_owned(::dafny_runtime::BigInt::parse_bytes(b"4294967296", 10).unwrap())))));
-let mut r#_30_x4: super::r#StandardLibrary_Compile_UInt_Compile::r#uint64 = <super::r#StandardLibrary_Compile_UInt_Compile::r#uint64 as ::dafny_runtime::DafnyUnerasable<_>>::unerase_owned((::dafny_runtime::DafnyErasable::erase_owned((&r#_29_x3).clone()) + (::dafny_runtime::DafnyErasable::erase_owned(<super::r#StandardLibrary_Compile_UInt_Compile::r#uint64 as ::dafny_runtime::DafnyUnerasable<_>>::unerase_owned(::dafny_runtime::DafnyErasable::erase_owned(((r#s)[<usize as ::dafny_runtime::NumCast>::from(::dafny_runtime::DafnyErasable::erase_owned(::dafny_runtime::BigInt::parse_bytes(b"4", 10).unwrap())).unwrap()]).clone()))) * ::dafny_runtime::DafnyErasable::erase_owned(<super::r#StandardLibrary_Compile_UInt_Compile::r#uint64 as ::dafny_runtime::DafnyUnerasable<_>>::unerase_owned(::dafny_runtime::BigInt::parse_bytes(b"16777216", 10).unwrap())))));
-let mut r#_31_x5: super::r#StandardLibrary_Compile_UInt_Compile::r#uint64 = <super::r#StandardLibrary_Compile_UInt_Compile::r#uint64 as ::dafny_runtime::DafnyUnerasable<_>>::unerase_owned((::dafny_runtime::DafnyErasable::erase_owned((&r#_30_x4).clone()) + (::dafny_runtime::DafnyErasable::erase_owned(<super::r#StandardLibrary_Compile_UInt_Compile::r#uint64 as ::dafny_runtime::DafnyUnerasable<_>>::unerase_owned(::dafny_runtime::DafnyErasable::erase_owned(((r#s)[<usize as ::dafny_runtime::NumCast>::from(::dafny_runtime::DafnyErasable::erase_owned(::dafny_runtime::BigInt::parse_bytes(b"5", 10).unwrap())).unwrap()]).clone()))) * ::dafny_runtime::DafnyErasable::erase_owned(<super::r#StandardLibrary_Compile_UInt_Compile::r#uint64 as ::dafny_runtime::DafnyUnerasable<_>>::unerase_owned(::dafny_runtime::BigInt::parse_bytes(b"65536", 10).unwrap())))));
-let mut r#_32_x6: super::r#StandardLibrary_Compile_UInt_Compile::r#uint64 = <super::r#StandardLibrary_Compile_UInt_Compile::r#uint64 as ::dafny_runtime::DafnyUnerasable<_>>::unerase_owned((::dafny_runtime::DafnyErasable::erase_owned((&r#_31_x5).clone()) + (::dafny_runtime::DafnyErasable::erase_owned(<super::r#StandardLibrary_Compile_UInt_Compile::r#uint64 as ::dafny_runtime::DafnyUnerasable<_>>::unerase_owned(::dafny_runtime::DafnyErasable::erase_owned(((r#s)[<usize as ::dafny_runtime::NumCast>::from(::dafny_runtime::DafnyErasable::erase_owned(::dafny_runtime::BigInt::parse_bytes(b"6", 10).unwrap())).unwrap()]).clone()))) * ::dafny_runtime::DafnyErasable::erase_owned(<super::r#StandardLibrary_Compile_UInt_Compile::r#uint64 as ::dafny_runtime::DafnyUnerasable<_>>::unerase_owned(::dafny_runtime::BigInt::parse_bytes(b"256", 10).unwrap())))));
-let mut r#_33_x: super::r#StandardLibrary_Compile_UInt_Compile::r#uint64 = <super::r#StandardLibrary_Compile_UInt_Compile::r#uint64 as ::dafny_runtime::DafnyUnerasable<_>>::unerase_owned((::dafny_runtime::DafnyErasable::erase_owned((&r#_32_x6).clone()) + ::dafny_runtime::DafnyErasable::erase_owned(<super::r#StandardLibrary_Compile_UInt_Compile::r#uint64 as ::dafny_runtime::DafnyUnerasable<_>>::unerase_owned(::dafny_runtime::DafnyErasable::erase_owned(((r#s)[<usize as ::dafny_runtime::NumCast>::from(::dafny_runtime::DafnyErasable::erase_owned(::dafny_runtime::BigInt::parse_bytes(b"7", 10).unwrap())).unwrap()]).clone())))));
-::dafny_runtime::DafnyUnerasable::<_>::unerase_owned(::dafny_runtime::DafnyErasable::erase_owned((&r#_33_x).clone()))
-}
-
-pub fn r#UINT16__LIMIT() -> ::dafny_runtime::BigInt {
-::dafny_runtime::DafnyUnerasable::<_>::unerase_owned(::dafny_runtime::DafnyErasable::erase_owned(::dafny_runtime::BigInt::parse_bytes(b"65536", 10).unwrap()))
-}
-
-pub fn r#UINT32__LIMIT() -> ::dafny_runtime::BigInt {
-::dafny_runtime::DafnyUnerasable::<_>::unerase_owned(::dafny_runtime::DafnyErasable::erase_owned(::dafny_runtime::BigInt::parse_bytes(b"4294967296", 10).unwrap()))
-}
-
-pub fn r#UINT64__LIMIT() -> ::dafny_runtime::BigInt {
-::dafny_runtime::DafnyUnerasable::<_>::unerase_owned(::dafny_runtime::DafnyErasable::erase_owned(::dafny_runtime::BigInt::parse_bytes(b"18446744073709551616", 10).unwrap()))
-}
-
-pub fn r#INT32__MAX__LIMIT() -> ::dafny_runtime::BigInt {
-::dafny_runtime::DafnyUnerasable::<_>::unerase_owned(::dafny_runtime::DafnyErasable::erase_owned(::dafny_runtime::BigInt::parse_bytes(b"2147483648", 10).unwrap()))
-}
-
-pub fn r#INT64__MAX__LIMIT() -> ::dafny_runtime::BigInt {
-::dafny_runtime::DafnyUnerasable::<_>::unerase_owned(::dafny_runtime::DafnyErasable::erase_owned(::dafny_runtime::BigInt::parse_bytes(b"9223372036854775808", 10).unwrap()))
-}
-
-
-}
-impl  ::std::default::Default for r#__default {
-fn default() -> Self {
-r#__default::new()
-}
-}
-
-impl  ::dafny_runtime::DafnyPrint for r#__default {
-fn fmt_print(&self, __fmt_print_formatter: &mut ::std::fmt::Formatter, _in_seq: bool) -> std::fmt::Result {
-write!(__fmt_print_formatter, "StandardLibrary_Compile.UInt_Compile.__default")
-}
-}
-
-impl  ::std::cmp::PartialEq for r#__default {
-fn eq(&self, other: &Self) -> bool {
-::std::ptr::eq(self, other)
-}
-}
-
-impl  ::dafny_runtime::DafnyErasable for r#__default {
-type Erased = r#__default;
-}
-impl  ::dafny_runtime::DafnyUnerasable<r#__default> for r#__default {}
-
-#[derive(Clone, PartialEq)]
-#[repr(transparent)]
-pub struct r#uint8(pub ::dafny_runtime::BigInt);
-impl  ::dafny_runtime::DafnyErasable for r#uint8 {
-type Erased = ::dafny_runtime::BigInt;
-}
-impl  ::dafny_runtime::DafnyUnerasable<::dafny_runtime::BigInt> for r#uint8 {}
-impl  ::dafny_runtime::DafnyUnerasable<r#uint8> for r#uint8 {}
-impl  ::std::default::Default for r#uint8 {
-fn default() -> Self {
-r#uint8(::std::default::Default::default())
-}
-}
-impl  ::dafny_runtime::DafnyPrint for r#uint8 {
-fn fmt_print(&self, __fmt_print_formatter: &mut ::std::fmt::Formatter, in_seq: bool) -> ::std::fmt::Result {
-::dafny_runtime::DafnyPrint::fmt_print(&self.0, __fmt_print_formatter, in_seq)
-}
-}
-impl  ::std::ops::Deref for r#uint8 {
-type Target = ::dafny_runtime::BigInt;
-fn deref(&self) -> &Self::Target {
-&self.0
-}
-}
-
-#[derive(Clone, PartialEq)]
-#[repr(transparent)]
-pub struct r#uint16(pub ::dafny_runtime::BigInt);
-impl  ::dafny_runtime::DafnyErasable for r#uint16 {
-type Erased = ::dafny_runtime::BigInt;
-}
-impl  ::dafny_runtime::DafnyUnerasable<::dafny_runtime::BigInt> for r#uint16 {}
-impl  ::dafny_runtime::DafnyUnerasable<r#uint16> for r#uint16 {}
-impl  ::std::default::Default for r#uint16 {
-fn default() -> Self {
-r#uint16(::std::default::Default::default())
-}
-}
-impl  ::dafny_runtime::DafnyPrint for r#uint16 {
-fn fmt_print(&self, __fmt_print_formatter: &mut ::std::fmt::Formatter, in_seq: bool) -> ::std::fmt::Result {
-::dafny_runtime::DafnyPrint::fmt_print(&self.0, __fmt_print_formatter, in_seq)
-}
-}
-impl  ::std::ops::Deref for r#uint16 {
-type Target = ::dafny_runtime::BigInt;
-fn deref(&self) -> &Self::Target {
-&self.0
-}
-}
-
-#[derive(Clone, PartialEq)]
-#[repr(transparent)]
-pub struct r#uint32(pub ::dafny_runtime::BigInt);
-impl  ::dafny_runtime::DafnyErasable for r#uint32 {
-type Erased = ::dafny_runtime::BigInt;
-}
-impl  ::dafny_runtime::DafnyUnerasable<::dafny_runtime::BigInt> for r#uint32 {}
-impl  ::dafny_runtime::DafnyUnerasable<r#uint32> for r#uint32 {}
-impl  ::std::default::Default for r#uint32 {
-fn default() -> Self {
-r#uint32(::std::default::Default::default())
-}
-}
-impl  ::dafny_runtime::DafnyPrint for r#uint32 {
-fn fmt_print(&self, __fmt_print_formatter: &mut ::std::fmt::Formatter, in_seq: bool) -> ::std::fmt::Result {
-::dafny_runtime::DafnyPrint::fmt_print(&self.0, __fmt_print_formatter, in_seq)
-}
-}
-impl  ::std::ops::Deref for r#uint32 {
-type Target = ::dafny_runtime::BigInt;
-fn deref(&self) -> &Self::Target {
-&self.0
-}
-}
-
-#[derive(Clone, PartialEq)]
-#[repr(transparent)]
-pub struct r#uint64(pub ::dafny_runtime::BigInt);
-impl  ::dafny_runtime::DafnyErasable for r#uint64 {
-type Erased = ::dafny_runtime::BigInt;
-}
-impl  ::dafny_runtime::DafnyUnerasable<::dafny_runtime::BigInt> for r#uint64 {}
-impl  ::dafny_runtime::DafnyUnerasable<r#uint64> for r#uint64 {}
-impl  ::std::default::Default for r#uint64 {
-fn default() -> Self {
-r#uint64(::std::default::Default::default())
-}
-}
-impl  ::dafny_runtime::DafnyPrint for r#uint64 {
-fn fmt_print(&self, __fmt_print_formatter: &mut ::std::fmt::Formatter, in_seq: bool) -> ::std::fmt::Result {
-::dafny_runtime::DafnyPrint::fmt_print(&self.0, __fmt_print_formatter, in_seq)
-}
-}
-impl  ::std::ops::Deref for r#uint64 {
-type Target = ::dafny_runtime::BigInt;
-fn deref(&self) -> &Self::Target {
-&self.0
-}
-}
-
-#[derive(Clone, PartialEq)]
-#[repr(transparent)]
-pub struct r#int32(pub ::dafny_runtime::BigInt);
-impl  ::dafny_runtime::DafnyErasable for r#int32 {
-type Erased = ::dafny_runtime::BigInt;
-}
-impl  ::dafny_runtime::DafnyUnerasable<::dafny_runtime::BigInt> for r#int32 {}
-impl  ::dafny_runtime::DafnyUnerasable<r#int32> for r#int32 {}
-impl  ::std::default::Default for r#int32 {
-fn default() -> Self {
-r#int32(::std::default::Default::default())
-}
-}
-impl  ::dafny_runtime::DafnyPrint for r#int32 {
-fn fmt_print(&self, __fmt_print_formatter: &mut ::std::fmt::Formatter, in_seq: bool) -> ::std::fmt::Result {
-::dafny_runtime::DafnyPrint::fmt_print(&self.0, __fmt_print_formatter, in_seq)
-}
-}
-impl  ::std::ops::Deref for r#int32 {
-type Target = ::dafny_runtime::BigInt;
-fn deref(&self) -> &Self::Target {
-&self.0
-}
-}
-
-#[derive(Clone, PartialEq)]
-#[repr(transparent)]
-pub struct r#int64(pub ::dafny_runtime::BigInt);
-impl  ::dafny_runtime::DafnyErasable for r#int64 {
-type Erased = ::dafny_runtime::BigInt;
-}
-impl  ::dafny_runtime::DafnyUnerasable<::dafny_runtime::BigInt> for r#int64 {}
-impl  ::dafny_runtime::DafnyUnerasable<r#int64> for r#int64 {}
-impl  ::std::default::Default for r#int64 {
-fn default() -> Self {
-r#int64(::std::default::Default::default())
-}
-}
-impl  ::dafny_runtime::DafnyPrint for r#int64 {
-fn fmt_print(&self, __fmt_print_formatter: &mut ::std::fmt::Formatter, in_seq: bool) -> ::std::fmt::Result {
-::dafny_runtime::DafnyPrint::fmt_print(&self.0, __fmt_print_formatter, in_seq)
-}
-}
-impl  ::std::ops::Deref for r#int64 {
-type Target = ::dafny_runtime::BigInt;
-fn deref(&self) -> &Self::Target {
-&self.0
-}
-}
-
-#[derive(Clone, PartialEq)]
-#[repr(transparent)]
-pub struct r#posInt64(pub ::dafny_runtime::BigInt);
-impl  ::dafny_runtime::DafnyErasable for r#posInt64 {
-type Erased = ::dafny_runtime::BigInt;
-}
-impl  ::dafny_runtime::DafnyUnerasable<::dafny_runtime::BigInt> for r#posInt64 {}
-impl  ::dafny_runtime::DafnyUnerasable<r#posInt64> for r#posInt64 {}
-impl  ::std::default::Default for r#posInt64 {
-fn default() -> Self {
-r#posInt64(::dafny_runtime::BigInt::parse_bytes(b"1", 10).unwrap())
-}
-}
-impl  ::dafny_runtime::DafnyPrint for r#posInt64 {
-fn fmt_print(&self, __fmt_print_formatter: &mut ::std::fmt::Formatter, in_seq: bool) -> ::std::fmt::Result {
-::dafny_runtime::DafnyPrint::fmt_print(&self.0, __fmt_print_formatter, in_seq)
-}
-}
-impl  ::std::ops::Deref for r#posInt64 {
-type Target = ::dafny_runtime::BigInt;
-fn deref(&self) -> &Self::Target {
-&self.0
-}
-}
-
-#[derive(Clone, PartialEq)]
-#[repr(transparent)]
-pub struct r#seq16<r#T, >(pub ::std::vec::Vec<r#T>);
-impl <r#T: ::dafny_runtime::DafnyErasable + ::dafny_runtime::DafnyUnerasable<r#T> + Clone + ::dafny_runtime::DafnyPrint + ::std::default::Default + 'static, > ::dafny_runtime::DafnyErasable for r#seq16<r#T, > {
-type Erased = ::std::vec::Vec<r#T>;
-}
-impl <r#T: ::dafny_runtime::DafnyErasable + ::dafny_runtime::DafnyUnerasable<r#T> + Clone + ::dafny_runtime::DafnyPrint + ::std::default::Default + 'static, > ::dafny_runtime::DafnyUnerasable<::std::vec::Vec<r#T>> for r#seq16<r#T, > {}
-impl <r#T: ::dafny_runtime::DafnyErasable + ::dafny_runtime::DafnyUnerasable<r#T> + Clone + ::dafny_runtime::DafnyPrint + ::std::default::Default + 'static, > ::dafny_runtime::DafnyUnerasable<r#seq16<r#T, >> for r#seq16<r#T, > {}
-impl <r#T: ::dafny_runtime::DafnyErasable + ::dafny_runtime::DafnyUnerasable<r#T> + Clone + ::dafny_runtime::DafnyPrint + ::std::default::Default + 'static, > ::std::default::Default for r#seq16<r#T, > where <r#T as ::dafny_runtime::DafnyErasable>::Erased: ::std::cmp::PartialEq,  {
-fn default() -> Self {
-r#seq16(::std::default::Default::default())
-}
-}
-impl <r#T: ::dafny_runtime::DafnyErasable + ::dafny_runtime::DafnyUnerasable<r#T> + Clone + ::dafny_runtime::DafnyPrint + ::std::default::Default + 'static, > ::dafny_runtime::DafnyPrint for r#seq16<r#T, > {
-fn fmt_print(&self, __fmt_print_formatter: &mut ::std::fmt::Formatter, in_seq: bool) -> ::std::fmt::Result {
-::dafny_runtime::DafnyPrint::fmt_print(&self.0, __fmt_print_formatter, in_seq)
-}
-}
-impl <r#T: ::dafny_runtime::DafnyErasable + ::dafny_runtime::DafnyUnerasable<r#T> + Clone + ::dafny_runtime::DafnyPrint + ::std::default::Default + 'static, > ::std::ops::Deref for r#seq16<r#T, > {
-type Target = ::std::vec::Vec<r#T>;
-fn deref(&self) -> &Self::Target {
-&self.0
-}
-}
-
-#[derive(Clone, PartialEq)]
-#[repr(transparent)]
-pub struct r#seq32<r#T, >(pub ::std::vec::Vec<r#T>);
-impl <r#T: ::dafny_runtime::DafnyErasable + ::dafny_runtime::DafnyUnerasable<r#T> + Clone + ::dafny_runtime::DafnyPrint + ::std::default::Default + 'static, > ::dafny_runtime::DafnyErasable for r#seq32<r#T, > {
-type Erased = ::std::vec::Vec<r#T>;
-}
-impl <r#T: ::dafny_runtime::DafnyErasable + ::dafny_runtime::DafnyUnerasable<r#T> + Clone + ::dafny_runtime::DafnyPrint + ::std::default::Default + 'static, > ::dafny_runtime::DafnyUnerasable<::std::vec::Vec<r#T>> for r#seq32<r#T, > {}
-impl <r#T: ::dafny_runtime::DafnyErasable + ::dafny_runtime::DafnyUnerasable<r#T> + Clone + ::dafny_runtime::DafnyPrint + ::std::default::Default + 'static, > ::dafny_runtime::DafnyUnerasable<r#seq32<r#T, >> for r#seq32<r#T, > {}
-impl <r#T: ::dafny_runtime::DafnyErasable + ::dafny_runtime::DafnyUnerasable<r#T> + Clone + ::dafny_runtime::DafnyPrint + ::std::default::Default + 'static, > ::std::default::Default for r#seq32<r#T, > where <r#T as ::dafny_runtime::DafnyErasable>::Erased: ::std::cmp::PartialEq,  {
-fn default() -> Self {
-r#seq32(::std::default::Default::default())
-}
-}
-impl <r#T: ::dafny_runtime::DafnyErasable + ::dafny_runtime::DafnyUnerasable<r#T> + Clone + ::dafny_runtime::DafnyPrint + ::std::default::Default + 'static, > ::dafny_runtime::DafnyPrint for r#seq32<r#T, > {
-fn fmt_print(&self, __fmt_print_formatter: &mut ::std::fmt::Formatter, in_seq: bool) -> ::std::fmt::Result {
-::dafny_runtime::DafnyPrint::fmt_print(&self.0, __fmt_print_formatter, in_seq)
-}
-}
-impl <r#T: ::dafny_runtime::DafnyErasable + ::dafny_runtime::DafnyUnerasable<r#T> + Clone + ::dafny_runtime::DafnyPrint + ::std::default::Default + 'static, > ::std::ops::Deref for r#seq32<r#T, > {
-type Target = ::std::vec::Vec<r#T>;
-fn deref(&self) -> &Self::Target {
-&self.0
-}
-}
-
-#[derive(Clone, PartialEq)]
-#[repr(transparent)]
-pub struct r#seq64<r#T, >(pub ::std::vec::Vec<r#T>);
-impl <r#T: ::dafny_runtime::DafnyErasable + ::dafny_runtime::DafnyUnerasable<r#T> + Clone + ::dafny_runtime::DafnyPrint + ::std::default::Default + 'static, > ::dafny_runtime::DafnyErasable for r#seq64<r#T, > {
-type Erased = ::std::vec::Vec<r#T>;
-}
-impl <r#T: ::dafny_runtime::DafnyErasable + ::dafny_runtime::DafnyUnerasable<r#T> + Clone + ::dafny_runtime::DafnyPrint + ::std::default::Default + 'static, > ::dafny_runtime::DafnyUnerasable<::std::vec::Vec<r#T>> for r#seq64<r#T, > {}
-impl <r#T: ::dafny_runtime::DafnyErasable + ::dafny_runtime::DafnyUnerasable<r#T> + Clone + ::dafny_runtime::DafnyPrint + ::std::default::Default + 'static, > ::dafny_runtime::DafnyUnerasable<r#seq64<r#T, >> for r#seq64<r#T, > {}
-impl <r#T: ::dafny_runtime::DafnyErasable + ::dafny_runtime::DafnyUnerasable<r#T> + Clone + ::dafny_runtime::DafnyPrint + ::std::default::Default + 'static, > ::std::default::Default for r#seq64<r#T, > where <r#T as ::dafny_runtime::DafnyErasable>::Erased: ::std::cmp::PartialEq,  {
-fn default() -> Self {
-r#seq64(::std::default::Default::default())
-}
-}
-impl <r#T: ::dafny_runtime::DafnyErasable + ::dafny_runtime::DafnyUnerasable<r#T> + Clone + ::dafny_runtime::DafnyPrint + ::std::default::Default + 'static, > ::dafny_runtime::DafnyPrint for r#seq64<r#T, > {
-fn fmt_print(&self, __fmt_print_formatter: &mut ::std::fmt::Formatter, in_seq: bool) -> ::std::fmt::Result {
-::dafny_runtime::DafnyPrint::fmt_print(&self.0, __fmt_print_formatter, in_seq)
-}
-}
-impl <r#T: ::dafny_runtime::DafnyErasable + ::dafny_runtime::DafnyUnerasable<r#T> + Clone + ::dafny_runtime::DafnyPrint + ::std::default::Default + 'static, > ::std::ops::Deref for r#seq64<r#T, > {
-type Target = ::std::vec::Vec<r#T>;
-fn deref(&self) -> &Self::Target {
-&self.0
-}
-}
-
-}
-mod r#StandardLibrary_Compile {
-
-}
-mod r#_module {
 
+pub mod r#_UTF8_Compile {
+  use dafny_runtime::dafny_runtime_conversions;
+  use dafny_runtime::ToPrimitive;
+  use dafny_runtime::BigInt;
+  use crate::UTF8;
+  pub struct _default {}
+  impl _default {
+    pub fn new() -> Self {
+      _default {}
+    }
+    pub fn Encode(s: &::dafny_runtime::Sequence<::dafny_runtime::DafnyCharUTF16>) -> ::std::rc::Rc<super::r#_Wrappers_Compile::Result<super::r#_UTF8_Compile::ValidUTF8Bytes, ::dafny_runtime::Sequence<::dafny_runtime::DafnyCharUTF16>>> {
+      UTF8::UTF8::Encode(s)
+    }
+    pub fn Decode(b: &::dafny_runtime::Sequence<u8>) -> ::std::rc::Rc<super::r#_Wrappers_Compile::Result<::dafny_runtime::Sequence<::dafny_runtime::DafnyCharUTF16>, ::dafny_runtime::Sequence<::dafny_runtime::DafnyCharUTF16>>> {
+      UTF8::UTF8::Decode(b)
+    }
+    
+    pub fn CreateEncodeSuccess(bytes: &super::r#_UTF8_Compile::ValidUTF8Bytes) -> ::std::rc::Rc<super::r#_Wrappers_Compile::Result<super::r#_UTF8_Compile::ValidUTF8Bytes, ::dafny_runtime::Sequence<::dafny_runtime::DafnyCharUTF16>>> {
+      ::std::rc::Rc::new(super::r#_Wrappers_Compile::Result::<super::r#_UTF8_Compile::ValidUTF8Bytes, ::dafny_runtime::Sequence<::dafny_runtime::DafnyCharUTF16>>::Success {value: (bytes.clone()) })
+    }
+    pub fn CreateEncodeFailure(error: &::dafny_runtime::Sequence<::dafny_runtime::DafnyCharUTF16>) -> ::std::rc::Rc<super::r#_Wrappers_Compile::Result<super::r#_UTF8_Compile::ValidUTF8Bytes, ::dafny_runtime::Sequence<::dafny_runtime::DafnyCharUTF16>>> {
+      ::std::rc::Rc::new(super::r#_Wrappers_Compile::Result::<super::r#_UTF8_Compile::ValidUTF8Bytes, ::dafny_runtime::Sequence<::dafny_runtime::DafnyCharUTF16>>::Failure {error: (error.clone()) })
+    }
+    pub fn CreateDecodeSuccess(s: &::dafny_runtime::Sequence<::dafny_runtime::DafnyCharUTF16>) -> ::std::rc::Rc<super::r#_Wrappers_Compile::Result<::dafny_runtime::Sequence<::dafny_runtime::DafnyCharUTF16>, ::dafny_runtime::Sequence<::dafny_runtime::DafnyCharUTF16>>> {
+      ::std::rc::Rc::new(super::r#_Wrappers_Compile::Result::<::dafny_runtime::Sequence<::dafny_runtime::DafnyCharUTF16>, ::dafny_runtime::Sequence<::dafny_runtime::DafnyCharUTF16>>::Success {value: (s.clone()) })
+    }
+    pub fn CreateDecodeFailure(error: &::dafny_runtime::Sequence<::dafny_runtime::DafnyCharUTF16>) -> ::std::rc::Rc<super::r#_Wrappers_Compile::Result<::dafny_runtime::Sequence<::dafny_runtime::DafnyCharUTF16>, ::dafny_runtime::Sequence<::dafny_runtime::DafnyCharUTF16>>> {
+      ::std::rc::Rc::new(super::r#_Wrappers_Compile::Result::<::dafny_runtime::Sequence<::dafny_runtime::DafnyCharUTF16>, ::dafny_runtime::Sequence<::dafny_runtime::DafnyCharUTF16>>::Failure {error: (error.clone()) })
+    }
+    pub fn IsASCIIString(s: &::dafny_runtime::Sequence<::dafny_runtime::DafnyCharUTF16>) -> bool {
+      true
+    }
+    pub fn EncodeAscii(s: &::dafny_runtime::Sequence<::dafny_runtime::DafnyCharUTF16>) -> super::r#_UTF8_Compile::ValidUTF8Bytes {
+      let mut _accumulator: super::r#_UTF8_Compile::ValidUTF8Bytes = ::dafny_runtime::seq![] as ::dafny_runtime::Sequence<u8>;
+      let mut s = s.clone();
+      'TAIL_CALL_START: loop {
+        if s.cardinality() == ::dafny_runtime::DafnyInt::from(0) {
+          return _accumulator.concat(&(::dafny_runtime::seq![] as ::dafny_runtime::Sequence<u8>));
+        } else {
+          let mut x: ::dafny_runtime::Sequence<u8> = ::dafny_runtime::seq![0 as u8];
+          _accumulator = _accumulator.concat(&x);
+          let mut _in0: ::dafny_runtime::Sequence<::dafny_runtime::DafnyCharUTF16> = s.drop(&::dafny_runtime::DafnyInt::from(1));
+          s = _in0.clone();
+          continue 'TAIL_CALL_START;
+        }
+      }
+    }
+    pub fn Uses1Byte(s: &::dafny_runtime::Sequence<u8>) -> bool {
+      (/*optimized*/0) <= s.get(&::dafny_runtime::DafnyInt::from(0)) && s.get(&::dafny_runtime::DafnyInt::from(0)) <= (/*optimized*/127)
+    }
+    pub fn Uses2Bytes(s: &::dafny_runtime::Sequence<u8>) -> bool {
+      (/*optimized*/194) <= s.get(&::dafny_runtime::DafnyInt::from(0)) && s.get(&::dafny_runtime::DafnyInt::from(0)) <= (/*optimized*/223) && ((/*optimized*/128) <= s.get(&::dafny_runtime::DafnyInt::from(1)) && s.get(&::dafny_runtime::DafnyInt::from(1)) <= (/*optimized*/191))
+    }
+    pub fn Uses3Bytes(s: &::dafny_runtime::Sequence<u8>) -> bool {
+      s.get(&::dafny_runtime::DafnyInt::from(0)) == (/*optimized*/224) && ((/*optimized*/160) <= s.get(&::dafny_runtime::DafnyInt::from(1)) && s.get(&::dafny_runtime::DafnyInt::from(1)) <= (/*optimized*/191)) && ((/*optimized*/128) <= s.get(&::dafny_runtime::DafnyInt::from(2)) && s.get(&::dafny_runtime::DafnyInt::from(2)) <= (/*optimized*/191)) || (/*optimized*/225) <= s.get(&::dafny_runtime::DafnyInt::from(0)) && s.get(&::dafny_runtime::DafnyInt::from(0)) <= (/*optimized*/236) && ((/*optimized*/128) <= s.get(&::dafny_runtime::DafnyInt::from(1)) && s.get(&::dafny_runtime::DafnyInt::from(1)) <= (/*optimized*/191)) && ((/*optimized*/128) <= s.get(&::dafny_runtime::DafnyInt::from(2)) && s.get(&::dafny_runtime::DafnyInt::from(2)) <= (/*optimized*/191)) || s.get(&::dafny_runtime::DafnyInt::from(0)) == (/*optimized*/237) && ((/*optimized*/128) <= s.get(&::dafny_runtime::DafnyInt::from(1)) && s.get(&::dafny_runtime::DafnyInt::from(1)) <= (/*optimized*/159)) && ((/*optimized*/128) <= s.get(&::dafny_runtime::DafnyInt::from(2)) && s.get(&::dafny_runtime::DafnyInt::from(2)) <= (/*optimized*/191)) || (/*optimized*/238) <= s.get(&::dafny_runtime::DafnyInt::from(0)) && s.get(&::dafny_runtime::DafnyInt::from(0)) <= (/*optimized*/239) && ((/*optimized*/128) <= s.get(&::dafny_runtime::DafnyInt::from(1)) && s.get(&::dafny_runtime::DafnyInt::from(1)) <= (/*optimized*/191)) && ((/*optimized*/128) <= s.get(&::dafny_runtime::DafnyInt::from(2)) && s.get(&::dafny_runtime::DafnyInt::from(2)) <= (/*optimized*/191))
+    }
+    pub fn Uses4Bytes(s: &::dafny_runtime::Sequence<u8>) -> bool {
+      s.get(&::dafny_runtime::DafnyInt::from(0)) == (/*optimized*/240) && ((/*optimized*/144) <= s.get(&::dafny_runtime::DafnyInt::from(1)) && s.get(&::dafny_runtime::DafnyInt::from(1)) <= (/*optimized*/191)) && ((/*optimized*/128) <= s.get(&::dafny_runtime::DafnyInt::from(2)) && s.get(&::dafny_runtime::DafnyInt::from(2)) <= (/*optimized*/191)) && ((/*optimized*/128) <= s.get(&::dafny_runtime::DafnyInt::from(3)) && s.get(&::dafny_runtime::DafnyInt::from(3)) <= (/*optimized*/191)) || (/*optimized*/241) <= s.get(&::dafny_runtime::DafnyInt::from(0)) && s.get(&::dafny_runtime::DafnyInt::from(0)) <= (/*optimized*/243) && ((/*optimized*/128) <= s.get(&::dafny_runtime::DafnyInt::from(1)) && s.get(&::dafny_runtime::DafnyInt::from(1)) <= (/*optimized*/191)) && ((/*optimized*/128) <= s.get(&::dafny_runtime::DafnyInt::from(2)) && s.get(&::dafny_runtime::DafnyInt::from(2)) <= (/*optimized*/191)) && ((/*optimized*/128) <= s.get(&::dafny_runtime::DafnyInt::from(3)) && s.get(&::dafny_runtime::DafnyInt::from(3)) <= (/*optimized*/191)) || s.get(&::dafny_runtime::DafnyInt::from(0)) == (/*optimized*/244) && ((/*optimized*/128) <= s.get(&::dafny_runtime::DafnyInt::from(1)) && s.get(&::dafny_runtime::DafnyInt::from(1)) <= (/*optimized*/143)) && ((/*optimized*/128) <= s.get(&::dafny_runtime::DafnyInt::from(2)) && s.get(&::dafny_runtime::DafnyInt::from(2)) <= (/*optimized*/191)) && ((/*optimized*/128) <= s.get(&::dafny_runtime::DafnyInt::from(3)) && s.get(&::dafny_runtime::DafnyInt::from(3)) <= (/*optimized*/191))
+    }
+    pub fn ValidUTF8Range(a: &::dafny_runtime::Sequence<u8>, lo: &super::_System::nat, hi: &super::_System::nat) -> bool {
+      let mut a = a.clone();
+      let mut lo = lo.clone();
+      let mut hi = hi.clone();
+      'TAIL_CALL_START: loop {
+        if lo.clone() == hi.clone() {
+          return true;
+        } else {
+          let mut r: ::dafny_runtime::Sequence<u8> = a.slice(&lo, &hi);
+          if <(super::r#_UTF8_Compile::_default)>::Uses1Byte(&r) {
+            let mut _in1: ::dafny_runtime::Sequence<u8> = a.clone();
+            let mut _in2: ::dafny_runtime::DafnyInt = lo.clone() + ::dafny_runtime::DafnyInt::from(1);
+            let mut _in3: super::_System::nat = hi.clone();
+            a = _in1.clone();
+            lo = _in2.clone();
+            hi = _in3.clone();
+            continue 'TAIL_CALL_START;
+          } else {
+            if ::dafny_runtime::DafnyInt::from(2) <= r.cardinality() && <(super::r#_UTF8_Compile::_default)>::Uses2Bytes(&r) {
+              let mut _in4: ::dafny_runtime::Sequence<u8> = a.clone();
+              let mut _in5: ::dafny_runtime::DafnyInt = lo.clone() + ::dafny_runtime::DafnyInt::from(2);
+              let mut _in6: super::_System::nat = hi.clone();
+              a = _in4.clone();
+              lo = _in5.clone();
+              hi = _in6.clone();
+              continue 'TAIL_CALL_START;
+            } else {
+              if ::dafny_runtime::DafnyInt::from(3) <= r.cardinality() && <(super::r#_UTF8_Compile::_default)>::Uses3Bytes(&r) {
+                let mut _in7: ::dafny_runtime::Sequence<u8> = a.clone();
+                let mut _in8: ::dafny_runtime::DafnyInt = lo.clone() + ::dafny_runtime::DafnyInt::from(3);
+                let mut _in9: super::_System::nat = hi.clone();
+                a = _in7.clone();
+                lo = _in8.clone();
+                hi = _in9.clone();
+                continue 'TAIL_CALL_START;
+              } else {
+                if ::dafny_runtime::DafnyInt::from(4) <= r.cardinality() && <(super::r#_UTF8_Compile::_default)>::Uses4Bytes(&r) {
+                  let mut _in10: ::dafny_runtime::Sequence<u8> = a.clone();
+                  let mut _in11: ::dafny_runtime::DafnyInt = lo.clone() + ::dafny_runtime::DafnyInt::from(4);
+                  let mut _in12: super::_System::nat = hi.clone();
+                  a = _in10.clone();
+                  lo = _in11.clone();
+                  hi = _in12.clone();
+                  continue 'TAIL_CALL_START;
+                } else {
+                  return false;
+                }
+              }
+            }
+          }
+        }
+      }
+    }
+    pub fn ValidUTF8Seq(s: &::dafny_runtime::Sequence<u8>) -> bool {
+      <(super::r#_UTF8_Compile::_default)>::ValidUTF8Range(s, &::dafny_runtime::DafnyInt::from(0), &s.cardinality())
+    }
+  }
+  impl ::std::default::Default for _default {
+    fn default() -> Self {
+      _default::new()
+    }
+  }
+  impl ::dafny_runtime::DafnyPrint for _default {
+    fn fmt_print(&self, _formatter: &mut ::std::fmt::Formatter, _in_seq: bool) -> std::fmt::Result {
+      write!(_formatter, "UTF8_Compile.__default")
+    }
+  }
+  impl ::std::cmp::PartialEq for _default {
+    fn eq(&self, other: &Self) -> bool {
+      ::std::ptr::eq(self, other)
+    }
+  }
+  pub type ValidUTF8Bytes = ::dafny_runtime::Sequence<u8>;
+}
+pub mod r#_StandardLibraryInterop_Compile {
+  pub struct WrappersInterop {}
+  impl WrappersInterop {
+    pub fn new() -> Self {
+      WrappersInterop {}
+    }
+    pub fn _allocated() -> *mut Self {
+      ::dafny_runtime::allocate::<Self>()
+    }
+    pub fn CreateStringSome(s: &::dafny_runtime::Sequence<::dafny_runtime::DafnyCharUTF16>) -> ::std::rc::Rc<super::r#_Wrappers_Compile::Option<::dafny_runtime::Sequence<::dafny_runtime::DafnyCharUTF16>>> {
+      ::std::rc::Rc::new(super::r#_Wrappers_Compile::Option::<::dafny_runtime::Sequence<::dafny_runtime::DafnyCharUTF16>>::Some {
+          value: s.clone()
+        })
+    }
+    pub fn CreateStringNone() -> ::std::rc::Rc<super::r#_Wrappers_Compile::Option<::dafny_runtime::Sequence<::dafny_runtime::DafnyCharUTF16>>> {
+      ::std::rc::Rc::new(super::r#_Wrappers_Compile::Option::<::dafny_runtime::Sequence<::dafny_runtime::DafnyCharUTF16>>::None {})
+    }
+    pub fn CreateBooleanSome(b: bool) -> ::std::rc::Rc<super::r#_Wrappers_Compile::Option<bool>> {
+      ::std::rc::Rc::new(super::r#_Wrappers_Compile::Option::<bool>::Some {
+          value: b
+        })
+    }
+    pub fn CreateBooleanNone() -> ::std::rc::Rc<super::r#_Wrappers_Compile::Option<bool>> {
+      ::std::rc::Rc::new(super::r#_Wrappers_Compile::Option::<bool>::None {})
+    }
+  }
+  impl ::std::default::Default for WrappersInterop {
+    fn default() -> Self {
+      WrappersInterop::new()
+    }
+  }
+  impl ::dafny_runtime::DafnyPrint for WrappersInterop {
+    fn fmt_print(&self, _formatter: &mut ::std::fmt::Formatter, _in_seq: bool) -> std::fmt::Result {
+      write!(_formatter, "StandardLibraryInterop_Compile.WrappersInterop")
+    }
+  }
+  impl ::std::cmp::PartialEq for WrappersInterop {
+    fn eq(&self, other: &Self) -> bool {
+      ::std::ptr::eq(self, other)
+    }
+  }
+}
+pub mod _module {
+  
 }
\ No newline at end of file
diff --git b/TestModels/dafny-dependencies/StandardLibrary/runtimes/rust/src/lib.rs a/TestModels/dafny-dependencies/StandardLibrary/runtimes/rust/src/lib.rs
new file mode 100644
index 00000000..8ba31f25
--- /dev/null
+++ a/TestModels/dafny-dependencies/StandardLibrary/runtimes/rust/src/lib.rs
@@ -0,0 +1,297 @@
+#[allow(non_snake_case)]
+pub mod UTF8;
+pub mod implementation_from_dafny;
+
+#[cfg(test)]
+#[allow(non_snake_case)]
+mod TestUTF8 {
+    use super::*;
+    #[test]
+    fn TestEncodeHappyCase() {
+        let unicodeString = ::dafny_runtime::string_utf16_of("abc\u{0306}\u{01FD}\u{03B2}");
+        let expectedBytes =
+            dafny_runtime::seq![0x61, 0x62, 0x63, 0xCC, 0x86, 0xC7, 0xBD, 0xCE, 0xB2];
+        let _r = implementation_from_dafny::r#_UTF8_Compile::_default::Encode(&unicodeString);
+        if _r.IsFailure() {
+            panic!("Encode failed");
+        }
+        let encoded = _r.Extract();
+        assert_eq!(expectedBytes, encoded);
+    }
+
+    #[test]
+    fn TestEncodeInvalidUnicode() {
+        let invalidUnicode = ::dafny_runtime::seq![
+            ::dafny_runtime::DafnyCharUTF16('a' as u16),
+            ::dafny_runtime::DafnyCharUTF16('b' as u16),
+            ::dafny_runtime::DafnyCharUTF16('c' as u16),
+            ::dafny_runtime::DafnyCharUTF16(0xD800)
+        ];
+        let encoded = implementation_from_dafny::r#_UTF8_Compile::_default::Encode(&invalidUnicode);
+        assert!(encoded.IsFailure());
+    }
+
+    #[test]
+    fn TestDecodeHappyCase() {
+        let unicodeBytes =
+            ::dafny_runtime::seq![0x61, 0x62, 0x63, 0xCC, 0x86, 0xC7, 0xBD, 0xCE, 0xB2];
+        assert!(
+            implementation_from_dafny::r#_UTF8_Compile::_default::Uses2Bytes(
+                &::dafny_runtime::seq![0xC7 as u8, 0xBD as u8, 0xCE as u8, 0xB2 as u8]
+            )
+        );
+        assert_eq!(
+            ::dafny_runtime::seq![0xC7 as u8, 0xBD as u8, 0xCE as u8, 0xB2 as u8],
+            unicodeBytes.slice(&::dafny_runtime::int!(5), &::dafny_runtime::int!(9))
+        );
+        assert!(
+            implementation_from_dafny::r#_UTF8_Compile::_default::ValidUTF8Range(
+                &unicodeBytes,
+                &::dafny_runtime::int!(7),
+                &::dafny_runtime::int!(9)
+            )
+        );
+        assert!(
+            implementation_from_dafny::r#_UTF8_Compile::_default::ValidUTF8Range(
+                &unicodeBytes,
+                &::dafny_runtime::int!(0),
+                &::dafny_runtime::int!(9)
+            )
+        );
+        let expectedString = ::dafny_runtime::string_utf16_of("abc\u{0306}\u{01FD}\u{03B2}");
+        let _r = implementation_from_dafny::r#_UTF8_Compile::_default::Decode(&unicodeBytes);
+        if _r.IsFailure() {
+            panic!("Decode failed");
+        }
+        let decoded = _r.Extract();
+        assert_eq!(expectedString, decoded);
+    }
+
+    #[test]
+    fn TestDecodeInvalidUnicode() {
+        let invalidUnicode = ::dafny_runtime::seq![
+            0x61 as u8, 0x62 as u8, 0x63 as u8, 0xED as u8, 0xA0 as u8, 0x80 as u8
+        ];
+        let _r = implementation_from_dafny::r#_UTF8_Compile::_default::Decode(&invalidUnicode);
+        assert!(_r.IsFailure());
+    }
+
+    #[test]
+    fn Test1Byte() {
+        // Null
+        let mut decoded = ::dafny_runtime::string_utf16_of("\u{0000}");
+        let mut _r = implementation_from_dafny::r#_UTF8_Compile::_default::Encode(&decoded);
+        assert!(!_r.IsFailure());
+        let mut encoded = _r.Extract();
+        assert_eq!(::dafny_runtime::seq![0x00 as u8], encoded);
+        assert!(implementation_from_dafny::r#_UTF8_Compile::_default::Uses1Byte(&encoded));
+        let mut _r2 = implementation_from_dafny::r#_UTF8_Compile::_default::Decode(&encoded);
+        assert!(!_r2.IsFailure());
+        let mut redecoded = _r2.Extract();
+        assert_eq!(decoded, redecoded);
+
+        // Space
+        decoded = ::dafny_runtime::string_utf16_of(" ");
+        _r = implementation_from_dafny::r#_UTF8_Compile::_default::Encode(&decoded);
+        assert!(!_r.IsFailure());
+        encoded = _r.Extract();
+        assert_eq!(::dafny_runtime::seq![0x20 as u8], encoded);
+        assert!(implementation_from_dafny::r#_UTF8_Compile::_default::Uses1Byte(&encoded));
+        _r2 = implementation_from_dafny::r#_UTF8_Compile::_default::Decode(&encoded);
+        assert!(!_r2.IsFailure());
+        redecoded = _r2.Extract();
+        assert_eq!(decoded, redecoded);
+
+        decoded = ::dafny_runtime::string_utf16_of("$");
+        _r = implementation_from_dafny::r#_UTF8_Compile::_default::Encode(&decoded);
+        assert!(!_r.IsFailure());
+        encoded = _r.Extract();
+        assert_eq!(::dafny_runtime::seq![0x24 as u8], encoded);
+        assert!(implementation_from_dafny::r#_UTF8_Compile::_default::Uses1Byte(&encoded));
+        _r2 = implementation_from_dafny::r#_UTF8_Compile::_default::Decode(&encoded);
+        assert!(!_r2.IsFailure());
+        redecoded = _r2.Extract();
+        assert_eq!(decoded, redecoded);
+
+        decoded = ::dafny_runtime::string_utf16_of("0");
+        _r = implementation_from_dafny::r#_UTF8_Compile::_default::Encode(&decoded);
+        assert!(!_r.IsFailure());
+        encoded = _r.Extract();
+        assert_eq!(::dafny_runtime::seq![0x30 as u8], encoded);
+        assert!(implementation_from_dafny::r#_UTF8_Compile::_default::Uses1Byte(&encoded));
+        _r2 = implementation_from_dafny::r#_UTF8_Compile::_default::Decode(&encoded);
+        assert!(!_r2.IsFailure());
+        redecoded = _r2.Extract();
+        assert_eq!(decoded, redecoded);
+        decoded = ::dafny_runtime::string_utf16_of("A");
+        _r = implementation_from_dafny::r#_UTF8_Compile::_default::Encode(&decoded);
+        assert!(!_r.IsFailure());
+        encoded = _r.Extract();
+        assert_eq!(::dafny_runtime::seq![0x41 as u8], encoded);
+        assert!(implementation_from_dafny::r#_UTF8_Compile::_default::Uses1Byte(&encoded));
+        _r2 = implementation_from_dafny::r#_UTF8_Compile::_default::Decode(&encoded);
+        assert!(!_r2.IsFailure());
+        redecoded = _r2.Extract();
+        assert_eq!(decoded, redecoded);
+        decoded = ::dafny_runtime::string_utf16_of("a");
+        _r = implementation_from_dafny::r#_UTF8_Compile::_default::Encode(&decoded);
+        assert!(!_r.IsFailure());
+        encoded = _r.Extract();
+        assert_eq!(::dafny_runtime::seq![0x61 as u8], encoded);
+        assert!(implementation_from_dafny::r#_UTF8_Compile::_default::Uses1Byte(&encoded));
+        _r2 = implementation_from_dafny::r#_UTF8_Compile::_default::Decode(&encoded);
+        assert!(!_r2.IsFailure());
+        redecoded = _r2.Extract();
+        assert_eq!(decoded, redecoded);
+    }
+
+    #[test]
+    fn Test2Bytes() {
+        let mut decoded = ::dafny_runtime::string_utf16_of("\u{00A3}");
+        let mut _r = implementation_from_dafny::r#_UTF8_Compile::_default::Encode(&decoded);
+        assert!(!_r.IsFailure());
+        let mut encoded = _r.Extract();
+        assert_eq!(::dafny_runtime::seq![0xC2 as u8, 0xA3 as u8], encoded);
+        assert!(implementation_from_dafny::r#_UTF8_Compile::_default::Uses2Bytes(&encoded));
+        let mut _r2 = implementation_from_dafny::r#_UTF8_Compile::_default::Decode(&encoded);
+        assert!(!_r2.IsFailure());
+        let mut redecoded = _r2.Extract();
+        assert_eq!(decoded, redecoded);
+        decoded = ::dafny_runtime::string_utf16_of("\u{00A9}");
+        _r = implementation_from_dafny::r#_UTF8_Compile::_default::Encode(&decoded);
+        assert!(!_r.IsFailure());
+        encoded = _r.Extract();
+        assert_eq!(::dafny_runtime::seq![0xC2 as u8, 0xA9 as u8], encoded);
+        assert!(implementation_from_dafny::r#_UTF8_Compile::_default::Uses2Bytes(&encoded));
+        _r2 = implementation_from_dafny::r#_UTF8_Compile::_default::Decode(&encoded);
+        assert!(!_r2.IsFailure());
+        redecoded = _r2.Extract();
+        assert_eq!(decoded, redecoded);
+        decoded = ::dafny_runtime::string_utf16_of("\u{00AE}");
+        _r = implementation_from_dafny::r#_UTF8_Compile::_default::Encode(&decoded);
+        assert!(!_r.IsFailure());
+        encoded = _r.Extract();
+        assert_eq!(::dafny_runtime::seq![0xC2 as u8, 0xAE as u8], encoded);
+        assert!(implementation_from_dafny::r#_UTF8_Compile::_default::Uses2Bytes(&encoded));
+        _r2 = implementation_from_dafny::r#_UTF8_Compile::_default::Decode(&encoded);
+        assert!(!_r2.IsFailure());
+        redecoded = _r2.Extract();
+        assert_eq!(decoded, redecoded);
+        decoded = ::dafny_runtime::string_utf16_of("\u{03C0}");
+        _r = implementation_from_dafny::r#_UTF8_Compile::_default::Encode(&decoded);
+        assert!(!_r.IsFailure());
+        encoded = _r.Extract();
+        assert_eq!(::dafny_runtime::seq![0xCF as u8, 0x80 as u8], encoded);
+        assert!(implementation_from_dafny::r#_UTF8_Compile::_default::Uses2Bytes(&encoded));
+        _r2 = implementation_from_dafny::r#_UTF8_Compile::_default::Decode(&encoded);
+        assert!(!_r2.IsFailure());
+        redecoded = _r2.Extract();
+        assert_eq!(decoded, redecoded);
+    }
+
+    #[test]
+    fn Test3Bytes() {
+        let mut decoded = ::dafny_runtime::string_utf16_of("\u{2386}");
+        let mut _r = implementation_from_dafny::r#_UTF8_Compile::_default::Encode(&decoded);
+        assert!(!_r.IsFailure());
+        let mut encoded = _r.Extract();
+        assert_eq!(
+            ::dafny_runtime::seq![0xE2 as u8, 0x8E as u8, 0x86 as u8],
+            encoded
+        );
+        assert!(implementation_from_dafny::r#_UTF8_Compile::_default::Uses3Bytes(&encoded));
+        let mut _r2 = implementation_from_dafny::r#_UTF8_Compile::_default::Decode(&encoded);
+        assert!(!_r2.IsFailure());
+        let mut redecoded = _r2.Extract();
+        assert_eq!(decoded, redecoded);
+        decoded = ::dafny_runtime::string_utf16_of("\u{2387}");
+        _r = implementation_from_dafny::r#_UTF8_Compile::_default::Encode(&decoded);
+        assert!(!_r.IsFailure());
+        encoded = _r.Extract();
+        assert_eq!(
+            ::dafny_runtime::seq![0xE2 as u8, 0x8E as u8, 0x87 as u8],
+            encoded
+        );
+        assert!(implementation_from_dafny::r#_UTF8_Compile::_default::Uses3Bytes(&encoded));
+        _r2 = implementation_from_dafny::r#_UTF8_Compile::_default::Decode(&encoded);
+        assert!(!_r2.IsFailure());
+        redecoded = _r2.Extract();
+        assert_eq!(decoded, redecoded);
+        decoded = ::dafny_runtime::string_utf16_of("\u{231B}");
+        _r = implementation_from_dafny::r#_UTF8_Compile::_default::Encode(&decoded);
+        assert!(!_r.IsFailure());
+        encoded = _r.Extract();
+        assert_eq!(
+            ::dafny_runtime::seq![0xE2 as u8, 0x8C as u8, 0x9B as u8],
+            encoded
+        );
+        assert!(implementation_from_dafny::r#_UTF8_Compile::_default::Uses3Bytes(&encoded));
+        _r2 = implementation_from_dafny::r#_UTF8_Compile::_default::Decode(&encoded);
+        assert!(!_r2.IsFailure());
+        redecoded = _r2.Extract();
+        assert_eq!(decoded, redecoded);
+        decoded = ::dafny_runtime::string_utf16_of("\u{1D78}");
+        _r = implementation_from_dafny::r#_UTF8_Compile::_default::Encode(&decoded);
+        assert!(!_r.IsFailure());
+        encoded = _r.Extract();
+        assert_eq!(
+            ::dafny_runtime::seq![0xE1 as u8, 0xB5 as u8, 0xB8 as u8],
+            encoded
+        );
+        assert!(implementation_from_dafny::r#_UTF8_Compile::_default::Uses3Bytes(&encoded));
+        _r2 = implementation_from_dafny::r#_UTF8_Compile::_default::Decode(&encoded);
+        assert!(!_r2.IsFailure());
+        redecoded = _r2.Extract();
+        assert_eq!(decoded, redecoded);
+        decoded = ::dafny_runtime::string_utf16_of("\u{732B}");
+        _r = implementation_from_dafny::r#_UTF8_Compile::_default::Encode(&decoded);
+        assert!(!_r.IsFailure());
+        encoded = _r.Extract();
+        assert_eq!(
+            ::dafny_runtime::seq![0xE7 as u8, 0x8C as u8, 0xAB as u8],
+            encoded
+        );
+        assert!(implementation_from_dafny::r#_UTF8_Compile::_default::Uses3Bytes(&encoded));
+        _r2 = implementation_from_dafny::r#_UTF8_Compile::_default::Decode(&encoded);
+        assert!(!_r2.IsFailure());
+        redecoded = _r2.Extract();
+        assert_eq!(decoded, redecoded);
+    }
+
+    #[test]
+    fn Test4Bytes() {
+        let mut decoded = ::dafny_runtime::seq![
+            ::dafny_runtime::DafnyCharUTF16(0xD808),
+            ::dafny_runtime::DafnyCharUTF16(0xDC00)
+        ];
+        let mut _r = implementation_from_dafny::r#_UTF8_Compile::_default::Encode(&decoded);
+        println!(
+            "{}",
+            ::dafny_runtime::DafnyPrintWrapper(&_r.as_ref().clone())
+        );
+        assert!(!_r.IsFailure());
+        let mut encoded = _r.Extract();
+        assert_eq!(
+            ::dafny_runtime::seq![0xF0 as u8, 0x92 as u8, 0x80 as u8, 0x80 as u8],
+            encoded
+        );
+        assert!(implementation_from_dafny::r#_UTF8_Compile::_default::Uses4Bytes(&encoded));
+        let mut _r2 = implementation_from_dafny::r#_UTF8_Compile::_default::Decode(&encoded);
+        assert!(!_r2.IsFailure());
+        let mut redecoded = _r2.Extract();
+        assert_eq!(decoded, redecoded);
+        decoded = ::dafny_runtime::string_utf16_of("\u{1D7C1}");
+        _r = implementation_from_dafny::r#_UTF8_Compile::_default::Encode(&decoded);
+        assert!(!_r.IsFailure());
+        encoded = _r.Extract();
+        assert_eq!(
+            ::dafny_runtime::seq![0xF0 as u8, 0x9D as u8, 0x9F as u8, 0x81 as u8],
+            encoded
+        );
+        assert!(implementation_from_dafny::r#_UTF8_Compile::_default::Uses4Bytes(&encoded));
+        _r2 = implementation_from_dafny::r#_UTF8_Compile::_default::Decode(&encoded);
+        assert!(!_r2.IsFailure());
+        redecoded = _r2.Extract();
+        assert_eq!(decoded, redecoded);
+    }
+}
